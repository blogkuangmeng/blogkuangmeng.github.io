<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">

  <title>基本算法 | 欢迎来到匡盟盟的博客！</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta name="keywords" content="匡盟盟, Colyn Kuang, Blog, 博客" />


  <meta name="google-site-verification" content="3YclHsmiu1_poywYScAg4jt4RGqoHUoIXQJFV5vEZ1I" />


  <meta name="baidu-site-verification" content="d6tIQA0tgL" />


  <meta name="description" content="数论算法 求两数的最大公约数 function  gcd(a,b:integer):integer;   begin      if b=0 then gcd:=a       else gcd:=gcd (b,a mod b);   end ; 123      ## 求两数的最小公倍数```stylus function  lcm(a,b:integer):integer;   begin">
  <meta name="keywords" content="算法设计">
  <meta property="og:type" content="article">
  <meta property="og:title" content="基本算法">
  <meta property="og:url" content="http://meng.uno/posts/cff3a942/index.html">
  <meta property="og:site_name" content="欢迎来到匡盟盟的博客！">
  <meta property="og:description" content="数论算法 求两数的最大公约数 function  gcd(a,b:integer):integer;   begin      if b=0 then gcd:=a       else gcd:=gcd (b,a mod b);   end ; 123      ## 求两数的最小公倍数```stylus function  lcm(a,b:integer):integer;   begin">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:updated_time" content="2018-02-18T13:25:50.287Z">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="基本算法">
  <meta name="twitter:description" content="数论算法 求两数的最大公约数 function  gcd(a,b:integer):integer;   begin      if b=0 then gcd:=a       else gcd:=gcd (b,a mod b);   end ; 123      ## 求两数的最小公倍数```stylus function  lcm(a,b:integer):integer;   begin">
  <meta name="twitter:creator" content="@kuangmengmeng">
  <link rel="publisher" href="mengmengkuang">
  <meta property="fb:admins" content="kuangmengmeng">
  <meta property="fb:app_id" content="1559086807462632">

  <link rel="alternate" href="/atom.xml" title="欢迎来到匡盟盟的博客！" type="application/atom+xml">




  <link rel="icon" href="/css/images/logo.png">
  <link rel="apple-touch-icon" href="/css/images/logo.png">

  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">

  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face {
      font-family: futura-pt;
      src: url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");
      font-weight: 500;
      font-style: normal;
    }

    @font-face {
      font-family: futura-pt;
      src: url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");
      font-weight: 500;
      font-style: normal;
    }

    @font-face {
      font-family: futura-pt;
      src: url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");
      font-weight: lighter;
      font-style: normal;
    }

    @font-face {
      font-family: futura-pt;
      src: url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");
      font-weight: 400;
      font-style: italic;
    }
  </style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>
  <script src="/js/bootstrap.js"></script>
  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">


  <link rel="stylesheet" href="/css/dialog.css">





  <link rel="stylesheet" href="/css/header-post.css">





  <link rel="stylesheet" href="/css/vdonate.css">





  <script>
    window._bd_share_config = {
      "common": {
        "bdSnsKey": {},
        "bdText": "",
        "bdMini": "1",
        "bdMiniList": ["copy", "weixin", "linkedin", "sqq", "tsina", "twi", "fbook", "mail"],
        "bdPic": "",
        "bdStyle": "0",
        "bdSize": "16"
      },
      "slide": {
        "type": "slide",
        "bdImg": "0",
        "bdPos": "left",
        "bdTop": "100"
      },
      "selectShare": {
        "bdContainerClass": null,
        "bdSelectMiniList": ["qzone", "tsina", "tqq", "renren", "weixin"]
      }
    };
    with(document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=' + ~(-new Date() / 36e5)];
  </script>


</head>


<body data-spy="scroll" data-target="#toc" data-offset="50">


  <div id="container">
    <div id="wrap">

      <header>
        <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
          <div class="navbar-inner">
            <div class="container">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>


              <a class="brand" style="
                 margin-top: 0px;" href="#" data-toggle="modal" data-target="#myModal">
                  <img class="trans-rotate" width="124px" height="124px" alt="Hike News" src="/css/images/logo.png">
              </a>


              <div class="navbar-collapse collapse">
                <ul class="hnav navbar-nav">

                  <li> <a class="main-nav-link" href="/">首页</a> </li>

                  <li> <a class="main-nav-link" href="/archives">所有文章</a> </li>

                  <li> <a class="main-nav-link" href="/categories">分类</a> </li>

                  <li> <a class="main-nav-link" href="/tags">标签</a> </li>

                  <li> <a class="main-nav-link" href="/about">关于我</a> </li>

                  <li> <a class="main-nav-link" href="/comments">留言板</a> </li>

                  <li>
                    <div id="search-form-wrap">

                      <form class="search-form">
                        <input type="text" style="width=0;" class="ins-search-input search-form-input" placeholder="" />
                        <button type="submit" class="search-form-submit"></button>
                      </form>
                      <div class="ins-search">
                        <div class="ins-search-mask"></div>
                        <div class="ins-search-container">
                          <div class="ins-input-wrapper">
                            <input type="text" class="ins-search-input" placeholder="请输入关键词..." />
                            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
                          </div>
                          <div class="ins-section-wrapper">
                            <div class="ins-section-container"></div>
                          </div>
                        </div>
                      </div>
                      <script>
                        (function(window) {
                          var INSIGHT_CONFIG = {
                            TRANSLATION: {
                              POSTS: '文章',
                              PAGES: '页面',
                              CATEGORIES: '分类',
                              TAGS: '标签',
                              UNTITLED: '空标题',
                            },
                            ROOT_URL: '/',
                            CONTENT_URL: '/content.json',
                          };
                          window.INSIGHT_CONFIG = INSIGHT_CONFIG;
                        })(window);
                      </script>
                      <script src="/js/insight.js"></script>

                    </div>
                  </li>
              </div>
            </div>

          </div>
        </div>

      </header>


      <div id="content" class="outer">

        <section id="main" style="float:none;">
          <article id="post-algorithm" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost">
            <div id="articleInner" class="article-inner">


              <header class="article-header">
                <h1 class="thumb" class="article-title" itemprop="name">
                  基本算法
                </h1>
              </header>

              <div class="article-meta">
                <a href="/posts/cff3a942/" class="article-date">
	  <time datetime="2016-07-17T13:01:44.000Z" itemprop="datePublished">2016-07-17</time>
	</a>
                <a class="article-category-link" href="/categories/算法设计/">算法设计<span class="article-category-count">2</span></a>
                <a class="article-views">
	<span id="busuanzi_container_page_pv">
		阅读量<span id="busuanzi_value_page_pv"></span>
	</span>
	<span class="post-count"> | 字数6,207</span>
	<span class="post-count"> | 预计时间32分钟</span>
	</a>
              </div>
              <div class="article-entry" itemprop="articleBody">

                <h1>数论算法</h1>
                <h2>求两数的最大公约数</h2>
                <pre><code class="language-stylus">function  gcd(a,b:integer):integer;
  begin 
    if b=0 then gcd:=a
      else gcd:=gcd (b,a mod b);
  end ;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                </td>
                <td class="code">
                  <pre><span class="line">
## 求两数的最小公倍数</span><br><span class="line"></span><br><span class="line">```stylus
function  lcm(a,b:integer):integer;
  begin
    if a&lt;b then swap(a,b);
    lcm:=a;
    while lcm mod b&gt;0 do inc(lcm,a);
  end;</span><br></pre>
                </td>
                </tr>
                </table>
                </figure>


                ## 素数的求法 ### 小范围内判断一个数是否为质数
                <figure class="highlight">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">  function prime (n: integer): Boolean;
    var I: integer;
    begin
      for I:=2 to trunc(sqrt(n)) do
        if n mod I=0 then begin 
          prime:=false; exit;
      end;
          prime:=true;
    end;</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                ### 判断longint范围内的数是否为素数（包含求50000以内的素数表） ```stylus     procedure getprime;       var         i,j:longint;         p:array[1..50000] of boolean;        begin          fillchar(p,sizeof(p),true);   p[1]:=false;   i:=2;   while i&lt;50000 do begin     if
                p[i] then begin       j:=i*2;       while j&lt;50000 do begin         p[j]:=false;         inc(j,i);       end;      end;      inc(i);    end;    l:=0;    for i:=1 to 50000 do      if p[i] then begin        inc(l);pr[l]:=i;     end; end;{getprime}
                    function prime(x:longint):integer;        var i:integer;        begin          prime:=false;   for i:=1 to l do     if pr[i]&gt;=x then break       else if x mod pr[i]=0 then exit;   prime:=true; end;{prime}
                <figure class="highlight plain">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">
# 图论算法</span><br><span class="line">## 最小生成树</span><br><span class="line">### Prim算法</span><br><span class="line"></span><br><span class="line">```stylus
     procedure prim(v0:integer);
       var
         lowcost,closest:array[1..maxn] of integer;
  i,j,k,min:integer;
       begin
         for i:=1 to n do begin
    lowcost[i]:=cost[v0,i];
    closest[i]:=v0;
   end;
  for i:=1 to n-1 do begin
    &#123;寻找离生成树最近的未加入顶点k&#125;
    min:=maxlongint;
    for j:=1 to n do
      if (lowcost[j]&lt;min) and (lowcost[j]&lt;&gt;0) then begin
        min:=lowcost[j];
        k:=j;
      end;
    lowcost[k]:=0; &#123;将顶点k加入生成树&#125;
       &#123;生成树中增加一条新的边k到closest[k]&#125;
    &#123;修正各点的lowcost和closest值&#125;
    for j:=1 to n do
      if  cost[k,j]&lt;lwocost[j] then begin
        lowcost[j]:=cost[k,j];
        closest[j]:=k;
      end;
    end;
end;&#123;prim&#125;</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                ### Kruskal算法(贪心) 按权值递增顺序删去图中的边，若不形成回路则将此边加入最小生成树。

                <figure class="highlight">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">function find(v:integer):integer; &#123;返回顶点v所在的集合&#125;
  var i:integer;
  begin
    i:=1;
    while (i&lt;=n) and (not v in vset[i]) do inc(i);
    if i&lt;=n then find:=i else find:=0;
  end;
procedure kruskal;
  var
    tot,i,j:integer;
  begin
    for i:=1 to n do vset[i]:=[i];&#123;初始化定义n个集合，第I个集合包含一个元素I&#125;
p:=n-1; q:=1; tot:=0; &#123;p为尚待加入的边数，q为边集指针&#125;
sort;
&#123;对所有边按权值递增排序，存于e[I]中，e[I].v1与e[I].v2为边I所连接的两个顶点的序号，e[I].len为第I条边的长度&#125;
    while p&gt;0 do begin
      i:=find(e[q].v1);j:=find(e[q].v2);
      if i&lt;&gt;j then begin
        inc(tot,e[q].len);
        vset[i]:=vset[i]+vset[j];vset[j]:=[];
        dec(p);
      end;
      inc(q);
    end;
    writeln(tot);
  end;</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                ## 最短路径 ### 标号法求解单源点最短路径 ```stylus     var       a:array[1..maxn,1..maxn] of integer;       b:array[1..maxn] of integer; {b[i]指顶点i到源点的最短路径}       mark:array[1..maxn] of boolean;     procedure bhf;       var         best,best_j:integer;       begin         fillchar(mark,sizeof(mark),false);
                     mark[1]:=true; b[1]:=0;{1为源点}      repeat        best:=0;          for i:=1 to n do           If mark[i] then {对每一个已计算出最短路径的点}            for j:=1 to n do              if (not mark[j]) and (a[i,j]&gt;0) then             if (best=0)
                or (b[i]+a[i,j]&lt;best) then begin               best:=b[i]+a[i,j];  best_j:=j;            end;         if best&gt;0 then begin           b[best_j]:=best；mark[best_j]:=true;         end;       until best=0;       end;{bhf}
                <figure class="highlight plain">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">
### Floyed算法求解所有顶点对之间的最短路径</span><br><span class="line"></span><br><span class="line">```stylus
      procedure floyed;
        begin
for I:=1 to n do
  for j:=1 to n do
  if a[I,j]&gt;0 then p[I,j]:=I else p[I,j]:=0; &#123;p[I,j]表示I到j的最短路径上j的前驱结点&#125;
   for k:=1 to n do &#123;枚举中间结点&#125;
     for i:=1 to n do
       for j:=1 to n do
         if a[i,k]+a[j,k]&lt;a[i,j] then begin
        a[i,j]:=a[i,k]+a[k,j];
              p[I,j]:=p[k,j];
      end;
       end;</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                ### Dijkstra 算法 ```stylus var       a:array[1..maxn,1..maxn] of integer;       b,pre:array[1..maxn] of integer; {pre[i]指最短路径上I的前驱结点}       mark:array[1..maxn] of boolean; procedure dijkstra(v0:integer);   begin     fillchar(mark,sizeof(mark),false);     for
                i:=1 to n do begin       d[i]:=a[v0,i];       if d[i]&lt;&gt;0 then pre[i]:=v0 else pre[i]:=0;     end;     mark[v0]:=true;     repeat   {每循环一次加入一个离1集合最近的结点并调整其他结点的参数}       min:=maxint; u:=0; {u记录离1集合最近的结点}       for i:=1 to n do         if
                (not mark[i]) and (d[i]&lt;min) then begin           u:=i; min:=d[i];       end;       if u&lt;&gt;0 then begin         mark[u]:=true;         for i:=1 to n do          if (not mark[i]) and (a[u,i]+d[u]&lt;d[i]) then begin            d[i]:=a[u,i]+d[u];
                           pre[i]:=u;         end;       end;     until u=0;   end;
                <figure class="highlight plain">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">
## 计算图的传递闭包</span><br><span class="line"></span><br><span class="line">```stylus
Procedure Longlink;
  Var
T:array[1..maxn,1..maxn] of boolean;
  Begin
Fillchar(t,sizeof(t),false);
For k:=1 to n do
  For I:=1 to n do
    For j:=1 to n do T[I,j]:=t[I,j] or (t[I,k] and t[k,j]);
  End;</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                ## 无向图的连通分量 ### 深度优先 ```stylus   procedure dfs ( now,color: integer);      begin        for i:=1 to n do         if a[now,i] and c[i]=0 then begin {对结点I染色}           c[i]:=color;           dfs(I,color);         end; end;
                <figure class="highlight plain">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">
### 宽度优先（种子染色法）

## 关键路径
</span><br><span class="line">几个定义： 顶点1为源点，n为汇点。
</span><br><span class="line">a. 顶点事件最早发生时间Ve[j], Ve [j] = max&#123; Ve [j] + w[I,j] &#125;,其中Ve (1) = 0;
</span><br><span class="line">b. 顶点事件最晚发生时间 Vl[j], Vl [j] = min&#123; Vl[j] – w[I,j] &#125;,其中 Vl(n) = Ve(n);
</span><br><span class="line">c. 边活动最早开始时间 Ee[I], 若边I由&lt;j,k&gt;表示，则Ee[I] = Ve[j];
</span><br><span class="line">d. 边活动最晚开始时间 El[I], 若边I由&lt;j,k&gt;表示，则El[I] = Vl[k] – w[j,k];
</span><br><span class="line">若 Ee[j] = El[j] ，则活动j为关键活动，由关键活动组成的路径为关键路径。
</span><br><span class="line">求解方法：
</span><br><span class="line">a. 从源点起topsort,判断是否有回路并计算Ve;
</span><br><span class="line">b. 从汇点起topsort,求Vl;
</span><br><span class="line">c. 算Ee 和 El;

## 拓扑排序
</span><br><span class="line">找入度为0的点，删去与其相连的所有边，不断重复这一过程。
</span><br><span class="line">例：寻找一数列，其中任意连续p项之和为正，任意q 项之和为负，若不存在则输出NO.

## 回路问题
### Euler回路(DFS)
</span><br><span class="line">定义：经过图的每条边仅一次的回路。（充要条件：图连同且无奇点）
</span><br><span class="line">### Hamilton回路
</span><br><span class="line">定义：经过图的每个顶点仅一次的回路。
</span><br><span class="line">一笔画
</span><br><span class="line">充要条件：图连通且奇点个数为0个或2个。</span><br><span class="line">
## 判断图中是否有负权回路 Bellman-ford 算法
</span><br><span class="line">x[I],y[I],t[I]分别表示第I条边的起点，终点和权。共n个结点和m条边。</span><br><span class="line"></span><br><span class="line">```stylus
   procedure bellman-ford
    begin
for I:=0 to n-1 do d[I]:=+infinitive;
d[0]:=0;
for I:=1 to n-1 do
  for j:=1 to m do &#123;枚举每一条边&#125;
    if d[x[j]]+t[j]&lt;d[y[j]] then d[y[j]]:=d[x[j]]+t[j];
for I:=1 to m do
  if d[x[j]]+t[j]&lt;d[y[j]] then return false else return true;
    end;</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                ## 第n最短路径问题 **第二最短路径：每举最短路径上的每条边，每次删除一条，然后求新图的最短路径，取这些路径中最短的一条即为第二最短路径。同理，第n最短路径可在求解第n-1最短路径的基础上求解。** # 背包问题 ## 部分背包问题可有贪心法求解：计算Pi/Wi        - 数据结构：         - w[i]:第i个背包的重量；     - p[i]:第i个背包的价值； ## 0-1背包： 每个背包只能使用一次或有限次(可转化为一次) ### 求最多可放入的重量。 有一个箱子容量为v(正整数，o≤v≤20000)，同时有n个物品(o≤n≤30)，每个物品有一个体积
                (正整数)。要求从 n 个物品中，任取若千个装入箱内，使箱子的剩余空间为最小。 #### 搜索方法 ```stylus     procedure search(k,v:integer); {搜索第k个物品，剩余空间为v}     var i,j:integer;     begin       if v&lt;best then best:=v;       if v-(s[n]-s[k-1])&gt;=best then exit; {s[n]为前n个物品的重量和}
                      if k&lt;=n then begin         if v&gt;w[k] then search(k+1,v-w[k]);         search(k+1,v);       end;     end;
                <figure class="highlight plain">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">
#### DP</span><br><span class="line">
F[I,j]为前i个物品中选择若干个放入使其体积正好为j的标志，为布尔型。</span><br><span class="line">
实现:将最优化问题转化为判定性问题
</span><br><span class="line">```stylus</span><br><span class="line">f [I, j] = f [ i-1, j-w[i] ] (w[I]&lt;=j&lt;=v)       边界：f[0,0]:=true.
For I:=1 to n do
  For j:=w[I] to v do  F[I,j]:=f[I-1,j-w[I]];
优化：当前状态只与前一阶段状态有关，可降至一维。
F[0]:=true;
For I:=1 to n do begin
  F1:=f;
  For j:=w[I] to v do
If f[j-w[I]] then f1[j]:=true;
  F:=f1;
End;</span><br><span class="line">```
### 求可以放入的最大价值。</span><br><span class="line"></span><br><span class="line">```stylus
F[I,j] 为容量为I时取前j个背包所能获得的最大价值。
F [i,j] = max &#123; f [ i – w [ j ], j-1] + p [ j ],  f[ i,j-1] &#125;</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                ### 求恰好装满的情况数。 ```stylus DP: Procedure update; var j,k:integer; begin     c:=a;     for j:=0 to n do       if a[j]&gt;0 then           if j+now&lt;=n then inc(c[j+now],a[j]);     a:=c; end;
                <figure class="highlight plain">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">
## 可重复背包
### 求最多可放入的重量。
</span><br><span class="line">F[I,j]为前i个物品中选择若干个放入使其体积正好为j的标志，为布尔型。
</span><br><span class="line">状态转移方程为:
</span><br><span class="line">f[I,j] = f [ I-1, j – w[I]*k ] (k=1.. j div w[I])</span><br><span class="line">
### 求可以放入的最大价值。</span><br><span class="line">
进行一次竞赛，总时间T固定，有若干种可选择的题目，每种题目可选入的数量不限，每种题目有一个ti（解答此题所需的时间）和一个si（解答此题所得的分数），现要选择若干题目，使解这些题的总时间在T以内的前提下，所得的总分最大，求最大的得分。
</span><br><span class="line">易想到：
</span><br><span class="line">f[i,j] = max &#123; f [i- k*w[j], j-1] + k*p[j] &#125;  (0&lt;=k&lt;= i div w[j])
</span><br><span class="line">其中f[i,j]表示容量为i时取前j种背包所能达到的最大值。
</span><br><span class="line">实现：</span><br><span class="line"></span><br><span class="line">```stylus
Begin
  FillChar(f,SizeOf(f),0);
  For i:=1 To M Do
  For j:=1 To N Do
    If i-problem[j].time&gt;=0 Then
    Begin
      t:=problem[j].point+f[i-problem[j].time];
      If t&gt;f[i] Then f[i]:=t;
    End;
  Writeln(f[M]);
End.</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                ### 求恰好装满的情况数。 求自然数n本质不同的质数和的表达式的数目。 思路一，生成每个质数的系数的排列，在一一测试，这是通法。

                <figure class="highlight">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">procedure try(dep:integer);
    var i,j:integer;
    begin
      cal; &#123;此过程计算当前系数的计算结果，now为结果&#125;
      if now&gt;n then exit; &#123;剪枝&#125;
      if dep=l+1 then begin &#123;生成所有系数&#125;
        cal;
        if now=n then inc(tot);
        exit;
      end;
      for i:=0 to n div pr[dep]  do  begin
        xs[dep]:=i;
        try(dep+1);
        xs[dep]:=0;
      end;
    end;</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                思路二，递归搜索效率较高

                <figure class="highlight">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">  procedure try(dep,rest:integer);
    var i,j,x:integer;
    begin
      if (rest&lt;=0) or (dep=l+1) then begin
        if rest=0 then inc(tot);
        exit;
      end;
      for i:=0 to rest div pr[dep] do
        try(dep+1,rest-pr[dep]*i);
    end;
&#123;main: try(1,n); &#125;</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                思路三：可使用动态规划求解 V个物品，背包容量为n，求放法总数。 实现： ```stylus Procedure update; var j,k:integer; begin     c:=a;     for j:=0 to n do       if a[j]&gt;0 then         for k:=1 to n div now do           if j+now*k&lt;=n then inc(c[j+now*k],a[j]);     a:=c; end; {main}
                begin read(now); {读入第一个物品的重量}   i:=0;   {a[i]为背包容量为i时的放法总数}   while i&lt;=n do begin a[i]:=1; inc(i,now); end;  {定义第一个物品重的整数倍的重量a值为1，作为初值} for i:=2 to v do   begin     read(now);     update; {动态更新}   end;   writeln(a[n]);
                <figure class="highlight plain">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">
# 排序算法
## 快速排序</span><br><span class="line"></span><br><span class="line">```stylus
procedure qsort(l,r:integer);
   var i,j,mid:integer;
   begin
        i:=l;j:=r; mid:=a[(l+r) div 2]; &#123;将当前序列在中间位置的数定义为中间数&#125;
    repeat
      while a[i]&lt;mid do inc(i); &#123;在左半部分寻找比中间数大的数&#125;
      while a[j]&gt;mid do dec(j);&#123;在右半部分寻找比中间数小的数&#125;
      if i&lt;=j then begin  &#123;若找到一组与排序目标不一致的数对则交换它们&#125;
        swap(a[i],a[j]);
        inc(i);dec(j);  &#123;继续找&#125;
      end;
   until i&gt;j;
   if l&lt;j then qsort(l,j); &#123;若未到两个数的边界，则递归搜索左右区间&#125;
   if i&lt;r then qsort(i,r);
  end;&#123;sort&#125;</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                ## 插入排序 思路：当前a[1]..a[i-1]已排好序了，现要插入a[i]使a[1]..a[i]有序。

                <figure class="highlight">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">  procedure insert_sort;
  var i,j:integer;
  begin
    for i:=2 to n do begin
      a[0]:=a[i];
      j:=i-1;
      while a[0]&lt;a[j] do begin
        a[j+1]:=a[j];
j:=j-1;
      end;
      a[j+1]:=a[0];
    end;
  end;&#123;inset_sort&#125;</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                ## 选择排序 ```stylus procedure sort;    var i,j,k:integer;    begin      for i:=1 to n-1 do        for j:=i+1 to n do          if a[i]&gt;a[j] then swap(a[i],a[j]);    end;
                <figure class="highlight plain">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">
## 冒泡排序</span><br><span class="line"></span><br><span class="line">```stylus
procedure bubble_sort;
   var i,j,k:integer;
   begin
    for i:=1 to n-1 do
      for j:=n downto i+1 do
        if a[j]&lt;a[j-1] then swap( a[j],a[j-1]); &#123;每次比较相邻元素的关系&#125;
  end;</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                ## 堆排序 ```stylus procedure sift(i,m:integer);{调整以i为根的子树成为堆,m为结点总数}   var k:integer;   begin     a[0]:=a[i]; k:=2*i;{在完全二叉树中结点i的左孩子为2*i,右孩子为2*i+1}     while k&lt;=m do begin       if (k&lt;m) and (a[k]&lt;a[k+1]) then inc(k);{找出a[k]与a[k+1]中较大值}     if
                a[0]&lt;a[k] then begin a[i]:=a[k];i:=k;k:=2*i; end     else k:=m+1;     end;     a[i]:=a[0]; {将根放在合适的位置}   end; procedure heapsort;   var     j:integer;   begin     for j:=n div 2 downto 1 do sift(j,n);     for j:=n downto 2 do begin
                      swap(a[1],a[j]);       sift(1,j-1);     end; end;
                <figure class="highlight plain">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">
## 归并排序</span><br><span class="line"></span><br><span class="line">```stylus
&#123;a为序列表，tmp为辅助数组&#125;
procedure merge(var a:listtype; p,q,r:integer);
&#123;将已排序好的子序列a[p..q]与a[q+1..r]合并为有序的tmp[p..r]&#125;
  var I,j,t:integer;
     tmp:listtype;
  begin
    t:=p;i:=p;j:=q+1;&#123;t为tmp指针，I,j分别为左右子序列的指针&#125;
    while (t&lt;=r) do begin
      if (i&lt;=q)&#123;左序列有剩余&#125; and ((j&gt;r) or (a[i]&lt;=a[j])) &#123;满足取左边序列当前元素的要求&#125;
        then begin
              tmp[t]:=a[i]; inc(i);
        end
      else begin
            tmp[t]:=a[j];inc(j);
      end;
    inc(t);
  end;
  for i:=p to r do a[i]:=tmp[i];
end;&#123;merge&#125;
procedure merge_sort(var a:listtype; p,r: integer); &#123;合并排序a[p..r]&#125;
  var  q:integer;
  begin
    if p&lt;&gt;r then begin
      q:=(p+r-1) div 2;
      merge_sort (a,p,q);
      merge_sort (a,q+1,r);
      merge (a,p,q,r);
    end;
  end;
&#123;main&#125;
begin
  merge_sort(a,1,n);
end.</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                ## 基数排序 思想：对每个元素按从低位到高位对每一位进行一次排序 # 高精度计算 高精度数的定义：

                <figure class="highlight">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">  type hp=array[1..maxlen] of integer;</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                ## 高精度加法 ```stylus procedure plus ( a,b:hp; var c:hp);   var i,len:integer; begin   fillchar(c,sizeof(c),0);   if a[0]&gt;b[0] then len:=a[0] else len:=b[0];   for i:=1 to len do begin     inc(c[i],a[i]+b[i]); if c[i]&gt;10 then begin dec(c[i],10); inc(c[i+1]);
                end; {进位} end;   if c[len+1]&gt;0 then inc(len);   c[0]:=len; end;{plus}
                <figure class="highlight plain">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">
## 高精度减法</span><br><span class="line"></span><br><span class="line">```stylus
procedure substract(a,b:hp;var c:hp); 
  var i,len:integer;
  begin
    fillchar(c,sizeof(c),0);
    if a[0]&gt;b[0] then len:=a[0] else len:=b[0];
    for i:=1 to len do begin
      inc(c[i],a[i]-b[i]);
      if c[i]&lt;0 then begin inc(c[i],10);dec(c[i+1]); end;
      while (len&gt;1) and (c[len]=0) do dec(len);
    c[0]:=len;
  end;</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                ## 高精度乘以低精度 ```stylus procedure multiply(a:hp;b:longint;var c:hp);   var i,len:integer;   begin     fillchar(c,sizeof(c),0);     len:=a[0];     for i:=1 to len do begin       inc(c[i],a[i]*b);       inc(c[i+1],(a[i]*b) div 10);       c[i]:=c[i] mod 10;
                    end;     inc(len);     while (c[len]&gt;=10) do begin {处理最高位的进位}       c[len+1]:=c[len] div 10;       c[len]:=c[len] mod 10;       inc(len);      end;     while (len&gt;1) and (c[len]=0) do dec(len); {若不需进位则调整len}     c[0]:=len;   end;{multiply}
                <figure class="highlight plain">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">
## 高精度乘以高精度</span><br><span class="line"></span><br><span class="line">```stylus
procedure high_multiply(a,b:hp; var c:hp&#125;
  var i,j,len:integer;
  begin
    fillchar(c,sizeof(c),0);
    for i:=1 to a[0] do
      for j:=1 to b[0] do begin
        inc(c[i+j-1],a[i]*b[j]);
     inc(c[i+j],c[i+j-1] div 10);
     c[i+j-1]:=c[i+j-1] mod 10;
      end;
    len:=a[0]+b[0]+1;
    while (len&gt;1) and (c[len]=0) do dec(len);
    c[0]:=len;
  end;</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                ## 高精度除以低精度 ```stylus procedure devide(a:hp;b:longint; var c:hp; var d:longint);   {c:=a div b; d:= a mod b}   var i,len:integer;   begin     fillchar(c,sizeof(c),0);     len:=a[0]; d:=0;     for i:=len downto 1 do begin       d:=d*10+a[i];       c[i]:=d
                div b;       d:=d mod b;     end;     while (len&gt;1) and (c[len]=0) then dec(len);     c[0]:=len;   end;
                <figure class="highlight plain">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">
## 高精度除以高精度</span><br><span class="line"></span><br><span class="line">```stylus
procedure high_devide(a,b:hp; var c,d:hp);
  var
    i,len:integer;
  begin
    fillchar(c,sizeof(c),0);
    fillchar(d,sizeof(d),0);
    len:=a[0];d[0]:=1;
    for i:=len downto 1 do begin
      multiply(d,10,d);
      d[1]:=a[i];
      while(compare(d,b)&gt;=0) do &#123;即d&gt;=b&#125;
      begin
        Subtract(d,b,d);
        inc(c[i]);
      end;
    end;
    while(len&gt;1)and(c.s[len]=0) do dec(len);
    c.len:=len;
  end;</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                # 树的遍历 ## 已知前序中序求后序 ```stylus procedure Solve(pre,mid:string);   var i:integer;   begin     if (pre='') or (mid='') then exit;     i:=pos(pre[1],mid);     solve(copy(pre,2,i),copy(mid,1,i-1));     solve(copy(pre,i+1,length(pre)-i),copy(mid,i+1,length(mid)-i));
                    post:=post+pre[1]; {加上根，递归结束后post即为后序遍历}   end;
                <figure class="highlight plain">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">
## 已知中序后序求前序</span><br><span class="line"></span><br><span class="line">```stylus
procedure Solve(mid,post:string);
  var i:integer;
  begin
    if (mid=&apos;&apos;) or (post=&apos;&apos;) then exit;
    i:=pos(post[length(post)],mid);
    pre:=pre+post[length(post)]; &#123;加上根，递归结束后pre即为前序遍历&#125;
    solve(copy(mid,1,I-1),copy(post,1,I-1));
    solve(copy(mid,I+1,length(mid)-I),copy(post,I,length(post)-i));
  end;</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                ## 已知前序后序求中序的一种 ```stylus function ok(s1,s2:string):boolean;   var i,l:integer;   p:boolean;   begin     ok:=true;     l:=length(s1);     for i:=1 to l do begin       p:=false;       for j:=1 to l do         if s1[i]=s2[j] then p:=true;       if not p
                then begin ok:=false;exit;end;     end;   end; procedure solve(pre,post:string);    var i:integer;    begin      if (pre='') or (post='') then exit;      i:=0;      repeat        inc(i);      until ok(copy(pre,2,i),copy(post,1,i));      solve(copy(pre,2,i),copy(post,1,i));
                     midstr:=midstr+pre[1];      solve(copy(pre,i+2,length(pre)-i-1),copy(post,i+1,length(post)-i-1));    end;
                <figure class="highlight plain">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">
# 进制转换
## 任意正整数进制间的互化
  </span><br><span class="line">除n取余
</span><br><span class="line">## 实数任意正整数进制间的互化
</span><br><span class="line">乘n取整
</span><br><span class="line">## 负数进制</span><br><span class="line">
设计一个程序，读入一个十进制数的基数和一个负进制数的基数，并将此十进制数转换为此负 进制下的数：-R∈&#123;-2，-3，-4,....-20&#125; </span><br><span class="line">
# 全排列与组合的生成
## 排列的生成：（1..n）
</span><br><span class="line">```stylus</span><br><span class="line">procedure solve(dep:integer);
    var
      i:integer;
    begin
      if dep=n+1 then begin writeln(s);exit; end;
      for i:=1 to n do
        if not used[i] then begin
          s:=s+chr(i+ord(&apos;0&apos;));used[i]:=true;
          solve(dep+1);
          s:=copy(s,1,length(s)-1); used[i]:=false;
      end;
    end;</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                ## 组合的生成(1..n中选取k个数的所有方案)

                <figure class="highlight">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">procedure solve(dep,pre:integer);
    var
      i:integer;
    begin
      if dep=k+1 then begin writeln(s);exit; end;
      for i:=1 to n do
        if (not used[i]) and (i&gt;pre) then begin
          s:=s+chr(i+ord('0'));used[i]:=true;
          solve(dep+1,i);
          s:=copy(s,1,length(s)-1); used[i]:=false;
      end;
end;</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                # 查找算法 ## 折半查找 ```stylus function binsearch(k:keytype):integer;   var low,hig,mid:integer;   begin     low:=1;hig:=n;     mid:=(low+hig) div 2;     while (a[mid].key&lt;&gt;k) and (low&lt;=hig) do begin       if a[mid].key&gt;k then hig:=mid-1         else
                low:=mid+1;       mid:=(low+hig) div 2;     end;     if low&gt;hig then mid:=0;     binsearch:=mid;   end;
                <figure class="highlight plain">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">
## 树形查找
</span><br><span class="line">二叉排序树：每个结点的值都大于其左子树任一结点的值而小于其右子树任一结点的值。
</span><br><span class="line">查找
</span><br><span class="line">```stylus</span><br><span class="line">function treesrh(k:keytype):pointer;
  var q:pointer;
  begin
    q:=root;
    while (q&lt;&gt;nil) and (q^.key&lt;&gt;k) do
      if k&lt;q^.key then q:=q^.left
      else q:=q^.right;
     treesrh:=q;
  end;</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                # 贪心 会议问题 - n个活动每个活动有一个开始时间和一个结束时间，任一时刻仅一项活动进行，求满足活动数最多的情况。 解：按每项活动的结束时间进行排序，排在前面的优先满足。 - 会议室空闲时间最少。 - 每个客户有一个愿付的租金，求最大利润。 - 共R间会议室，第i个客户需使用i间会议室，费用相同，求最大利润。 # 回溯法框架 ## n皇后问题 ```stylus procedure try(i:byte);   var j:byte;   begin     if i=n+1 then begin
                print;exit;end;       for j:=1 to n do         if a[i] and b[j+i] and c[j-i] then begin           x[i]:=j;        a[j]:=false; b[j+i]:=false; c[j-i]:=false;        try(i+1);        a[j]:=true; b[i+j]:=true; c[j-i]:=true;      end;   end;
                <figure class="highlight plain">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">
## Hanoi Tower   
  </span><br><span class="line">```stylus </span><br><span class="line">  h(n)=2*h(n-1)+1   h(1)=1 </span><br><span class="line">  初始所有铜片都在a柱上
  procedure hanoi(n,a,b,c:byte); &#123;将第n块铜片从a柱通过b柱移到c柱上&#125;
begin
  if n=0 then exit;
  hanoi(n-1,a,c,b); &#123;将上面的n-1块从a柱通过c柱移到b柱上&#125;
  write(n,’moved from’,a,’to’,c);
  hanoi(n-1,b,a,c);&#123; 将b上的n-1块从b柱通过a柱移到c柱上
end;
  初始铜片分布在3个柱上，给定目标柱goal
  h[1..3,0..n]存放三个柱的状态，now与nowp存最大的不到位的铜片的柱号和编号,h[I,0]存第I个柱上的个数。
  Procedure move(k,goal:integer); &#123;将最大不到位的k移到目标柱goal上&#125;
Begin
  If k=0 then exit;
  For I:=1 to 3 do
    For j:=1 to han[I,0] do
     If h[I,j]=k then begin now:=I;nowp:=j; end; &#123;找到k的位置&#125;
  If now&lt;&gt;goal then begin  &#123;若未移到目标&#125;
    Move(k-1,6-now-goal);  &#123;剩下的先移到没用的柱上&#125;
    Writeln(k moved from now to goal);
    H[goal,h[goal,0]+1]:=h[now,nowp]; h[now,nowp]:=0;
    Inc(h[goal,0]); dec(h[now,0]);
    Move(k-1,goal); &#123;剩下的移到目标上&#125;
End;</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                # DFS框架 ```stylus procedure work(dep,pre,s:longint); {入口为work(1,1,n)} {dep为当前试放的第dep个数,pre为前一次试放的数,s为当前剩余可分的总数}   var j:longint;   begin     if dep=n then begin       if s&gt;=pre then inc(r); exit;     end;     for j:=pre to s div 2 do work(dep+1,j,s-j);
                  end; 类似： procedure try(dep:integer);     var i:integer;     begin       if dep=k then begin         if tot&gt;=a[dep-1] then inc(sum);           exit; end;       for i:=a[dep-1] to tot div 2 do begin         a[dep]:=i; dec(tot,i); try(dep+1);
                        inc(tot,i);       end;     end;{try}
                <figure class="highlight plain">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">
# BFS框架
</span><br><span class="line">```stylus
head:=1; tail:=0;
while tail&lt;head do begin
  inc(tail);
  for k:=1 to n do
    if k方向可扩展 then begin
      inc(head);
      list[head].x:=list[tail].x+dx[k];  &#123;扩展出新结点list[head]&#125;
      list[head].y:=list[tail].y+dy[k];
      处理新结点list[head];
    end;
end;</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                # 数据结构相关算法 ## 链表的定位函数loc(I:integer):pointer; {寻找链表中的第I个结点的指针} ```stylus procedure loc(L:linklist; I:integer):pointer;   var p:pointer; j:integer;   begin p:=L.head; j:=0; if (I&gt;=1) and (I&lt;=L.len) then   while j&lt;I do begin p:=p^.next; inc(j);
                end; loc:=p;   end;
                <figure class="highlight plain">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">
## 单链表的插入操作</span><br><span class="line"></span><br><span class="line">```stylus
procedure insert(L:linklist; I:integer; x:datatype);
  var p,q:pointer;
  begin
p:=loc(L,I);
new(q);
q^.data:=x;
q^.next:=p^.next;
p^.next:=q;
inc(L.len);
  end;</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                ## 单链表的删除操作 ```stylus procedure delete(L:linklist; I:integer);   var p,q:pointer;   begin p:=loc(L,I-1); q:=p^.next; p^.next:=q^.next; dispose(q); dec(L.len);   end;
                <figure class="highlight plain">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">
## 双链表的插入操作（插入新结点q）
</span><br><span class="line">```stylus</span><br><span class="line">p:=loc(L,I);
new(q);
q^.data:=x;
q^.pre:=p;
q^.next:=p^.next;
p^.next:=q;
q^.next^.pre:=q;</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                ## 双链表的删除操作

                <figure class="highlight">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">p:=loc(L,I); &#123;p为要删除的结点&#125;
p^.pre^.next:=p^.next;
p^.next^.pre:=p^.pre;
dispose(p);</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>


                ## 关键路径（最长路经） ```stylus var a,b:array [1..10,1..10] of integer;     n,last,out:integer;     q,c:array [1..10] of integer;     o:set of 1..10; procedure init;   var i,j:integer; begin   readln(n);   for i:=1 to n do     for j:=1 to n do       read(a[i,j]);
                  last:=0;   o:=[]; out:=0;   b:=a; end; procedure sort;   var i,j:integer;       p:boolean; begin   while out&lt;&gt;n do begin     for i:=1 to n do     if not (i in o) then begin       p:=true;       for j:=1 to n do         if a[j,i]=1
                then begin           p:=false;           break;         end;       if p then begin         inc(last);         q[last]:=i;         inc(out); o:=o+[i];         fillchar(a[i],sizeof(a[i]),0);       end;     end;   end; end; procedure work_1;
                  var i,j,t,k:integer; begin   a:=b;  c[1]:=0;   for i:=1 to n do begin     k:=0;     for j:=1 to i-1 do       if (a[q[j],q[i]]&gt;0) and (a[q[j],q[i]]+c[q[j]]&gt;k)         then k:=a[q[j],q[i]]+c[q[j]];     c[q[i]]:=k;   end; end; procedure
                work_2;   var i,j,k:integer; begin   writeln(q[n]);   for i:=n-1 downto 1 do begin     k:=maxint;     for j:=i+1 to n do       if (a[q[i],q[j]]&gt;0) and (c[q[j]]-a[q[i],q[j]]&lt;k) then k:=c[q[j]]-a[q[i],q[j]];     if c[q[i]]=k then writeln(q[i],'
                ');     c[q[i]]:=k;   end; end; begin   init;   sort;   work_1;   work_2; end.
                <figure class="highlight plain">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line">
## 拓扑排序</span><br><span class="line"></span><br><span class="line">```stylus 
var a:array [1..100,1..100] of 0..1;
    n:integer;
    p:set of 1..100;
procedure init;
  var i,j,k:integer;
begin
  fillchar(a,sizeof(a),0);
  readln(n);
  for i:=1 to n do begin
    read(k);
    while k&lt;&gt;0 do begin
      a[i,k]:=1;
      read(k);
    end;
  end;
  p:=[];
end;
procedure search;
  var i,j,t,sum,printed:integer;
begin
  printed:=0;
  while printed&lt;n do
    for i:=1 to n do begin
      sum:=0;
      for j:=1 to n do sum:=sum+a[j,i];
      if (sum=0) and not(i in p) then begin
        write(i,&apos; &apos;);
        p:=p+[i];
        inc(printed);
        for t:=1 to n do a[i,t]:=0;
      end;
    end;
end;
begin
  init;
  search;
end.</span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>
                </code>
                </pre>

              </div>
              <footer class="article-footer">

                <div id="donation_div"></div>

                <script src="/js/vdonate.js"></script>
                <script>
                  var a = new Donate({
                    title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
                    btnText: '打赏支持', // 可选参数，打赏按钮文字
                    el: document.getElementById('donation_div'),
                    wechatImage: 'http://www.meng.uno/money/wechat.JPG',
                    alipayImage: 'http://www.meng.uno/money/alipay.JPG'
                  });
                </script>


                <div id="comment">
                  <!-- 来必力City版安装代码 -->
                  <div id="lv-container" data-id="city" data-uid="MTAyMC8zNDA2OC8xMDYwNg==">
                    <script type="text/javascript">
                      (function(d, s) {
                        var j, e = d.getElementsByTagName(s)[0];

                        if (typeof LivereTower === 'function') {
                          return;
                        }

                        j = d.createElement(s);
                        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                        j.async = true;

                        e.parentNode.insertBefore(j, e);
                      })(document, 'script');
                    </script>
                    <noscript>为正常使用评论功能请激活JavaScript</noscript>
                  </div>
                  <!-- City版安装代码已完成 -->
                </div>

                <ul class="article-tag-list">
                  <li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法设计/">算法设计</a><span class="article-tag-list-count">2</span></li>
                </ul>
              </footer>
            </div>

            <nav id="article-nav">

              <a href="/posts/832e4a48/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          一次数学建模经历
        
      </div>
    </a>


              <a href="/posts/8e9f2014/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">完全动态最大匹配的简单确定性算法</div>
    </a>

            </nav>

          </article>

          <!-- Table of Contents -->

          <aside id="toc-sidebar">
            <div id="toc" class="toc-article">
              <strong class="toc-title">目录导航</strong>

              <ol class="nav">
                <li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">数论算法</span></a>
                  <ol class="nav-child">
                    <li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">1.1.</span> <span class="nav-text">求两数的最大公约数</span></a></li>
                  </ol>
                </li>
              </ol>

            </div>
          </aside>
        </section>

      </div>

      <footer id="footer">


        <div class="container">
          <div class="row">
            <p id="copyRightEn">&copy; 2018.02.08 - 2018.02.18 <a href="http://www.meng.uno/">匡盟盟</a>&nbsp;保留所有权利！</p>

            <p class="busuanzi_uv">
              访客数 : <span id="busuanzi_value_site_uv"></span> | 访问量 : <span id="busuanzi_value_site_pv"></span>
            </p>

            <a href="http://webscan.360.cn/index/checkwebsite/url/www.meng.uno"><img border="0" height=27px width=74px src="/css/images/webscan.png"/></a>
            <img border="0" height=27px width=109px style="background-color:white;" src="/css/images/kaba.png" />

            <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a>

          </div>

        </div>
      </footer>


      <!-- min height -->

      <script>
        var wrapdiv = document.getElementById("wrap");
        var contentdiv = document.getElementById("content");
        var allheader = document.getElementById("allheader");

        wrapdiv.style.minHeight = document.body.offsetHeight + "px";
        if (allheader != null) {
          contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
        } else {
          contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
        }
      </script>

      <script>
        (function() {
          var src = (document.location.protocol == "http:") ? "http://js.passport.qihucdn.com/11.0.1.js?5d3bca9f7d6a95532f3ebb56e3c6bf11" : "https://jspassport.ssl.qhimg.com/11.0.1.js?5d3bca9f7d6a95532f3ebb56e3c6bf11";
          document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
      </script>
    </div>
    <!-- <nav id="mobile-nav">

  <a href="/" class="mobile-nav-link">Home</a>

  <a href="/archives" class="mobile-nav-link">Archives</a>

  <a href="/categories" class="mobile-nav-link">Categories</a>

  <a href="/tags" class="mobile-nav-link">Tags</a>

  <a href="/about" class="mobile-nav-link">About</a>

  <a href="/comments" class="mobile-nav-link">Comments</a>

</nav> -->
    <!-- mathjax config similar to math.stackexchange -->

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] } });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() { var all = MathJax.Hub.getAllJax(), i; for(i=0; i
      < all.length; i +=1 ) { all[i].SourceElement().parentNode.className +=' has-jax' ; } }); </script>

        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>


        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
        <script src="/fancybox/jquery.fancybox.pack.js"></script>


        <script src="/js/scripts.js"></script>




        <script src="/js/dialog.js"></script>


        <!-- Google Analytics -->
        <script type="text/javascript">
          (function(i, s, o, g, r, a, m) {
            i['GoogleAnalyticsObject'] = r;
            i[r] = i[r] || function() {
              (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o),
              m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m)
          })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

          ga('create', 'UA-113947925-1', 'auto');
          ga('send', 'pageview');
        </script>
        <!-- End Google Analytics -->


        <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
        </script>
  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h2 class="modal-title" id="myModalLabel">设置</h2>
        </div>
        <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
        <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


        <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
            <div class="panel-body">
              您已调整页面字体大小
            </div>
          </div>



          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
          </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
            <div class="panel-body">
              夜间模式已经开启，再次单击按钮即可关闭
            </div>
          </div>

          <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
          </div>
          <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
            <div class="panel-body">
              欢迎来到匡盟盟的博客！
            </div>
            <div class="panel-body">
              一个不满平凡的大龄码农
            </div>
            <div class="panel-body">
              Copyright © 2018 匡盟盟 All Rights Reserved.
            </div>
          </div>
        </div>


        <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
        <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
        <div class="modal-footer">
          <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
        </div>
      </div>
    </div>
  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>

  <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>


<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":100,"height":200,"superSample":2,"hOffset":-30,"vOffset":-130},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2}});</script></body>

</html>