<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>欢迎来到匡盟盟的博客！</title>
  
  <subtitle>Colyn 崛起正当时！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.meng.uno/"/>
  <updated>2018-07-17T02:29:34.464Z</updated>
  <id>http://www.meng.uno/</id>
  
  <author>
    <name>匡盟盟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java合并List</title>
    <link href="http://www.meng.uno/articles/66999e7d/"/>
    <id>http://www.meng.uno/articles/66999e7d/</id>
    <published>2018-07-15T02:15:54.000Z</published>
    <updated>2018-07-17T02:29:34.464Z</updated>
    
    <content type="html"><![CDATA[<h1>问题</h1><p>在写我的毕业设计时，遇到了这样两个问题：</p><ol>  <li>给定一个分词结果（List    <string>）与一个知道偏置的专有名词（特定领域命名实体）的结果（List      <stirng>），怎么将两者融合成一个统一的分词结果（List        <string>）。</string></stirng></string></li>  <li>给定一个分词结果（List    <string>）与一条规则（人为规定的分词结果（List      <string>）），怎么将规则整合到分词结果中，得到一个统一的分词结果（List        <string>）。</string></string></string></li></ol><p>虽然在算法上没有多少难度，但是在实现上还是挺费时间思考，所以我将我的实现保存起来，以后没准我还会再用到。</p><h1>方案</h1><h2 id="合并专有名词">合并专有名词</h2><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre>      </td>      <td class="code">        <pre><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">segTemp</span><span class="params">(List&lt;String&gt; tmp, List&lt;Term&gt; area, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ret = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">int</span> area_len = area.size();</span><br><span class="line">    <span class="keyword">if</span> (area_len == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp_i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tmp.size(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (index == area.get(tmp_i).getOffe()) &#123;</span><br><span class="line">        ret.add(area.get(tmp_i).getRealName());</span><br><span class="line">        index += area.get(tmp_i).getRealName().length();</span><br><span class="line">        i--;</span><br><span class="line">        <span class="keyword">if</span> (tmp_i &lt; area_len - <span class="number">1</span>) &#123;</span><br><span class="line">          tmp_i++;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; tmp_index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp_index + tmp.get(i).length() &lt;= index) &#123;</span><br><span class="line">          tmp_index += tmp.get(i).length();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ret.add(tmp.get(i).substring(index - tmp_index));</span><br><span class="line">          tmp_index += tmp.get(i).length();</span><br><span class="line">          index = tmp_index;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index + tmp.get(i).length() &lt;= area.get(tmp_i).getOffe()) &#123;</span><br><span class="line">        ret.add(tmp.get(i));</span><br><span class="line">        index += tmp.get(i).length();</span><br><span class="line">        tmp_index += tmp.get(i).length();</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index + tmp.get(i).length() &gt; area.get(tmp_i).getOffe()</span><br><span class="line">          &amp;&amp; index &lt; area.get(tmp_i).getOffe()) &#123;</span><br><span class="line">        ret.add(tmp.get(i).substring(<span class="number">0</span>, area.get(tmp_i).getOffe() - index));</span><br><span class="line">        index += area.get(tmp_i).getOffe() - index;</span><br><span class="line">        tmp_index += tmp.get(i).length();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从上一个位置break</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; tmp.size(); j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (index &gt; tmp_index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp_index + tmp.get(j).length() &lt;= index) &#123;</span><br><span class="line">          tmp_index += tmp.get(j).length();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ret.add(tmp.get(j).substring(index - tmp_index));</span><br><span class="line">          tmp_index += tmp.get(j).length();</span><br><span class="line">          index = tmp_index;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret.add(tmp.get(j));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">## 合并规则</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">match</span><span class="params">(String text, List&lt;String&gt; ori, List&lt;Rule&gt; rule)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rule.isEmpty())&#123;</span><br><span class="line"><span class="keyword">return</span> ori;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; ret = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span>(Rule ru : rule)&#123;</span><br><span class="line">List&lt;Integer&gt; loc = getLocation(text,ru.toString());</span><br><span class="line"><span class="keyword">if</span>(loc.isEmpty())&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">int</span> num = loc.size();</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; num;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = loc.get(i);</span><br><span class="line"><span class="keyword">while</span>(idx+ori.get(j).length() &lt; tmp)&#123;</span><br><span class="line">ret.add(ori.get(j));</span><br><span class="line">idx += ori.get(j).length(); </span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ori.get(j).substring(idx+ori.get(j).length() - tmp) != <span class="keyword">null</span> || !ori.get(j).substring(idx+ori.get(j).length() - tmp).equals(<span class="string">""</span>))&#123;</span><br><span class="line">ret.add(ori.get(j).substring(idx+ori.get(j).length() - tmp));</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">ret.addAll(ru.getRule());</span><br><span class="line"><span class="keyword">while</span>(j&lt;ori.size())&#123;</span><br><span class="line"><span class="keyword">if</span>(idx + ori.get(j).length() &lt;= tmp+ru.toString().length())&#123;</span><br><span class="line">idx += ori.get(j).length();</span><br><span class="line">j++;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(idx + ori.get(j).length() &gt; tmp+ru.toString().length() &amp;&amp; idx &lt; tmp + ru.toString().length())&#123;</span><br><span class="line">idx += ori.get(j).length();</span><br><span class="line">ret.add(ori.get(j).substring(idx - (tmp + ru.toString().length() )));</span><br><span class="line">j++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(j&lt;ori.size())&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t = j;t &lt; ori.size();t++)&#123;</span><br><span class="line">ret.add(ori.get(t));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ori = ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="keyword">false</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> ori;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p><br><br>本文链接： <a href="http://www.meng.uno/articles/undefined/">http://www.meng.uno/articles/undefined/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      问题
在写我的毕业设计时，遇到了这样两个问题：

 1. 给定一个分词结果（List ）与一个知道偏置的专有名词（特定领域命名实体）的结果（List ），怎么将两者融合成一个统一的分词结果（List ）。
 2. 给定一个分词结果（List ）与一条规则（人为规定的分词结果（List ）），怎么将规则整合到分词结果中，得到一个统一的分词结果（List ）。

虽然在算法上没有多少难度，但是在实现上还是挺费时间思考，所以我将我的实现保存起来，以后没准我还会再用到。

方案
合并专有名词
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
2
    
    </summary>
    
      <category term="Java开发Tips" scheme="http://www.meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/"/>
    
    
      <category term="Java" scheme="http://www.meng.uno/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Oracle教程</title>
    <link href="http://www.meng.uno/articles/33c755f8/"/>
    <id>http://www.meng.uno/articles/33c755f8/</id>
    <published>2018-04-04T06:56:38.000Z</published>
    <updated>2018-04-04T08:08:39.319Z</updated>
    
    <content type="html"><![CDATA[<h1>Oracle第一章</h1><ol>  <li>首先打开Oracle服务</li>  <li>配置监听器（这个是因为教室的电脑Oracle安装有问题，没有配置好监听器）开始菜单中找到<em>net configration assistant</em>添加一个监听器</li>  <li>用system用户登录sqlplus</li>  <li>解锁scott用户 :（也是因为教室的Oracle安装问题导致scott账户未解锁）</li></ol><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">alter user scott account unlock;</span><br></pre>      </td>    </tr>  </table></figure><ol start="5">  <li>修改scott密码:</li></ol><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">alter user scott identified by tiger;</span><br></pre>      </td>    </tr>  </table></figure><ol start="6">  <li>使用scott登录sqlplus, scott是oracle自带的一个实例账户，它带有四个实例表,其中重要的就是<code>emp</code>员工表与<code>dept</code>部门表</li>  <li>安装PL/SQL第三方工具, 因为Oracle没有自带的图形化界面管理器，所以我们需要安装PLSQL，它是oracle的一个第三方GUI工具。</li></ol><p><strong><em>介绍一下Oracle的命令</em></strong></p><ul>  <li>连接数据库：</li></ul><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">connect scoott/tiger@orcl;</span><br></pre>      </td>    </tr>  </table></figure><p>用户名为scott，密码为tiger,数据库名为orcl</p><ul>  <li>显示当前用户：</li></ul><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">show user;</span><br></pre>      </td>    </tr>  </table></figure><p>也可使用查询语句：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">select USER from dual; --dual是oracle的一个虚拟表</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>显示表结构(以emp表为例)：</li></ul><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">describe emp;</span><br></pre>      </td>    </tr>  </table></figure><p>可简写为：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">desc emp;</span><br></pre>      </td>    </tr>  </table></figure><h1>Oracle第二章</h1><h2 id="创建表空间">创建表空间</h2><p>（在SqlServer中称为创建一个是数据库，而在Oracle中则称为创建一个表空间）</p><p><em>格式： create tablespace 表空间名 datafile ‘文件路径’ size 文件大小</em></p><p>如：</p><pre><code>cerate tablespace myspace datafile 'D:\myspace.dbf' size 10MB;</code></pre><p>删除表空间：</p><pre><code>drop tablespace myspace incluiding contents and datafile;</code></pre><h2 id="创建用户">创建用户</h2><p><em>格式： create user 用户名 identified by 密码 default tablespace 默认表空间</em></p><p>如：</p><pre><code>create user user1 identified by user1 default tablespace system;</code></pre><p><strong>删除用户：</strong></p><pre><code>drop user user1 cascade;</code></pre><h2 id="给用户授权">给用户授权</h2><p><em>方式一：授予角色</em></p><pre><code>1、connect     //登录2、resource    //普通权限，用于操作3、DBA         //管理员权限（慎用）</code></pre><p>如：</p><pre><code>grant connect to user1;grant connect,resource to user1;</code></pre><p><em>方式二：授予单个权限</em></p><p>如：</p><pre><code>grant create table to user1;           //授予user1建表的权限grant drop table to user1;             //授予user1删表的权限</code></pre><p><em>方式三：将某个对象的权限授予用户</em></p><p>如：</p><pre><code>grant select on scott.emp to user1;      //将scott用户的emp表的查询权限授予user1grant all on scott.emp to user1;       //将scott用户的emp表的所有权限授予user1 </code></pre><p><strong>收回权限：</strong></p><p><em>格式： revoke 权限 from 用户</em></p><p>如：</p><pre><code>revoke connect from user1;   //收回user1的connect权限revoke select on scott.emp from user1;    //收回user1对emp表的查询权限  </code></pre><h1>Oracle第三章</h1><h2 id="基本查询">基本查询</h2><p><em>select格式：</em></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">select 列名 from 表名 ；</span><br><span class="line">where 查询条件</span><br><span class="line">group by 分组列</span><br><span class="line">having 分组后条件</span><br><span class="line">order by 排序列 asc[desc]</span><br></pre>      </td>    </tr>  </table></figure><p>如：查询部门10的雇员</p><pre><code>select * from emp where deptno=10;</code></pre><h2 id="行号-rownum">行号（rownum）</h2><p><strong>每个表都有一个虚列ROWNUM，它用来显示结果中记录的行号。我们在查询中也可以显示这个列。</strong></p><p>如：显示emp表的行号</p><pre><code>select rownum,ename from emp;</code></pre><p>如：显示前三行</p><pre><code>select * from emp where rownum&lt;=3;</code></pre><h2 id="查询进行计算">查询进行计算</h2><p>如：显示雇员工资上浮20%的结果</p><pre><code>select ename,sal,sal*(1+20%) from emp;</code></pre><p>如：显示每个员工的总工资（工资+奖金）</p><pre><code>update emp set comm = o where comm is null;    //因为null的特殊性，它与任何值运算都等于null，所以先要把它更新为0，后面我们会学到一个函数来处理null值select ename,sal+comm from emp;</code></pre><h2 id="使用别名">使用别名</h2><p>如：在查询中使用列别名</p><pre><code>select ename as 名称，sal as 工资 from emp; //建议省略as</code></pre><p><em>另，在别名为关键字或有特殊符号时需要加双引号</em></p><p>如：</p><pre><code>select ename as &quot;select&quot;,sal*12+5000 as &quot;年度工资（加年终奖）&quot; from emp;</code></pre><h2 id="连接运算符">连接运算符</h2><p><strong>连接运算符是双竖线“||”。通过连接运算可以将两个字符串连接在一起。</strong></p><p>如：在查询中使用连接运算</p><pre><code>select ename||job as &quot;雇员和职务表&quot; from emp;</code></pre><p>*注意：‘5’||5结果为’55’    ‘5’+5结果为 10 *</p><h2 id="六-消除重复行-distinct">六、消除重复行（distinct）</h2><p><strong>如果在显示结果中存在重复行，可以使用关键字<code>distinct</code>消除重复显示</strong></p><p>如：统计职务的数量</p><pre><code>select count(distinct job) from emp;</code></pre><h2 id="排序">排序</h2><p><strong>1、升序（默认为升序<code>asc</code>,所以可以忽略）</strong></p><p>如：查询雇员姓名和工资，并按工资从小到大排序</p><pre><code>select ename,sal from emp order by sal asc;</code></pre><p><strong>2、降序（<code>desc</code>不可忽略）</strong></p><p>如：查询雇员姓名和雇佣日期，并按雇佣日期排序，后雇佣的先显示</p><pre><code>select ename,hiredate from emp order by hiredate desc;</code></pre><p><strong>3、多列排序</strong></p><p><em>可以按多列进行排序，先按第一列，然后按第二列、第三列…。</em></p><p>如：查询雇员信息，先按部门从小到大排序，再按雇佣时间的先后排序</p><pre><code>select ename,deptno,hiredate from emp order by deptno hiredate;</code></pre><h1>Oracle第四章——条件查询、字符型函数</h1><h2 id="条件查询">条件查询</h2><p><strong>1、模糊查询(between、in、like)</strong></p><p>A、between：在某某之间。如,显示工资在1000~2000之间的雇员</p><pre><code>select * from emp where sal beteween 1000 and 2000;</code></pre><p>B、in：在某某之间。如，显示职务为“SALMAN”，“CLEARK”和“MANAGER”的雇员信息</p><pre><code>select * from emp where job in ('SALMAN','CLERK','MANAGER');</code></pre><p>C、like：与通配符使用</p><p><em>通配符：% 代表0个或任意个字符     —_ 代表1个字符</em></p><p>如：显示姓名以“S”开头的雇员信息。</p><pre><code>select * from emp where ename like 'S%';</code></pre><p>显示姓名第二个字符为“A”的雇员信息</p><pre><code>select * from emp ename like '_A%';</code></pre><p><strong>2、空值查询</strong></p><p><em>空：is null      非空： is not null</em></p><p>如：查询奖金为空的雇员信息</p><pre><code>select * from emp where comm is null;</code></pre><h2 id="函数">函数</h2><p><strong>1、数学函数</strong></p><table>  <tr>    <td>函数</td>    <td>功能</td>    <td>实例</td>    <td>结果</td>  </tr>  <tr>    <td>abs</td>    <td>求绝对值函数</td>    <td>abs(-5)</td>    <td>5</td>  </tr>  <tr>    <td>sqrt</td>    <td>求平方根</td>    <td>sqrt(2)</td>    <td>1.414</td>  </tr>  <tr>    <td>power</td>    <td>求幂函数</td>    <td>power(2,3)</td>    <td>8</td>  </tr></table><p>使用求绝对值函数abs</p><pre><code>select abs(-5) from dual;</code></pre><p>使用求平方根函数sqrt。</p><pre><code>select sqrt(2) from dual;</code></pre><p>使用ceil函数。</p><pre><code>select ceil(2.35) from dual;</code></pre><p>使用floor函数。</p><pre><code>select floor(2.35) from dual;</code></pre><p><strong>2、使用四舍五入函数round</strong> <small> 格式：round(数字，保留的位数)</small></p><pre><code>select round(45.923,2), round(45.923,0), round(45.923,-1) from dual;</code></pre><p><strong>3、字符型函数</strong></p><table><tr><td>ascii</td><td>返回与ASCII码相应的字符</td><td>Ascii('A')</td><td>65</td></tr><td>char</td><td>返回与ASCII码相应的字符</td><td>char(65)</td><td>A</td><tr><td>lower</td><td>将字符串转换成小写</td><td>lower ('SQL Course')</td><td>sql course</td></tr><tr><td>upper</td><td>将字符串转换成</td><td>upper('SQL Course')</td><td>SQL COURSE</td></tr><tr><td>initcap</td><td>将字符串转换成每个单词以大写开头</td><td>initcap('SQL course')</td><td>SQL Course</td></tr><tr><td>concat</td><td>连接两个字符串</td><td>concat('SQL', ' Course')</td><td>SQL Course</td></tr><tr><td>substr</td><td>给出起始位置和长度，返回子字符串</td><td>substr('String',1,3)</td><td>Str</td></tr><tr><td>length</td><td>求字符串的长度</td><td>length('Wellcom')</td><td>7</td></tr><tr><td>trim</td><td>在一个字符串中去除另一个字符串</td><td>trim('S' FROM 'SSMITH')</td><td>MITH</td></tr><tr><td>replace</td><td>用一个字符串替换另一个字符串中的子字符串</td><td>replace('ABC', 'B', 'D')</td><td>ADC</td></tr></table><p>如果不知道表的字段内容是大写还是小写，可以转换后比较。</p><pre><code>select empno, ename,deptno from emp where lower(ename)='blake';</code></pre><p>显示名称以“W”开头的雇员，并将名称转换成以大写开头。</p><pre><code>select empno,initcap(ename),job from emp wher substr(ename,1,1)='W';</code></pre><p>显示雇员名称中包含“S”的雇员名称及名称长度。</p><pre><code>select empno,ename,legth(ename) from emp where instr(ename,'S',1,1)&gt;0;</code></pre><h1>Oracle第五章——函数</h1><h2 id="日期型函数">日期型函数</h2><p><strong>Oracle使用内部数字格式来保存时间和日期，包括世纪、年、月、日、小时、分、秒。缺省日期格式为 DD-MON-YY，如“08-05月-03”代表2003年5月8日。</strong></p><ul><li>SYSDATE：返回系统日期和时间的虚列函数。</li></ul><p>如：返回系统的当前日期。</p><pre><code>SELECT sysdate FROM dual;</code></pre><ul><li>对两个日期相减，得到相隔天数。</li></ul><p><em>通过加小时来增加天数，24小时为一天，如12小时可以写成12/24(或0.5)。</em></p><p>如：例1 假定当前的系统日期是2003年2月6日，求再过1000天的日期。</p><pre><code>SELECT sysdate+1000 AS &quot;NEW DATE&quot; FROM dual;</code></pre><p>例2：两个日期相减</p><pre><code> select to_date('1-1月-2000') - to_date('1-8月-1999') from dual;</code></pre><ul><li>其它日期函数</li></ul><table><thead><tr><th>函数</th><th>功能</th><th>实例</th><th>结果</th></tr></thead><tbody><tr><td>months_between</td><td>返回两个日期间的月份</td><td>months_between (‘04-11月-05’,‘11-1月-01’)57.7741935</td><td></td></tr><tr><td>add_months</td><td>返回把月份数加到日期上的新日期</td><td>add_months(‘06-2月-03’,1)，add_months(‘06-2月-03’,-1)</td><td>06-3月-03，06-1月-03</td></tr><tr><td>next_day</td><td>返回指定日期后的星期对应的新日期</td><td>next_day(‘06-2月-03’,‘星期一’)</td><td>10-2月-03</td></tr><tr><td>last_day</td><td>返回指定日期所在的月的最后一天</td><td>last_day(‘06-2月-03’)</td><td>28-2月-03</td></tr><tr><td>round</td><td>按指定格式对日期进行四舍五入</td><td>round(to_date(‘13-2月-03’),‘YEAR’)，round(to_date(‘13-2月-03’),‘MONTH’)，round(to_date(‘13-2月-03’),‘DAY’)</td><td>01-1月-03，01-2月-03，16-2月-03(按周四舍五入)</td></tr></tbody></table><p>如：返回2003年2月的最后一天。</p><pre><code>SELECT last_day('08-2月-03') FROM dual;</code></pre><p>假定当前的系统日期是2003年2月6日，显示部门10雇员的雇佣天数。</p><pre><code>SELECT ename, round(sysdate-hiredate) DAYS FROM emp WHERE  deptno = 10;</code></pre><h2 id="转换函数">转换函数</h2><table><thead><tr><th>函数</th><th>功能</th><th>实例</th><th>结果</th></tr></thead><tbody><tr><td>To_char</td><td>转换成字符串类型</td><td>To_char(1234.5, ‘$9999.9’)</td><td>$1234.5</td></tr><tr><td>To_date</td><td>转换成日期类型</td><td>To_date(‘1980-01-01’, ‘yyyy-mm-dd’)</td><td>01-1月-80</td></tr><tr><td>To_number</td><td>转换成数值类型</td><td>To_number(‘1234.5’)</td><td>1234.5</td></tr></tbody></table><ul><li>自动类型转换</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT &apos;12.5&apos;+11 FROM dual;    //结果为：23.5</span><br><span class="line">Select  ‘12.5’||11 from dual;    //结果为：’12.511’</span><br></pre></td></tr></table></figure><ul><li>日期类型转换</li></ul><table><thead><tr><th>代码</th><th>代表的格式</th><th>例子</th></tr></thead><tbody><tr><td>AM、PM</td><td>上午、下午</td><td>08 AM</td></tr><tr><td>D</td><td>数字表示的星期(1～7)</td><td>1,2,3,4,5,6,7</td></tr><tr><td>DD</td><td>数字表示月中的日期(1～31)</td><td>1,2,3,…,31</td></tr><tr><td>MM</td><td>两位数的月份</td><td>01,02,…,12</td></tr><tr><td>Y、YY、YYY、YYYY</td><td>年份的后几位</td><td>3,03,003,2003</td></tr><tr><td>RR</td><td>解决Y2K问题的年度转换</td><td></td></tr><tr><td>DY</td><td>简写的星期名</td><td>MON,TUE,FRI,…</td></tr><tr><td>DAY</td><td>全拼的星期名</td><td>MONDAY,TUESDAY,…</td></tr><tr><td>MON</td><td>简写的月份名</td><td>JAN,FEB,MAR,…</td></tr><tr><td>MONTH</td><td>全拼的月份名</td><td>JANUARY,FEBRUARY,…</td></tr><tr><td>HH、HH12</td><td>12小时制的小时(1～12)</td><td>1,2,3,…,12</td></tr><tr><td>HH24</td><td>24小时制的小时(0～23)</td><td>0,1,2,…,23</td></tr><tr><td>MI</td><td>分(0～59)</td><td>0,1,2,…,59</td></tr><tr><td>SS</td><td>秒(0～59)</td><td>0,1,2,…,59</td></tr><tr><td>,./-;:</td><td>原样显示的标点符号</td><td></td></tr><tr><td>‘TEXT’</td><td>引号中的文本原样显示</td><td>TEXT</td></tr></tbody></table><p>如：1、日期型转字符型</p><p>将日期转换成带时间和星期的字符串并显示。</p><pre><code>SELECT TO_CHAR(sysdate,'YYYY-MM-DD HH24:MI:SS AM DY') FROM dual;</code></pre><p>将日期显示转换成中文的年月日。</p><pre><code>SELECT TO_CHAR(sysdate,'YYYY&quot;年&quot;MM&quot;月&quot;DD&quot;日&quot;') FROM dual;</code></pre><p>2.字符型转日期型</p><p>往emp表中插入一条记录</p><pre><code>insert into emp values(8888,'张三','CLERK',7369,to_date('1-1月-2000'),1000,10,10);insert into emp values(8889,'李四','CLERK',7369,to_date('2000-01-01','YYYY-MM-DD'),1000,10,10);</code></pre><h2 id="其他常用函数">其他常用函数</h2><table><thead><tr><th>函数</th><th>功能</th><th>实例</th><th>结果</th></tr></thead><tbody><tr><td>nvl</td><td>空值转换函数</td><td>nvl(null, ‘空’)</td><td>空</td></tr><tr><td>decode</td><td>实现分支功能</td><td>decode(1,1, ‘男’, 2, ‘女’)</td><td>男</td></tr><tr><td>userenv</td><td>返回环境信息</td><td>userenv(‘LANGUAGE’)</td><td>SIMPLIFIED CHINESE_CHINA.ZHS16GBK</td></tr><tr><td>greatest</td><td>返回参数的最大值</td><td>greatest(20,35,18,9)</td><td>35</td></tr><tr><td>least</td><td>least返回参数的最小值</td><td>least(20,35,18,9)</td><td>9</td></tr></tbody></table><h3 id="1-空值的转换">1．空值的转换</h3><p><em>如果对空值NULL不能很好的处理，就会在查询中出现一些问题。在一个空值上进行算术运算的结果都是NULL。最典型的例子是，在查询雇员表时，将工资sal字段和津贴字段comm进行相加，如果津贴为空，则相加结果也为空，这样容易引起误解。</em></p><p><strong>使用nvl函数，可以转换NULL为实际值。该函数判断字段的内容，如果不为空，返回原值；为空，则返回给定的值。</strong></p><p>如下3个函数，分别用新内容代替字段的空值：</p><pre><code>nvl(comm, 0)：用0代替空的Comm值。nvl(hiredate, '01-1月-97')：用1997年1月1日代替空的雇佣日期。nvl(job, '无')：用“无”代替空的职务。</code></pre><p>使用nvl函数转换空值。</p><pre><code>SELECTename,nvl(job,'无'),nvl(hiredate,'01-1月-97'),nvl(comm,0) FROM emp;</code></pre><h3 id="2-decode函数">2．decode函数</h3><p><em>decode函数可以通过比较进行内容的转换，完成的功能相当于分支语句。在参数的最后位置上可以存在单独的参数，如果以上比较过程没有找到匹配值，则返回该参数的值，如果不存在该参数，则返回NULL。</em></p><p>将职务转换成中文显示。</p><pre><code>SELECTename,decode(job, 'MANAGER', '经理', 'CLERK','职员', 'SALESMAN','推销员', 'ANALYST','系统分析员','未知') FROM emp;</code></pre><h3 id="3-最大-最小值函数">3．最大、最小值函数</h3><p><em>greatest返回参数列表中的最大值，least返回参数列表中的最小值。</em></p><p><strong>如果表达式中有NULL，则返回NULL。</strong></p><h1>Oracle第六章——相等、外连接</h1><h2 id="相等连接">相等连接</h2><h3 id="1-三个步骤">1、三个步骤</h3><p>A、先列出要显示的列： select ename,job,comm,emp,deptno,dname</p><p>B、列出查询的表： from emp,dept</p><p>C、列出多表相连条件（主外键）：where emp.deptno=dept.deptno</p><p><em>注意：如果两个表有同名列，那么前面必须接表名 如： emp.deptno ,如果不是同名字段则表名可以省略</em></p><h3 id="2-inner-join-的写法">2、inner join 的写法</h3><pre><code>select enaem,job,sal,comm,emp.deptno,dname from emp inner join dept on emp.deptno = dept.deptno;</code></pre><h3 id="3-三表或三表以上的写法">3、三表或三表以上的写法</h3><pre><code>select 字段1，字段2 , 字段3 。。。。from 表1，表2，表3.。。where 表1.外键 = 表2.主键  and 表1.外键 = 表3.主键 and 。。。</code></pre><p><em>注意：两个表有一个条件 ，三个表有两个条件 ，四个表有三个条件 以此类推</em></p><h2 id="外连接-不等连接">外连接（不等连接）</h2><p><em>左外连接即在内连接的基础上，左边表中有但右边表中没有的记录也以null的形式显示出来，右外连接则反之</em></p><h3 id="1-写法1">1、写法1</h3><p><em>(右外连接)</em></p><pre><code>select ename,d.deptno,dname from emp e,dept d where e.deptno(+) = d.deptno</code></pre><p><em>(左外连接)</em></p><pre><code>select ename,d.deptno,dname from emp e,dept d where d.deptno = e.deptno(+)    </code></pre><h3 id="2-写法2">2、写法2</h3><pre><code>select ename,d.deptno,dname from emp e right join dept d on e.deptno = d.deptno  </code></pre><h1>Oracle第七章——连接、分组查询</h1><h2 id="不等连接">不等连接</h2><p><strong>拿一个表作为另一表的查询条件或范围</strong></p><p>如：显示雇员名称，工资和所属工资等级。</p><pre><code>select e.ename,e.sal,s.grade from emp e,salgrade s where e.sal between s.losal and s.hisal;</code></pre><h2 id="自连接">自连接</h2><p><strong>自连接就是一个表，同本身进行连接。对于自连接可以想像存在两个相同的表(表和表的副本)，可以通过不同的别名区别两个相同的表（其它就是内连接)</strong></p><p>如：显示雇员名称和雇员的经理名称</p><pre><code>select worker.ename||'的经理是'||manager.ename as 雇员经理 from emp worker,emp manager where worker.mgr=manager.empno;</code></pre><h2 id="组函数">组函数</h2><ul><li>组函数只能应用于SELECT子句、HAVING子句或ORDER BY子句中。</li><li>组函数也可以称为统计函数。</li><li>组函数忽略列的空值。</li><li>对组可以应用组函数。</li><li>在组函数中可使用DISTINCT或ALL关键字。</li><li>ALL表示对所有非NULL值(可重复)进行运算。</li><li>DISTINCT 表示对每一个非NULL值，如果存在重复值，则组函数只运算一次。如果不指明上述关键字，默认为ALL。</li></ul><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>AVG</td><td>求平均值</td></tr><tr><td>COUNT</td><td>求计数值，返回非空行数，*表示返回所有行</td></tr><tr><td>MAX</td><td>求最大值</td></tr><tr><td>MIN</td><td>求最小值</td></tr><tr><td>SUM</td><td>求和</td></tr><tr><td>SIDDEV</td><td>求标准偏差，是根据差的平方根得到的</td></tr><tr><td>VARIANCE</td><td>求统计方差</td></tr></tbody></table><h2 id="分组查询">分组查询</h2><p><strong>1、如：按职务统计工资总和。</strong></p><pre><code>select deptno,job,sum(sal) from emp group by deptno,job;</code></pre><p><strong>2、多列分组</strong></p><p>如：按部门和职务分组统计工资总和:</p><pre><code>select deptno,job,sum(sal) from emp group by deptno,job;</code></pre><p><strong>3、HAVING</strong></p><p><em>HAVING从句过滤分组后的结果，它只能出现在GROUP BY从句之后，而WHERE从句要出现在GROUP BY从句之前。</em></p><p>如：统计各部门的最高工资，排除最高工资小于3000的部门。</p><pre><code>select deptno,max(sal) from emp group by deptno having max(sal)&gt;=3000;</code></pre><p><strong>4、分组统计结果排序</strong></p><p><em>可以使用ORDER BY从句对统计的结果进行排序，ORDER BY从句要出现在语句的最后。</em></p><p>如：按职务统计工资总和并排序。</p><pre><code>select job 职务, sum(sal) 工资总和 from emp group by job order by sum(sal);</code></pre><p><strong>5、组函数的嵌套使用</strong></p><p>如：求各部门平均工资的最高值。</p><pre><code>select max(avg(sal)) from emp group by deptno;</code></pre><h1>Oracle第八章——子查询</h1><h2 id="子查询">子查询</h2><p><strong>通过把一个查询的结果作为另一个查询的一部分,子查询一般出现在SELECT语句的WHERE子句中，Oracle也支持在FROM或HAVING子句中出现子查询。子查询比主查询先执行，结果作为主查询的条件，在书写上要用圆括号扩起来，并放在比较运算符的右侧。</strong></p><h3 id="1-单行子查询">1、单行子查询</h3><p>如：查询比SCOTT工资高的雇员名字和工资。</p><pre><code>select ename,sal from emp where sal&gt;(select sal from emp where empno=7788);</code></pre><h3 id="2-多行子查询">2、多行子查询*</h3><p><strong>如果子查询返回多行的结果，则我们称它为多行子查询。多行子查询要使用不同的比较运算符号，它们是IN、ANY和ALL。</strong></p><p>如:查询工资低于任意一个“CLERK”的工资的雇员信息。</p><pre><code>select empno,ename,job,sal from emp where sal &lt; any (select sal from emp where job = 'CLERK') and job &lt;&gt; 'CLERK';</code></pre><p>如：查询工资比所有的“SALESMAN”都高的雇员的编号、名字和工资。</p><pre><code>select empno,ename,job from emp where job in (select job from emp where deptno = 10) and deptno = 20;</code></pre><h3 id="3-多列子查询">3.多列子查询</h3><p>**如果子查询返回多列，则对应的比较条件中也应该出现多列，这种查询称为多列子查询。以下是多列子查询的训练实例。**如： 查询职务和部门与SCOTT相同的雇员的信息。</p><pre><code>select empno, ename,sal from emp where (job,deptno) = (select job,deptno from emp where empno = 7788);</code></pre><h3 id="4-在from从句中使用子查询">4．在FROM从句中使用子查询</h3><p><strong>在FROM从句中也可以使用子查询，在原理上这与在WHERE条件中使用子查询类似。有的时候我们可能要求从雇员表中按照雇员出现的位置来检索雇员，很容易想到的是使用rownum虚列。比如我们要求显示雇员表中6～9位置上的雇员，可以用以下方法</strong></p><p>如：查询雇员表中排在第6～9位置上的雇员。</p><pre><code>select ename, sal, from (select rownum as num,ename,sal from emp where rownum&lt;=9) where num&gt;=6;</code></pre><h2 id="集合运算">集合运算</h2><table><thead><tr><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>union</td><td>并集，合并两个操作的结果，去掉重复的部分</td></tr><tr><td>union all</td><td>并集，合并两个操作的结果，保留重复的部分</td></tr><tr><td>minus</td><td>差集，从前面的操作结果中去掉与后面操作结果相同的部分</td></tr><tr><td>intersect</td><td>交集，取两个操作结果中相同的部分</td></tr></tbody></table><p>如：查询部门10和部门20的所有职务。</p><pre><code>select job from emp where deptno = 10 unionselect job from emp where deptno = 20;</code></pre><p>如：查询只在部门表中出现，但没有在雇员表中出现的部门编号。</p><pre><code>select deptno from deptminusselect deptno from emp;</code></pre><h1>Oracle第九章——增删改、序列、事务</h1><h2 id="增删改">增删改</h2><p>增： <code>insert into 表名(列名) values (值)；</code></p><p>删： <code>delete from 表名 where 条件；</code></p><p>改： <code>update 表名 set 列名1=值1，列名2=值2... where 条件；</code></p><h2 id="复制数据">复制数据</h2><p><strong>1、通过一条查询语句创建一个新表(要求目标表不存在)</strong></p><pre><code>create table manager as select empno,ename,sal, from emp where job= 'CLERK';</code></pre><p><strong>2、通过一条查询语句复制数据(要求目标表必须已建好)</strong></p><pre><code>insert into manager select empno,ename,sal from emp where job = 'CLERK';</code></pre><h2 id="序列">序列</h2><h3 id="1-创建序列">1、创建序列</h3><p>如：创建从2000起始，增量为1 的序列abc：</p><pre><code>create sequence abc increment by 1 start with 2000maxvalue 99999 cycle nocache;</code></pre><h3 id="2-使用序列">2、使用序列</h3><p>序列名.nextval: 代表下一个值</p><p>序列名.currval: 代表当前值</p><p>如：</p><pre><code>insert into manager values(abc.nextval,'小王',2500);insert into manager values(abc.nextval,'小赵'，2800);</code></pre><h2 id="事务">事务</h2><p>    <strong>两次连续成功的COMMIT或ROLLBACK之间的操作，称为一个事务。在一个事务内，数据的修改一起提交或撤销，如果发生故障或系统错误，整个事务也会自动撤销</strong><br>    <strong>数据库事务处理可分为隐式和显式两种。显式事务操作通过命令实现，隐式事务由系统自动完成提交或撤销(回退)工作，无需用户的干预。</strong></p><p>1、隐式提交的情况包括：</p><p>    当用户正常退出SQL*Plus或执行CREATE、DROP、GRANT、REVOKE等命令时会发生事务的自动提交。</p><p>2、显示事务:</p><pre>COMMIT        数据库事务提交，将变化写入数据库ROLLBACK数据库事务回退，撤销对数据的修改SAVEPOINT创建保存点，用于事务的阶段回退</pre><h1>Oracle第十章————建表</h1><h2 id="建表">建表</h2><p>格式：</p><pre>create table 表名      (  列名1   类型   约束,  列名2   类型   约束,  ......      );</pre><p>如：</p><p>– 创建出版社表</p><pre><code>create table 出版社（编号 varchar2(2),出版社名称 varchar2(30),地址 varchar2(30),联系电话 varchar2(20)）;</code></pre><p>– 创建图书表</p><pre><code>create table 图书 (图书编号 VARCHAR2(5),图书名称 VARCHAR2(30),出版社编号 VARCHAR2(2),作者 VARCHAR2(10),出版日期 DATE,数量 NUMBER(3),单价 NUMBER(7,2));</code></pre><h2 id="通过子查询建表">通过子查询建表</h2><p>步骤1：完全复制图书表到“图书1”</p><pre><code>create table 图书1 as select * from 图书;</code></pre><p>步骤2：创建新的图书表“图书2”，只包含书名和单价</p><pre><code>create table 图书2（书名，单价） as seelct 图书名称，单价 from 图书；</code></pre><p>步骤3：创建新的图书表“图书3”，只包含书名和单价，不复制内容</p><pre><code>create table 图书3（书名，单价） as select 图书名称，单价 from 图书 where 1=2；</code></pre><h2 id="添加表的约束">添加表的约束</h2><pre>主键     primary key      PK唯一     unique           UQ默认值   default          DF检查约束 check            CK外键约束 foreign key      FK</pre><h3 id="方法一：建表的同时添加约束">方法一：建表的同时添加约束</h3><p>如：</p><pre>create table stuinfo( sno int primary key not null,       --主键 sname varchar2(10) unique not null,       --唯一 sex char(2) default '男' check(sex='男' or sex = '女') not null,   --默认及检查 saddress varchar2(50) not null, phone char(11), email varchar2(50));create table stumarks( marksId int, sno int references stuinfo(sno) not null,     --外键 score number(5,1), examDate date default sysdate);</pre><h3 id="方法二：建表完成后-再添加约束">方法二：建表完成后，再添加约束</h3><p>如：（之前已建好了出版社表及图书表）</p><p>–主键约束</p><pre><code>alter table 出版社 add constraint PK_编号 primary key (编号);</code></pre><p>–唯一约束</p><pre><code>alter table 出版社 add constraint UQ_地址 unique (地址);</code></pre><p>–检查约束</p><pre><code>alter table 出版社 add constraint CK_联系电话 check (联系电话 like '1%');</code></pre><p>–默认值</p><pre><code>alter table 出版社 modify 地址 default '湘潭';</code></pre><p>–外键约束</p><pre><code>alter table 图书 add constraint FK_图书编号 foreign key (图书编号) references 出版社(编号);</code></pre><p>–外键约束</p><pre><code>alter table 图书 add constraint FK_图书编号 foreign key (图书编号) references 出版社(编号);</code></pre><h2 id="查看约束条件">查看约束条件</h2><p><strong>数据字典<code>USER_CONSTRAINTS</code>中包含了当前模式用户的约束条件信息。其中，CONSTRAINTS_TYPE 显示的约束类型为：</strong></p><pre>C：CHECK约束。P：PRIMARY KEY约束。U：UNIQUE约束。R：FOREIGN KEY约束。</pre><p><em>其他信息可根据需要进行查询显示，可用DESCRIBE命令查看<code>USER_CONSTRAINTS的</code>结构。</em></p><p>如:检查表的约束信息：</p><pre><code>SELECT CONSTRAINT_NAME,CONSTRAINT_TYPE,SEARCHCONDITONFROM USER_CONSTRAINTSWHERE TABLE_NAME='图书';</code></pre><h2 id="删除约束条件">删除约束条件</h2><pre><code>ALTER TABLE 表名 DROP CONSTRAINT 约束名;</code></pre><h2 id="表的操作">表的操作</h2><pre>1、删除表    drop table 表名2、重命名表  RENAME 表名 TO 新表名;3、查看表</pre><p><em>可以通过对数据字典<code>USER_OBJECTS</code>的查询，显示当前模式用户的所有表。</em></p><p>如： 显示当前用户的所有表。</p><pre><code>SELECT object_name FROM user_objects WHERE object_type='TABLE';</code></pre><h2 id="修改表">修改表</h2><h3 id="1-增加新列">1、增加新列:</h3><p>如： 为“出版社”增加一列“电子邮件”：</p><pre><code>ALTER TABLE 出版社ADD 电子邮件 VARCHAR2(30) CHECK(电子邮件 LIKE '%@%');</code></pre><h3 id="2-修改列">2、修改列</h3><p>修改列定义有以下一些特点：</p><pre>(1) 列的宽度可以增加或减小，在表的列没有数据或数据为NULL时才能减小宽度。(2) 在表的列没有数据或数据为NULL时才能改变数据类型，CHAR和VARCHAR2之间可以随意转换。(3) 只有当列的值非空时，才能增加约束条件NOT NULL。(4) 修改列的默认值，只影响以后插入的数据。如：修改“出版社”表“电子邮件”列的宽度为40。</pre><pre><code>ALTER TABLE 出版社 MODIFY 电子邮件 VARCHAR2(40);</code></pre><h3 id="3-删除列">3、删除列</h3><p>如：删除“出版社”表的“电子邮件”列。</p><pre><code>ALTER TABLE 出版社 DROP COLUMN 电子邮件;</code></pre><h1>Oracle第十一章————视图</h1><h2 id="分区表">分区表</h2><p><strong>在某些场合会使用非常大的表，比如人口信息统计表。如果一个表很大，就会降低查询的速度，并增加管理的难度。一旦发生磁盘损坏，可能整个表的数据就会丢失，恢复比较困难。根据这一情况，可以创建分区表，把一个大表分成几个区(小段)，对数据的操作和管理都可以针对分区进行，这样就可以提高数据库的运行效率。分区可以存在于不同的表空间上，提高了数据的可用性。例：创建和使用分区表。</strong></p><p>如：创建按成绩分区的考生表，共分为3个区：</p><pre>CREATE TABLE 考生 (考号 VARCHAR2(5),姓名 VARCHAR2(30),成绩 NUMBER(3))PARTITION BY RANGE(成绩)(PARTITION A VALUES LESS THAN (300)TABLESPACE USERS,PARTITION B VALUES LESS THAN (500)TABLESPACE USERS,PARTITION C VALUES LESS THAN (MAXVALUE)TABLESPACE USERS);</pre><p>步骤3：检查A区中的考生：</p><pre><code>SELECT *  FROM  考生 PARTITION(A);</code></pre><p>步骤4：检查全部的考生：</p><pre><code>SELECT *  FROM  考生;</code></pre><h2 id="视图">视图</h2><h3 id="1-视图的概念">1、视图的概念</h3><p>视图不同于表，视图本身不包含任何数据。而视图只是一种定义，对应一个查询语句。视图的数据都来自于某些表，这些表被称为基表。</p><p>视图可以在表能够使用的任何地方使用，但在对视图的操作上同表相比有些限制，特别是插入和修改操作。对视图的操作将传递到基表，所以在表上定义的约束条件和触发器在视图上将同样起作用。2、视图的创建</p><h3 id="2-格式：">2、格式：</h3><pre><code>create [or replace] view 视图名 asselect 语句;</code></pre><p>例：创建图书作者视图：</p><pre><code>CREATE VIEW 图书作者(书名,作者) AS SELECT 图书名称,作者 FROM 图书;</code></pre><p>查询视图全部内容</p><pre><code>SELECT * FROM 图书作者;    </code></pre><p>查询部分视图：</p><pre><code>SELECT 作者 FROM 图书作者;</code></pre><p>删除视图：</p><pre><code>DROP VIEW 清华图书;</code></pre><h3 id="3-创建只读视图">3．创建只读视图</h3><p>创建只读视图要用<code>WITH READ ONLY</code>选项。</p><p>例：创建emp表的经理视图：</p><pre><code>CREATE OR REPLACE VIEW manager AS SELECT * FROM emp WHERE job= 'MANAGER'WITH READ ONLY;</code></pre><h3 id="4-使用with-check-option选项">4．使用WITH CHECK OPTION选项</h3><p>使用<code>WITH CHECK OPTION</code>选项。使用该选项，可以对视图的插入或更新进行限制，即该数据必须满足视图定义中的子查询中的WHERE条件，否则不允许插入或更新。</p><p>例：</p><pre><code>CREATE OR REPLACE VIEW 清华图书 AS SELECT * FROM 图书 WHERE 出版社编号= '01'</code></pre><p><em>WITH CHECK OPTION;注：插入数据时，由于带了with check option的选项，则只能插入出版社编为’01’的数据</em></p><h3 id="5-来自基表的限制">5．来自基表的限制</h3><p>除了以上的限制，基表本身的限制和约束也必须要考虑。如果生成子查询的语句是一个分组查询，或查询中出现计算列，这时显然不能对表进行插入。另外，主键和NOT NULL列如果没有出现在视图的子查询中，也不能对视图进行插入。在视图中插入的数据，也必须满足基表的约束条件。</p><h3 id="6-视图的查看">6.视图的查看</h3><p><code>USER_VIEWS</code>字典中包含了视图的定义。</p><p><code>USER_UPDATABLE_COLUMNS</code>字典包含了哪些列可以更新、插入、删除。</p><p><code>USER_OBJECTS</code>字典中包含了用户的对象。</p><p>可以通过<code>DESCRIB</code>E命令查看字典的其他列信息。</p><p>例：查看用户拥有的视图：</p><pre><code>SELECT object_name FROM user_objects WHERE object_type='VIEW';</code></pre><h1>Oracle第十二章——索引、同义词、数据库链接、PL/SQL语句</h1><h2 id="索引">索引</h2><p><strong>索引(INDEX)是为了加快数据的查找而创建的数据库对象，特别是对大表，索引可以有效地提高查找速度，也可以保证数据的惟一性</strong></p><p><strong>创建索引一般要掌握以下原则：只有较大的表才有必要建立索引，表的记录应该大于50条，查询数据小于总行数的2%～4%。虽然可以为表创建多个索引，但是无助于查询的索引不但不会提高效率，还会增加系统开销。因为当执行DML操作时，索引也要跟着更新，这时索引可能会降低系统的性能。</strong></p><p>创建索引：</p><pre><code> CREATE INDEX 索引名 ON 表名(列名);</code></pre><p>删除索引：</p><pre><code>  DROP INDEX 索引名；</code></pre><h2 id="同义词">同义词</h2><p><strong>同义词(SYNONYM)是为模式对象起的别名，可以为表、视图、序列、过程、函数和包等数据库模式对象创建同义词。</strong></p><p>创建私有同义词：</p><pre><code>  CREATE SYNONYM BOOK FOR 图书；</code></pre><p>创建公有同义词(先要获得创建公有同义词的权限)：</p><pre><code>  CREATE PUBLIC SYNONYM BOOK FOR SCOTT.图书；</code></pre><p>删除同义词：</p><pre><code>DROP SYNONYM 同义词名；</code></pre><h2 id="数据库链接">数据库链接</h2><p><strong>数据库链接(DATABASE LINK)是在分布式环境下，为了访问远程数据库而创建的数据通信链路。</strong></p><p>格式：</p><pre><code> CREATE DATABASE LINK 链接名 CONNECT TO 账户 IDENTIFIED BY 口令 USING 服务名;</code></pre><p>数据库链接一旦建立并测试成功，就可以使用以下形式来访问远程用户的表。</p><pre><code>表名@数据库链接名</code></pre><h2 id="pl-sql">PL/sql</h2><h3 id="1-块结构和基本语法要求">1、块结构和基本语法要求</h3><p>块中各部分的作用解释如下：</p><pre><code>(1)  DECLARE：声明部分标志。(2)  BEGIN：可执行部分标志。(3)  EXCEPTION：异常处理部分标志。(4)  END；：程序结束标志。</code></pre><h3 id="2-输出">2、输出</h3><p>第一种形式：</p><pre><code>DBMS_OUTPUT.PUT(字符串表达式)；</code></pre><p>第二种形式：</p><pre><code>DBMS_OUTPUT.PUT_LINE(字符串表达式)；</code></pre><p>第三种形式：</p><pre><code>DBMS_OUTPUT.NEW_LINE；</code></pre><h3 id="3-变量赋值：">3、变量赋值：</h3><p>第一种形式：</p><pre><code>SELECT 列名1，列名2... INTO 变量1，变量2... FROM 表名 WHERE 条件；第二种形式：变量名:=值</code></pre><p>例：查询雇员编号为7788的雇员姓名和工资。</p><pre><code>SET SERVEROUTPUT ON--在命令行界面必须写DECLARE--定义部分标识 v_name  VARCHAR2(10);--定义字符串变量v_name v_sal   NUMBER(5);--定义数值变量v_salBEGIN--可执行部分标识SELECT ename,sal INTO v_name,v_sal  FROM emp  WHERE empno=7788;--在程序中插入的SQL语句DBMS_OUTPUT.PUT_LINE('7788号雇员是：'||v_name||'，工资为：'||to_char(v_sal));--输出雇员名和工资END;</code></pre><h3 id="4-结合变量的定义和使用-即全局变量">4、结合变量的定义和使用（即全局变量）</h3><p><em><em>该变量是在整个SQL</em>Plus环境下有效的变量，在退出SQL</em>Plus之前始终有效，所以可以使用该变量在不同的程序之间传递信息。结合变量不是由程序定义的，而是使用系统命令VARIABLE定义的。**</p><p>例：定义并使用结合变量</p><p>步骤1：输入和执行下列命令，定义结合变量g_ename：</p><pre><code>--SET SERVEROUTPUT ON VARIABLE  g_ename VARCHAR2(100)BEGIN:g_ename:=:g_ename|| 'Hello~ ';--在程序中使用结合变量DBMS_OUTPUT.PUT_LINE(:g_ename);                --输出结合变量的值END;</code></pre><h3 id="5-记录变量的定义">5．记录变量的定义</h3><p><strong>还可以根据表或视图的一个记录中的所有字段定义变量，称为记录变量。记录变量包含若干个字段，在结构上同表的一个记录相同，定义方法是在表名后跟%ROWTYPE。记录变量的字段名就是表的字段名，数据类型也一致。</strong></p><p>如：</p><pre><code> v_name emp.ename%TYPE;</code></pre><h1>Oracle第十三章——PL/SQL空值语句、游标</h1><h2 id="if语句">IF语句</h2><h3 id="1-if-then-end-if形式">1、IF-THEN-END IF形式</h3><pre>   IF 条件 then        语句集;   END IF;</pre><h3 id="2-if-then-else-end-if形式">2、IF-THEN-ELSE-END IF形式</h3><pre>   IF 条件 then        语句集1;   ElSE       语句集2   END IF;</pre><h3 id="3-if-then-elsif-else-end-if形式">3．IF-THEN-ELSIF-ELSE-END IF形式</h3><pre>   IF 条件1 THEN语句集1;   ELSIF 条件2 THEN语句集2;   ELSIF 条件3 THEN语句集3;   ...   ELSE语句集n;   END IF;</pre><h2 id="case语句">CASE语句</h2><h3 id="1-基本case结构">1．基本CASE结构</h3><pre>   CASE 变量或表达式   When 值1 then 结果1;   When 值2 then 结果2;   When 值3 then 结果3;   ...   ELSE 结果n;   END CASE;</pre><h3 id="2-搜索case结构">2.搜索CASE结构</h3><pre>  CASE    When 条件1 then 结果1;   When 条件2 then 结果2;   When 条件3 then 结果3;   ...   ELSE 结果n;   END CASE;</pre><h2 id="循环">循环</h2><h3 id="1-基本loop循环">1．基本LOOP循环</h3><pre>   loop      语句集;   exit when 条件      语句集;   end loop;</pre><h3 id="2-for-loop循环">2.FOR LOOP循环</h3><p>FOR循环是固定次数循环，格式如下：</p><pre>FOR 控制变量 in [REVERSE] 下限..上限 LOOP   语句集;  END LOOP;</pre><p><em>注：循环控制变量是隐含定义的，不需要声明。</em></p><p><strong>下限和上限用于指明循环次数。正常情况下循环控制变量的取值由下限到上限递增，REVERSE关键字表示循环控制变量的取值由上限到下限递减。</strong></p><h2 id="3-while-loop循环">3．WHILE LOOP循环</h2><pre>   while 条件 loop       语句集;   end loop;</pre><h2 id="游标">游标</h2><h3 id="1-概念">1、概念</h3><p><strong>游标是SQL的一个内存工作区，由系统或用户以变量的形式定义。游标的作用就是用于临时存储从数据库中提取的数据块。在某些情况下，需要把数据从存放在磁盘的表中调到计算机内存中进行处理，最后将处理结果显示出来或最终写回数据库。这样数据处理的速度才会提高，否则频繁的磁盘数据交换会降低效率。</strong></p><p>游标有两种类型：显式游标和隐式游标。</p><p>在前述程序中用到的SELECT…INTO…查询语句，一次只能从数据库中提取一行数据，系统都会使用一个隐式游标。</p><p>显式游标对应一个返回结果为多行多列的SELECT语句。</p><p>游标一旦打开，数据就从数据库中传送到游标变量中，然后应用程序再从游标变量中分解出需要的数据，并进行处理。</p><h3 id="2-隐式游标属性">2、隐式游标属性</h3><table><thead><tr><th>隐式游标的属性</th><th>返回值类型</th><th>意义</th></tr></thead><tbody><tr><td>SQL%ROWCOUNT</td><td>整型</td><td>代表DML语句成功执行的数据行数</td></tr><tr><td>SQL%FOUND</td><td>布尔型</td><td>值为TRUE代表插入、删除、更新或单行查询操作成功</td></tr><tr><td>SQL%NOTFOUND</td><td>布尔型</td><td>与SQL%FOUND属性返回值相反</td></tr><tr><td>SQL%ISOPEN</td><td>布尔型</td><td>DML执行过程中为真，结束后为假</td></tr></tbody></table><p>如：使用隐式游标的属性，判断对雇员工资的修改是否成功。</p><pre><code>SET SERVEROUTPUT ON BEGIN  UPDATE emp SET sal=sal+100 WHERE empno=1234; IF SQL%FOUND THEN  DBMS_OUTPUT.PUT_LINE('成功修改雇员工资！');  COMMIT;  ELSEDBMS_OUTPUT.PUT_LINE('修改雇员工资失败！'); END IF; END;</code></pre><h3 id="3-显式游标">3、显式游标</h3><p>游标的使用分成以下4个步骤。</p><h4 id="a-声明游标">a．声明游标</h4><p>在DECLEAR部分按以下格式声明游标：</p><pre><code>CURSOR 游标名[(参数1 数据类型[，参数2 数据类型...])] IS SELECT语句;</code></pre><p>参数是可选部分，所定义的参数可以出现在SELECT语句的WHERE子句中。如果定义了参数，则必须在打开游标时传递相应的实际参数。</p><h4 id="b-打开游标">b.打开游标</h4><p>在可执行部分，按以下格式打开游标：</p><pre><code>OPEN 游标名[(实际参数1[，实际参数2...])];</code></pre><p>打开游标时，SELECT语句的查询结果就被传送到了游标工作区。</p><h4 id="c-提取数据">c.提取数据</h4><p>在可执行部分，按以下格式将游标工作区中的数据取到变量中。提取操作必须在打开游标之后进行。</p><pre><code>FETCH 游标名 INTO 变量名1[，变量名2...];</code></pre><p>或</p><pre><code>FETCH 游标名 INTO 记录变量;</code></pre><p>游标打开后有一个指针指向数据区，FETCH语句一次返回指针所指的一行数据，要返回多行需重复执行，可以使用循环语句来实现。控制循环可以通过判断游标的属性来进行。</p><p>定义记录变量的方法如下：</p><pre><code>     变量名 表名|游标名%ROWTYPE；</code></pre><h4 id="d-关闭游标">d.关闭游标</h4><pre><code>CLOSE 游标名;</code></pre><p>显式游标打开后，必须显式地关闭。游标一旦关闭，游标占用的资源就被释放，游标变成无效，必须重新打开才能使用。</p><p>【例1】 用游标提取emp表中7788雇员的名称和职务。</p><pre><code>SET SERVEROUTPUT ON     --在命令行界面是必须的，在第三方工具的SQL界面中无需此语句DECLARE    v_ename VARCHAR2(10);    v_job VARCHAR2(10);    CURSOR emp_cursor IS  SELECT ename,job FROM emp WHERE empno=7788;BEGIN    OPEN emp_cursor;    FETCH emp_cursor INTO v_ename,v_job;    DBMS_OUTPUT.PUT_LINE(v_ename||','||v_job);    CLOSE emp_cursor;END;</code></pre><p>【例2】  用游标提取emp表中7788雇员的姓名、职务和工资。</p><pre><code>SET SERVEROUTPUT ON     --在命令行界面是必须的，在第三方工具的SQL界面中无需此语句DECLARE CURSOR emp_cursor IS  SELECT ename,job,sal FROM emp WHERE empno=7788;emp_record emp_cursor%ROWTYPE;    --用游标定义记录变量BEGIN OPEN emp_cursor;FETCH emp_cursor INTO emp_record;   DBMS_OUTPUT.PUT_LINE(emp_record.ename||','|| emp_record.job||','|| emp_record.sal); CLOSE emp_cursor;END;</code></pre><p>【例3】  显示工资最高的前3名雇员的名称和工资。</p><pre><code>SET SERVEROUTPUT ON   --在命令行界面是必须的，在第三方工具的SQL界面中无需此语句DECLARE V_ename VARCHAR2(10);V_sal NUMBER(5);CURSOR emp_cursor IS  SELECT ename,sal FROM emp ORDER BY sal DESC;BEGIN OPEN emp_cursor; FOR I IN 1..3 LOOP   FETCH emp_cursor INTO v_ename,v_sal; DBMS_OUTPUT.PUT_LINE(v_ename||','||v_sal);  END LOOP;   CLOSE emp_cursor;END;</code></pre><h3 id="4-游标循环-重点">4、游标循环（重点）</h3><p>方法一：使用特殊的FOR循环形式显示全部雇员的编号和名称(省略掉定义记录变量、打开游标、提取数据、关闭游标)。</p><pre><code>SET SERVEROUTPUT ON     --在命令行界面是必须的，在第三方工具的SQL界面中无需此语句DECLARE CURSOR emp_cursor IS  SELECT empno, ename FROM emp;BEGINFOR Emp_record IN emp_cursor LOOP    DBMS_OUTPUT.PUT_LINE(Emp_record.empno|| Emp_record.ename);END LOOP;END;</code></pre><p>方法二：最简单方式</p><pre><code>SET SERVEROUTPUT ON      --在命令行界面是必须的，在第三方工具的SQL界面中无需此语句BEGIN FOR re IN (SELECT ename FROM EMP)  LOOPDBMS_OUTPUT.PUT_LINE(re.ename)END LOOP;END;</code></pre><h3 id="5-利用游标属性做循环条件">5、利用游标属性做循环条件</h3><p>【训练1】  使用游标的属性练习。</p><pre><code>SET SERVEROUTPUT ON         --在命令行界面是必须的，在第三方工具的SQL界面中无需此语句DECLARE  V_ename VARCHAR2(10);  CURSOR emp_cursor IS   SELECT ename FROM emp;BEGIN  OPEN emp_cursor;   IF emp_cursor%ISOPEN THEN  LOOP    FETCH emp_cursor INTO v_ename;            EXIT WHEN emp_cursor%NOTFOUND;    DBMS_OUTPUT.PUT_LINE(to_char(emp_cursor%ROWCOUNT)||'-'||v_ename);        END LOOP;  ELSE    DBMS_OUTPUT.PUT_LINE('用户信息：游标没有打开！');  END IF;           CLOSE  emp_cursor;END;</code></pre><h1>Oracle第十四章——游标、存储过程</h1><h2 id="游标参数的传递">游标参数的传递</h2><p>例：</p><pre><code>SET SERVEROUTPUT ONDECLARE    V_empno NUMBER(5);V_ename VARCHAR2(10);CURSOR emp_cursor(p_deptno NUMBER,p_job VARCHAR2) IS SELECT empno,ename FROM emp WHEREdeptno = p_deptno AND job = p_job;BEGIN OPEN emp_cursor(10, 'CLERK');  LOOP     FETCH emp_cursor INTO v_empno,v_ename;  EXIT WHEN emp_cursor%NOTFOUND;     DBMS_OUTPUT.PUT_LINE(v_empno||','||v_ename);END LOOP;END; </code></pre><h2 id="异常处理">异常处理</h2><p>错误处理的语法如下：</p><pre><code>     EXCEPTIONWHEN 错误1[OR 错误2] THEN 语句序列1;WHEN 错误3[OR 错误4] THEN 语句序列2;...WHEN OTHERS 语句序列n;      END;</code></pre><p>例：SET SERVEROUTPUT ON</p><pre><code>DECLARE    v_name VARCHAR2(10);BEGIN    SELECTename  INTO v_name  FROM emp  WHEREempno = 1234;DBMS_OUTPUT.PUT_LINE('该雇员名字为：'|| v_name);EXCEPTIONWHEN NO_DATA_FOUND THENDBMS_OUTPUT.PUT_LINE('编号错误，没有找到相应雇员！');WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('发生其他错误！');END;</code></pre><h2 id="存储过程">存储过程</h2><h3 id="创建和删除存储过程">创建和删除存储过程</h3><p>格式：</p><pre><code> CREATE [OR REPLACE] PROCEDURE 存储过程名[(参数[IN|OUT|IN OUT] 数据类型...)]{AS|IS}[说明部分]   --定义需要使用的临时变量BEGIN语句集;[EXCEPTION]    [错误处理部分]END [过程名];</code></pre><p>删除：</p><pre><code>drop procedure 存储过程名;</code></pre><h3 id="调用存储过程">调用存储过程</h3><p>方法1：</p><pre><code>  EXECUTE 模式名.存储过程名[(参数...)];   (适用于命今行窗口及sql窗口)</code></pre><p>方法2： (适用于sql窗口)</p><pre><code>BEGIN      模式名.存储过程名[(参数...)];END;</code></pre><p>例：编写显示雇员信息的存储过程EMP_LIST，并引用EMP_COUNT存储过程(无参存储过程 )。</p><pre><code>CREATE OR REPLACE PROCEDURE EMP_LISTAS       CURSOR emp_cursor IS SELECT empno,ename FROM emp;BEGINFOR Emp_record IN emp_cursor LOOP   DBMS_OUTPUT.PUT_LINE(Emp_record.empno||Emp_record.ename);END LOOP;EMP_COUNT;END;调用：beginEMP_LIST;          end;</code></pre><h3 id="参数传递">参数传递</h3><p>a.输入参数: 参数名  IN 数据类型 DEFAULT 值；</p><pre><code>例：编写给雇员增加工资的存储过程CHANGE_SALARY，通过IN类型的参数传递要增加工资的雇员编号和增加的工资额。CREATE OR REPLACE PROCEDURE CHANGE_SALARY(P_EMPNO IN NUMBER DEFAULT 7788,P_RAISE NUMBER DEFAULT 10)  --形参P_EMPNO及P_RAISEAS   V_ENAME VARCHAR2(10);   V_SAL NUMBER(5);BEGIN   SELECT ENAME,SAL INTO V_ENAME,V_SAL FROM EMP WHERE EMPNO=P_EMPNO;   UPDATE EMP SET SAL=SAL+P_RAISE WHERE EMPNO=P_EMPNO;   DBMS_OUTPUT.PUT_LINE('雇员'||V_ENAME||'的工资被改为'||TO_CHAR(V_SAL+P_RAISE));   COMMIT;EXCEPTION  WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('发生错误，修改失败！');  ROLLBACK; --如果出了异常则撤消END;调用：beginCHANGE_SALARY(7788,80)      end;</code></pre><p>b.输出参数: 参数名 OUT 数据类型 DEFAULT  值；</p><pre><code>    --例：统计雇员的人数       CREATE OR REPLACE PROCEDURE EMP_COUNT(P_TOTAL OUT NUMBER)   --P_TOTAL为输出参数AS   BEGINSELECT COUNT(*) INTO P_TOTAL FROM EMP;   END;调用：DECLARE V_EMPCOUNT NUMBER;   --定义变量接收过程求出的结果      BEGIN EMP_COUNT(V_EMPCOUNT); DBMS_OUTPUT.PUT_LINE('雇员总人数为：'||V_EMPCOUNT);      END;</code></pre><p>c.输入输出参数： 参数名  IN OUT   数据类型   DEFAULT   值；</p><pre><code>--例：使用IN OUT类型的参数，给电话号码增加区码。CREATE OR REPLACE PROCEDURE ADD_REGION(P_HPONE_NUM IN OUT VARCHAR2)ASBEGIN   P_HPONE_NUM:='024-'||P_HPONE_NUM;END;调用： DECLARE V_PHONE_NUM VARCHAR2(15);       BEGIN V_PHONE_NUM:='26731092'; ADD_REGION(V_PHONE_NUM); DBMS_OUTPUT.PUT_LINE('新的电话号码：'||V_PHONE_NUM);       END;</code></pre><p><br><br>本文链接： <a href="http://www.meng.uno/articles/33c755f8/">http://www.meng.uno/articles/33c755f8/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      Oracle第一章
 1. 首先打开Oracle服务
 2. 配置监听器（这个是因为教室的电脑Oracle安装有问题，没有配置好监听器）开始菜单中找到net configration assistant添加一个监听器
 3. 用system用户登录sqlplus
 4. 解锁scott用户 :（也是因为教室的Oracle安装问题导致scott账户未解锁）

1


alter user scott account unlock;


 5. 修改scott密码:

1


alter user scott identified by tiger;


 6. 使用scott登录sqlplus,
    
    </summary>
    
      <category term="Java开发Tips" scheme="http://www.meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/"/>
    
    
      <category term="Java" scheme="http://www.meng.uno/tags/Java/"/>
    
      <category term="Oracle" scheme="http://www.meng.uno/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>几个常见的社区推荐算法</title>
    <link href="http://www.meng.uno/articles/82a6b55c/"/>
    <id>http://www.meng.uno/articles/82a6b55c/</id>
    <published>2018-03-18T11:03:48.000Z</published>
    <updated>2018-03-18T13:39:36.183Z</updated>
    
    <content type="html"><![CDATA[<h1>PageRank算法</h1><p>PageRank算法预先给每个网页一个PR值（PR值指代PageRank值），PR值在物理意义上为一个网页被访问的概率，所以一般是1/N，其中N为网页总数。</p><p>另外，所有网页的PR值的和一般为1。（如果实在不为1也不是不行，最后算出来的不同网页之间PR值的大小关系仍然是正确的，只是这个数值不能直接地反映概率罢了。）</p><p>接着，运用下面的算法不断迭代计算，直至达到平稳分布为止。</p><h2 id="普通情况">普通情况</h2><p><img src="http://www.meng.uno/images/recommend/13.jpg" alt=""></p><p>互联网中的众多网页可以看成一个有向图，箭头的指向即为链接的链入，根据上图，我们得到A的PR值为：PR(A)=PR(B)/2+PR©/1。</p><h2 id="没有出链">没有出链</h2><p><img src="http://www.meng.uno/images/recommend/14.jpg" alt=""></p><p>网络中不乏一些没有出链的网页，如上图，其中，网页C没有出链，也就是说网页C对其他网页没有PR值的贡献，我们不喜欢这种“自私”的网页（其实是为了满足 Markov 链的收敛性），于是设定其对所有网页（包括它自己）都有出链，则此图中A的PR值表示为：PR(A)=PR(B)/2+PR©/4。</p><h2 id="出链循环圈">出链循环圈</h2><p><img src="http://www.meng.uno/images/recommend/15.jpg" alt=""></p><p>网络中还存在这样的网页：只对自己有出链，或者几个网页的出链形成一个循环圈。那么在不断迭代的过程中，这一个或几个网页的PR值将只增不减，这显然是不合理的。</p><p>那么如何解决这个问题呢？我们假设某人正在浏览网页C，显然他不会一直停留在网页C，他可能会随机地输入一个网址从而去往另一个网页，并且其跳转到每个网页的概率是一样的。于是此图中A的PR值表示为：PR(A)=∂(PR(B)/2)+(1-∂)/4。</p><p>综上，一般情况下，一个网页的PR值计算公式如下：</p><p><img src="http://www.meng.uno/images/recommend/16.png" alt=""></p><p>其中，Mpi是所有对pi网页有出链的网页集合，L(pj)是网页pj的出链数目，N是网页总数，α一般取0.85。</p><p>根据上面的公式，我们就可以计算出每个网页的PR值，在不断迭代并趋于平稳的时候，即为最终结果。</p><h1>HITS算法</h1><p>算法简介：</p><p>首先把那些根据关键相关返回网页作为根集合S，再由S集合网页节点的链入和链出网页节点派生出结合C，结合C包括S，链入和链出节点集合。</p><p>C中的每个节点分配一对权重&lt;h(s),a(s)&gt;, 节点h(s)权重由节点链出的节点的a(s)决定，a(s)由节点的链入节点的h(s)决定。</p><p>算法过程：</p><p><img src="http://www.meng.uno/images/recommend/7.jpg" alt=""></p><p>网页的a权重向量：</p><p><img src="http://www.meng.uno/images/recommend/8.jpg" alt=""></p><p>关于HITS算法收敛性，可以从如下变换形式来得出：</p><p><img src="http://www.meng.uno/images/recommend/9.jpg" alt=""></p><p>当算法收敛时候，a其实就是对应矩阵A那个最大特征值对应的特征向量的归一化形式，同样，h也是H矩阵那个最大特征值对应的特征向量的归一化形式。</p><p>算法实现：</p><figure class="highlight python">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HITSIterator</span>:</span></span><br><span class="line">    __doc__ = <span class="string">'''计算一张图中的hub,authority值'''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, dg)</span>:</span></span><br><span class="line">        self.max_iterations = <span class="number">100</span>  <span class="comment"># 最大迭代次数</span></span><br><span class="line">        self.min_delta = <span class="number">0.0001</span>  <span class="comment"># 确定迭代是否结束的参数</span></span><br><span class="line">        self.graph = dg</span><br><span class="line"></span><br><span class="line">        self.hub = &#123;&#125;</span><br><span class="line">        self.authority = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes():</span><br><span class="line">            self.hub[node] = <span class="number">1</span></span><br><span class="line">            self.authority[node] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hits</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        计算每个页面的hub,authority值</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.graph:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        flag = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.max_iterations):</span><br><span class="line">            change = <span class="number">0.0</span>  <span class="comment"># 记录每轮的变化值</span></span><br><span class="line">            norm = <span class="number">0</span>  <span class="comment"># 标准化系数</span></span><br><span class="line">            tmp = &#123;&#125;</span><br><span class="line">            <span class="comment"># 计算每个页面的authority值</span></span><br><span class="line">            tmp = self.authority.copy()</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes():</span><br><span class="line">                self.authority[node] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> incident_page <span class="keyword">in</span> self.graph.incidents(node):  <span class="comment"># 遍历所有“入射”的页面</span></span><br><span class="line">                    self.authority[node] += self.hub[incident_page]</span><br><span class="line">                norm += pow(self.authority[node], <span class="number">2</span>)</span><br><span class="line">            <span class="comment"># 标准化</span></span><br><span class="line">            norm = sqrt(norm)</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes():</span><br><span class="line">                self.authority[node] /= norm</span><br><span class="line">                change += abs(tmp[node] - self.authority[node])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算每个页面的hub值</span></span><br><span class="line">            norm = <span class="number">0</span></span><br><span class="line">            tmp = self.hub.copy()</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes():</span><br><span class="line">                self.hub[node] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> neighbor_page <span class="keyword">in</span> self.graph.neighbors(node):  <span class="comment"># 遍历所有“出射”的页面</span></span><br><span class="line">                    self.hub[node] += self.authority[neighbor_page]</span><br><span class="line">                norm += pow(self.hub[node], <span class="number">2</span>)</span><br><span class="line">            <span class="comment"># 标准化</span></span><br><span class="line">            norm = sqrt(norm)</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes():</span><br><span class="line">                self.hub[node] /= norm</span><br><span class="line">                change += abs(tmp[node] - self.hub[node])</span><br><span class="line"></span><br><span class="line">            print(<span class="string">"This is NO.%s iteration"</span> % (i + <span class="number">1</span>))</span><br><span class="line">            print(<span class="string">"authority"</span>, self.authority)</span><br><span class="line">            print(<span class="string">"hub"</span>, self.hub)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> change &lt; self.min_delta:</span><br><span class="line">                flag = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            print(<span class="string">"finished in %s iterations!"</span> % (i + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"finished out of 100 iterations!"</span>)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"The best authority page: "</span>, max(self.authority.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]))</span><br><span class="line">        print(<span class="string">"The best hub page: "</span>, max(self.hub.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    dg = digraph()</span><br><span class="line"></span><br><span class="line">    dg.add_nodes([<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>])</span><br><span class="line"></span><br><span class="line">    dg.add_edge((<span class="string">"A"</span>, <span class="string">"C"</span>))</span><br><span class="line">    dg.add_edge((<span class="string">"A"</span>, <span class="string">"D"</span>))</span><br><span class="line">    dg.add_edge((<span class="string">"B"</span>, <span class="string">"D"</span>))</span><br><span class="line">    dg.add_edge((<span class="string">"C"</span>, <span class="string">"E"</span>))</span><br><span class="line">    dg.add_edge((<span class="string">"D"</span>, <span class="string">"E"</span>))</span><br><span class="line">    dg.add_edge((<span class="string">"B"</span>, <span class="string">"E"</span>))</span><br><span class="line">    dg.add_edge((<span class="string">"E"</span>, <span class="string">"A"</span>))</span><br><span class="line"></span><br><span class="line">    hits = HITSIterator(dg)</span><br><span class="line">    hits.hits()</span><br></pre>      </td>    </tr>  </table></figure><h1>SALSA算法</h1><p>SALSA算法和HITS算法初始部分一样，构建相同的集合集C和彼此的链接关系。</p><p>SALSA一种随机游走过程，但是不同经典的随机游走。它涉及到把一个网页节点看成2种不同类型节点：hub和authority，随机游走对应着这样两种不用类型的Markov链：hub链和authority链，状态转移为网页前向和后向。</p><p><img src="http://www.meng.uno/images/recommend/10.jpg" alt=""></p><p>首先是把构建一个无向图，原图节点分为2类，然后构建边。</p><p>这样从某个节点出发，进行两个方向的随机游走。h和a方向的状态转移矩阵：</p><p><img src="http://www.meng.uno/images/recommend/11.jpg" alt=""></p><p>对于以上的形式可以通过如下的矩阵相乘的方式展现：</p><p><img src="http://www.meng.uno/images/recommend/12.jpg" alt=""></p><p>有了H和A矩阵，就可以知道节点集合最终的h和a向量：和HITS一样，h和a对应H和A的最大特征值对应的归一化特征向量。其实，计算h和a可以参照HITS，进行迭代求解。</p><p><br><br>本文链接： <a href="http://www.meng.uno/articles/82a6b55c/">http://www.meng.uno/articles/82a6b55c/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      PageRank算法
PageRank算法预先给每个网页一个PR值（PR值指代PageRank值），PR值在物理意义上为一个网页被访问的概率，所以一般是1/N，其中N为网页总数。

另外，所有网页的PR值的和一般为1。（如果实在不为1也不是不行，最后算出来的不同网页之间PR值的大小关系仍然是正确的，只是这个数值不能直接地反映概率罢了。）

接着，运用下面的算法不断迭代计算，直至达到平稳分布为止。

普通情况


互联网中的众多网页可以看成一个有向图，箭头的指向即为链接的链入，根据上图，我们得到A的PR值为：PR(A)=PR(B)/2+PR©/1。

没有出链


网络中不乏一些没有出链的网页，
    
    </summary>
    
      <category term="机器学习" scheme="http://www.meng.uno/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="推荐" scheme="http://www.meng.uno/tags/%E6%8E%A8%E8%8D%90/"/>
    
      <category term="社交网络" scheme="http://www.meng.uno/tags/%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>商品推荐：协同过滤</title>
    <link href="http://www.meng.uno/articles/6f93935a/"/>
    <id>http://www.meng.uno/articles/6f93935a/</id>
    <published>2018-03-17T06:05:52.000Z</published>
    <updated>2018-03-18T07:18:29.430Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>过去很长时间以及现今，电商都在蓬勃发展，支持电商越做越大的一个很重要的因素就是“商品推荐”。当我们打开天猫，我们发现不同的用户，一般而言，首页是不一样的，原因就是，它为不同的用户推荐了不同的商品。我们为什么要用某一个购物网站或者APP，我觉得很大程度上取决于其推荐的准确与否。本篇博客我将向大家介绍协同过滤在商品推荐上的应用。</p></blockquote><h1>关于推荐系统</h1><p>根据推荐引擎的数据源不同，一般而言，推荐系统可以分为如下三类：</p><ul>  <li>基于人口统计学的推荐机制（Demographic-based Recommendation）：根据系统用户的基本信息发现用户的相关程度。</li></ul><p><img src="http://www.meng.uno/images/recommend/6.jpg" alt=""></p><ul>  <li>基于内容的推荐机制（Content-based Recommendation）：根据推荐物品或内容的元数据，发现物品或者内容的相关性。</li></ul><p><img src="http://www.meng.uno/images/recommend/3.jpg" alt=""></p><ul>  <li>协同过滤的推荐机制（Collaborative Filtering-based Recommendation）：根据用户对物品或者信息的偏好，发现物品或者内容本身的相关性，或者是发现用户的相关性。</li></ul><p>根据推荐模型的建立方式不同，推荐系统可以分为这样三类：</p><ul>  <li>基于物品和用户本身。这种推荐引擎将每个用户和每个物品都当作独立的实体，预测每个用户对于每个物品的喜好程度，这些信息往往是用一个二维矩阵描述的。由于用户感兴趣的物品远远小于总物品的数目，这样的模型导致大量的数据空置，即我们得到的二维矩阵往往是一个很大的稀疏矩阵。同时为了减小计算量，我们可以对物品和用户进行聚类， 然后记录和计算一类用户对一类物品的喜好程度，但这样的模型又会在推荐的准确性上有损失。</li>  <li>基于关联规则的推荐（Rule-based Recommendation）。关联规则的挖掘已经是数据挖掘中的一个经典的问题，主要是挖掘一些数据的依赖关系，典型的场景就是“购物篮问题”，通过关联规则的挖掘，我们可以找到哪些物品经常被同时购买，或者用户购买了一些物品后通常会购买哪些其他的物品，当我们挖掘出这些关联规则之后，我们可以基于这些规则给用户进行推荐。</li>  <li>基于模型的推荐（Model-based Recommendation）。这是一个典型的机器学习的问题，可以将已有的用户喜好信息作为训练样本，训练出一个预测用户喜好的模型，这样以后用户在进入系统，可以基于此模型计算推荐。这种方法的问题在于如何将用户实时或者近期的喜好信息反馈给训练好的模型，从而提高推荐的准确度。</li></ul><h1>协同过滤</h1><p>关于协同过滤的一个最经典的例子就是看电影，有时候不知道哪一部电影是我们喜欢的或者评分比较高的，那么通常的做法就是问问周围的朋友，看看最近有什么好的电影推荐。在问的时候，都习惯于问跟自己口味差不多的朋友，这就是协同过滤的核心思想。</p><h2 id="步骤">步骤</h2><p>要实现协同过滤，一般需要这样三步：</p><ul>  <li>收集用户偏好</li>  <li>找到相似物或人</li>  <li>计算并推荐</li></ul><h3 id="收集用户偏好">收集用户偏好</h3><p>从用户的行为和偏好中发现规律，并基于此进行推荐，所以如何收集用户的偏好信息成为系统推荐效果最基础的决定因素。用户有很多种方式向系统提供自己的偏好信息，比如：评分，投票，转发，保存书签，购买，点击流，页面停留时间等等。</p><p>当然，得到原始数据之后，我们总是需要进行降噪、归一化等，在此不再赘述。</p><h3 id="找到相似物或人">找到相似物或人</h3><p>既然是找相似，我们就需要设定一个计算相似度的指标，一般而言，余弦相似度与皮尔逊相关系数是很好的选择。</p><h4 id="余弦相似度">余弦相似度</h4><p><img src="http://www.meng.uno/images/recommend/4.gif" alt=""></p><h4 id="皮尔逊相关系数">皮尔逊相关系数</h4><p>皮尔逊相关也称为积差相关（或积矩相关）是英国统计学家皮尔逊于20世纪提出的一种计算直线相关的方法。</p><p>假设有两个变量X、Y，那么两变量间的皮尔逊相关系数可通过以下公式计算：</p><p><img src="http://www.meng.uno/images/recommend/5.gif" alt=""></p><h3 id="计算并推荐">计算并推荐</h3><ul>  <li>基于用户的协同过滤推荐</li></ul><p>基于用户的协同过滤推荐的基本原理是，根据所有用户对物品或者信息的偏好，发现与当前用户口味和偏好相似的“邻居”用户群，在一般的应用中是采用计算“K- 邻居”的算法；然后，基于这 K 个邻居的历史偏好信息，为当前用户进行推荐。</p><p><img src="http://www.meng.uno/images/recommend/1.jpg" alt=""></p><p>上图示意出基于用户的协同过滤推荐机制的基本原理，假设用户 A 喜欢物品 A，物品 C，用户 B 喜欢物品 B，用户 C 喜欢物品 A ，物品 C 和物品 D；从这些用户的历史喜好信息中，我们可以发现用户 A 和用户 C 的口味和偏好是比较类似的，同时用户 C 还喜欢物品 D，那么我们可以推断用户 A 可能也喜欢物品 D，因此可以将物品 D 推荐给用户 A。</p><p>基于用户的协同过滤推荐机制和基于人口统计学的推荐机制都是计算用户的相似度，并基于“邻居”用户群计算推荐，但它们所不同的是如何计算用户的相似度，基于人口统计学的机制只考虑用户本身的特征，而基于用户的协同过滤机制可是在用户的历史偏好的数据上计算用户的相似度，它的基本假设是，喜欢类似物品的用户可能有相同或者相似的口味和偏好。</p><ul>  <li>基于项目的协同过滤推荐</li></ul><p>基于项目的协同过滤推荐的基本原理也是类似的，只是说它使用所有用户对物品或者信息的偏好，发现物品和物品之间的相似度，然后根据用户的历史偏好信息，将类似的物品推荐给用户。</p><p><img src="http://www.meng.uno/images/recommend/2.jpg" alt=""></p><p>假设用户 A 喜欢物品 A 和物品 C，用户 B 喜欢物品 A，物品 B 和物品 C，用户 C 喜欢物品 A，从这些用户的历史喜好可以分析出物品 A 和物品 C 时比较类似的，喜欢物品 A 的人都喜欢物品 C，基于这个数据可以推断用户 C 很有可能也喜欢物品 C，所以系统会将物品 C 推荐给用户 C。</p><p>与上面讲的类似，基于项目的协同过滤推荐和基于内容的推荐其实都是基于物品相似度预测推荐，只是相似度计算的方法不一样，前者是从用户历史的偏好推断，而后者是基于物品本身的属性特征信息。</p><ul>  <li>基于模型的协同过滤推荐</li></ul><p>基于模型的协同过滤推荐就是基于样本的用户喜好信息，训练一个推荐模型，然后根据实时的用户喜好的信息进行预测，计算推荐。</p><p>基于协同过滤的推荐机制是现今应用最为广泛的推荐机制，它有以下几个显著的优点：</p><p>它不需要对物品或者用户进行严格的建模，而且不要求物品的描述是机器可理解的，所以这种方法也是领域无关的。 这种方法计算出来的推荐是开放的，可以共用他人的经验，很好的支持用户发现潜在的兴趣偏好 而它也存在以下几个问题：</p><p>方法的核心是基于历史数据，所以对新物品和新用户都有“冷启动”的问题。 推荐的效果依赖于用户历史偏好数据的多少和准确性。 在大部分的实现中，用户历史偏好是用稀疏矩阵进行存储的，而稀疏矩阵上的计算有些明显的问题，包括可能少部分人的错误偏好会对推荐的准确度有很大的影响等等。 对于一些特殊品味的用户不能给予很好的推荐。 由于以历史数据为基础，抓取和建模用户的偏好后，很难修改或者根据用户的使用演变，从而导致这个方法不够灵活。</p><h2 id="代码实现">代码实现</h2><p>基于用户的CF：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 基于用户的协同过滤推荐算法实现 </span></span><br><span class="line"><span class="comment">A a b d </span></span><br><span class="line"><span class="comment">B a c </span></span><br><span class="line"><span class="comment">C b e </span></span><br><span class="line"><span class="comment">D c d e </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserCF</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 输入用户--&gt;物品条目 一个用户对应多个物品 </span></span><br><span class="line"><span class="comment">   * 用户ID 物品ID集合 </span></span><br><span class="line"><span class="comment">   * A  a b d </span></span><br><span class="line"><span class="comment">   * B  a c </span></span><br><span class="line"><span class="comment">   * C  b e </span></span><br><span class="line"><span class="comment">   * D  c d e </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">"Input the total users number:"</span>);</span><br><span class="line"><span class="comment">//输入用户总量 </span></span><br><span class="line"><span class="keyword">int</span> N = scanner.nextint();</span><br><span class="line"><span class="keyword">int</span>[][] sparseMatrix = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line"><span class="comment">//建立用户稀疏矩阵，用于用户相似度计算【相似度矩阵】 </span></span><br><span class="line">Map&lt;String, Integer&gt; userItemLength = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//存储每一个用户对应的不同物品总数 eg: A 3 </span></span><br><span class="line">Map&lt;String, Set&lt;String&gt;&gt; itemUserCollection = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//建立物品到用户的倒排表 eg: a A B </span></span><br><span class="line">Set&lt;String&gt; items = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="comment">//辅助存储物品集合 </span></span><br><span class="line">Map&lt;String, Integer&gt; userID = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//辅助存储每一个用户的用户ID映射 </span></span><br><span class="line">Map&lt;Integer, String&gt; idUser = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//辅助存储每一个ID对应的用户映射 </span></span><br><span class="line">System.out.println(<span class="string">"Input user--items maping infermation:&lt;eg:A a b d&gt;"</span>);</span><br><span class="line">scanner.nextLine();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N ; i++)&#123;</span><br><span class="line"><span class="comment">//依次处理N个用户 输入数据 以空格间隔 </span></span><br><span class="line">String[] user_item = scanner.nextLine().split(<span class="string">" "</span>);</span><br><span class="line"><span class="keyword">int</span> length = user_item.length;</span><br><span class="line">userItemLength.put(user_item[<span class="number">0</span>], length-<span class="number">1</span>);</span><br><span class="line"><span class="comment">//eg: A 3 </span></span><br><span class="line">userID.put(user_item[<span class="number">0</span>], i);</span><br><span class="line"><span class="comment">//用户ID与稀疏矩阵建立对应关系 </span></span><br><span class="line">idUser.put(i, user_item[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//建立物品--用户倒排表 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; length; j ++)&#123;</span><br><span class="line"><span class="keyword">if</span>(items.contains(user_item[j]))&#123;</span><br><span class="line"><span class="comment">//如果已经包含对应的物品--用户映射，直接添加对应的用户 </span></span><br><span class="line">itemUserCollection.get(user_item[j]).add(user_item[<span class="number">0</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//否则创建对应物品--用户集合映射 </span></span><br><span class="line">items.add(user_item[j]);</span><br><span class="line">itemUserCollection.put(user_item[j], <span class="keyword">new</span> HashSet&lt;String&gt;());</span><br><span class="line"><span class="comment">//创建物品--用户倒排关系 </span></span><br><span class="line">itemUserCollection.get(user_item[j]).add(user_item[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(itemUserCollection.toString());</span><br><span class="line"><span class="comment">//计算相似度矩阵【稀疏】 </span></span><br><span class="line">Set&lt;Entry&lt;String, Set&lt;String&gt;&gt;&gt; entrySet = itemUserCollection.entrySet();</span><br><span class="line">Iterator&lt;Entry&lt;String, Set&lt;String&gt;&gt;&gt; iterator = entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">Set&lt;String&gt; commonUsers = iterator.next().getValue();</span><br><span class="line"><span class="keyword">for</span> (String user_u : commonUsers) &#123;</span><br><span class="line"><span class="keyword">for</span> (String user_v : commonUsers) &#123;</span><br><span class="line"><span class="keyword">if</span>(user_u.equals(user_v))&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">sparseMatrix[userID.get(user_u)][userID.get(user_v)] += <span class="number">1</span>;</span><br><span class="line"><span class="comment">//计算用户u与用户v都有正反馈的物品总数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(userItemLength.toString());</span><br><span class="line">System.out.println(<span class="string">"Input the user for recommendation:&lt;eg:A&gt;"</span>);</span><br><span class="line">String recommendUser = scanner.nextLine();</span><br><span class="line">System.out.println(userID.get(recommendUser));</span><br><span class="line"><span class="comment">//计算用户之间的相似度【余弦相似性】 </span></span><br><span class="line"><span class="keyword">int</span> recommendUserId = userID.get(recommendUser);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; sparseMatrix.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(j != recommendUserId)&#123;</span><br><span class="line">System.out.println(idUser.get(recommendUserId)+<span class="string">"--"</span>+idUser.get(j)+<span class="string">"相似度:"</span>+sparseMatrix[recommendUserId][j]/Math.sqrt(userItemLength.get(idUser.get(recommendUserId))*userItemLength.get(idUser.get(j))));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算指定用户recommendUser的物品推荐度 </span></span><br><span class="line"><span class="keyword">for</span> (String item: items)&#123;</span><br><span class="line"><span class="comment">//遍历每一件物品 </span></span><br><span class="line">Set&lt;String&gt; users = itemUserCollection.get(item);</span><br><span class="line"><span class="comment">//得到购买当前物品的所有用户集合 </span></span><br><span class="line"><span class="keyword">if</span>(!users.contains(recommendUser))&#123;</span><br><span class="line"><span class="comment">//如果被推荐用户没有购买当前物品，则进行推荐度计算 </span></span><br><span class="line"><span class="keyword">double</span> itemRecommendDegree = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (String user: users)&#123;</span><br><span class="line">itemRecommendDegree += sparseMatrix[userID.get(recommendUser)][userID.get(user)]/Math.sqrt(userItemLength.get(recommendUser)*userItemLength.get(user));</span><br><span class="line"><span class="comment">//推荐度计算</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"The item "</span>+item+<span class="string">" for "</span>+recommendUser +<span class="string">"'s recommended degree:"</span>+itemRecommendDegree);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">scanner.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>基于项目的CF：</p><figure class="highlight python">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span>  itemgetter</span><br><span class="line">random.seed(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItemBasedCF</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.trainset = &#123;&#125;</span><br><span class="line">        self.testset = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        self.n_sim_movie = <span class="number">20</span></span><br><span class="line">        self.n_rec_movie = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        self.movie_sim_mat = &#123;&#125;</span><br><span class="line">        self.movie_popular = &#123;&#125;</span><br><span class="line">        self.movie_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        print(<span class="string">'Similar movie number = %d'</span> % self.n_sim_movie, file = sys.stderr)</span><br><span class="line">        print(<span class="string">'Recommendend movie number = %d'</span> % self.n_rec_movie,file = sys.stderr)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loadfile</span><span class="params">(filename)</span>:</span></span><br><span class="line">        fp = open(filename, <span class="string">'r'</span>)</span><br><span class="line">        <span class="keyword">for</span> i, line <span class="keyword">in</span> enumerate(fp):</span><br><span class="line">            <span class="keyword">yield</span> line.strip(<span class="string">'\r\n'</span>)</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">100000</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">print</span> (<span class="string">'load %s(%s)'</span> %(filename,i), file = sys.stderr)</span><br><span class="line">        fp.close()</span><br><span class="line">        print(<span class="string">'load %s succ'</span> %filename, file = sys.stderr)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_dataset</span><span class="params">(self, filename, pivot = <span class="number">0.7</span>)</span>:</span></span><br><span class="line">        trainset_len = <span class="number">0</span></span><br><span class="line">        testset_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> self.loadfile(filename):</span><br><span class="line">            user, movie, rating , _= line.split(<span class="string">'::'</span>)</span><br><span class="line">            <span class="keyword">if</span> random.random() &lt; pivot:</span><br><span class="line">                self.trainset.setdefault(user,&#123;&#125;)</span><br><span class="line">                self.trainset[user][movie] = int(rating)</span><br><span class="line">                trainset_len += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.testset.setdefault(user,&#123;&#125;)</span><br><span class="line">                self.testset[user][movie] = int(rating)</span><br><span class="line">                testset_len += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        print(<span class="string">'split succ , trainset is %d , testset is %d'</span>  %(trainset_len,testset_len) , file = sys.stderr)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calc_movie_sim</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> user, movies <span class="keyword">in</span> self.trainset.items():</span><br><span class="line">            <span class="keyword">for</span> movie <span class="keyword">in</span> movies:</span><br><span class="line">                <span class="keyword">if</span> movie <span class="keyword">not</span> <span class="keyword">in</span> self.movie_popular:</span><br><span class="line">                    self.movie_popular[movie] = <span class="number">0</span></span><br><span class="line">                self.movie_popular[movie] += <span class="number">1</span></span><br><span class="line">        print(<span class="string">'count movies number and pipularity succ'</span>,file = sys.stderr)</span><br><span class="line"></span><br><span class="line">        self.movie_count = len(self.movie_popular)</span><br><span class="line">        print(<span class="string">'total movie number = %d'</span> %self.movie_count, file = sys.stderr)</span><br><span class="line"></span><br><span class="line">        itemsim_mat = self.movie_sim_mat</span><br><span class="line">        print(<span class="string">'building co-rated users matrix'</span>, file = sys.stderr)</span><br><span class="line">        <span class="keyword">for</span> user, movies <span class="keyword">in</span> self.trainset.items():</span><br><span class="line">            <span class="keyword">for</span> m1 <span class="keyword">in</span> movies:</span><br><span class="line">                <span class="keyword">for</span> m2 <span class="keyword">in</span> movies:</span><br><span class="line">                    <span class="keyword">if</span> m1 == m2:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    itemsim_mat.setdefault(m1,&#123;&#125;)</span><br><span class="line">                    itemsim_mat[m1].setdefault(m2,<span class="number">0</span>)</span><br><span class="line">                    itemsim_mat[m1][m2] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        print(<span class="string">'build co-rated users matrix succ'</span>, file = sys.stderr)</span><br><span class="line">        print(<span class="string">'calculating movie similarity matrix'</span>, file = sys.stderr)</span><br><span class="line"></span><br><span class="line">        simfactor_count = <span class="number">0</span></span><br><span class="line">        PRINT_STEP = <span class="number">2000000</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> m1, related_movies <span class="keyword">in</span> itemsim_mat.items():</span><br><span class="line">            <span class="keyword">for</span> m2, count <span class="keyword">in</span> related_movies.items():</span><br><span class="line">                itemsim_mat[m1][m2] = count / math.sqrt(self.movie_popular[m1] * self.movie_popular[m2])</span><br><span class="line">                simfactor_count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> simfactor_count % PRINT_STEP == <span class="number">0</span>:</span><br><span class="line">                    print(<span class="string">'calcu movie similarity factor(%d)'</span> %simfactor_count, file = sys.stderr)</span><br><span class="line">        print(<span class="string">'calcu similiarity succ'</span>, file = sys.stderr)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recommend</span><span class="params">(self,user)</span>:</span></span><br><span class="line">        K = self.n_sim_movie</span><br><span class="line">        N = self.n_rec_movie</span><br><span class="line">        rank = &#123;&#125;</span><br><span class="line">        watched_movies = self.trainset[user]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> movie, rating <span class="keyword">in</span> watched_movies.items():</span><br><span class="line">            <span class="keyword">for</span> related_movie, similarity_factor <span class="keyword">in</span> sorted(self.movie_sim_mat[movie].items(), key=itemgetter(<span class="number">1</span>),</span><br><span class="line">                                                           reverse=<span class="keyword">True</span>)[<span class="number">0</span>:K]:</span><br><span class="line">                <span class="keyword">if</span> related_movie <span class="keyword">in</span> watched_movies:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                rank.setdefault(related_movie, <span class="number">0</span>)</span><br><span class="line">                rank[related_movie] += similarity_factor * rating</span><br><span class="line">        <span class="keyword">return</span> sorted(rank.items(), key=itemgetter(<span class="number">1</span>), reverse=<span class="keyword">True</span>)[<span class="number">0</span>:N]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'evaluation start'</span>, file = sys.stderr)</span><br><span class="line"></span><br><span class="line">        N = self.n_rec_movie</span><br><span class="line"></span><br><span class="line">        hit = <span class="number">0</span></span><br><span class="line">        rec_count = <span class="number">0</span></span><br><span class="line">        test_count = <span class="number">0</span></span><br><span class="line">        all_rec_movies = set()</span><br><span class="line">        popular_sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, user <span class="keyword">in</span> enumerate(self.trainset):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">500</span> == <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">'recommend for %d users '</span> %i , file = sys.stderr)</span><br><span class="line">            test_movies = self.testset.get(user,&#123;&#125;)</span><br><span class="line">            rec_movies = self.recommend(user)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> movie, _ <span class="keyword">in</span> rec_movies:</span><br><span class="line">                <span class="keyword">if</span> movie <span class="keyword">in</span> test_movies:</span><br><span class="line">                    hit += <span class="number">1</span></span><br><span class="line">                all_rec_movies.add(movie)</span><br><span class="line">                popular_sum += math.log(<span class="number">1</span> + self.movie_popular[movie])</span><br><span class="line"></span><br><span class="line">            rec_count += N</span><br><span class="line">            test_count += len(test_movies)</span><br><span class="line"></span><br><span class="line">            precision = hit / (<span class="number">1.0</span> * rec_count)</span><br><span class="line">            recall = hit / (<span class="number">1.0</span> * test_count)</span><br><span class="line">            coverage = len(all_rec_movies) / (<span class="number">1.0</span> * self.movie_count)</span><br><span class="line">            popularity = popular_sum / (<span class="number">1.0</span> * rec_count)</span><br><span class="line"></span><br><span class="line">            print(<span class="string">'precision is %.4f\t recall is %.4f \t coverage is %.4f \t popularity is %.4f'</span></span><br><span class="line">                  %(precision,recall,coverage,popularity), file = sys.stderr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ratingfile = os.path.join(<span class="string">'ml-1m'</span>, <span class="string">'ratings.dat'</span>)</span><br><span class="line">    itemcf = ItemBasedCF()</span><br><span class="line">    itemcf.generate_dataset(ratingfile)</span><br><span class="line">    itemcf.calc_movie_sim()</span><br><span class="line">    itemcf.evaluate()</span><br></pre>      </td>    </tr>  </table></figure><p><br><br>本文链接： <a href="http://www.meng.uno/articles/6f93935a/">http://www.meng.uno/articles/6f93935a/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      过去很长时间以及现今，电商都在蓬勃发展，支持电商越做越大的一个很重要的因素就是“商品推荐”。当我们打开天猫，我们发现不同的用户，一般而言，首页是不一样的，原因就是，它为不同的用户推荐了不同的商品。我们为什么要用某一个购物网站或者APP，我觉得很大程度上取决于其推荐的准确与否。本篇博客我将向大家介绍协同过滤在商品推荐上的应用。

关于推荐系统
根据推荐引擎的数据源不同，一般而言，推荐系统可以分为如下三类：

 * 基于人口统计学的推荐机制（Demographic-based Recommendation）：根据系统用户的基本信息发现用户的相关程度。



 * 基于内容的推荐机制（Content
    
    </summary>
    
      <category term="机器学习" scheme="http://www.meng.uno/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="社会网络" scheme="http://www.meng.uno/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%A4%BE%E4%BC%9A%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="社会网络" scheme="http://www.meng.uno/tags/%E7%A4%BE%E4%BC%9A%E7%BD%91%E7%BB%9C/"/>
    
      <category term="商品推荐" scheme="http://www.meng.uno/tags/%E5%95%86%E5%93%81%E6%8E%A8%E8%8D%90/"/>
    
      <category term="协同过滤" scheme="http://www.meng.uno/tags/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>JVM的垃圾回收机制</title>
    <link href="http://www.meng.uno/articles/dde60b3a/"/>
    <id>http://www.meng.uno/articles/dde60b3a/</id>
    <published>2018-03-09T07:14:32.000Z</published>
    <updated>2018-03-09T07:58:03.486Z</updated>
    
    <content type="html"><![CDATA[<h1>简介</h1><p>Java GC（Garbage Collection，垃圾收集，垃圾回收）机制，是Java与C++/C的主要区别之一，作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码，对内存泄露和溢出的问题，也不需要像C程序员那样战战兢兢。这是因为在Java虚拟机中，存在自动内存管理和垃圾清扫机制。概括地说，该机制对JVM（Java Virtual Machine）中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，永不停息（Nerver Stop）的保证JVM中的内存空间，防止出现内存泄露和溢出问题。</p><p>关于JVM，需要说明一下的是，目前使用最多的Sun公司的JDK中，自从1999年的JDK1.2开始直至现在仍在广泛使用的JDK6，其中默认的虚拟机都是HotSpot。2009年，Oracle收购Sun，加上之前收购的EBA公司，Oracle拥有3大虚拟机中的两个：JRockit和HotSpot，Oracle也表明了想要整合两大虚拟机的意图，但是目前在新发布的JDK7中，默认的虚拟机仍然是HotSpot，因此本文中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的GC机制。</p><p>学习Java GC机制，可以帮助我们在日常工作中排查各种内存溢出或泄露问题，解决性能瓶颈，达到更高的并发量，写出更高效的程序。</p><h1>解决哪些问题</h1><p>既然是要进行自动GC，那必然会有相应的策略，而这些策略解决了哪些问题呢，粗略的来说，主要有以下几点。</p><ul>  <li>哪些对象可以被回收。</li>  <li>何时回收这些对象。</li>  <li>采用什么样的方式回收。</li></ul><p>说到垃圾回收（Garbage Collection，GC），很多人就会自然而然地把它和Java联系起来。在Java中，程序员不需要去关心内存动态分配和垃圾回收的问题，这一切都交给了JVM来处理。</p><p>顾名思义，垃圾回收就是释放垃圾占用的空间，那么在Java中，什么样的对象会被认定为“垃圾”？那么当一些对象被确定为垃圾之后，采用什么样的策略来进行回收（释放空间）？在目前的商业虚拟机中，有哪些典型的垃圾收集器？</p><h2 id="如何确定某个对象是-垃圾-？">如何确定某个对象是“垃圾”？</h2><p>既然垃圾收集器的任务是回收垃圾对象所占的空间供新的对象使用，那么垃圾收集器如何确定某个对象是“垃圾”？即通过什么方法判断一个对象可以被回收了。</p><p>在java中是通过引用来和对象进行关联的，也就是说如果要操作对象，必须通过引用来进行。那么很显然一个简单的办法就是通过引用计数来判断一个对象是否可以被回收。不失一般性，如果一个对象没有任何引用与之关联，则说明该对象基本不太可能在其他地方被使用到，那么这个对象就成为可被回收的对象了。这种方式成为引用计数法。</p><p>这种方式的特点是实现简单，而且效率较高，但是它无法解决循环引用的问题，因此在Java中并没有采用这种方式（Python采用的是引用计数法）。看下面这段代码：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       MyObject object1 = <span class="keyword">new</span> MyObject();</span><br><span class="line">       MyObject object2 = <span class="keyword">new</span> MyObject();</span><br><span class="line">        </span><br><span class="line">       object1.object = object2;</span><br><span class="line">       object2.object = object1;</span><br><span class="line">        </span><br><span class="line">       object1 = <span class="keyword">null</span>;</span><br><span class="line">       object2 = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span></span>&#123;</span><br><span class="line">   <span class="keyword">public</span> Object object = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>最后面两句将object1和object2赋值为null，也就是说object1和object2指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数都不为0，那么垃圾收集器就永远不会回收它们。</p><p>为了解决这个问题，在Java中采取了 可达性分析法。该方法的基本思想是通过一系列的“GC Roots”对象作为起点进行搜索，如果在“GC Roots”和一个对象之间没有可达路径，则称该对象是不可达的，不过要注意的是被判定为不可达的对象不一定就会成为可回收对象。被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。</p><p>至于可达性分析法具体是如何操作的我暂时也没有看得很明白，如果有哪位朋友比较清楚的话请不吝指教。</p><p>下面来看个例子：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">Object aobj = <span class="keyword">new</span> Object ( ) ;</span><br><span class="line">Object bobj = <span class="keyword">new</span> Object ( ) ;</span><br><span class="line">Object cobj = <span class="keyword">new</span> Object ( ) ;</span><br><span class="line">aobj = bobj;</span><br><span class="line">aobj = cobj;</span><br><span class="line">cobj = <span class="keyword">null</span>;</span><br><span class="line">aobj = <span class="keyword">null</span>;</span><br></pre>      </td>    </tr>  </table></figure><p>第几行有可能会使得某个对象成为可回收对象？第7行的代码会导致有对象会成为可回收对象。至于为什么留给读者自己思考。</p><p>再看一个例子：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">SoftReference&lt;String&gt; sr = </span><br><span class="line"><span class="keyword">new</span> SoftReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"java"</span>));</span><br><span class="line">WeakReference&lt;String&gt; wr = </span><br><span class="line"><span class="keyword">new</span> WeakReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"world"</span>));</span><br></pre>      </td>    </tr>  </table></figure><p>这三句哪句会使得String对象成为可回收对象？第2句和第3句，第2句在内存不足的情况下会将String对象判定为可回收对象，第3句无论什么情况下String对象都会被判定为可回收对象。</p><p>最后总结一下平常遇到的比较常见的将对象判定为可回收对象的情况：</p><ul>  <li>显示地将某个引用赋值为null或者将已经指向某个对象的引用指向新的对象，比如下面的代码：</li></ul><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br><span class="line">Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line">Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line">obj1 = obj2;</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>局部引用所指向的对象，比如下面这段代码：</li></ul><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">       Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">       System.out.println(obj.getClass());</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>循环每执行完一次，生成的Object对象都会成为可回收的对象。</p><ul>  <li>只有弱引用与其关联的对象，比如：</li></ul><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">WeakReference&lt;String&gt; wr = <span class="keyword">new</span> WeakReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"world"</span>));</span><br></pre>      </td>    </tr>  </table></figure><h2 id="典型的垃圾收集算法">典型的垃圾收集算法</h2><p>在确定了哪些垃圾可以被回收后，垃圾收集器要做的事情就是开始进行垃圾回收，但是这里面涉及到一个问题是：如何高效地进行垃圾回收。由于Java虚拟机规范并没有对如何实现垃圾收集器做出明确的规定，因此各个厂商的虚拟机可以采用不同的方式来实现垃圾收集器，所以在此只讨论几种常见的垃圾收集算法的核心思想。</p><p>需要明确的一点是，这里谈到的垃圾回收算法针对的是JVM的堆内存，栈基本上不存在垃圾回收方面的困扰。</p><h3 id="mark-sweep-标记-清除-算法">Mark-Sweep（标记-清除）算法</h3><p>这是最基础的垃圾回收算法，之所以说它是最基础的是因为它最容易实现，思想也是最简单的。标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。</p><p>标记—清除算法是最基础的收集算法，它分为“标记”和“清除”两个阶段：首先标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实就是前面的根搜索算法中判定垃圾对象的标记过程。</p><p>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段。</p><p><img src="http://www.meng.uno/images/gc/3.png" alt=""></p><p><img src="http://www.meng.uno/images/gc/4.png" alt=""></p><p>标记-清除算法实现起来比较容易，但是有一个比较严重的问题就是容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。</p><p>该算法有如下缺点：</p><ul>  <li>标记和清除过程的效率都不高。</li>  <li>标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不触发另一次垃圾收集动作。</li></ul><p>我们在程序（程序也就是指我们运行在JVM上的JAVA程序）运行期间如果想进行垃圾回收，就必须让GC线程与程序当中的线程互相配合，才能在不影响程序运行的前提下，顺利的将垃圾进行回收。</p><p>为了达到这个目的，标记/清除算法就应运而生了。它的做法是当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被成为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。</p><ul>  <li>标记：标记的过程其实就是，遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。</li>  <li>清除：清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。</li></ul><p>就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行。</p><h3 id="copying-复制-算法">Copying（复制）算法</h3><p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。 当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。</p><p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[1]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。 HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。  当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</p><p>内存的分配担保就好比我们去银行借款，如果我们信誉很好，在98%的情况下都能按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有风险了。 内存的分配担保也一样，如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</p><p>复制算法是针对标记—清除算法的缺点，在其基础上进行改进而得到的，它讲课用内存按容量分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面，然后再把已使用过的内存空间一次清理掉。复制算法有如下优点：</p><ul>  <li>每次只对一块内存进行回收，运行高效。</li>  <li>只需移动栈顶指针，按顺序分配内存即可，实现简单。</li>  <li>内存回收时不用考虑内存碎片的出现。</li></ul><p>它的缺点是：可一次性分配的最大内存缩小了一半。</p><p><img src="http://www.meng.uno/images/gc/1.png" alt=""></p><p>这种算法虽然实现简单，运行高效且不容易产生内存碎片，但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。</p><p>很显然，Copying算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低。</p><p>我们首先一起来看一下复制算法的做法，复制算法将内存划分为两个区间，在任意时间点，所有动态分配的对象都只能分配在其中一个区间（称为活动区间），而另外一个区间（称为空闲区间）则是空闲的。</p><p>当有效内存空间耗尽时，JVM将暂停程序运行，开启复制算法GC线程。接下来GC线程会将活动区间内的存活对象，全部复制到空闲区间，且严格按照内存地址依次排列，与此同时，GC线程将更新存活对象的内存引用地址指向新的内存地址。</p><p>此时，空闲区间已经与活动区间交换，而垃圾对象现在已经全部留在了原来的活动区间，也就是现在的空闲区间。事实上，在活动区间转换为空间区间的同时，垃圾对象已经被一次性全部回收。</p><p>很明显，复制算法弥补了标记/清除算法中，内存布局混乱的缺点。不过与此同时，它的缺点也是相当明显的。</p><ol>  <li>它浪费了一半的内存，这太要命了。</li>  <li>如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。</li></ol><p>所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。</p><h3 id="mark-compact-标记-整理-算法">Mark-Compact（标记-整理）算法</h3><p>为了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。</p><p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。 更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p><p>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p>标记/整理算法与标记/清除算法非常相似，它也是分为两个阶段：标记和整理。下面LZ给各位介绍一下这两个阶段都做了什么。</p><ul>  <li>标记：它的第一个阶段与标记/清除算法是一模一样的，均是遍历GC Roots，然后将存活的对象标记。</li>  <li>整理：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段。</li></ul><p>复制算法比较适合于新生代，在老年代中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如标记—整理算法。该算法标记的过程与标记—清除算法中的标记过程一样，但对标记后出的垃圾对象的处理情况有所不同，它不是直接对可回收对象进行清理，而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="http://www.meng.uno/images/gc/2.png" alt=""></p><p>不难看出，标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价，可谓是一举两得，一箭双雕，一石两鸟。</p><p>不过任何算法都会有其缺点，标记/整理算法唯一的缺点就是效率也不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。</p><h3 id="generational-collection-分代收集-算法">Generational Collection（分代收集）算法</h3><p>分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。</p><p>目前大部分垃圾收集器对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照1：1的比例来划分新生代的空间的。一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。</p><p>而由于老年代的特点是每次回收都只回收少量对象，一般使用的是Mark-Compact算法。</p><p>注意，在堆区之外还有一个代就是永久代（Permanet Generation），它用来存储class类、常量、方法描述等。对永久代的回收主要回收两部分内容：废弃常量和无用的类。</p><p>当前商业虚拟机的垃圾收集 都采用分代收集，它根据对象的存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代。在新生代中，每次垃圾收集时都会发现有大量对象死去，只有少量存活，因此可选用复制算法来完成收集，而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记—清除算法或标记—整理算法来进行回收。</p><h2 id="典型的垃圾收集器">典型的垃圾收集器</h2><p>垃圾收集算法是 内存回收的理论基础，而垃圾收集器就是内存回收的具体实现。下面介绍一下HotSpot（JDK 7)虚拟机提供的几种垃圾收集器，用户可以根据自己的需求组合出各个年代使用的收集器。</p><ul>  <li>Serial/Serial Old</li></ul><p>Serial/Serial Old收集器是最基本最古老的收集器，它是一个单线程收集器，并且在它进行垃圾收集时，必须暂停所有用户线程。Serial收集器是针对新生代的收集器，采用的是Copying算法，Serial Old收集器是针对老年代的收集器，采用的是Mark-Compact算法。它的优点是实现简单高效，但是缺点是会给用户带来停顿。</p><ul>  <li>ParNew</li></ul><p>ParNew收集器是Serial收集器的多线程版本，使用多个线程进行垃圾收集。</p><ul>  <li>Parallel Scavenge</li></ul><p>Parallel Scavenge收集器是一个新生代的多线程收集器（并行收集器），它在回收期间不需要暂停其他用户线程，其采用的是Copying算法，该收集器与前两个收集器有所不同，它主要是为了达到一个可控的吞吐量。</p><ul>  <li>Parallel Old</li></ul><p>Parallel Old是Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和Mark-Compact算法。</p><ul>  <li>CMS</li></ul><p>CMS（Current Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是Mark-Sweep算法。</p><ul>  <li>G1</li></ul><p>G1收集器是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器，它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。</p><p><br><br>本文链接： <a href="http://www.meng.uno/articles/dde60b3a/">http://www.meng.uno/articles/dde60b3a/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      简介
Java GC（Garbage Collection，垃圾收集，垃圾回收）机制，是Java与C++/C的主要区别之一，作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码，对内存泄露和溢出的问题，也不需要像C程序员那样战战兢兢。这是因为在Java虚拟机中，存在自动内存管理和垃圾清扫机制。概括地说，该机制对JVM（Java Virtual Machine）中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，永不停息（Nerver Stop）的保证JVM中的内存空间，防止出现内存泄露和溢出问题。

关于JVM，需要说明一下的是，目前使用最多的Sun公司的JD
    
    </summary>
    
      <category term="Java开发Tips" scheme="http://www.meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/"/>
    
    
      <category term="JVM" scheme="http://www.meng.uno/tags/JVM/"/>
    
      <category term="GC" scheme="http://www.meng.uno/tags/GC/"/>
    
      <category term="垃圾回收" scheme="http://www.meng.uno/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>H5网页失去焦点Title改变的方法</title>
    <link href="http://www.meng.uno/articles/7794c7e7/"/>
    <id>http://www.meng.uno/articles/7794c7e7/</id>
    <published>2018-03-08T06:33:11.000Z</published>
    <updated>2018-03-08T06:47:36.988Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>今天要讲的其实是一个API：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/visibilitychange" target="_blank" rel="noopener">visibilitychange</a></p></blockquote><p>这个 API 本身非常简单，由以下三部分组成。</p><p>document.hidden：表示页面是否隐藏的布尔值。页面隐藏包括 页面在后台标签页中 或者 浏览器最小化 （注意，页面被其他软件遮盖并不算隐藏，比如打开的 sublime 遮住了浏览器）。</p><p>document.visibilityState：表示下面 4 个可能状态的值</p><p>hidden：页面在后台标签页中或者浏览器最小化</p><p>visible：页面在前台标签页中</p><p>prerender：页面在屏幕外执行预渲染处理 document.hidden 的值为 true</p><p>unloaded：页面正在从内存中卸载</p><p>Visibilitychange事件：当文档从可见变为不可见或者从不可见变为可见时，会触发该事件。</p><p>这样，我们可以监听 Visibilitychange 事件，当该事件触发时，获取 document.hidden 的值，根据该值进行页面一些事件的处理。</p><figure class="highlight html">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>这是原来的title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, maximum-scale=1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> tmptitle = <span class="built_in">document</span>.title;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.addEventListener(<span class="string">'visibilitychange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> isHidden = <span class="built_in">document</span>.hidden;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span> (isHidden) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.title = <span class="string">'当焦点不在当前窗口时的网页标题'</span>;</span></span><br><span class="line"><span class="javascript">          &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.title = tmptitle;</span></span><br><span class="line"><span class="undefined">          &#125;</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre>      </td>    </tr>  </table></figure><p><br><br>本文链接： <a href="http://www.meng.uno/articles/7794c7e7/">http://www.meng.uno/articles/7794c7e7/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      今天要讲的其实是一个API：visibilitychange

这个 API 本身非常简单，由以下三部分组成。

document.hidden：表示页面是否隐藏的布尔值。页面隐藏包括 页面在后台标签页中 或者 浏览器最小化 （注意，页面被其他软件遮盖并不算隐藏，比如打开的 sublime 遮住了浏览器）。

document.visibilityState：表示下面 4 个可能状态的值

hidden：页面在后台标签页中或者浏览器最小化

visible：页面在前台标签页中

prerender：页面在屏幕外执行预渲染处理 document.hidden 的值为 true

unloaded
    
    </summary>
    
      <category term="随笔" scheme="http://www.meng.uno/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="H5" scheme="http://www.meng.uno/tags/H5/"/>
    
      <category term="Title" scheme="http://www.meng.uno/tags/Title/"/>
    
      <category term="焦点" scheme="http://www.meng.uno/tags/%E7%84%A6%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Unix进程的那些事</title>
    <link href="http://www.meng.uno/articles/aeaab565/"/>
    <id>http://www.meng.uno/articles/aeaab565/</id>
    <published>2018-03-04T12:06:22.000Z</published>
    <updated>2018-03-04T12:56:59.397Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>不知道你们有没有这样的疑惑，每次在看资料时遇到<code>fork(2)</code>，我都不理解，为什么<code>fork()</code>函数需要<code>2</code>做参数？还只能是<code>2</code>。</p></blockquote><blockquote>  <p>本篇博客在阅读了《Working with Unix Processes》之后总结而成。</p></blockquote><h1>回答疑问</h1><p>首先，我就来解释一下之前留下的那个疑问，用过Mac或者Linux的同学都知道电脑中有很多<code>man</code>文件夹，我也不知道怎么回事，莫非是因为我是个<code>man</code>？后来我知道了，<code>man</code>是<code>manpages</code>的意思，中文译作“Unix手册页”，和我们现实中使用的手册一样，这个手册也是分节的，其中比较重要的几节：</p><ul>  <li>节1：一般命令</li>  <li>节2：系统调用</li>  <li>节3：C库函数</li>  <li>节4：特殊文件</li></ul><p>那么我们该如何使用这个手册呢？</p><p>很简单 我们只需要：<code>man [节号] 命令名</code>就可以了。</p><p>例如：<code>man 2 fork</code></p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre>      </td>      <td class="code">        <pre><span class="line">     fork() will fail and no child process will be created <span class="keyword">if</span>:</span><br><span class="line"></span><br><span class="line">     [EAGAIN]           The system-imposed limit on the total number of processes under</span><br><span class="line">                        execution would be exceeded.  This limit is configuration-depen-</span><br><span class="line">                        dent.</span><br><span class="line"></span><br><span class="line">     [EAGAIN]           The system-imposed limit MAXUPRC (&lt;sys/param.h&gt;) on the total num-</span><br><span class="line">                        ber of processes under execution by <span class="selector-tag">a</span> single user would be</span><br><span class="line">                        exceeded.</span><br><span class="line"></span><br><span class="line">     [ENOMEM]           There is insufficient swap space <span class="keyword">for</span> the new process.</span><br><span class="line"></span><br><span class="line">LEGACY SYNOPSIS</span><br><span class="line">     <span class="selector-id">#include</span> &lt;sys/types.h&gt;</span><br><span class="line">     <span class="selector-id">#include</span> &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">     The include file &lt;sys/types.h&gt; is necessary.</span><br><span class="line"></span><br><span class="line">SEE ALSO</span><br><span class="line">     execve(<span class="number">2</span>), sigaction(<span class="number">2</span>), wait(<span class="number">2</span>), compat(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">HISTORY</span><br><span class="line">     A fork() function call appeared <span class="keyword">in</span> Version <span class="number">6</span> AT&amp;T UNIX.</span><br><span class="line"></span><br><span class="line">CAVEATS</span><br><span class="line">     There are limits to what you can do <span class="keyword">in</span> the child process.  To be totally safe you</span><br><span class="line">     should restrict yourself to only executing async-signal safe operations until such</span><br><span class="line">     <span class="selector-tag">time</span> as one of the exec functions is called.  All APIs, including global data sym-</span><br><span class="line">     bols, <span class="keyword">in</span> any framework or library should be assumed to be unsafe after <span class="selector-tag">a</span> fork()</span><br><span class="line">     unless explicitly documented to be safe or async-signal safe.  If you need to use</span><br><span class="line">     these frameworks <span class="keyword">in</span> the child process, you must exec.  In this situation it is rea-</span><br><span class="line">     sonable to exec yourself.</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>th Berkeley Distribution        June <span class="number">4</span>, <span class="number">1993</span>        <span class="number">4</span>th Berkeley Distribution</span><br><span class="line">(END)</span><br></pre>      </td>    </tr>  </table></figure><p>这就是完整的对fork(2)的解释。</p><h1>Unix进程</h1><h2 id="提示">提示</h2><p>所有<code>Ruby</code>代码皆需要在<code>irb</code>环境下运行，如何安装<code>Ruby</code>，可以百度。</p><h2 id="进程标识">进程标识</h2><p>每个人都有一个唯一的身份证号，进程也是如此，这个唯一的标识符叫做<code>pid</code>。我们输入：<code>puts Process.pid</code>就可以得到当前进程的pid了。</p><p>pid并不传达关于进程本身的任何信息，它仅仅是一个顺序标识符。在内核眼中进程只是一个数字而已。</p><p>pid是对进程的一种简单通用的描述，至于用途之一，比如我们常常会在日志文件中发现pid，当有多个进程向一个日志文件写入日志的时候，在每一行加入pid就可以知道哪一行日志是由哪个进程写入的。</p><h2 id="父进程">父进程</h2><p>系统中运行的每一个进程都有对应的父进程，每一个进程都知道其父进程的标识符(ppid)。多数情况下特定进程的父进程就是调用它的那个进程。比如启动终端并进入bash提示符，此时新创建的bash进程的父进程就是终端进程。如果在bash中调用ls等命令，那么bash进程便是ls进程的父进程。</p><p>父进程对于检测守护进程有比较重要的作用。</p><p>我们输入：<code>puts Process.ppid</code>就可以得到当前进程的父进程pid了。</p><h2 id="文件描述符">文件描述符</h2><p>我们讨论进程，怎么突然说道“文件”？其实，在Unix眼中，一切皆为“文件”！设备是文件，套接字是文件，文件也是文件。当然为了避免误解，一般将文件称为文件，其他称为资源。</p><p>我们使用这样的语句打印某“文件”的描述符：<code>puts 文件名.fileno</code>。</p><p>例如，STDIN的描述符：<code>puts STDIN.fileno</code>，结果是不是很吃惊？因为居然是<code>0</code>！！！</p><p>同理，排在其后的分别是STDOUT与STDERR，他们三者也被称为标准流。</p><h2 id="资源限制">资源限制</h2><p>文件描述符代表已经打开的资源，当资源没有被关闭时，该资源的文件描述符编号会一直被占用，文件描述符编号一直处于递增状态，而内核为每个进程设置了最大文件描述符号，即施加了一些资源限制。对于文件描述符编号的限制有软限制和硬限制。软限制一般可以比较小而硬限制一般数值比较大而且可以修改。如果超出限制则会报错。</p><p>资源限制除了允许打开的最大资源数以外，还包括可创建的最大文件长度和进程最大段的大小等。对于用户内核会限制其最大并发进程数。</p><p>我们使用<code>p Process.getrlimit(:NOFILE)</code>来获取当前进程的资源限制，在我的电脑上结果是：<code>[256, 9223372036854775807]</code>。</p><p>可能我们觉得软限制256有点少，那好，我们尝试给他设置一个大的。使用如下命令：</p><p><code>Process.setrlimit(:NOFILE,4096)</code></p><h2 id="环境变量">环境变量</h2><p>我们每个人都设置过环境变量，环境变量是包含进程数据的键值对。所有进程都从其父进程继承环境变量，它们由父进程设置并被子进程所继承。每一个进程都有环境变量，环境变量对于特定进程而言是全局性的。比如环境变量PWD对应的值为当前的工作目录等等。环境变量经常作为一种将输入传递到命令行程序中的方法。</p><h2 id="参数">参数</h2><p>所有进程都可以访问名为ARGV的特殊数组（<code>p ARGV</code>），它是一个参数向量或数组。保存了在命令行中传递给当前进程的参数。有些像C语言中main函数中第二个参数：char** argv。</p><h2 id="进程名">进程名</h2><p>系统中每一个进程都有名称，进程名可以在运行期间被修改并作为一种通信手段。一般都会有一个全局变量来存储当前进程的名称。可以通过给这个全局变量赋值来修改当前进程的名称。</p><p>我们可以用<code>puts $PROGRAM_NAME</code>来打印当前进程的进程名。</p><h2 id="退出码">退出码</h2><p>我们写C程序的时候，总是默认加上<code>return 0</code>，可能大家也遇到过其他的返回值，例如<code>exit(1)</code>等，这里的0、1就是退出码。</p><p>所有进程在退出时都带有数字退出码(0-255)用于指明进程是否顺利结束。一般退出码为0的进程被认为是顺利结束，其他的退出码则表明出现了错误，不同的退出码代表不同的错误。</p><p>尽管退出码通常用来表明不同的错误，它们其实是一种通信手段。作为程序员的你可以以适合自己程序的方式来处理各种进程退出码。</p><ul>  <li>exit</li></ul><p>默认进程退出码为<code>0</code>，可以传递指定的退出码。<code>exit 22</code>代表定制进程退出码为<code>22</code>，不指定数字则默认为<code>0</code>，而且指定退出码在<code>0-255</code>之间的数值才是有效的。</p><ul>  <li>exit!</li></ul><p>默认进程退出码为<code>1</code>，可以传递指定的退出码。<code>exit!33</code>代表定制进程退出码为<code>33</code>，不指定数字时默认为<code>1</code>，而且指定退出码在<code>0-255</code>之间的数值才是有效的。</p><ul>  <li>abort</li></ul><p>会将当前进程的退出码设置为<code>1</code>，而且可以传递一条消息给STDERR。例如<code>abort “Something went wrong!”</code>，则进程退出码为<code>1</code>且会在<code>STDERR</code>中打印<code>“Something went wrong”</code>。注意该方法不能指定退出码。</p><ul>  <li>raise</li></ul><p><code>raise</code>方法不会立即结束进程，它只是抛出一个异常，该异常会沿着调用栈向上传递并可能会得到处理。如果没有代码对其进程处理，那么这个未处理的异常将会终结该进程。类似于<code>abort</code>方法，一个未处理的异常会将退出码设置为<code>1</code>。也可以传递一条消息给<code>STDERR</code>。例如<code>raise “Something went wrong!”</code>，则进程退出码为<code>1</code>且会在<code>STDERR</code>中打印<code>“Something went wrong”</code>。<strong>注意该方法也不能指定退出码。</strong></p><h2 id="fork-与友好进程">fork()与友好进程</h2><p>fork()系统调用允许运行中的进程以编程的形式创建新的进程，这个心进程和原始进程一模一样。调用fork()的进程被称为父进程，新创建的进程被称为子进程。因子进程是一个全新的进程，所以它拥有自己唯一的进程id。</p><p>子进程从父进程处继承了其所占用内存中的所有内容，以及所有属于父进程的已打开的文件描述符的编号。这样，两个进程就可以共享打开的文件、套接字等。因子进程会复制父进程在内存中的所有内容，所以子进程可以随意更改其内存内容的副本，而不会对父进程造成任何影响(后面会介绍COW写时复制技术)。</p><p>对于fork()方法的一次调用实际上会返回两次。fork方法创造了一个新进程，在调用进程(父进程)中返回一次，且会返回子进程的pid；在新创建的进程(子进程)中又返回一次，返回0。</p><p>fork创建了一个和旧进程一模一样的新进程。所以试想一个使用了500MB内存的进程进行了衍生，那么就有1GB的内存被占用了。重复同样的操作十次，很快就会耗尽内存，这通常被称为“fork炸弹”。</p><p>所以现代的Unix/Linux操作系统采用写时复制(copy-on-write, COW)的方法来克服这个问题。COW将实际的内存复制操作推迟到了真正需要写入的时候。所以说父进程和子进程实际上是在共享内存中的数据，直到它们其中一个需要对数据进行修改，届时才会进行内存复制，使得两个进程保持适当的隔离。</p><p>这里多补充点COW的知识，自己在面试中也被问到这个问题，当时并不了解这个知识点，所以对这个知识点印象比较深刻。当采用COW技术时，子进程并不完全复制父进程的数据，只是以只读的方式共享父进程的页表，并将符进程的页表项也标记为只读。当父子进程中任何一个进程试图修改这些地址空间时，就会引发系统的页错误异常。异常错误处理程序将会生成该页的一份复制，并修改进程的页表项，指向新生成的页面，并将该页标记为已修改。</p><p>除了修改的数据和页面之外，其余的部分依然可以共享。</p><p>在一些语言当中，比如ruby中，会通过block代码块来使用fork。将一个block代码块传递给fork方法，那么这个block代码块将在新的子进程中执行，而父进程会跳过block中的内容。而且子进程执行完block之后就会退出，并不会像父进程那样指向随后的代码。</p><h2 id="孤儿进程">孤儿进程</h2><p>当父进程结束后而子进程没有结束时，子进程会照常继续运行，此时子进程被称为孤儿进程。孤儿进程会被系统当中的守护进程所收养，该进程是一种长期运行的进程，而且是有意作为孤儿进程存在。</p><h2 id="进程等待与僵尸进程">进程等待与僵尸进程</h2><p>wait是一个阻塞调用，该调用使得父进程一直等到它的某个子进程退出以后才继续执行。wait会返回其等待子进程的pid。wait2会返回两个值(pid, status)。除了pid之外还包括status，该变量存储有大量关于子进程的有用的信息，可让我们获知某个进程是怎样退出的。</p><p>wait/wait2是等待任意子进程的退出，而waitpid/waitpid2则是等待特定的由pid指定的子进程退出。</p><p>内核将退出的进程信息加入到队列，这样以来父进程就总是能够依照子进程退出的顺序接收到信息。就是说，即使子进程退出而父进程还没有准备妥当的时候，父进程也总能够通过队列获取到每个子进程的退出信息。注意，如果不存在子进程，调用wait的任一变体都会抛出ERRNO::ECHILD异常。所以最好让调用wait的数量和创建的子进程的数量相等才不会抛出异常。</p><p>一些服务器会使用看护进程这一模式：有一个衍生出多个并发子进程的进程，这个进程看管这些子进程，确保它们能够保持响应，并对子进程的退出做出响应，这个进程就是看护进程。</p><p>内核会将已退出的子进程的状态信息加入队列，所以即便父进程在子进程退出很久之后才调用wait，依然可以获取它的状态信息。内核会一直保留已退出的子进程的状态信息直到父进程调用wait请求这些消息。如果父进程一直不发出请求，那么状态信息就会被内核一直保留着，因此创建一个即发即弃的子进程却不去请求状态信息，便是在浪费内核资源，比如pid，要知道内核可创建的pid和进程控制块PCB是有限的，如果一直创建进程其父进程却不去请求它的退出信息，那么pid和PCB有可能会被耗尽而使得系统无法继续产生新进程。此时的子进程就被称为僵尸进程，所以说僵尸进程是有害的。</p><p>任何应结束的进程，如果它的状态信息一直未能读取，那么它就是一个僵尸进程，任何子进程在结束之时其父进程仍在运行，那么这个子进程很快就会称为僵尸进程。一旦父进程读取了僵尸进程的状态信息，那么它就不复存在，也就不再消耗内核资源。</p><p>有一种避免僵尸进程出现的方法就是分离父子进程，当父进程新创建一个子进程以后，如果不打算调用wait去等待和读取子进程的退出信息，可以使用detach方法。detach方法核心就是生成一个新线程，这个线程唯一的工作就是等待有pid所指定的那个进程退出并获取进程退出信息，从而确保内核不会一直保留进程的状态信息造成僵尸进程的出现和内核资源的浪费。</p><p>那么怎么识别僵尸进程呢？</p><p>很简答，我们使用如下指令：<code>pid = fork{ sleep 1} ; puts pid; sleep</code>的方式，发现结果为：<code>z</code>。</p><h2 id="信号量">信号量</h2><p>wait为父进程提供了一种很好方式来监管子进程。但它是一个阻塞调用：直到子进程结束，调用才会返回，任何一行代码都可能被信号中断。信号投递时不可靠的。如果你的代码正在处理CHLD信号，这时候另一个子进程结束了，那么你未必能收到第二个CHLD信号(CHLD信号：提醒父进程子进程退出的信号)。如果同一个信号在极短间隔内被多次收到，就会出现这种情况。这时可以考虑使用wait的非阻塞方法，形如<code>wait(-1, Process::WNOHANG)</code>。当获得一个信号并返回值以后就继续等待信号的产生。</p><p>信号是一种异步通信，当进程从内核接收到一个信号时，它可以执行下列某一个操作：</p><ul>  <li>忽略该信号；</li>  <li>执行特定操作；</li>  <li>执行默认操作。</li></ul><p>信号有内核发出，信号是由一个进程发送给另一个进程，不过内核作为中介而已。下表为常用信号介绍，大部分信号的默认行为都是终止进程，其中dump动作表示进程会立即结束并进行核心转储(栈跟踪)，而且比较特殊信号有SIGKILL和SIGSTOP信号不能被捕获、阻塞或忽略，SIGSR1和SIGSR2两个信号对应的操作由你的进程来定义。</p><p>信号是一个了不起的工具，不过捕获一个信号有点像使用全局变量，有可能把其他程序锁依赖的东西给修改了，不过和全局变量不同的是信号处理程序并没有命名空间。从最佳事件角度来说，个人代码不应该定义任何信号处理程序，除非它是服务器。正如一个从命令行启动的长期运行的进程，库代码极少会捕获信号。</p><p>进程可以在任何时候接收到信号，这就是信号的美所在！而且信号是异步的。有了信号，一旦知道了对方的pid，系统中的进程便可以彼此通信，使得信号成为一种极其强大的通信工具，常见的用法是使用kill方法来发送信号。实践当中，信号多是由长期运行的进程响应和使用，例如服务器和守护进程。而多数情况下，发送信号的都是人类用户而非自动化程序。</p><h2 id="进程通讯">进程通讯</h2><p>进程间通信(IPC)两个常见的实用方法是管道和套接字对(socket pairs)。</p><p>管道是一个单向数据流。打开一个管道，一个进程拥有管道的一段，另一个进程拥有另一端。然后数据就沿着管道单向传递。因此如果某个进程将自己作为一个管道的reader，而非writer，那么它就无法向管道中写入数据，反之亦然。例如在ruby脚本程序中：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">reader，writer = IO.pipe</span><br><span class="line">writer.write(&quot;I am writing something..&quot;)</span><br><span class="line">writer.close</span><br><span class="line">puts reader.read</span><br></pre>      </td>    </tr>  </table></figure><p>结果为：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">I am writing something..</span><br></pre>      </td>    </tr>  </table></figure><p>pipe返回一个包含两个元素的数组，第一个元素为reader的信息，第二个元素为writer的信息。</p><p>向管道写完信息就关闭writer，是因为reader调用read方法时，会不停地试图从管道中读取数据，直到读到一个EOF(文件结束标志)。这个标志告诉reader已经读完管道中所有的数据了。只要writer保持打开，那么reader就可能读到更多的数据，因此它就会一直等待。在读取之前关闭writer，将一个EOF放入管道中，这样一来，reader获得原始数据之后就会停止读取。要是忘记或者省去关闭writer这一步，那么reader就会被阻塞并不停地试图读取数据。</p><p>因为管道是单向的，所以再上诉程序中，reader只能读取，writer只能写入。</p><p>当某个进程衍生出一个子进程的时候，会与子进程共享打开的资源，管道也被认为是一种资源，它有自己的文件描述符等，因此可以与子进程共享。</p><p>当使用诸如管道或TCP套接字这样的IO流时，将数据写入流中，之后跟着一些特定协议的分隔符，随后从IO流中读取数据时，一次读取一块(chuck)，遇到分隔符就停止读取。</p><p>Unix套接字是一种只能用于在同一台物理主机中进行通信的套接字，它比TCP套接字快很多，非常适合用于IPC。</p><p>管道和套接字都是对进程间通信的有益抽象。它们即快速有简单，多被用作通信通道，来代替更为原始的方法，如共享数据库或日志文件。使用哪种方法取决于自己的需要，不过记得管道提供的是单向通信，套接字提供的是双向通信。</p><h2 id="终端进程">终端进程</h2><p>我们在终端执行每一条命令，其实都是创建了一个终端进程。</p><p>exec()系统调用非常简单，它允许使用另一个进程来替换当前进程，exec()这种转变是有去无回的，一旦你将当前进程转变为另外一个别的进程，那就再也变不回来了。</p><p>在要生成新进程的时候，fork()+exec()的组合是常见的一种用法，使用fork()创建一个新进程，然后用exec()把这个进程变成自己想要的进程，你的当前进程仍像从前一样运行，也仍可以根据需要生成其他进程。如果程序依赖于exec()调用的输出结果，可用wait方法来确保你的程序一直等到子进程完成它的工作，这样就可取回结果。exec()在默认情况下不会关闭任何打开的文件描述符或进行内存清理。</p><p>把字符串传递给exec实际上会启动一个shell进程，然后shell进程对这个字符串进行解释，传递一个数组的话，它会跳过shell，直接将此数组作为新进程的ARGV-参数数组，除非真的需要，一般尽可能地传递数组。</p><p>fork()是有成本的，记住这点有益无害，有时候它会成为性能瓶颈，主要是因为fork()的新子进程的两个独特属性：</p><ul>  <li>获得了一份父进程在内存中所有内容的副本；</li>  <li>获得了父进程已打开的所有文件描述符的副本。</li></ul><p>有一个系统调用posix_spawn，子保留了第2条，没有保留第1条。posix_spawn所生成的子进程可以访问父进程打开的所有文件描述符，却无法与父进程共享内存。这也是为什么posix_spawn比fork快、更有效率的原因。但事务都有两面性，也会因此而缺乏灵活性。</p><h2 id="守护进程">守护进程</h2><p>守护进程是在后台运行的进程，不受终端用户控制。Web服务器或数据库服务器都属于常见的守护进程，它们一直在后台运行响应请求。守护进程也是操作系统的核心功能，有很多进程一直在后台运行以保证系统的正常运行，任何进程都可变成守护进程。</p><p>当内核被引导时会产生一个叫做init的进程。该进程的pid是1，而ppid是0，作为所有进程的祖父。它是首个进程，没有祖先。一个孤儿进程会被init进程收养，孤儿进程的ppid始终是1，这是内核能够确保一直运行的唯一进程。</p><p>每一个进程都属于某个组，每一个组都有唯一的整数id，称为进程组id。进程组是一个相关进程的集合，通常是父进程与子进程。但是也可以按照需要将进程分组，可以通过setpgrp(new_group_ip)方法来设置进程组id。通常情况下，进程组id和进程组组长的id是相同的。进程组组长是终端命令的发起进程。也就是说，如果在终端启动一个进程，那么它就会成为一个新进程组的组长，它所创建的子进程就成为同一个进程组的组员。</p><p>这里进一步说明一下，之前讲过孤儿进程，子进程在父进程退出后会被init进程收养而继续运行，这是父进程退出的行为，但是如果父进程由终端控制并被信号终止的话，孤儿进程也会被终止的。这是因为父子进程属于同一个进程组，而父进程由终端控制，当父进程收到来自终端的终止信号时，与父进程属于同一个进程组的子进程也会收到终止信号而被终止。</p><p>会话组是更高一级的抽象，它是进程组的集合。一个会话组可以依附于一个终端，也可以不依附与任何终端，比如守护进程。终端用一种特殊的方法来处理会话组：发送给会话领导的信号会被转发到该会话中的所有进程组内，然后再转发到这些进程组中的所有进程。系统调用getsid()可用来检索当前的会话组id。</p><p>以下是创建一个守护进程的过程：</p><ul>  <li>首先在终端创建一个进程，并在进程中衍生出一个子进程，然后作为父进程的自己退出。启动该进程的终端察觉到进程退出后，将控制返回给用户，但是衍生出的子进程仍然拥有从父进程中继承而来的组id和会话组id，此时这个衍生进程既非会话领导也非进程组组长。因终端与衍生进程之间仍有牵连，如果终端发送信号到衍生进程的会话组，衍生进程会接收到这个信号，但我们想要的是完全脱离终端。</li>  <li>setsid方法可使得衍生进程成为一个新进程组的组长和新会话组的领导，而且此时新的会话组并没有控制终端。注意，如果在某个已经是进程组组长的进程中调用setsid方法，则会失败，它只能从子进程中调用。</li>  <li>已经成为进程组和会话组组长的衍生进程再次进行衍生，然后自己退出。新衍生出的进程不再是进程组和会话组组长，由于之前会话领导并没有相应的控制终端，且此进程也不是会话领导，因此该进程绝对不会有相应的控制终端存在，如此就可以确保进程现在是完全脱离了控制终端并且可以独立运行。</li>  <li>将进程的工作目录更改为系统的根目录，可避免进程的启动进程出于个各种问题被删除或者卸载。</li>  <li>将所有标准流重定向到“/dev/null”，也就是将其忽略，主要是因为守护进程已不再依附于某个终端会话，所以标准流也就无用了，但是不能简单的关闭，因为一些进程可能还指望它们随时可用。</li></ul><p>以下是ruby语言创建一个守护进程的完整程序：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line">exit if fork</span><br><span class="line">Process.setsid</span><br><span class="line">exit if fork</span><br><span class="line"></span><br><span class="line">Dir.chdir  &quot;/&quot;</span><br><span class="line">STDIN.reopen   &quot;/dev/null&quot;</span><br><span class="line">STDOUT.reopen   &quot;/dev/null&quot;, &quot;a&quot;</span><br><span class="line">STDERR.reopen  &quot;/dev/null&quot;, &quot;a&quot;</span><br></pre>      </td>    </tr>  </table></figure><p>对于是否需要创建一个守护进程，就应该问自己一个基本问题：这个进程是否需要一直保持响应？如果答案为否，那么你也许可以考虑定时任务或后台作业系统，如果答案是肯定的，那就去创建，不用犹豫。</p><p><br><br>本文链接： <a href="http://www.meng.uno/articles/aeaab565/">http://www.meng.uno/articles/aeaab565/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      不知道你们有没有这样的疑惑，每次在看资料时遇到fork(2)，我都不理解，为什么fork()函数需要2做参数？还只能是2。

本篇博客在阅读了《Working with Unix Processes》之后总结而成。

回答疑问
首先，我就来解释一下之前留下的那个疑问，用过Mac或者Linux的同学都知道电脑中有很多man文件夹，我也不知道怎么回事，莫非是因为我是个man？后来我知道了，man是manpages的意思，中文译作“Unix手册页”，和我们现实中使用的手册一样，这个手册也是分节的，其中比较重要的几节：

 * 节1：一般命令
 * 节2：系统调用
 * 节3：C库函数
 * 节4：特
    
    </summary>
    
      <category term="操作系统" scheme="http://www.meng.uno/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Unix" scheme="http://www.meng.uno/tags/Unix/"/>
    
      <category term="进程" scheme="http://www.meng.uno/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>自制简单搜索引擎及Wiser的使用</title>
    <link href="http://www.meng.uno/articles/c49b2caf/"/>
    <id>http://www.meng.uno/articles/c49b2caf/</id>
    <published>2018-03-03T06:10:07.000Z</published>
    <updated>2018-03-03T06:53:43.553Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>自己开发一个搜索引擎，可能是每一个计算机爱好者的梦想，但是当我们看到网上开源搜索引擎那么庞大时，未免有点害怕。那么开发一个搜索引擎真的很难么？</p></blockquote><blockquote>  <p>本博文在阅读了《How to Develop a Search Engineer》之后，总结而成。</p></blockquote><blockquote>  <p>代码下载：<a href="http://www.meng.uno/codes/wiser.zip">Wiser</a></p></blockquote><h1>搜索引擎简介</h1><p>搜索引擎（Search Engine）是指根据一定的策略、运用计算机技术从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务。在日常生活中，可以看到 Google 等 Web 检索网站，还有邮件检索和专利检索等各种应用程序。</p><h2 id="背景知识">背景知识</h2><p>在自己写一个搜索引擎之前，需要先了解基本的原理和概念。比如分词，倒排索引，排序算法（BM25、PageRank）等。</p><p>搜索引擎工作步骤分为这几步：</p><ul>  <li>爬虫模块 Crawler 在网页上抓取感兴趣的网页数据存储为 Cached pages</li>  <li>索引构造器 Indexer 对 Cached pages 处理生成倒排索引(Inverted Index)</li>  <li>对查询词 Query 在倒排索引中查找对应的文档 Document</li>  <li>计算 Query 和 Document 的关联度，返回给用户 TopK 个结果</li>  <li>根据用户点击 TopK 的行为去修正用户查询的 Query，形成反馈闭环。</li></ul><p>搜索引擎的四大组件：</p><ul>  <li>文档管理器(Document Manager)</li>  <li>索引构建器(Indexer)</li>  <li>索引管理器(Index Manager)</li>  <li>索引检索器(Index Searcher)</li></ul><p>组件关系图：</p><p><img src="http://www.meng.uno/images/se/1.png" alt=""></p><h1>Wiser使用</h1><h3 id="编译运行">编译运行</h3><p>下载好<code>wiser.zip</code>文件，并解压缩到相应位置，进入文件夹，运行<code>make wiser</code>，稍待片刻，即可完成编译。</p><p><img src="http://www.meng.uno/images/se/4.png" alt=""></p><h3 id="收集数据">收集数据</h3><p>在本次使用wiser的实验中，直接从<code>https://dumps.wikimedia.org/zhwiki/latest/</code>下载相应的<code>xml</code>文件即可（省去了实际的爬虫过程）。</p><p><strong>使用wiser存入sqlite使用命令：<code>wiser -x XXX.xml -m 100 wiki.db</code></strong></p><p><img src="http://www.meng.uno/images/se/2.png" alt=""></p><p>此时，我们已经将10条数据存入<code>.db</code>文件中了。</p><h3 id="构建倒排索引">构建倒排索引</h3><p>*在上一步已经完成。</p><h3 id="检索文档">检索文档</h3><p><strong>使用wiser搜索一个关键词使用命令：<code>wiser -q &quot;XXX&quot; wiki.db</code></strong></p><h3 id="排序并呈现">排序并呈现</h3><p><img src="http://www.meng.uno/images/se/3.png" alt=""></p><p>从截图中可见，score代表匹配指数，已经计算好，并返回给我们。</p><h1>Wiser代码剖析</h1><p>在此先简单的介绍各个主要的<code>.c</code>文件实现的功能：</p><ul>  <li><code>wiser.c</code>: 主程序，接收命令行输入，并相应的调用其他函数；</li>  <li><code>database.c</code>: 操作sqlite，包括增，查等功能；</li>  <li><code>search.c</code>: 全文检索，TF-IDF求相关度；</li>  <li><code>postings.c</code>: 倒排索引压缩与解压缩；</li>  <li><code>token.c</code>: 创建倒排索引，N-gram分词；</li>  <li><code>wikiload.c</code>: 加载wikipedia上下载的<code>xml</code>文件；</li>  <li><code>util.c</code>: 编码相关的杂项。</li></ul><p>其他详情，还请实际使用啊！</p><p><br><br>本文链接： <a href="http://www.meng.uno/articles/c49b2caf/">http://www.meng.uno/articles/c49b2caf/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      自己开发一个搜索引擎，可能是每一个计算机爱好者的梦想，但是当我们看到网上开源搜索引擎那么庞大时，未免有点害怕。那么开发一个搜索引擎真的很难么？

本博文在阅读了《How to Develop a Search Engineer》之后，总结而成。

代码下载：Wiser

搜索引擎简介
搜索引擎（Search Engine）是指根据一定的策略、运用计算机技术从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务。在日常生活中，可以看到 Google 等 Web 检索网站，还有邮件检索和专利检索等各种应用程序。

背景知识
在自己写一个搜索引擎之前，需要先了解基本的原理和概念。比如分词，
    
    </summary>
    
      <category term="信息检索" scheme="http://www.meng.uno/categories/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2/"/>
    
    
      <category term="搜索引擎" scheme="http://www.meng.uno/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
      <category term="Wiser" scheme="http://www.meng.uno/tags/Wiser/"/>
    
      <category term="倒排文件" scheme="http://www.meng.uno/tags/%E5%80%92%E6%8E%92%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse的阿里巴巴代码规范配置</title>
    <link href="http://www.meng.uno/articles/6e79ab7a/"/>
    <id>http://www.meng.uno/articles/6e79ab7a/</id>
    <published>2018-03-01T15:25:33.000Z</published>
    <updated>2018-03-01T15:25:51.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="插件安装">插件安装</h2><p>环境：JDK1.8，Eclipse4+。有同学遇到过这样的情况，安装插件重启后，发现没有对应的菜单项，从日志上也看不到相关的异常信息，最后把JDK从1.6升级到1.8解决问题。</p><p>Help -&gt; Install New Software…</p><p><img src="https://gw.alicdn.com/tfscom/TB1LOyPifJNTKJjSspoXXc6mpXa.png" alt=""></p><p>输入Update Site地址：<a href="https://p3c.alibaba.com/plugin/eclipse/update" target="_blank" rel="noopener">https://p3c.alibaba.com/plugin/eclipse/update</a> 回车，然后勾选Ali-CodeAnalysis，再一直点Next Next…按提示走下去就好。 然后就是提示重启了，安装完毕。</p><p><img src="https://gw.alicdn.com/tfscom/TB1Ud5kifBNTKJjSszcXXbO2VXa.png" alt=""></p><p>注意：有同学反映插件扫描会触发很多 “JPA Java Change Event Handler (Waiting)” 的任务，这个是Eclipse的一个<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=387455" target="_blank" rel="noopener">bug</a>，因为插件在扫描的时候会对文件进行标记，所以触发了JPA的任务。卸载JPA插件，或者尝试升级到最新版的Eclipse。附：<a href="https://my.oschina.net/cimu/blog/278724" target="_blank" rel="noopener">JPA project Change Event Handler问题解决</a></p><h2 id="插件使用">插件使用</h2><p>目前插件实现了开发手册中的53条规则，大部分基于PMD实现，其中有4条规则基于Eclipse实现，支持4条规则的QuickFix功能。</p><pre><code>* 所有的覆写方法，必须加@Override注解， * if/for/while/switch/do等保留字与左右括号之间都必须加空格,* long或者Long初始赋值时，必须使用大写的L，不能是小写的l）* Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。</code></pre><p>目前不支持代码实时检测，需要手动触发，希望更多的人加入进来一起把咱们的插件做得越来越好，尽量提升研发的使用体验。</p><h3 id="代码扫描">代码扫描</h3><p>可以通过右键菜单、Toolbar按钮两种方式手动触发代码检测。同时结果面板中可以对部分实现了QuickFix功能的规则进行快速修复。</p><h4 id="触发扫描">触发扫描</h4><p>在当前编辑的文件中点击右键，可以在弹出的菜单中触发对该文件的检测。</p><p><img src="https://gw.alicdn.com/tfscom/TB1XGo8iPihSKJjy0FeXXbJtpXa.png" alt=""></p><p>在左侧的Project目录树种点击右键，可以触发对整个工程或者选择的某个目录、文件进行检测。</p><p><img src="https://gw.alicdn.com/tfscom/TB18UsJi2NZWeJjSZFpXXXjBFXa.png" alt=""></p><p>也可以通过Toolbar中的按钮来触发检测，目前Toolbar的按钮触发的检测范围与您IDE当时的焦点有关，如当前编辑的文件或者是Project目录树选中的项，是不是感觉与右键菜单的检测范围类似呢。</p><p><img src="https://gw.alicdn.com/tfscom/TB1vt1oifBNTKJjSszcXXbO2VXa.png" alt=""></p><h4 id="扫描结果">扫描结果</h4><p>简洁的结果面板，按规则等级分类，等级-&gt;规则-&gt;文件-&gt;违规项。同时还提供一个查看规则详情的界面。</p><p>清除结果标记更方便，支持上面提到的4条规则QuickFix。</p><p><img src="https://gw.alicdn.com/tfscom/TB1_uFJi6ihSKJjy0FlXXadEXXa.png" alt=""></p><h4 id="查看所有规则">查看所有规则</h4><p><img src="https://gw.alicdn.com/tfscom/TB1UNTnmYsTMeJjSszhXXcGCFXa.png" alt="">  <img src="https://gw.alicdn.com/tfscom/TB1_rf7sOAKL1JjSZFoXXagCFXa.png" alt=""></p><h4 id="国际化">国际化</h4><p><img src="https://gw.alicdn.com/tfscom/TB1KsyYsiFTMKJjSZFAXXckJpXa.png" alt=""></p><p><img src="https://gw.alicdn.com/tfscom/TB19bzdm3oQMeJjy1XaXXcSsFXa.png" alt=""></p><p><br><br>本文链接： <a href="http://www.meng.uno/articles/6e79ab7a/">http://www.meng.uno/articles/6e79ab7a/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      插件安装
环境：JDK1.8，Eclipse4+。有同学遇到过这样的情况，安装插件重启后，发现没有对应的菜单项，从日志上也看不到相关的异常信息，最后把JDK从1.6升级到1.8解决问题。

Help -&gt; Install New Software…



输入Update Site地址：https://p3c.alibaba.com/plugin/eclipse/update 回车，然后勾选Ali-CodeAnalysis，再一直点Next Next…按提示走下去就好。 然后就是提示重启了，安装完毕。



注意：有同学反映插件扫描会触发很多 “JPA Java Change Event Ha
    
    </summary>
    
      <category term="Java开发Tips" scheme="http://www.meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/"/>
    
      <category term="代码规范" scheme="http://www.meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="代码规范" scheme="http://www.meng.uno/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
      <category term="Alibaba Format" scheme="http://www.meng.uno/tags/Alibaba-Format/"/>
    
      <category term="Eclipse" scheme="http://www.meng.uno/tags/Eclipse/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse的Google样式Java代码自动规范配置</title>
    <link href="http://www.meng.uno/articles/548d5dfd/"/>
    <id>http://www.meng.uno/articles/548d5dfd/</id>
    <published>2018-03-01T12:59:33.000Z</published>
    <updated>2018-03-01T15:24:23.946Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>不知道大家在用Eclipse的时候有没有感觉到，当代码量一大就看不懂自己代码了呢？有人可能要说了，eclipse不是自己带有格式化代码工具吗？确实如此，但是我们可能想使用更高级的自动化工具，例如Google—Java-Style。这篇博文，我将展示如何使用eclipse自带的自动化代码规范工具，以及怎么配置Google-Java-Style。</p></blockquote><h1>准备</h1><p>文件下载：</p><ul>  <li>Eclipse: <a href="http://www.eclipse.org/" target="_blank" rel="noopener">进入官网</a></li>  <li>Google Java Format File: <a href="http://meng.uno/utils/eclipse-java-google-style.xml" target="_blank" rel="noopener">点击下载</a></li></ul><h1>使用Eclipse自带</h1><ul>  <li>快捷键： <code>Ctrl/Command + Shift + F</code></li>  <li>鼠标：    <ul>      <li>单个文件：进入文件/对着文件名<code>点右键</code> &gt; 找到<code>Source</code> &gt; 点击<code>Format</code> (其实就是快捷键的作用！)</li>      <li>项目：对着项目名/包名<code>点右键</code> &gt; 找到<code>Source</code> &gt; 点击<code>Format</code></li>    </ul>  </li></ul><p>如下截图：</p><p><img src="http://www.meng.uno/images/format/3.png" alt="右键"></p><h1>更换成Google Style</h1><p>当我们下载了本博客提供的<code>eclipse-java-google-style.xml</code>，就可以开始为formatter改风格了。</p><ul>  <li>打开eclipse的<code>Preferences</code>找到<code>Java</code>，再展开<code>Code Style</code>，找到<code>Formatter</code>。</li></ul><p><img src="http://www.meng.uno/images/format/1.jpg" alt="Code Style"></p><p>点击<code>Import</code>，在弹出窗口里选择我们下载的文件，确定即可。</p><p><img src="http://www.meng.uno/images/format/2.jpg" alt="Code Style"></p><p>再次进入项目，对着想要格式化的对象进行格式化操作，在进度条走完，我们就得到一份Google Java Style的代码了。</p><h1>后记</h1><ul>  <li>按照相似的步骤，我们也可以<code>Import</code>其他风格的代码规范；</li>  <li>Google不仅提供了eclipse上Java的代码规范，还有其他很多规范，详见<a href="https://github.com/google/styleguide" target="_blank" rel="noopener">Goole Style Guile</a></li>  <li>如果任何代码规范都不和心意，也可以打开某个代码规范，自己做相应的改动。</li></ul><p><img src="http://www.meng.uno/images/format/4.png" alt="Code Style"></p><p><br><br>本文链接： <a href="http://www.meng.uno/articles/548d5dfd/">http://www.meng.uno/articles/548d5dfd/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      不知道大家在用Eclipse的时候有没有感觉到，当代码量一大就看不懂自己代码了呢？有人可能要说了，eclipse不是自己带有格式化代码工具吗？确实如此，但是我们可能想使用更高级的自动化工具，例如Google—Java-Style。这篇博文，我将展示如何使用eclipse自带的自动化代码规范工具，以及怎么配置Google-Java-Style。

准备
文件下载：

 * Eclipse: 进入官网
 * Google Java Format File: 点击下载

使用Eclipse自带
 * 快捷键： Ctrl/Command + Shift + F
 * 鼠标：  * 单个文件：进入文件/
    
    </summary>
    
      <category term="Java开发Tips" scheme="http://www.meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/"/>
    
      <category term="代码规范" scheme="http://www.meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="代码规范" scheme="http://www.meng.uno/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
      <category term="Eclipse" scheme="http://www.meng.uno/tags/Eclipse/"/>
    
      <category term="Google Format" scheme="http://www.meng.uno/tags/Google-Format/"/>
    
  </entry>
  
  <entry>
    <title>What are Human Genome Project and ENCODE Project?</title>
    <link href="http://www.meng.uno/articles/32469d52/"/>
    <id>http://www.meng.uno/articles/32469d52/</id>
    <published>2018-02-18T11:54:31.000Z</published>
    <updated>2018-02-18T13:25:50.293Z</updated>
    
    <content type="html"><![CDATA[<h1>Human Genome Project</h1><h2 id="the-profile-of-the-project">The Profile of the Project</h2><p>人类基因组计划(Human Genome Project,简称HGP)是由美国科学家于1985年率先提出，又于1990年正式启动的。来自美国、英国、法国、德国、日本和中国科学家共同参与了这一预算达30亿美元的人类基因组计划。按照这个计划的设想，在2005年，要把人体内约10万个基因的密码全部解开，同时绘制出人类基因的谱图。换句话说，就是要揭开组成人体4万个基因的30亿个碱基对的秘密。</p><p>这一计划的最终目的是测定人类基因组30亿个基本化学组成（称为碱基对或核苷酸），进而揭开与人类的生老病死有关的数万个基因的相互关系。1984年，美国能源部开会，开始酝酿“人类基因组计划”。1989年，美国能源部和美国国家卫生研究所提出了人类基因图谱工程。美国在1990年10月1日率先启动人类基因组计划。美国人类基因组顾问委员会委员梅纳德•奥尔森是人类基因组计划最早的推动者之一，另外美国一个测序中心的主任罗伯特•沃特斯顿以及英国的人类基因组总负责人均表示支持。美国完成人类基因组计划近54%的工作量，为人类基因组计划最大的贡献国。英国是人类基因组计划的第二大贡献国，共34%的贡献都是由Wellcome基金会资助的Sanger中心完成的。日本、法国、德国对人类基因组计划的贡献分别为6.8%、2.8%与2.2%。中国承担了3号染色体区域短臂端粒侧约30  cM，约占人类整个基因组1% 的测序工作。中国的华大基因、国家自然科学基金会、中科院遗传所南方基因中心、北方人类基因组中心等单位及于军、杨焕明、汪建、刘斯奇、吴旻、强伯勤、陈竺等也给予人类基因组计划大力的推动。</p><h2 id="the-importance-of-the-project">The Importance of the Project</h2><h3 id="目的">目的</h3><p>人类是在“进化”历程上最高级的生物，对人类基因的研究有助于认识自身、掌握生老病死规律、疾病的诊断和治疗、了解生命的起源。 测出人类基因组DNA的30亿个碱基对的序列，发现所有人类基因，找出它们在染色体上的位置，破译人类全部遗传信息。</p><p>在人类基因组计划中，还包括对五种生物基因组的研究：大肠杆菌、酵母、线虫、果蝇和小鼠，称之为人类的五种“模式生物”。</p><p>HGP的目的是解码生命、了解生命的起源、了解生命体生长发育的规律、认识种属之间和个体之间存在差异的起因、认识疾病产生的机制以及长寿与衰老等生命现象、为疾病的诊治提供科学依据。</p><h3 id="意义">意义</h3><p>人类基因组计划是一项规模宏大，跨国跨学科的科学探索工程。其宗旨在于测定组成人类染色体(指单倍体)中所包含的30亿个碱基对组成的核苷酸序列，从而绘制人类基因组图谱，并且辨识其载有的基因及其序列，达到破译人类遗传信息的最终目的。基因组计划是人类为了探索自身的奥秘所迈出的重要一步。</p><p>“人类基因组计划”与”曼哈顿原子弹计划”和”阿波罗计划”并称为二十世纪三大科学计划。</p><h2 id="the-achievement-of-the-project">The Achievement of the Project</h2><p>2000年6月26日，美国总统克林顿与英国首相布莱尔共同宣布人类基因组计划工作草图完成；次年2月，工作草图的具体序列信息、测序所采用的方法以及序列的分析结果被国际人类基因组测序联盟和塞雷拉基因组的科学家分别公开发表于《自然》与《科学》杂志。这一工作草图覆盖了基因组序列的83％，包括常染色质区域的90％（带有150,000个空缺，且许多片断的顺序和方位并没有得到确定）。</p><p>2001年2月12日，美国Celera公司与人类基因组计划分别在《科学》和《自然》杂志上公布了人类基因组精细图谱及其初步分析结果。</p><p>2003年，发现了新的方法通过检测另外的库来关闭Gaps。使用FISH技术或其他方法来分析没有闭合的Gaps大小。22，21条染色体就是用这种方式。</p><p>1999年至2006年，完成了全部23条染色体的测序工作，具体如下：</p><p>1999年12月，22号染色体测序完成；</p><p>2000年5月，21号染色体测序完成；</p><p>2001年12月，20号染色体测序完成；</p><p>2003年2月，14号染色体测序完成；</p><p>2003年6月，男性特有的Y染色体测序完成；</p><p>2003年5月和7月，7号染色体测序完成；</p><p>2003年10月，6号染色体测序完成；</p><p>2004年4月，13号和19号染色体测序完成；</p><p>2004年5月，9号和10号染色体测序完成；</p><p>2004年9月，5号染色体测序完成；</p><p>2004年12月，16号染色体测序完成；</p><p>2005年3月，X染色体测序完成；</p><p>2005年4月，2号和4号染色体测序完成；</p><p>2005年9月，18号染色体测序完成；</p><p>2006年1月，8号染色体测序完成；</p><p>2006年3月，11号,12号和15号染色体测序完成；</p><p>2006年4月，17号和3号染色体测序完成；Human Genome Project Information</p><p>2006年5月，1号染色体测序完成；Human Genome Project Information</p><p>2004年，国际人类基因组测序联盟的研究者宣布，人类基因组中所含基因的预计数目从先前的30,000至40,000（在计划初期的预计数目则高达2,000,000）调整为20,000至25,000。预期还需要多年的时间来确定人类基因组中所含基因的精确数目。</p><p>截止到2005年，人类基因组计划的测序工作已经完成。</p><h2 id="the-research-contents-of-the-project">The Research Contents of the Project</h2><h3 id="遗传图谱">遗传图谱</h3><p>遗传图谱又称连锁图谱（linkage map），它是以具有遗传多态性（在一个遗传位点上具有一个以上的等位基因，在群体中的出现频率皆高于1%）的遗传标记为“路标”，以遗传学距离（在减数分裂事件中两个位点之间进行交换、重组的百分率，1%的重组率称为1cM）为图距的基因组图。遗传图谱的建立为基因识别和完成基因定位创造了条件。意义：6000多个遗传标记已经能够把人的基因组分成6000多个区域，使得连锁分析法可以找到某一致病的或表现型的基因与某一标记邻近（紧密连锁）的证据，这样可把这一基因定位于这一已知区域，再对基因进行分离和研究。对于疾病而言，找基因和分析基因是个关键。</p><h3 id="物理图谱">物理图谱</h3><p>物理图谱是指有关构成基因组的全部基因的排列和间距的信息，它是通过对构成基因组的DNA分子进行测定而绘制的。绘制物理图谱的目的是把有关基因的遗传信息及其在每条染色体上的相对位置线性而系统地排列出来。DNA物理图谱是指DNA链的限制性酶切片段的排列顺序，即酶切片段在DNA链上的定位。因限制性内切酶在DNA链上的切口是以特异序列为基础的，核苷酸序列不同的DNA，经酶切后就会产生不同长度的DNA片段，由此而构成独特的酶切图谱。因此，DNA物理图谱是DNA分子结构的特征之一。DNA是很大的分子，由限制酶产生的用于测序反应的DNA片段只是其中的极小部分，这些片段在DNA链中所处的位置关系是应该首先解决的问题，故DNA物理图谱是顺序测定的基础，也可理解为指导DNA测序的蓝图。广义地说，DNA测序从物理图谱制作开始，它是测序工作的第一步。制作DNA物理图谱的方法有多种，这里选择一种常用的简便方法──标记片段的部分酶解法，来说明图谱制作原理。</p><h3 id="序列图谱">序列图谱</h3><p>随着遗传图谱和物理图谱的完成，测序就成为重中之重的工作。DNA序列分析技术是一个包括制备DNA片段化及碱基分析、DNA信息翻译的多阶段的过程。通过测序得到基因组的序列图谱。</p><h3 id="基因图谱">基因图谱</h3><h4 id="简介">简介</h4><p>基因图谱是在识别基因组所包含的蛋白质编码序列的基础上绘制的结合有关基因序列、位置及表达模式等信息的图谱。在人类基因组中鉴别出占具2%~5%长度的全部基因的位置、结构与功能，最主要的方法是通过基因的表达产物mRNA反追到染色体的位置。</p><h4 id="意义-v2">意义</h4><p>它能有效地反应在正常或受控条件中表达的全基因的时空图。通过这张图可以了解某一基因在不同时间不同组织、不同水平的表达；也可以了解一种组织中不同时间、不同基因中不同水平的表达，还可以了解某一特定时间、不同组织中的不同基因不同水平的表达。人类基因组是一个国际合作项目：表征人类基因组，选择的模式生物的DNA测序和作图，发展基因组研究的新技术，完善人类基因组研究涉及的伦理、法律和社会问题，培训能利用HGP发展起来的这些技术和资源进行生物学研究的科学家，促进人类健康。</p><h2 id="the-contributions-of-the-project">The Contributions of the Project</h2><h3 id="对人类疾病的贡献">对人类疾病的贡献</h3><p>人类疾病相关的基因是人类基因组中结构和功能完整性至关重要的信息。对于单基因病，采用“定位克隆”和“定位候选克隆”的全新思路，导致了亨廷顿氏舞蹈症、遗传性结肠癌和乳腺癌等一大批单基因遗传病致病基因的发现，为这些疾病的基因诊断和基因治疗奠定了基础。对于心血管疾病、肿瘤、糖尿病、神经精神类疾病（老年性痴呆、精神分裂症）、自身免疫性疾病等多基因疾病是疾病基因研究的重点。健康相关研究是HGP的重要组成部分，1997年相继提出：“肿瘤基因组解剖计划”“环境基因组学计划”。</p><h3 id="对医学的贡献">对医学的贡献</h3><p>基因诊断、基因治疗和基于基因组知识的治疗、基于基因组信息的疾病预防、疾病易感基因的识别、风险人群生活方式、环境因子的干预。</p><h3 id="对生物技术的贡献">对生物技术的贡献</h3><h4 id="基因工程药物">基因工程药物</h4><p>分泌蛋白（多肽激素，生长因子，趋化因子，凝血和抗凝血因子等）及其受体。</p><h4 id="诊断和研究试剂">诊断和研究试剂</h4><p>基因和抗体试剂盒、诊断和研究用生物芯片、疾病和筛药模型。</p><h4 id="细胞工程">细胞工程</h4><p>胚胎和成年期干细胞、克隆技术、器官再造技术。</p><h2 id="the-project-with-china">The Project with China</h2><p>作为继美、英、法、德、日6个成员国之后中唯一的发展中国家，中国对人类基因组的的贡献不只是工作量，在这个划时代的里程碑上，已经刻上了中国人的名字，中国在生物组学的发展上占有一席之地，通过参与这一计划，我们可以分享数据、资源、技术与发言权，最终来开发我国自己的基因资源。中国的加入改变了国际人类基因组计划原有的组织格局，提高其国际合作的形象，带来了国际社会对“国际人类基因组计划精神”的支持，联合国教科文组织关于人类基因组基本信息免费共享的声明，就是在中国代表的直接努力下促成的。可以说，中国需要人类基因组计划，而基因组计划也使我国的基因测序能力进人世界前列，在中国本土成长起来的作为我国基因组学的典型代表、创新型机构——华大基因已经成为全球最大的基因组学中心。</p><p>因此，人类基因组计划对华大基因的影响力也是举足轻重的，华大基因也因此而“生”的伟大。华大基因随着“国际人类基因组计划1%项目”的正式启动而诞生。华大基因自成立之日起就站在世界同步的轨迹上，使得中国的基因组学研究位于跟踪——参与——同步的国际地位。为后期的华大基因在基因组上的引领及跨越式发展奠定了基础。</p><p>在人类基因组计划之后，人类基因研究开始朝着与人类生育健康、肿瘤个体化治疗、病原微生物、遗传性疾病、血液病等的相关疾病的基因检测方向发展，未来，医疗技术将从末端的疾病治疗，逐步走向前端的基因诊断和预防，个性化医疗及精准医疗。人类将通过基因检测技术、通过个性化医疗以更精确的诊断，预测潜在疾病的风险，提供更有效、更有针对性的治疗，预防某种疾病的发生，比“治有病”更节约治疗成本。</p><p>华大基因希望凭借全球领先的基因组学技术，华大基因将千万家庭远离遗传性出生缺陷，肿瘤能早期检测和诊断并能全景式、定期监控个人健康动态，人人做到“我的基因我知道，我的健康我做主”。其研究方向主要涉及遗传性出生缺陷、肿瘤、心脑血管疾病、精准医疗 # The ENCODE Project</p><h2 id="the-profile-of-the-project-v2">The Profile of the Project</h2><p>The ENCODE Project（即Encyclopedia Of DNA Elements，中文译作DNA元件百科全书计划），是美国国立人类基因组研究院（US National Human Genome Research Institute，NHGRI）在2003年9月启动的跨国研究项目。该项目旨在解析人类基因组中的所有功能性元件，它是人类基因组计划完成之后，又一重要的跨国基因组学研究项目。该项目联合了来自美国，英国，西班牙，新加坡和日本的32个实验室的422名科学家的努力，获得了迄今最详细的人类基因组分析数据（他们获得并分析了超过15兆兆字节的原始数据）。研究花费了约300年的计算机时间，对147个组织类型进行了分析，以确定哪些能打开和关闭特定的基因，以及不同类型细胞之间的“开关”存在什么差异。</p><h2 id="the-achievement-of-the-project-v2">The Achievement of the Project</h2><p>近年来基因研究已经取得巨大进展。不过，迄今为止，这些研究主要还集中在编码蛋白的特定基因上，而它们所佔的比例不到整个人类基因组的2%。ENCODE计划首次系统地研究了所有类型的功能元件的位点和组织方式。</p><p>迄今为止，ENCODE计划主要集中研究了44个靶标共3000万个DNA硷基对。负责该计划数据整合和分析工作的欧洲分子生物学实验室主任Ewan Birney说：“我们的结论揭示了有关DNA功能元件构成的重要原理，为从DNA转录到哺乳动物进化的一切过程提供了新的认识。”</p><p>研究发现，人类基因组中的大多数DNA都会转录成RNA，这些副本会普遍交叠。因此，人类基因组实际上是一个非常复杂的网络，所谓的无用基因实际上非常少。基因只不过是众多具有特定功能的DNA序列类型之一。科学家们在基因之外的调控区域新发现了4491个转录启动位点，这一数字超过了已知基因的10倍。这些都挑战了长期以来的一个观点，即基因组中的基因是孤立的，同时，新的发现也支持了人类基因数量应该超过3万个的看法。</p><p>ENCODE计划的另一个巨大成就就是对哺乳动物基因组进化的认识。传统理论认为，与生理功能相关的重要DNA序列往往位于基因组中的“进化限制”区域，它们在物种进化过程中更容易保存下来。但是，最新的研究表明，大约一半人类基因组中的功能元件在进化过程中不会受到很大限制。科学家认为，哺乳动物缺乏“进化限制”这一点，很可能意味著许多物种的基因组都囊括了大量包括RNA转录副本在内的功能元件，在进化过程中，这些功能元件成了基因“仓库”。</p><p>此次ENCODE计划的成果亮点还包括：确定了许多之前不为人知的DNA转录启动位点；推翻了传统观点的认识，调控区域也有可能位于DNA转录启动位点的下游；确定了组蛋白变化的特定标记；加深了人们对组蛋白改变协调DNA复制的理解。</p><p>2012年9月5日，ENCODE项目的阶段性研究结果被整理成30篇论文发表于《自然》（6篇），《基因组研究》（6篇）和《基因组生物学》（18篇）上。</p><p>研究结果显示，人类基因组内的非编码DNA至少80%是有生物活性的，而并非之前认为的“垃圾” DNA （junk DNA）。这些新的发现有望帮助研究人员理解基因受到控制的途径，以及澄清某些疾病的遗传学风险因子。 ENCODE是人类基因组计划之后国际科学界在基因组学研究领域取得的又一重大进展。</p><p>2012年12月21日，ENCODE项目被《科学》杂志评为本年度十大科学突破之一。</p><h2 id="the-research-contents-of-the-project-v2">The Research Contents of the Project</h2><h3 id="试点研究的内容">试点研究的内容</h3><p>对编码的功能DNA进行鉴定和分类；对已存在的几种方法进行测试和比较，严格分析了人类基因组序列中已被定义的序列。</p><p>阐明人类生物学和疾病之间的关系。</p><p>对大量鉴定基因特征的方法、技术和手段进行检测和评估。</p><h3 id="研究对象">研究对象</h3><p>编码蛋白基因</p><p>非编码蛋白基因</p><p>调控区域</p><p>染色体结构维持和调节染色体复制能力的DNA元件</p><h3 id="研究特点">研究特点</h3><p>采用综合性研究策略</p><p>重视新技术的研发</p><p>将计划向学术界和公司开放</p><h2 id="the-contributions-of-the-project-v2">The Contributions of the Project</h2><h3 id="人细胞转录全景图">人细胞转录全景图</h3><p>通过ENCODE项目，人们知道RNA是基因组编码的遗传信息的直接输出。细胞的大部分调节功能都集中在RNA的合成、加工和运输、修饰和翻译之中。研究人员证实，75%的人基因组能够发生转录，并且观察到几乎所有当前已标注的RNA和上千个之前未标注的RNA的表达范围与水平、定位、加工命运、调节区和修饰。总之，这些观察结果表明人们需要重新定义基因的概念。</p><h3 id="人基因组中可访问的染色质全景图">人基因组中可访问的染色质全景图</h3><p>DNase I超敏感位点(DNase I hypersensitive sites, DHSs)是调节性DNA序列的标记物。研究人员通过对125个不同的细胞和组织类型进行全基因组谱分析而鉴定出大约290万个人DHSs，并且首次大范围地绘制出人DHSs图谱。</p><h3 id="基因启动子的远距离相互作用全景图">基因启动子的远距离相互作用全景图</h3><p>在ENCODE项目中，研究人员选择1%的基因组作为项目试点区域，并且利用染色体构象捕获碳拷贝(chromosome conformation capture carbon copy, 简称为5C)技术来综合性地分析了这个区域中转录起始位点和远端序列元件之间的相互作用。他们获得GM12878、K562和HeLa-S3细胞的5C图谱。在每个细胞系，他们发现启动子和远端序列元件之间存在1000多个远距离相互作用。</p><h3 id="gencode：encode项目的人基因组参照标注">GENCODE：ENCODE项目的人基因组参照标注</h3><p>GENCODE项目旨在利用计算分析、人工标注和实验验证来鉴定出人基因组中所有的基因特征。GENCODE第七版(GENCODE v7)公开发布了基因组标注数据集，包含了20687个蛋白编码的RNA基因座位、9640个长链非编码RNA基因座位，并且拥有33977个在UCSC基因数据库和RefSeq数据库中不存在的编码性转录本。它还对公开获得的长链非编码RNA(long noncoding RNA, lncRNA)进行最全面的标注。</p><h1>我的认识</h1><p>在上这门课之前，我从没认真想过这个问题，到底研究基因有什么用？通过这几天的学习，以及对文章所提的两个项目的检索、认识，我对基因测序这一工作，有了更深层次的认识。</p><p>虽然外界关于基因测序有不同的看法，例如有人支持，因为它可以为医学做贡献；有人反对，因为这样做相当于为基因做了一次曝光，这样一来，就有优劣基因之分。在我看来，这一任务还是利大于弊的，毕竟现在看来是这样。科学家可以通过对已有的基因测序结果的分析，总结出基因的“中心法则”，使我们对自身有了更进一步的了解。再者，基因分析有很多好的应用，通过对胎儿基因分析可以达到优生的目的，以及对有基因缺陷、先天性遗传病患者可以提供治标治本的治疗方案。</p><p>当然，要了解所有基因的功能还有很长的一段路要走。例如以前人们所认为的垃圾DNA实际上并不“垃圾”，它们在基因组的进化、每个个体的差异性以及许多其他方面扮演着重要角色，是世界上许多实验室着力研究的目标。</p><p>即使已经过了将近30年，人类基因组也没有完成“完全”测序，不过我们了解到了基因并不是静态的，而是处在复杂的变化之中，所以对人类基因的研究也是对人类自身的研究，这一研究将会一直进行下去，永无终点。 虽然人类基因组目前也只是一张初步的蓝图，需要经过更多的研究和分析。但是人类已经通过对基因组的学习，进入了医学的新纪元，为预防、诊断和治疗疾病带来了新的方法。所以对基因组的研究势必将成为人类新的曙光。</p><p>总之，我对基因组计划以及ENCODE计划充满期待与支持。</p><h1>参考资料</h1><ol>  <li>HGP计划百度百科：<a href="http://dwz.cn/3ITVf3" target="_blank" rel="noopener">http://dwz.cn/3ITVf3</a></li>  <li>人类基因组计划- 维基百科http://dwz.cn/3JHOap</li>  <li>科学松鼠会之人类基因组计划 <a href="http://dwz.cn/3JHOXZ" target="_blank" rel="noopener">http://dwz.cn/3JHOXZ</a></li>  <li>ENCODE项目百度百科：<a href="http://dwz.cn/3ITSPr" target="_blank" rel="noopener">http://dwz.cn/3ITSPr</a></li>  <li>Genome网 <a href="https://www.genome.gov/10005107/encode-project" target="_blank" rel="noopener">https://www.genome.gov/10005107/encode-project</a></li>  <li>ENCODE项目官网：<a href="https://www.encodeproject.org" target="_blank" rel="noopener">https://www.encodeproject.org</a></li>  <li>“DNA元件百科全书”首批成果出炉，链接：<a href="http://big5.cas.cn/xw/kjsm/gjdt/200706/t20070619_1011212.shtml" target="_blank" rel="noopener">http://big5.cas.cn/xw/kjsm/gjdt/200706/t20070619_1011212.shtml</a></li></ol><p><br><br>本文链接： <a href="http://www.meng.uno/articles/32469d52/">http://www.meng.uno/articles/32469d52/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      Human Genome Project
The Profile of the Project
人类基因组计划(Human Genome Project,简称HGP)是由美国科学家于1985年率先提出，又于1990年正式启动的。来自美国、英国、法国、德国、日本和中国科学家共同参与了这一预算达30亿美元的人类基因组计划。按照这个计划的设想，在2005年，要把人体内约10万个基因的密码全部解开，同时绘制出人类基因的谱图。换句话说，就是要揭开组成人体4万个基因的30亿个碱基对的秘密。

这一计划的最终目的是测定人类基因组30亿个基本化学组成（称为碱基对或核苷酸），进而揭开与人类的生老病死有关的数万个
    
    </summary>
    
      <category term="生物信息" scheme="http://www.meng.uno/categories/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="生物信息" scheme="http://www.meng.uno/tags/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF/"/>
    
      <category term="Genome" scheme="http://www.meng.uno/tags/Genome/"/>
    
      <category term="ENCODE" scheme="http://www.meng.uno/tags/ENCODE/"/>
    
  </entry>
  
  <entry>
    <title>关于比特币（Bitcoin）</title>
    <link href="http://www.meng.uno/articles/7bfe1542/"/>
    <id>http://www.meng.uno/articles/7bfe1542/</id>
    <published>2018-02-14T11:47:44.000Z</published>
    <updated>2018-02-14T12:14:20.810Z</updated>
    
    <content type="html"><![CDATA[<h1>比特币术语</h1><h2 id="比特币">比特币</h2><p>首字母大写的Bitcoin用来表示比特币的概念或整个比特币网络本身。例如：“今天我学了些有关Bitcoin协议的内容。”</p><p>而没有大写的bitcoin则表示一个记账单位。例如：“我今天转出了10个bitcoin。”该单位通常也简写为BTC或XBT。</p><h2 id="比特币地址">比特币地址</h2><p>比特币地址就像一个物理地址或者电子邮件地址。这是别人付给你比特币时你唯一需要提供的信息。然而一个重要的区别是，每个地址应该只用于单笔交易。</p><h2 id="对等式网络">对等式网络</h2><p>对等式网络是指，通过允许单个节点与其他节点直接交互，从而实现整个系统像有组织的集体一样运作的系统 。对于比特币来说，比特币网络以这样一种方式构建——每个用户都在传播其他用户的交易。而且重要的是，不需要银行作为第三方。</p><h2 id="哈希率">哈希率</h2><p>哈希率是衡量比特币网络处理能力的测量单位。为保证安全，比特币网络必须进行大量的数学运算。当网络达到10Th/秒的哈希率时，就意味着它能够进行每秒10万亿次的计算。</p><h2 id="交易确认">交易确认</h2><p>交易确认意味着一笔交易已经被网络处理且不太可能被撤销。当交易被包含进一个块时会收到一个确认，后续的每一个块都对应一个确认。对于小金额交易单个确认便可视为安全，然而对于比如1000美元的大金额交易，等待6个以上的确认比较合理。每一个确认都成指数级地降低交易撤销的风险。</p><h2 id="块链">块链</h2><p>块链是一个按时间顺序排列的比特币交易公共记录。块链由所有比特币用户共享。它被用来验证比特币交易的永久性并防止双重消费。</p><h2 id="密码学">密码学</h2><p>密码学是数学的一个分支，它让我们创造出可以提供很高安全性的数学证明。电子商务和网上银行也用到了密码学。对于比特币来说，密码学用来保证任何人都不可能使用他人钱包里的资金，或者破坏块链。密码学也用来给钱包加密，这样没有密码就用不了钱包。</p><h2 id="签名">签名</h2><p>密码学签名是一个让人可以证明所有权的数学机制。对于比特币来说，一个比特币钱包和它的私钥通过一些数学魔法关联到一起。当你的比特币软件用对应的私钥为一笔交易签名，整个网络都能知道这个签名和已花费的比特币相匹配。但是，世界上没有人可以猜到你的私钥来窃取你辛苦赚来的比特币。</p><h2 id="钱包">钱包</h2><p>比特币钱包大致实体钱包在比特币网络中的等同物。钱包中实际上包含了你的私钥，可以让你消费块链中分配给钱包的比特币。和真正的钱包一样，每个比特币钱包都可以显示它所控制的所有比特币的总余额，并允许你将一定金额的比特币付给某人。这与商家进行扣款的信用卡不同。</p><h2 id="区块">区块</h2><p>一个块是块链中的一条记录，包含并确认待处理的交易。平均约每10分钟就有一个包含交易的新块通过挖矿的方式添加到块链中。</p><h2 id="双重消费">双重消费</h2><p>如果一个不怀好意的用户试图将比特币同时支付给两个不同的收款人，就被称为双重消费。比特币挖矿和块链将就两比交易中那笔获得确认并被视为有效在网络上达成一致。</p><h2 id="私钥">私钥</h2><p>私钥是一个证明你有权从一个特定的钱包消费比特币的保密数据块，是通过一个密码学签名来实现的 。如果你使用的是钱包软件，你的私钥就存储在你的计算机内；如果使用的是在线钱包，你的私钥就存储在远程服务器上。千万不能泄露私钥，因为它们可以让你消费对应比特币钱包里的比特币。</p><h2 id="挖矿">挖矿</h2><p>比特币挖矿是利用计算机硬件为比特币网络做数学计算进行交易确认和提高安全性的过程。作为对他们服务的奖励，矿工可以得到他们所确认的交易中包含的手续费，以及新创建的比特币。挖矿是一个专业的、竞争激烈的市场，奖金按照完成的计算量分割。并非所有的比特币用户都挖矿，挖矿赚钱也并不容易。</p><h2 id="bit">Bit</h2><p>Bit是标明一个比特币的次级单位的常用单位 -1,000,000 bit 等于1 比特币 (BTC 或 B⃦).，这个单位对于标示小费、商品和服务价格更方便。</p><h2 id="btc">BTC</h2><p>BTC 是用于标示一个比特币 (B⃦). 的常用单位。</p><h1>比特币账户</h1><p>我们可以在<code>bitcoin.org</code>上选择自己的钱包。我在这里向大家展示使用一个浏览器插件<code>GreenAddress</code>，下载链接是：<code>https://chrome.google.com/webstore/detail/greenaddress/dgbimgjoijjemhdamicmljbncacfndmp/related</code></p><h2 id="注册">注册</h2><p>打开安装好的<code>GreenAddress</code>，没有账户点击右上角，开始注册。</p><p><img src="http://www.meng.uno/images/bitcoins/1.jpg" alt="BITCOIN"></p><p><strong>打码的位置请保存下来，应该需要用它来登录</strong></p><p>接着是验证你保存没保存（想的还很周到）。</p><p>再就是添加两步验证，这个比较常见了，我只选了“邮件”验证，推荐是选两个，要不然总是有warning。</p><p><img src="http://www.meng.uno/images/bitcoins/2.jpg" alt="BITCOIN"></p><h2 id="使用">使用</h2><p>接着就进入主界面了，有很多配置需要大家自己去查看，主界面显示了你的“Bitcoin URI”，分享这个，别人就可以向你转钱了，应该。</p><p><img src="http://www.meng.uno/images/bitcoins/3.jpg" alt="BITCOIN"></p><p><strong>最后强调一下，我的比特币地址是：3CEzyZnpij4WnrAsHhhcaoD1Kf5JqSAEGj</strong></p><p><br><br>本文链接： <a href="http://www.meng.uno/articles/7bfe1542/">http://www.meng.uno/articles/7bfe1542/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      比特币术语
比特币
首字母大写的Bitcoin用来表示比特币的概念或整个比特币网络本身。例如：“今天我学了些有关Bitcoin协议的内容。”

而没有大写的bitcoin则表示一个记账单位。例如：“我今天转出了10个bitcoin。”该单位通常也简写为BTC或XBT。

比特币地址
比特币地址就像一个物理地址或者电子邮件地址。这是别人付给你比特币时你唯一需要提供的信息。然而一个重要的区别是，每个地址应该只用于单笔交易。

对等式网络
对等式网络是指，通过允许单个节点与其他节点直接交互，从而实现整个系统像有组织的集体一样运作的系统 。对于比特币来说，比特币网络以这样一种方式构建——每个用户都在传
    
    </summary>
    
    
      <category term="比特币" scheme="http://www.meng.uno/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="Bitcoin" scheme="http://www.meng.uno/tags/Bitcoin/"/>
    
  </entry>
  
  <entry>
    <title>简单的Python3爬虫</title>
    <link href="http://www.meng.uno/articles/51d32f19/"/>
    <id>http://www.meng.uno/articles/51d32f19/</id>
    <published>2018-02-12T12:18:15.000Z</published>
    <updated>2018-02-13T14:08:54.149Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>我们先从分析原理入手，然后再使用Python提供的基本的库urllib。</p>  <p>注意，我全程使用的是Python3，如果你必须使用不同版本，请自行百度某些库及函数的转换，需要使用的库不一定你的电脑上预装了，所以请自行百度安装。</p></blockquote><h1>原理</h1><p>网络爬虫，也叫网络蜘蛛(Web Spider)，如果把互联网比喻成一个蜘蛛网，Spider就是一只在网上爬来爬去的蜘蛛。网络爬虫就是根据网页的地址来寻找网页的，也就是URL。</p><h2 id="url">URL</h2><p>URL就是统一资源定位符(Uniform Resource Locator)，它的一般格式如下(带方括号[]的为可选项)：</p><p><code>protocol ://hostname[:port]/path/[;parameters][?query]#fragment</code></p><p>可见，一个URL包含三个部分：</p><ol>  <li>protocol：协议，例如https，http等；</li>  <li>hostname[:port]：主机名(端口号为可选参数)，一般网站默认的端口号为80，例如我的博客域名www.meng.uno，可以作为主机名使用;</li>  <li>path：第三部分就是主机资源的具体地址，如目录和文件名等。</li></ol><p>爬虫就是向URL发送请求，然后得到响应，基本就实现了爬取网页的功能。</p><p><strong>URI可以分为URL,URN或同时具备locators 和names特性的一个东西。URN作用就好像一个人的名字，URL就像一个人的地址。换句话说：URN确定了东西的身份，URL提供了找到它的方式。</strong></p><h2 id="从浏览器发送和接收数据看起">从浏览器发送和接收数据看起</h2><p>进入我的首页<code>www.meng.uno</code>，打开浏览器的“检查”功能，选项卡选到“Network”，然后点击所有文章，随便选择一条，我们可以发现如下截图的&quot;Headers&quot;</p><p><img src="http://meng.uno/images/crawl/1.png" alt="Headers"></p><p>我们可以发现最明显的有两个区域（我已经圈出来了）：“request”和“response”。从字面意思上来看，我们就知道分别是（发送的）请求和（收到的）回复。</p><p>接收的信息是我们请求的网页给的，不用我们管，但是“请求的网页”是我们需要提前设定的，当然最简单的方式就是什么都不设置。爬虫会增加网站的负荷，所以很多网站希望大家通过API的方式使用其开放的资源而禁止爬虫，其中的一个做法就是判断你的请求内容（不全的基本都是爬虫）。于是，为了做到一个完整的可用的爬虫，我们需要模拟真实用户的请求，这就要求我们伪造“User Agent”。</p><p>常见的“User Agent”列举如下：</p><ol>  <li>    <p>Android</p>    <ul>      <li>Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166 Safari/535.19</li>      <li>Mozilla/5.0 (Linux; U; Android 4.0.4; en-gb; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30</li>      <li>Mozilla/5.0 (Linux; U; Android 2.2; en-gb; GT-P1000 Build/FROYO) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1</li>    </ul>  </li>  <li>    <p>Firefox</p>    <ul>      <li>Mozilla/5.0 (Windows NT 6.2; WOW64; rv:21.0) Gecko/20100101 Firefox/21.0</li>      <li>Mozilla/5.0 (Android; Mobile; rv:14.0) Gecko/14.0 Firefox/14.0</li>    </ul>  </li>  <li>    <p>Google Chrome</p>    <ul>      <li>Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36</li>      <li>Mozilla/5.0 (Linux; Android 4.0.4; Galaxy Nexus Build/IMM76B) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.133 Mobile Safari/535.19</li>    </ul>  </li>  <li>    <p>iOS</p>    <ul>      <li>Mozilla/5.0 (iPad; CPU OS 5_0 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9A334 Safari/7534.48.3</li>      <li>Mozilla/5.0 (iPod; U; CPU like Mac OS X; en) AppleWebKit/420.1 (KHTML, like Gecko) Version/3.0 Mobile/3A101a Safari/419.3</li>    </ul>  </li></ol><p>User Agent已经设置好了，但是还应该考虑一个问题，程序的运行速度是很快的，如果我们利用一个爬虫程序在网站爬取东西，一个固定IP的访问频率就会很高，这不符合人为操作的标准，因为人操作不可能在几ms内，进行如此频繁的访问。所以一些网站会设置一个IP访问频率的阈值，如果一个IP访问频率超过这个阈值，说明这个不是人在访问，而是一个爬虫程序。</p><p>一个很简单的解决办法就是设置延时，但是这显然不符合爬虫快速爬取信息的目的，所以另一种更好的方法就是使用IP代理。使用代理的步骤：</p><ul>  <li>调用urlib.request.ProxyHandler()，proxies参数为一个字典；</li>  <li>创建Opener(类似于urlopen，这个代开方式是我们自己定制的)；</li>  <li>安装Opener；</li></ul><p><strong>这个网站提供了很多代理主机：<a href="http://www.xicidaili.com/" target="_blank" rel="noopener">http://www.xicidaili.com/</a></strong></p><h2 id="正则表达式">正则表达式</h2><p>我直接以表格的形式呈现好了：</p><table>  <thead>    <tr>      <th style="text-align:center">元字符</th>      <th style="text-align:right">说明</th>    </tr>  </thead>  <tbody>    <tr>      <td style="text-align:center">.</td>      <td style="text-align:right">代表任意字符</td>    </tr>    <tr>      <td style="text-align:center"></td>      <td style="text-align:right"></td>    </tr>    <tr>      <td style="text-align:center">[ ]</td>      <td style="text-align:right">匹配内部的任一字符或子表达式</td>    </tr>    <tr>      <td style="text-align:center">[^]</td>      <td style="text-align:right">对字符集和取非</td>    </tr>    <tr>      <td style="text-align:center">-</td>      <td style="text-align:right">定义一个区间</td>    </tr>    <tr>      <td style="text-align:center">\</td>      <td style="text-align:right">对下一字符取非（通常是普通变特殊，特殊变普通）</td>    </tr>    <tr>      <td style="text-align:center">*</td>      <td style="text-align:right">匹配前面的字符或者子表达式0次或多次</td>    </tr>    <tr>      <td style="text-align:center">*?</td>      <td style="text-align:right">惰性匹配上一个</td>    </tr>    <tr>      <td style="text-align:center">+</td>      <td style="text-align:right">匹配前一个字符或子表达式一次或多次</td>    </tr>    <tr>      <td style="text-align:center">+?</td>      <td style="text-align:right">惰性匹配上一个</td>    </tr>    <tr>      <td style="text-align:center">?</td>      <td style="text-align:right">匹配前一个字符或子表达式0次或1次重复</td>    </tr>    <tr>      <td style="text-align:center">{n}</td>      <td style="text-align:right">匹配前一个字符或子表达式</td>    </tr>    <tr>      <td style="text-align:center">{m,n}</td>      <td style="text-align:right">匹配前一个字符或子表达式至少m次至多n次</td>    </tr>    <tr>      <td style="text-align:center">{n,}</td>      <td style="text-align:right">匹配前一个字符或者子表达式至少n次</td>    </tr>    <tr>      <td style="text-align:center">{n,}?</td>      <td style="text-align:right">前一个的惰性匹配</td>    </tr>    <tr>      <td style="text-align:center">^</td>      <td style="text-align:right">匹配字符串的开头</td>    </tr>    <tr>      <td style="text-align:center">\A</td>      <td style="text-align:right">匹配字符串开头</td>    </tr>    <tr>      <td style="text-align:center">$</td>      <td style="text-align:right">匹配字符串结束</td>    </tr>    <tr>      <td style="text-align:center">[\b]</td>      <td style="text-align:right">退格字符</td>    </tr>    <tr>      <td style="text-align:center">\c</td>      <td style="text-align:right">匹配一个控制字符</td>    </tr>    <tr>      <td style="text-align:center">\d</td>      <td style="text-align:right">匹配任意数字</td>    </tr>    <tr>      <td style="text-align:center">\D</td>      <td style="text-align:right">匹配数字以外的字符</td>    </tr>    <tr>      <td style="text-align:center">\t</td>      <td style="text-align:right">匹配制表符</td>    </tr>    <tr>      <td style="text-align:center">\w</td>      <td style="text-align:right">匹配任意数字字母下划线</td>    </tr>    <tr>      <td style="text-align:center">\W</td>      <td style="text-align:right">不匹配数字字母下划线</td>    </tr>  </tbody></table><h1>代码</h1><h2 id="简单带错误信息的获取网页内所有url的爬虫">简单带错误信息的获取网页内所有URL的爬虫</h2><figure class="highlight python">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="comment">#获取URL的包</span></span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="comment">#获取字符集编码方式</span></span><br><span class="line"><span class="keyword">import</span> chardet</span><br><span class="line"><span class="comment">#正则表达式</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#Request 对象</span></span><br><span class="line">req = urllib.request.Request(<span class="string">"http://meng.uno/"</span>)</span><br><span class="line">data = <span class="keyword">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#得到Response</span></span><br><span class="line">    response = urllib.request.urlopen(req,data)</span><br><span class="line">    <span class="comment">#读出response == 请求文件的全部字符</span></span><br><span class="line">    html = response.read()</span><br><span class="line">    <span class="comment">#获取这个response的编码方式</span></span><br><span class="line">    charset = chardet.detect(html)</span><br><span class="line">    print(<span class="string">"编码方式："</span>,charset)</span><br><span class="line">    <span class="comment">#以这种编码方式解码打印</span></span><br><span class="line">    html = html.decode(charset.get(<span class="string">"encoding"</span>))</span><br><span class="line">    print(html)</span><br><span class="line">    urls = re.findall(<span class="string">'href=\"https*://w*\.*meng\.uno/.*?\"'</span>, html,re.S)</span><br><span class="line">    uris = re.findall(<span class="string">'href=\"/[^/].*?[^\.]\"'</span>,html, re.S)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> urls:</span><br><span class="line">        print(item[<span class="number">6</span>:<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> uris:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">".html"</span> <span class="keyword">in</span> item:</span><br><span class="line">            print(<span class="string">"http://www.meng.uno"</span>+item[<span class="number">6</span>:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">'.'</span> <span class="keyword">in</span> item:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"http://www.meng.uno"</span>+item[<span class="number">6</span>:<span class="number">-1</span>])</span><br><span class="line"><span class="keyword">except</span> urllib.error.HTTPError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">if</span> hasattr(e, <span class="string">'code'</span>):</span><br><span class="line">        print(<span class="string">"HTTPError"</span>)</span><br><span class="line">        print(e.code)</span><br><span class="line">    <span class="keyword">elif</span> hasattr(e, <span class="string">'reason'</span>):</span><br><span class="line">        print(<span class="string">"URLError"</span>)</span><br><span class="line">        print(e.reason)</span><br></pre>      </td>    </tr>  </table></figure><h2 id="模拟真实环境的爬虫">模拟真实环境的爬虫</h2><figure class="highlight python">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"> <span class="comment">#访问网址</span></span><br><span class="line">url = <span class="string">'http://www.whatismyip.com.tw/'</span></span><br><span class="line"><span class="comment">#这是代理IP</span></span><br><span class="line">proxy = &#123;<span class="string">'https'</span>:<span class="string">'110.73.48.189:8123'</span>&#125;</span><br><span class="line"><span class="comment">#创建ProxyHandler</span></span><br><span class="line">proxy_support = urllib.request.ProxyHandler(proxy)</span><br><span class="line"><span class="comment">#创建Opener</span></span><br><span class="line">opener = urllib.request.build_opener(proxy_support)</span><br><span class="line"><span class="comment">#添加User Angent</span></span><br><span class="line">opener.addheaders = [(<span class="string">'User-Agent'</span>,<span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'</span>)]</span><br><span class="line"><span class="comment">#安装OPener</span></span><br><span class="line">urllib.request.install_opener(opener)</span><br><span class="line"><span class="comment">#使用自己安装好的Opener</span></span><br><span class="line">response = urllib.request.urlopen(url)</span><br><span class="line"><span class="comment">#读取相应信息并解码</span></span><br><span class="line">html = response.read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line"><span class="comment">#打印信息</span></span><br><span class="line">print(html)</span><br></pre>      </td>    </tr>  </table></figure><h2 id="通过队列获取网站所有url的爬虫">通过队列获取网站所有URL的爬虫</h2><figure class="highlight python">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="comment">#python系统关于队列的包</span></span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="comment">#获取URL的包</span></span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="comment">#获取字符集编码方式</span></span><br><span class="line"><span class="keyword">import</span> chardet</span><br><span class="line"><span class="comment">#正则表达式</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">initial_page = <span class="string">"http://www.meng.uno"</span></span><br><span class="line"></span><br><span class="line">url_queue = queue.Queue()</span><br><span class="line">seen = set()</span><br><span class="line"></span><br><span class="line">seen.add(initial_page)</span><br><span class="line">url_queue.put(initial_page)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_urls</span><span class="params">(url)</span>:</span></span><br><span class="line">    req = urllib.request.Request(url)</span><br><span class="line">    <span class="comment">#得到Response</span></span><br><span class="line">    response = urllib.request.urlopen(req)</span><br><span class="line">    <span class="comment">#读出response == 请求文件的全部字符</span></span><br><span class="line">    html = response.read()</span><br><span class="line">    <span class="comment">#获取这个response的编码方式</span></span><br><span class="line">    charset = chardet.detect(html)</span><br><span class="line">    <span class="comment">#以这种编码方式解码打印</span></span><br><span class="line">    html = html.decode(charset.get(<span class="string">"encoding"</span>))</span><br><span class="line">    urls = re.findall(<span class="string">'href=\"https*://w*\.*meng\.uno/.*?\"'</span>, html,re.S)</span><br><span class="line">    uris = re.findall(<span class="string">'href=\"/[^/].*?[^\.]\"'</span>,html, re.S)</span><br><span class="line">    tempseen = set()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> urls:</span><br><span class="line">        tempseen.add(item[<span class="number">6</span>:<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> uris:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">".html"</span> <span class="keyword">in</span> item:</span><br><span class="line">            tempseen.add(<span class="string">"http://www.meng.uno"</span>+item[<span class="number">6</span>:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">'.'</span> <span class="keyword">in</span> item:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tempseen.add(<span class="string">"http://www.meng.uno"</span>+item[<span class="number">6</span>:<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> tempseen</span><br><span class="line">            </span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">True</span>): <span class="comment">#一直进行直到海枯石烂</span></span><br><span class="line">    <span class="keyword">if</span> url_queue.qsize()&gt;<span class="number">0</span>:</span><br><span class="line">        current_url = url_queue.get()    <span class="comment">#拿出队例中第一个的url</span></span><br><span class="line">        print(current_url)               <span class="comment">#把这个url代表的网页存储好</span></span><br><span class="line">        <span class="keyword">for</span> next_url <span class="keyword">in</span> extract_urls(current_url): <span class="comment">#提取把这个url里链向的url</span></span><br><span class="line">            <span class="keyword">if</span> next_url <span class="keyword">not</span> <span class="keyword">in</span> seen:      </span><br><span class="line">                seen.add(next_url)</span><br><span class="line">                url_queue.put(next_url)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre>      </td>    </tr>  </table></figure><p><strong><em>这里先简单解释，以后有实际项目会再补充！</em></strong></p><p><br><br>本文链接： <a href="http://www.meng.uno/articles/51d32f19/">http://www.meng.uno/articles/51d32f19/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      我们先从分析原理入手，然后再使用Python提供的基本的库urllib。

注意，我全程使用的是Python3，如果你必须使用不同版本，请自行百度某些库及函数的转换，需要使用的库不一定你的电脑上预装了，所以请自行百度安装。

原理
网络爬虫，也叫网络蜘蛛(Web Spider)，如果把互联网比喻成一个蜘蛛网，Spider就是一只在网上爬来爬去的蜘蛛。网络爬虫就是根据网页的地址来寻找网页的，也就是URL。

URL
URL就是统一资源定位符(Uniform Resource Locator)，它的一般格式如下(带方括号[]的为可选项)：

protocol ://hostname[:port]/
    
    </summary>
    
      <category term="Python" scheme="http://www.meng.uno/categories/Python/"/>
    
      <category term="爬虫" scheme="http://www.meng.uno/categories/Python/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="http://www.meng.uno/tags/Python/"/>
    
      <category term="爬虫" scheme="http://www.meng.uno/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>pjax: 当ajax遇上pushState</title>
    <link href="http://www.meng.uno/articles/c039b062/"/>
    <id>http://www.meng.uno/articles/c039b062/</id>
    <published>2018-02-12T00:55:00.000Z</published>
    <updated>2018-03-20T06:59:57.926Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>var pjax = pushState + ajax;<br> 小时候，小浣熊方便面里面有各种水浒人物的卡片。我买了一包，吃了方便面，饱了。而我又买了第二包，不是想吃方便面，而是仅仅想得到里面的卡片…  </p></blockquote><h1>一、简介</h1><p>pushState是html5中提供的方法，用以</p><ul>  <li>无刷新的更新浏览器地址栏；</li>  <li>如其名称，将新地址push到历史堆栈中</li></ul><p>用法：<code>pushState(data, title ,url)</code></p><p>data为保存的对象，可以在window.onpopstate时获取到；title为页面标题；url为需地址栏和历史发生改变的url。<br> 正是这点看似很平常的功能，跟ajax结合到一起产生了火花。因为，ajax最擅长的事情就是局部刷新页面。</p><h1>二、ajax的纠结历史</h1><p>一切可以从ajax最擅长的事情说起。</p><p>ajax作为一个异步请求模型，从最初设计开始，也许压根就没打算将它跟浏览器历史挂钩。原因是历史堆栈所记录的，某种意思上可以说是顺序，跟我们理解的“同步”更为密切。</p><p>因而，<code>ajax可以无刷新改变页面内容，却无法改变页面的url</code>。</p><h2 id="历史问题1-如何操控历史">历史问题1 - 如何操控历史</h2><p>当单页面越来越流行，操作记录却很容易被忽略。假设有这样的单页面，按照分类点击，界面逐层递进：<code>体育 - 篮球 -nba -马刺队 - 邓肯</code><br> 当我们点了4下到“邓肯”界面时，一个不小心的刷新，出现在你面前的也许是“体育”。原因是操作记录没有被记录。  <br> 而通常的解决方案是修改hash，每递进一层，去更新url的hash值，这样的方法：</p><ol>  <li>刷新时预先判断url的hash，从而知道这是哪一层，加载相应数据；</li>  <li>支持了历史</li></ol><p>这样的方式貌似比较完善，其实不然。</p><h2 id="历史问题2-对搜索引擎不友好">历史问题2 - 对搜索引擎不友好</h2><p>最大的问题是，hash后生成的内容是不会被搜索引擎引用到。数据不能被爬取，无疑是浪费和损失。因此google放言，咱可以约定个协议：<code>#!xxx</code>这样hash的url，google也去爬取。称之为<code>hash bang</code>（哈希大爆炸？）。这一协议，在g+，twitter，人人，新浪微博上都可以看到。</p><p>事实上，ajax最或缺的两个问题，恰好被pushState的功能补充完善。</p><h1>三、pjax带来的价值</h1><p>除去补齐了ajax的问题，我们发现pjax会给web带来更多的好处。<br> 回到开始说的“两包方便面”，我的意思是，有时你访问两个url，部分数据是相同的。比如百度贴吧，第一页和第二页的区别只是帖子内容（卡片）的不同，网站外框部分（方便面）都是一样的，这些东西就不需要在页面刷新时重复加载。</p><p>ajax处理这样的局部刷新，已经给我们带来了web2.0的体验，而加上pushstate的ajax则更进一步：</p><ol>  <li>一个url对应一套数据，有利于SEO；</li>  <li>更改数据和url时，只是局部刷新，带来较好的用户体验；</li>  <li>兼容性好，对不支持pushstate的浏览器，url也能正常请求页面（虽然有重复加载）；</li>  <li>刷新页面时，由于是url唯一，能正常加载到用户希望看到的数据，比处理hash的方式更方便；</li>  <li>后退与前进的浏览器操作，依然可以局部刷新（通过onpushstate事件捕获）</li></ol><h1>四、注意事项</h1><p>然而pjax不等于单纯的分离使用pushstate与ajax，还必须得做一些封装。缘于以下我能想到的注意事项：</p><ul>  <li>服务器端增加额外处理逻辑<br> 服务器端，需要根据请求的参数，作出全页渲染或局部渲染响应  </li></ul><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">Accept:text/html, */*; q=0.01</span><br><span class="line">Accept-Encoding:gzip,deflate,sdch</span><br><span class="line">Connection:keep-alive</span><br><span class="line">Host:qianduannotes.duapp.com</span><br><span class="line">User-Agent:AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36</span><br><span class="line">X-Requested-With:XMLHttpRequest</span><br><span class="line">X-PJAX:true</span><br></pre>      </td>    </tr>  </table></figure><p>比如请求头部可以设定一个X-PAJX:true，用以通知服务器。</p><ul>  <li>浏览器兼容</li></ul><p>假如浏览器不支持pushstate，提供fallback操作，直接打开需更改url的地址：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line">$.support.pjax = window.history &amp;&amp; window.history.pushState</span><br><span class="line">// Fallback</span><br><span class="line">if ( !$.support.pjax ) &#123;</span><br><span class="line">  $.pjax = function( options ) &#123;</span><br><span class="line">    window.location = $.isFunction(options.url) ? options.url() : options.url</span><br><span class="line">  &#125;</span><br><span class="line">  $.fn.pjax = function() &#123; return this &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>本地存储机制</li></ul><p>无疑pjax与localstorage共同使用可以进一步提升体验，但这一步容易忽略的是数据上报。</p><h1>五、参考资料</h1><p><a href="https://github.com/defunkt/jquery-pjax" target="_blank" rel="noopener">jquery-pjax</a><br>  <a href="https://github.com/welefen/pjax" target="_blank" rel="noopener">welefen封装的pjax</a></p><p><br><br>本文链接： <a href="http://www.meng.uno/articles/c039b062/">http://www.meng.uno/articles/c039b062/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      var pjax = pushState + ajax;
小时候，小浣熊方便面里面有各种水浒人物的卡片。我买了一包，吃了方便面，饱了。而我又买了第二包，不是想吃方便面，而是仅仅想得到里面的卡片… 

一、简介
pushState是html5中提供的方法，用以

 * 无刷新的更新浏览器地址栏；
 * 如其名称，将新地址push到历史堆栈中

用法：pushState(data, title ,url)

data为保存的对象，可以在window.onpopstate时获取到；title为页面标题；url为需地址栏和历史发生改变的url。
正是这点看似很平常的功能，跟ajax结合到一起产生了火花
    
    </summary>
    
      <category term="web" scheme="http://www.meng.uno/categories/web/"/>
    
    
      <category term="ajax" scheme="http://www.meng.uno/tags/ajax/"/>
    
      <category term="js" scheme="http://www.meng.uno/tags/js/"/>
    
      <category term="html5" scheme="http://www.meng.uno/tags/html5/"/>
    
      <category term="pjax" scheme="http://www.meng.uno/tags/pjax/"/>
    
      <category term="pushState" scheme="http://www.meng.uno/tags/pushState/"/>
    
  </entry>
  
  <entry>
    <title>CPAchecker</title>
    <link href="http://www.meng.uno/articles/c5d9877c/"/>
    <id>http://www.meng.uno/articles/c5d9877c/</id>
    <published>2018-02-11T14:08:59.000Z</published>
    <updated>2018-02-11T14:15:48.025Z</updated>
    
    <content type="html"><![CDATA[<p>CPAchecker is a tool for configurable software verification which means expressing different program analysis and model checking approaches in one single formalism. The main algorithm is configurable to perform a reachability analysis on arbitrary combinations  of existing configurable program analysis (CPA). One application of CPAchecker is the verification of Linux device drivers.</p><p>CPA provides a conceptual basis for expressing different verification approaches in the same formal setting. The CPA formalism provides an interface for the definition of program analyses, which includes the abstract domain, the post operator, the merge  operator, and the stop operator. Consequently, the corresponding tool implementation CPAchecker provides an implementation framework that allows the seamless integration of program analyses that are expressed in the CPA framework. The comparison of  different approaches in the same experimental setting becomes easy and the experimental results will be more meaningful.</p><h2 id="architecture">Architecture</h2><p><img src="http://www.meng.uno/images/cpa/1.png" alt="CPAchecker"></p><p>The above picture is the overview of CPAchecker’s architecture. The central data structure is a set of control-flow automata (CFA), which consist of control-flow locations and control-flow edges. A location represents a program-counter value, and an edge  represents a program operation, which is either an assume operation, an assignment block, a function call, or a function return. Before a program analysis starts, the input program is transformed into a syntax tree, and further into CFAs. The framework  provides interfaces to SMT solvers and interpolation procedures, such that the CPA operators can be written in a concise and convenient way. From the picture, we know that they use MathSAT as an SMT solver, and CSIsat and MathSAT as interpolation procedures.  They also use JavaBDD as a BDD package, and provide an interface to an Octagon Library as well. The CPA Algorithm is the center of this project and the detailed design is shown as follows.</p><p><img src="http://www.meng.uno/images/cpa/2.png" alt="CPAchecker"></p><p>The CPA algorithm (shown at the top in the above figure) takes as input a set of control-flow automata (CFA) representing the program, and a CPA, which is in most cases a Composite CPA. The interfaces correspond one-to-one to the formal framework. The  elements in the gray box (top right) represent the abstract interfaces of the CPA and the CPA operations. The two gray boxes at the bottom of the figure show two implementations of the interface CPA, one is a Composite CPA that can combine several other  CPAs, and the other is a Leaf CPA.</p><h2 id="build-and-test">Build and Test</h2><p>Owing to the long development history, this project is very prefect which means you could use its binary directly, build from the source and even use their jar-ball in Java applications. To experience it, I will build it from the source and use it in  the command-line.</p><p>We need to install “jdk”, “ant”, “svn” and “subversion” before we build it. Then enter the root directory and run “ant”. Wait a moment and this is the result.</p><p>To test this project, we need to write a C/C++ code without “#include  <headers>”. I choose a simple one (QuickSort) shown in the attachment.</headers></p><p>The result contains a log file, a statistics file and a report which is in “html” format.</p><p><br><br>本文链接： <a href="http://www.meng.uno/articles/c5d9877c/">http://www.meng.uno/articles/c5d9877c/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      CPAchecker is a tool for configurable software verification which means expressing different program analysis and model checking approaches in one single formalism. The main algorithm is configurable to perform a reachability analysis on arbitrary combinations of existing configurable program analys
    
    </summary>
    
      <category term="Software Verification" scheme="http://www.meng.uno/categories/Software-Verification/"/>
    
      <category term="CPA" scheme="http://www.meng.uno/categories/Software-Verification/CPA/"/>
    
      <category term="CPAchecker" scheme="http://www.meng.uno/categories/Software-Verification/CPA/CPAchecker/"/>
    
    
      <category term="CPA" scheme="http://www.meng.uno/tags/CPA/"/>
    
      <category term="CPAchecker" scheme="http://www.meng.uno/tags/CPAchecker/"/>
    
  </entry>
  
  <entry>
    <title>Linux Test Project</title>
    <link href="http://www.meng.uno/articles/bfb74f68/"/>
    <id>http://www.meng.uno/articles/bfb74f68/</id>
    <published>2018-02-11T13:29:33.000Z</published>
    <updated>2018-02-11T14:04:49.151Z</updated>
    
    <content type="html"><![CDATA[<p>I found this project from the references of other papers, and I thought it was good, so I plan to run it. As we can see from its name, Linux Test Project (LTP) has a goal to deliver test suites to the open source community that validate the reliability,  robustness, and stability of Linux. This project wants to support Linux development by making unit testing more complete and minimizing user impact by building a barrier to keep bugs from making it to the user. There are two important testing techniques  which are supported by giving developers an ever growing set of tools to help identify any operational problems in their code: Design and Code Inspections. I knew that Yggdrasil and Hyperkernel which I have run successfully belong to the last category.  LTP doesn’t have a benchmark which means they don’t compare different kernel of Linux.</p><p>In LTP, we need to know:</p><ul>  <li>Test case: A single action and verification which has a result PASS/FAIL.</li>  <li>Test suite: Containing one or more test cases.</li>  <li>Test tags: Pairing a unique identifier with a test program and a set of command line options.</li></ul><p>We also need to know the ways of reporting the results of a test case. There are two main ways which are contained in LTP:</p><ul>  <li>Exit status: If a test program encounters unexpected or incorrect results, exit the test program with a non-zero exit status, i.e. exit(1). Conversely, if a program completes as expected, return a zero exit status, i.e. exit(0).</li>  <li>Standard output: Tools can be used to analyze the results, if they are written in a standard way.</li></ul><h2 id="build-and-run">Build and Run</h2><p>To build this project, we need to run the following executions:</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">$ git clone https:<span class="comment">//github.com/linux-test-project/ltp.git</span></span><br><span class="line">$ cd ltp</span><br><span class="line">$ make autotools</span><br><span class="line">$ ./configure</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre>      </td>    </tr>  </table></figure><p>Before these, we need to ensure “git, autoconf, automake, m4” are installed. If not, we can use “apt-get” to get them. The output of “make” is shown as following.</p><p><img src="http://www.meng.uno/images/ltp/1.png" alt="LTP"></p><p>After building this project, let’s run it personally. If we want to run all the test suites, we just need run “./runltp” in the “opt/ltp/” directory. However, I will run a single test suite to verify this project only with “./runltp -f syscalls” execution.</p><p><img src="http://www.meng.uno/images/ltp/2.png" alt="LTP"></p><p>The picture above is the output of “abort01” test case. From it we can see that the test method is “Exit status test” and it passes all the situations.</p><p>If a test case needs datafiles to work, these would be put in a subdirectory named datafilesand installed in the testcases/data/$TCID directory</p><h2 id="analyze-test-cases">Analyze Test Cases</h2><p>We could find LTP in “/opt/ltp” and the test suites are installed in the “/opt/ltp/runtest/” directory. The following picture is a screenshot of it.</p><p><img src="http://www.meng.uno/images/ltp/3.png" alt="LTP"></p><p>In a single file, such as “syscalls” file, there exist many single test cases which are like the follows.</p><p><img src="http://www.meng.uno/images/ltp/4.png" alt="LTP"></p><p>From this picture, those words, like “abort01”, represent different test cases which are laid in “/opt/ltp/testcases/bin/” directory.</p><p><img src="http://www.meng.uno/images/ltp/5.png" alt="LTP"></p><p>Each test case is a binary written either in portable Shell or C such as “abort01” which is from “abort01.c” which lays in the “ltp/testcases/kernel/syscalls/abort” directory. The test gets a configuration via environment variables and/or command line  parameters, it prints additional information into the stdout and reports overall success/failure via the exit value.</p><p><img src="http://www.meng.uno/images/ltp/6.png" alt="LTP"></p><h2 id="write-a-test-suite">Write A Test Suite</h2><p>To make things simple, I will use LTP standard interface, not add custom reporting functions and use LTP build system. The following are my steps (These steps are very simple, so I didn’t list any screenshot):</p><ul>  <li>Add a new file “meng” to “ltp/runtest/” directory;</li>  <li>Write some test cases’ names, such as “abort01 accept01”;</li>  <li>Run “make” and “make install”;</li>  <li>Enter “/opt/ltp/” directory;</li>  <li>Run “./runltp -f meng”;</li>  <li>Get the result as the picture. (You can also find the full logs from “meng_output.txt” file in the attachment)</li></ul><p><img src="http://www.meng.uno/images/ltp/7.png" alt="LTP"></p><h2 id="write-a-test-case">Write A Test Case</h2><p>As I said before, we can use C language or Shell to write a test case, however, in this section, I will just use C language to write a simple one which may make me have a deep understanding of this project.</p><p><strong>I used the “man-pages” to find the untested system calls, however, my linux version maybe a little old (2015 release, version 16.04), so that I can’t find a untested one which is excluded by the newest LTP.</strong></p><p>I will write a test for verifying system call “file rename”. First, I create a new file “meng.c” in the “ltp/testcases/kernel/syscalls/meng/” directory. Then I need to write the codes. The next thing I need to do is to include “tst_test.h” (There are  also another headers, however, this one is basic). We need to write “main(), setup(), clean()” functions and the detailed realizations are in the “meng.c” which is in the attachment (I give some notes of the code in the “meng.c” file as well). What’s  more, we need to create a “Makefile” in the same directory and write the compiling information. The compiled file is like this.</p><p><img src="http://www.meng.uno/images/ltp/8.png" alt="LTP"></p><p>Last, I will add this test case to the “meng” test suite and see the result (You can find the full output in “meng_syscall_output.txt” in the attachment).</p><p><img src="http://www.meng.uno/images/ltp/9.png" alt="LTP"></p><p>From the above picture, we can see that the verification is “pass” which means that not only the “rename” system call is correct, but also my code is right.</p><p><br><br>本文链接： <a href="http://www.meng.uno/articles/bfb74f68/">http://www.meng.uno/articles/bfb74f68/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      I found this project from the references of other papers, and I thought it was good, so I plan to run it. As we can see from its name, Linux Test Project (LTP) has a goal to deliver test suites to the open source community that validate the reliability, robustness, and stability of Linux. This proje
    
    </summary>
    
      <category term="Linux" scheme="http://www.meng.uno/categories/Linux/"/>
    
      <category term="Linux Test" scheme="http://www.meng.uno/categories/Linux/Linux-Test/"/>
    
    
      <category term="Linux" scheme="http://www.meng.uno/tags/Linux/"/>
    
      <category term="Linux Test" scheme="http://www.meng.uno/tags/Linux-Test/"/>
    
  </entry>
  
  <entry>
    <title>A Melody Composer for both Tonal and Non-Tonal Languages</title>
    <link href="http://www.meng.uno/articles/2251dcee/"/>
    <id>http://www.meng.uno/articles/2251dcee/</id>
    <published>2018-02-11T04:03:24.000Z</published>
    <updated>2018-03-02T03:27:32.829Z</updated>
    
    <content type="html"><![CDATA[<h1>Summary</h1><h2 id="abstract">Abstract</h2><p>This paper contains some improvements on an algorithmic melody composer called “T-music”. “T-music” is an algorithm which can compose a melody for users’ input lyrics by mining the relationship between the melodies and lyrics. These relationships are  known as frequent patterns (FPS) . The ameliorations are two ways to enhance the methods of mining frequent patterns form instrumental compositions and an optimal way of using FPS mined from songs in one language to compose a melody for the input things  in another language.</p><h2 id="propse">Propse</h2><p>The propose is to get an algorithm which take lyrics as input and a good melody as outcome in order to help those people who have little music background to compose songs. In view of the fact that there is already a pretty well method, T-music, the authors’  tasks are making some improvements on the basis of the original algorithm.</p><h2 id="deficiencies-of-original-algorithm">Deficiencies of original algorithm</h2><p>At the first place, I need to borrow a figure from the paper as follows to express my understanding of the original T-music method.</p><p><img src="http://www.meng.uno/images/t-music/t-music-arch.png" alt="t-musuc"></p><p>As the picture shows that the system architecture of T-music can be divided as two phases which are “Frequent Pattern Mining” and “Melody Composition”. I will report this method following the flow of the algorithm.</p><ul>  <li>    <p>Mining the FPS from “Song Database” and storing them in the “Frequent Pattern Database”:</p>    <ul>      <li>Obtaining tone sequences from “Song Database” by reading the “Language Dictionary”;</li>      <li>Generating s-sequence from a melody, a pitch sequence and a duration sequence;</li>      <li>Mining the FPS from s-sequence;</li>      <li>Storing the FPS to “Frequent Pattern Database”.</li>    </ul>  </li>  <li>    <p>Composing a melody for the “Lyrics” based on FPS in the “Frequent Pattern Database”:</p>    <ul>      <li>Obtaining the tone sequence of the lyrics by reading the “Language Dictionary”;</li>      <li>Adding some “Music Parameters” such as some music rules;</li>      <li>Generating “Melody” by the process “Melody Composition” using FPS.</li>    </ul>  </li></ul><p>There are some deficiencies of the original T-music algorithm as follows. It can only mine FPS from songs in which lyrics must be present. What’s more, the original one can’t use the FPS mined from a language to compose melody in another language. However,  we can’t always get the ideal songs data which have lyrics embedded easily. What we can get from the Internet are those instrumental compositions in which lyrics are absent. Also, we want to achieve that composing melody in a language with the FPS mined  from another language which can make the algorithm more efficient.</p><h2 id="improvements">Improvements</h2><p>What the authors have done provided two ways to mine Frequent Patterns from instrumental compositions and an optimal mapping method for composing a melody using FPS in different language with the input lyrics.</p><p>The first way is “Method emphasizing the original FPS”. I will use the following picture to express my comprehension. Firstly, mining the FPS from songs and storing them in “FP database (General)”. Secondly, mining the frequent pitch trends from “Instrumental  compositions with style database” and storing them in “Frequent pitch trends (Style)” and then using it as a selector to select those FPS storing the matches in “FP database (Style)”.</p><p><img src="http://www.meng.uno/images/t-music/t-music-database.png" alt="t-musuc"></p><p>The second way is “Method emphasizing the newly mined frequent pitch trends”. I will also introduce it using the screenshot from the paper. The FPS based on those of the first way was subdivided. The frequent pitch trends are mined as usually. The most  difference is that one pitch trend may match a set of several tone trends.</p><p><img src="http://www.meng.uno/images/t-music/t-music-database2.png" alt="t-musuc"></p><p>The optimal mapping method is shown as follows. Firstly, using the same method gets a “FP database” in one language. Then, generating several tone sequences for each tone trend in this “FP database”. There are some lemmas proofed on the paper to decide  the specific number of the mapping.</p><h1>Improvements</h1><p>In this section, I will analysis some excellent algorithms, important thoughts or some key points. Some of them may look small or nothing special, but each has its function.</p><h2 id="using-the-trend-representation">Using the “Trend” representation</h2><p>If I were doing this job, I could have chosen the simple “absolute” representation, just because this is the most intuitive frequent pattern we can get from songs. After careful consideration, just as the author explains that same melodies which start  at different pitches may sound similar to us. Then, I understand that it is a big wisdom to use the “trend” representation which uses a FP to extract the general rules of a set of FPS with different pitches, simplifying a large number of calculations  and making the result more obvious.</p><h2 id="using-frequent-pitch-trends-style-as-a-selector">Using “Frequent pitch trends (Style)” as a selector</h2><p>Though we know that “T-music” uses “the FPS between the tone port and the pitch part” and agree the mining method used on mining the frequent pattern which contains a tone trend and a pitch trend, there must be some correlation between “Tone trend” and  “Pitch trend”. Since the instrumental compositions don’t contain lyrics, we couldn’t mine a whole frequent pattern from them. However, we can also mine part of the frequent pattern from them which is “Pitch trend”. For we have so much instrumental compositions  which means we can get enough “Pitch trend” and we already know the correlation between “Tone trend” and “Pitch trend”, we can estimate the frequency of the original frequent pattern and eliminate part of them which have a zero frequency.</p><h2 id="using-the-subsequences-of-original-frequent-pattern">Using the subsequences of original frequent pattern</h2><p>According to the Apriori property that all nonempty subsets of frequent item set must also be frequent, the authors artfully break the original FPS into smaller form and then making them combine more FPS which can be selected from the original FP database.  By doing this, we can get more frequent patterns from the identical data which means our mining algorithm is more efficient.</p><h2 id="using-multi-map-as-a-data-structure">Using multi-map as a data structure</h2><p>This data structure allows the task of retrieving a value by a key quickly and returns more than one frequent pattern with a support. From it, we can get a tuple in top-k tuples with some selection strategies and ensure that a pattern with a very large  support isn’t always selected because it doesn’t mean that it is always the best choice.</p><h2 id="employing-the-divide-and-conquer-idea">Employing the divide and conquer idea</h2><p>Considering to compose a melody of a very long lyric, we may need to divide the original tone trend into several shorter tone trends, apply the same procedure on them and then return the concatenation of the results of the sub-problems. It is a simple  idea of solving such problem, but we can’t resist its correctness and effectiveness.</p><h1>Limitations</h1><p>I just list some areas that I think need improvements or I think it can be added slightly on the basis of the original research.</p><h2 id="applying-word-segmentation">Applying word segmentation</h2><p>Though the paper has mentioned the use of word segmentation, there is just a word and no detailed explanation. I think I should express my own idea here. Firstly, the word segmentation here isn’t the same of those applied in the fields of natural language  processing (NLP). As we all known, the latter has so many strict norms to follow, however, in the lyrics, the norms aren’t very same. Why we do this in the input lyrics is because we want to determine the length of durations between every two words,  which is different from the propose in the NLP which just wants to add pause at the same length of time between words and words.</p><h2 id="handling-the-tone-trend-with-a-length-of-1">Handling the tone trend with a length of 1</h2><p>In this paper, the authors just simply set the pitch trend to be the input tone trend where, I think, may need improvement. Firstly, we all know that “the tone trend with a length of 1” couldn’t appear individually. It is usually because we matched the  tone sequences before it or after it. I think if we consider dividing the original sequence into overlapping parts using the similar idea of divide and conquer idea, the question may disappear.</p><h2 id="mining-the-relationship-between-tone-trend-and-pitch-trend">Mining the relationship between “tone trend” and “pitch trend”</h2><p>The authors just determine the relationship based on statistics in whether the original T-music method or the improved edition, store the regulars on a multi-map and when using the frequent pattern, the method just randomly selects a tuple from top-k  tuples from the multi-map. Therefore, no matter which one we choose, it is just the original sequence in the FP-database. If there is a very large database which contains a large number of every frequent pattern, it may have a remarkable effect without  complex computations. However, we can’t ensure it or we just want to improve our algorithm with little support of so many records. Let’s look at the following samples which has the form as same as those in the multi-map and assume that the same tone  trend only has the three tuples.</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&gt; —&gt; (&lt;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">1</span>,-<span class="number">2</span>&gt;, <span class="number">10</span>)</span><br><span class="line">&lt;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&gt; —&gt; (&lt;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">2</span>,-<span class="number">1</span>&gt;, <span class="number">9</span>) </span><br><span class="line">&lt;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&gt; —&gt; (&lt;<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">2</span>,-<span class="number">1</span>&gt;, <span class="number">5</span>)</span><br></pre>      </td>    </tr>  </table></figure><p>As we can see, they have the same tone trend and different pitch trends with different values of a support. If we just use the method described in the paper, we may get the result of the 1st, the 2nd, or the 3rd. However, is it the best one? Maybe not,  I think. I mean maybe <code>&lt;1,1,2,0,-2,-1&gt;</code> is better. I think we need to add some correlation analyses to the pitch trends which have the same tone trends.</p><h1>Expanding Research</h1><p>After reading this paper, I have some ideas for further research and some of them are listed as follows.</p><h2 id="adding-location-variables">Adding location variables</h2><p>I mean, as we all known, a same lyric may have different melodies when it is at the beginning or at the end of a song. Of course, if we just want to use a simple sentence as its input, this consideration is rather superfluous. However, if the input lyric  is long enough, it is very important then.</p><h2 id="generating-a-melody-with-a-longer-note">Generating a melody with a longer note</h2><p>This thought is mentioned in the end of the paper as well. We may have noticed that the normal notes will be longer than the syllables of lyrics, at least at the end of each sentence. We may need to modify the match method to add the frequent pattern  which contains group of pitch trends sequences and its corresponding longer tone trends sequences.</p><h2 id="applying-syntactic-analysis">Applying syntactic analysis</h2><p>The following is my exploratory opinion of the original T-music. If I have many songs with lyrics, I will mine the frequent patterns of syntactic analysis and add them to the “s-sequence” mentioned in this paper. Thus I will reform the original multi-map  as follows.</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">(&lt;pitch trend pattern&gt;, &lt;syntax pattern&gt;) —&gt; (&lt;tone trend pattern&gt;, support)</span><br></pre>      </td>    </tr>  </table></figure><p>When we match the input lyrics, we need to not only match the “pitch trend pattern” from the FP-database but also contrast the “syntax pattern” and then make the best decision.</p><h2 id="expanding-to-speech-recognization">Expanding to speech recognization</h2><p>I have a simple idea of speech recognization using the same method mentioned in this paper. If I could collect enough voice information spoken by the same person, I would mine the frequent patterns of his intonation habit from the voice data and then  using them to judge whether another voice is his or not.</p><h2 id="expanding-to-password-security">Expanding to password security</h2><p>In order to prevent the password being stolen, all websites are making efforts on password diversity. I think the method of mining frequent pattern can be applied to protect users’ password as well. For the same string of ciphers, different people may  type it out in different speeds with different intermission on every two letters. I, for example, usually use the combination of my name and birthday as a password and when I type it out there is a longer break between the last letter of my name and  the first number of my birthday. If we use the same way to mine the frequent patterns form enough times records of someone, we may use the frequent patterns to judge whether it is the right person or not who is typing the password.</p><h2 id="generating-good-problems">Generating “good problems”</h2><p>I often encounter some tricky programming problems and as we all known, “StackOverflow” is the biggest website which can offer you relevant solutions when you ask a question on it. However, we all want to get the best answer as soon as possible so we  may need to put forward “good questions”. I think the thought of this paper can be applied to this question. We can first collect enough “good questions” from the website and then mine the syntactic frequent patterns of each question by categories.  Finally, we can generate such “good questions” by adding the knowledge of sentence construction and providing some keywords needed.</p><h1>Related Research</h1><p>This paper is about mining frequent patterns which is a subfield of data mining. I will express my understanding mixing information retrieved from the Internet in this field.</p><p>With the rise of big data, so many research topics about data is more and more frequent such as forecasting passenger flow and passenger flow directions during the Spring Festival and predicting the composition of Chinese college entrance examination  this year. Data mining means the process of extracting valuable information and patterns from large amounts of data and these new discovery rules, patterns, information and concepts have potential value. It usually contains the association rules, classification,  estimation, clustering and so on.</p><p>As for association analysis, its propose is to discover interesting links hidden in large data sets and the patterns discovered are usually represented in association rules or frequent item sets just as this paper shown. There are several efficient and  scalable frequent item set mining methods such as Apriori algorithm and FP-growth which needs to construct FP-tree.</p><p>As for classification and prediction, I think it is a more stirring area. Think of this, a marketing manager needs data analysis to help guess whether or not a customer with a given profile will buy a new computer and then the marketing manager would  like to predict how much a given customer will spend during a sale, what an attractive job!</p><p><br><br>本文链接： <a href="http://www.meng.uno/articles/2251dcee/">http://www.meng.uno/articles/2251dcee/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      Summary
Abstract
This paper contains some improvements on an algorithmic melody composer called “T-music”. “T-music” is an algorithm which can compose a melody for users’ input lyrics by mining the relationship between the melodies and lyrics. These relationships are known as frequent patterns (FPS)
    
    </summary>
    
      <category term="Paper Report" scheme="http://www.meng.uno/categories/Paper-Report/"/>
    
      <category term="Data mining" scheme="http://www.meng.uno/categories/Paper-Report/Data-mining/"/>
    
    
      <category term="Paper Report" scheme="http://www.meng.uno/tags/Paper-Report/"/>
    
      <category term="Data Mining" scheme="http://www.meng.uno/tags/Data-Mining/"/>
    
  </entry>
  
  <entry>
    <title>.length与length()的区别</title>
    <link href="http://www.meng.uno/articles/61c2f1f1/"/>
    <id>http://www.meng.uno/articles/61c2f1f1/</id>
    <published>2018-02-10T13:58:04.000Z</published>
    <updated>2018-02-10T14:52:50.489Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>当我们需要使用数组或者字符串长度时，习惯了使用IDE自动补全的我们是否知道<code>.length</code>与<code>length()</code>的区别喻原因呢？</p></blockquote><p>上面问题的答案是：</p><ul>  <li>数组使用<code>.length</code>属性</li>  <li>字符串使用<code>length()</code>方法</li></ul><p>下面我来回答原因。</p><h2 id="为什么数组有-length属性？">为什么数组有<code>.length</code>属性？</h2><p>在Java中，数组是容器对象，其中包含了固定数量的同一类型的值，一旦数组创建，其长度就是固定的了，于是，其长度可以作为一个属性。</p><h2 id="为什么字符串需要length-方法？">为什么字符串需要<code>length()</code>方法？</h2><p>Java中的String，实际上是一个char类型数组，而char[]已经有了<code>.length</code>属性，所以在实现String时就没必要再定义重复的属性了，于是需要定义一个方法来返回其长度。</p><p><br><br>本文链接： <a href="http://www.meng.uno/articles/61c2f1f1/">http://www.meng.uno/articles/61c2f1f1/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      当我们需要使用数组或者字符串长度时，习惯了使用IDE自动补全的我们是否知道.length与length()的区别喻原因呢？

上面问题的答案是：

 * 数组使用.length属性
 * 字符串使用length()方法

下面我来回答原因。

为什么数组有.length属性？
在Java中，数组是容器对象，其中包含了固定数量的同一类型的值，一旦数组创建，其长度就是固定的了，于是，其长度可以作为一个属性。

为什么字符串需要length()方法？
Java中的String，实际上是一个char类型数组，而char[]已经有了.length属性，所以在实现String时就没必要再定义重复的属性了，
    
    </summary>
    
      <category term="Java开发Tips" scheme="http://www.meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/"/>
    
      <category term="String" scheme="http://www.meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/String/"/>
    
      <category term="Object" scheme="http://www.meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/String/Object/"/>
    
    
      <category term="Java" scheme="http://www.meng.uno/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java异常结构层次图</title>
    <link href="http://www.meng.uno/articles/1164dab2/"/>
    <id>http://www.meng.uno/articles/1164dab2/</id>
    <published>2018-02-09T14:11:15.000Z</published>
    <updated>2018-02-10T14:51:35.021Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中，异常分为<code>checked</code>与<code>unchecked</code>，他们都在一个分类层次中，如下图。</p><p><img src="http://www.meng.uno/images/ehd.jpeg" alt="DEH"></p><p>其中，红色的异常是<code>checked</code>异常，意味着在一个方法中，他们<code>throw</code>后必须<code>catch</code>或者<code>declare</code>。</p><p>另一种颜色的为<code>unchecked</code>异常，他们的异常不需要被<code>recover</code>。</p><p><br><br>本文链接： <a href="http://www.meng.uno/articles/1164dab2/">http://www.meng.uno/articles/1164dab2/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      在Java中，异常分为checked与unchecked，他们都在一个分类层次中，如下图。



其中，红色的异常是checked异常，意味着在一个方法中，他们throw后必须catch或者declare。

另一种颜色的为unchecked异常，他们的异常不需要被recover。



本文链接： http://www.meng.uno/articles/1164dab2/ 欢迎转载！
    
    </summary>
    
      <category term="Java开发Tips" scheme="http://www.meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/"/>
    
      <category term="Exception" scheme="http://www.meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/Exception/"/>
    
    
      <category term="Java" scheme="http://www.meng.uno/tags/Java/"/>
    
      <category term="Exception" scheme="http://www.meng.uno/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>二分查找的效率</title>
    <link href="http://www.meng.uno/articles/fff444e8/"/>
    <id>http://www.meng.uno/articles/fff444e8/</id>
    <published>2018-02-08T09:20:00.000Z</published>
    <updated>2018-02-10T13:05:27.172Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>查找是比较常见的工作，今天我通过对比几种在数组中查找一个确定的值的例子来向大家展示二分查找的魅力。</p></blockquote><h2 id="数组查找元素的几种方法">数组查找元素的几种方法</h2><h3 id="使用list">使用List</h3><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">useList</span><span class="params">(String[] arr, String targetValue)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Arrays.asList(arr).contains(targetValue);</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="使用set">使用Set</h3><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">useSet</span><span class="params">(String[] arr, String targetValue)</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(arr));</span><br><span class="line"><span class="keyword">return</span> set.contains(targetValue);</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="使用for-loop">使用for-loop</h3><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">useLoop</span><span class="params">(String[] arr, String targetValue)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(String s: arr)&#123;</span><br><span class="line"><span class="keyword">if</span>(s.equals(targetValue))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="使用二分">使用二分</h3><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">useArraysBinarySearch</span><span class="params">(String[] arr, String targetValue)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a =  Arrays.binarySearch(arr, targetValue);</span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="时间复杂性">时间复杂性</h2><h3 id="代码">代码</h3><blockquote>  <p>使用如下代码来验证不同数据规模（5，1k，10k）的查找任务下四种方法的时间复杂性。（二分查找需要对数据排序，排序时间未计算在内。）</p></blockquote><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String[] arr = <span class="keyword">new</span> String[] &#123;  <span class="string">"CD"</span>,  <span class="string">"BC"</span>, <span class="string">"EF"</span>, <span class="string">"DE"</span>, <span class="string">"AB"</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//use list</span></span><br><span class="line"><span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">useList(arr, <span class="string">"A"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line"><span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">System.out.println(<span class="string">"useList:  "</span> + duration / <span class="number">1000000</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//use set</span></span><br><span class="line">startTime = System.nanoTime();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">useSet(arr, <span class="string">"A"</span>);</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.nanoTime();</span><br><span class="line">duration = endTime - startTime;</span><br><span class="line">System.out.println(<span class="string">"useSet:  "</span> + duration / <span class="number">1000000</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//use loop</span></span><br><span class="line">startTime = System.nanoTime();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">useLoop(arr, <span class="string">"A"</span>);</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.nanoTime();</span><br><span class="line">duration = endTime - startTime;</span><br><span class="line">System.out.println(<span class="string">"useLoop:  "</span> + duration / <span class="number">1000000</span>);</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="5-结果">&quot;5&quot;结果</h3><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">useList:  <span class="number">13</span></span><br><span class="line">useSet:  <span class="number">72</span></span><br><span class="line">useLoop:  <span class="number">5</span></span><br></pre>      </td>    </tr>  </table></figure><h3 id="1k-结果">&quot;1k&quot;结果</h3><h4 id="随机生成数据">随机生成数据</h4><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">String[] arr = <span class="keyword">new</span> String[<span class="number">1000</span>];</span><br><span class="line"> </span><br><span class="line">Random s = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">arr[i] = String.valueOf(s.nextInt());</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h4 id="结果">结果</h4><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">useList:  <span class="number">112</span></span><br><span class="line">useSet:  <span class="number">2055</span></span><br><span class="line">useLoop:  <span class="number">99</span></span><br><span class="line">useArrayBinary:  <span class="number">12</span></span><br></pre>      </td>    </tr>  </table></figure><h3 id="10k-结果">&quot;10k&quot;结果</h3><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">useList:  <span class="number">1590</span></span><br><span class="line">useSet:  <span class="number">23819</span></span><br><span class="line">useLoop:  <span class="number">1526</span></span><br><span class="line">useArrayBinary:  <span class="number">12</span></span><br></pre>      </td>    </tr>  </table></figure><h2 id="结论">结论</h2><p>通过以上结果，我们可以发现二分搜索确实很高效，而且当数据量变大时，其时间增长幅度还比较小。</p><p>以后，我们就可以使用<code>Arrays.binarySearch()</code>来高效查找某元素了。</p><p><br><br>本文链接： <a href="http://www.meng.uno/articles/fff444e8/">http://www.meng.uno/articles/fff444e8/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      查找是比较常见的工作，今天我通过对比几种在数组中查找一个确定的值的例子来向大家展示二分查找的魅力。

数组查找元素的几种方法
使用List
1
2
3


public static boolean useList(String[] arr, String targetValue) {
	return Arrays.asList(arr).contains(targetValue);
}


使用Set
1
2
3
4


public static boolean useSet(String[] arr, String targetValue) {
	Set&lt;String&gt; set = ne
    
    </summary>
    
      <category term="Java开发Tips" scheme="http://www.meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/"/>
    
      <category term="Search" scheme="http://www.meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/Search/"/>
    
    
      <category term="Java" scheme="http://www.meng.uno/tags/Java/"/>
    
      <category term="算法复杂性" scheme="http://www.meng.uno/tags/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E6%80%A7/"/>
    
      <category term="二分查找" scheme="http://www.meng.uno/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
</feed>
