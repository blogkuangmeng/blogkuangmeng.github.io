<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>欢迎来到匡盟盟的博客！</title>
  
  <subtitle>Colyn 崛起正当时！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://meng.uno/"/>
  <updated>2018-03-09T07:58:03.486Z</updated>
  <id>http://meng.uno/</id>
  
  <author>
    <name>匡盟盟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM的垃圾回收机制</title>
    <link href="http://meng.uno/articles/dde60b3a/"/>
    <id>http://meng.uno/articles/dde60b3a/</id>
    <published>2018-03-09T07:14:32.000Z</published>
    <updated>2018-03-09T07:58:03.486Z</updated>
    
    <content type="html"><![CDATA[<h1>简介</h1><p>Java GC（Garbage Collection，垃圾收集，垃圾回收）机制，是Java与C++/C的主要区别之一，作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码，对内存泄露和溢出的问题，也不需要像C程序员那样战战兢兢。这是因为在Java虚拟机中，存在自动内存管理和垃圾清扫机制。概括地说，该机制对JVM（Java Virtual Machine）中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，永不停息（Nerver Stop）的保证JVM中的内存空间，防止出现内存泄露和溢出问题。</p><p>关于JVM，需要说明一下的是，目前使用最多的Sun公司的JDK中，自从1999年的JDK1.2开始直至现在仍在广泛使用的JDK6，其中默认的虚拟机都是HotSpot。2009年，Oracle收购Sun，加上之前收购的EBA公司，Oracle拥有3大虚拟机中的两个：JRockit和HotSpot，Oracle也表明了想要整合两大虚拟机的意图，但是目前在新发布的JDK7中，默认的虚拟机仍然是HotSpot，因此本文中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的GC机制。</p><p>学习Java GC机制，可以帮助我们在日常工作中排查各种内存溢出或泄露问题，解决性能瓶颈，达到更高的并发量，写出更高效的程序。</p><h1>解决哪些问题</h1><p>既然是要进行自动GC，那必然会有相应的策略，而这些策略解决了哪些问题呢，粗略的来说，主要有以下几点。</p><ul>  <li>哪些对象可以被回收。</li>  <li>何时回收这些对象。</li>  <li>采用什么样的方式回收。</li></ul><p>说到垃圾回收（Garbage Collection，GC），很多人就会自然而然地把它和Java联系起来。在Java中，程序员不需要去关心内存动态分配和垃圾回收的问题，这一切都交给了JVM来处理。</p><p>顾名思义，垃圾回收就是释放垃圾占用的空间，那么在Java中，什么样的对象会被认定为“垃圾”？那么当一些对象被确定为垃圾之后，采用什么样的策略来进行回收（释放空间）？在目前的商业虚拟机中，有哪些典型的垃圾收集器？</p><h2 id="如何确定某个对象是-垃圾-？">如何确定某个对象是“垃圾”？</h2><p>既然垃圾收集器的任务是回收垃圾对象所占的空间供新的对象使用，那么垃圾收集器如何确定某个对象是“垃圾”？即通过什么方法判断一个对象可以被回收了。</p><p>在java中是通过引用来和对象进行关联的，也就是说如果要操作对象，必须通过引用来进行。那么很显然一个简单的办法就是通过引用计数来判断一个对象是否可以被回收。不失一般性，如果一个对象没有任何引用与之关联，则说明该对象基本不太可能在其他地方被使用到，那么这个对象就成为可被回收的对象了。这种方式成为引用计数法。</p><p>这种方式的特点是实现简单，而且效率较高，但是它无法解决循环引用的问题，因此在Java中并没有采用这种方式（Python采用的是引用计数法）。看下面这段代码：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       MyObject object1 = <span class="keyword">new</span> MyObject();</span><br><span class="line">       MyObject object2 = <span class="keyword">new</span> MyObject();</span><br><span class="line">        </span><br><span class="line">       object1.object = object2;</span><br><span class="line">       object2.object = object1;</span><br><span class="line">        </span><br><span class="line">       object1 = <span class="keyword">null</span>;</span><br><span class="line">       object2 = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span></span>&#123;</span><br><span class="line">   <span class="keyword">public</span> Object object = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>最后面两句将object1和object2赋值为null，也就是说object1和object2指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数都不为0，那么垃圾收集器就永远不会回收它们。</p><p>为了解决这个问题，在Java中采取了 可达性分析法。该方法的基本思想是通过一系列的“GC Roots”对象作为起点进行搜索，如果在“GC Roots”和一个对象之间没有可达路径，则称该对象是不可达的，不过要注意的是被判定为不可达的对象不一定就会成为可回收对象。被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。</p><p>至于可达性分析法具体是如何操作的我暂时也没有看得很明白，如果有哪位朋友比较清楚的话请不吝指教。</p><p>下面来看个例子：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">Object aobj = <span class="keyword">new</span> Object ( ) ;</span><br><span class="line">Object bobj = <span class="keyword">new</span> Object ( ) ;</span><br><span class="line">Object cobj = <span class="keyword">new</span> Object ( ) ;</span><br><span class="line">aobj = bobj;</span><br><span class="line">aobj = cobj;</span><br><span class="line">cobj = <span class="keyword">null</span>;</span><br><span class="line">aobj = <span class="keyword">null</span>;</span><br></pre>      </td>    </tr>  </table></figure><p>第几行有可能会使得某个对象成为可回收对象？第7行的代码会导致有对象会成为可回收对象。至于为什么留给读者自己思考。</p><p>再看一个例子：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">SoftReference&lt;String&gt; sr = </span><br><span class="line"><span class="keyword">new</span> SoftReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"java"</span>));</span><br><span class="line">WeakReference&lt;String&gt; wr = </span><br><span class="line"><span class="keyword">new</span> WeakReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"world"</span>));</span><br></pre>      </td>    </tr>  </table></figure><p>这三句哪句会使得String对象成为可回收对象？第2句和第3句，第2句在内存不足的情况下会将String对象判定为可回收对象，第3句无论什么情况下String对象都会被判定为可回收对象。</p><p>最后总结一下平常遇到的比较常见的将对象判定为可回收对象的情况：</p><ul>  <li>显示地将某个引用赋值为null或者将已经指向某个对象的引用指向新的对象，比如下面的代码：</li></ul><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br><span class="line">Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line">Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line">obj1 = obj2;</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>局部引用所指向的对象，比如下面这段代码：</li></ul><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">       Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">       System.out.println(obj.getClass());</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>循环每执行完一次，生成的Object对象都会成为可回收的对象。</p><ul>  <li>只有弱引用与其关联的对象，比如：</li></ul><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">WeakReference&lt;String&gt; wr = <span class="keyword">new</span> WeakReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"world"</span>));</span><br></pre>      </td>    </tr>  </table></figure><h2 id="典型的垃圾收集算法">典型的垃圾收集算法</h2><p>在确定了哪些垃圾可以被回收后，垃圾收集器要做的事情就是开始进行垃圾回收，但是这里面涉及到一个问题是：如何高效地进行垃圾回收。由于Java虚拟机规范并没有对如何实现垃圾收集器做出明确的规定，因此各个厂商的虚拟机可以采用不同的方式来实现垃圾收集器，所以在此只讨论几种常见的垃圾收集算法的核心思想。</p><p>需要明确的一点是，这里谈到的垃圾回收算法针对的是JVM的堆内存，栈基本上不存在垃圾回收方面的困扰。</p><h3 id="mark-sweep-标记-清除-算法">Mark-Sweep（标记-清除）算法</h3><p>这是最基础的垃圾回收算法，之所以说它是最基础的是因为它最容易实现，思想也是最简单的。标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。</p><p>标记—清除算法是最基础的收集算法，它分为“标记”和“清除”两个阶段：首先标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实就是前面的根搜索算法中判定垃圾对象的标记过程。</p><p>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段。</p><p><img src="http://www.meng.uno/images/gc/3.png" alt=""></p><p><img src="http://www.meng.uno/images/gc/4.png" alt=""></p><p>标记-清除算法实现起来比较容易，但是有一个比较严重的问题就是容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。</p><p>该算法有如下缺点：</p><ul>  <li>标记和清除过程的效率都不高。</li>  <li>标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不触发另一次垃圾收集动作。</li></ul><p>我们在程序（程序也就是指我们运行在JVM上的JAVA程序）运行期间如果想进行垃圾回收，就必须让GC线程与程序当中的线程互相配合，才能在不影响程序运行的前提下，顺利的将垃圾进行回收。</p><p>为了达到这个目的，标记/清除算法就应运而生了。它的做法是当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被成为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。</p><ul>  <li>标记：标记的过程其实就是，遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。</li>  <li>清除：清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。</li></ul><p>就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行。</p><h3 id="copying-复制-算法">Copying（复制）算法</h3><p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。 当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。</p><p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[1]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。 HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。  当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</p><p>内存的分配担保就好比我们去银行借款，如果我们信誉很好，在98%的情况下都能按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有风险了。 内存的分配担保也一样，如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</p><p>复制算法是针对标记—清除算法的缺点，在其基础上进行改进而得到的，它讲课用内存按容量分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面，然后再把已使用过的内存空间一次清理掉。复制算法有如下优点：</p><ul>  <li>每次只对一块内存进行回收，运行高效。</li>  <li>只需移动栈顶指针，按顺序分配内存即可，实现简单。</li>  <li>内存回收时不用考虑内存碎片的出现。</li></ul><p>它的缺点是：可一次性分配的最大内存缩小了一半。</p><p><img src="http://www.meng.uno/images/gc/1.png" alt=""></p><p>这种算法虽然实现简单，运行高效且不容易产生内存碎片，但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。</p><p>很显然，Copying算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低。</p><p>我们首先一起来看一下复制算法的做法，复制算法将内存划分为两个区间，在任意时间点，所有动态分配的对象都只能分配在其中一个区间（称为活动区间），而另外一个区间（称为空闲区间）则是空闲的。</p><p>当有效内存空间耗尽时，JVM将暂停程序运行，开启复制算法GC线程。接下来GC线程会将活动区间内的存活对象，全部复制到空闲区间，且严格按照内存地址依次排列，与此同时，GC线程将更新存活对象的内存引用地址指向新的内存地址。</p><p>此时，空闲区间已经与活动区间交换，而垃圾对象现在已经全部留在了原来的活动区间，也就是现在的空闲区间。事实上，在活动区间转换为空间区间的同时，垃圾对象已经被一次性全部回收。</p><p>很明显，复制算法弥补了标记/清除算法中，内存布局混乱的缺点。不过与此同时，它的缺点也是相当明显的。</p><ol>  <li>它浪费了一半的内存，这太要命了。</li>  <li>如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。</li></ol><p>所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。</p><h3 id="mark-compact-标记-整理-算法">Mark-Compact（标记-整理）算法</h3><p>为了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。</p><p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。 更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p><p>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p>标记/整理算法与标记/清除算法非常相似，它也是分为两个阶段：标记和整理。下面LZ给各位介绍一下这两个阶段都做了什么。</p><ul>  <li>标记：它的第一个阶段与标记/清除算法是一模一样的，均是遍历GC Roots，然后将存活的对象标记。</li>  <li>整理：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段。</li></ul><p>复制算法比较适合于新生代，在老年代中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如标记—整理算法。该算法标记的过程与标记—清除算法中的标记过程一样，但对标记后出的垃圾对象的处理情况有所不同，它不是直接对可回收对象进行清理，而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="http://www.meng.uno/images/gc/2.png" alt=""></p><p>不难看出，标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价，可谓是一举两得，一箭双雕，一石两鸟。</p><p>不过任何算法都会有其缺点，标记/整理算法唯一的缺点就是效率也不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。</p><h3 id="generational-collection-分代收集-算法">Generational Collection（分代收集）算法</h3><p>分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。</p><p>目前大部分垃圾收集器对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照1：1的比例来划分新生代的空间的。一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。</p><p>而由于老年代的特点是每次回收都只回收少量对象，一般使用的是Mark-Compact算法。</p><p>注意，在堆区之外还有一个代就是永久代（Permanet Generation），它用来存储class类、常量、方法描述等。对永久代的回收主要回收两部分内容：废弃常量和无用的类。</p><p>当前商业虚拟机的垃圾收集 都采用分代收集，它根据对象的存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代。在新生代中，每次垃圾收集时都会发现有大量对象死去，只有少量存活，因此可选用复制算法来完成收集，而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记—清除算法或标记—整理算法来进行回收。</p><h2 id="典型的垃圾收集器">典型的垃圾收集器</h2><p>垃圾收集算法是 内存回收的理论基础，而垃圾收集器就是内存回收的具体实现。下面介绍一下HotSpot（JDK 7)虚拟机提供的几种垃圾收集器，用户可以根据自己的需求组合出各个年代使用的收集器。</p><ul>  <li>Serial/Serial Old</li></ul><p>Serial/Serial Old收集器是最基本最古老的收集器，它是一个单线程收集器，并且在它进行垃圾收集时，必须暂停所有用户线程。Serial收集器是针对新生代的收集器，采用的是Copying算法，Serial Old收集器是针对老年代的收集器，采用的是Mark-Compact算法。它的优点是实现简单高效，但是缺点是会给用户带来停顿。</p><ul>  <li>ParNew</li></ul><p>ParNew收集器是Serial收集器的多线程版本，使用多个线程进行垃圾收集。</p><ul>  <li>Parallel Scavenge</li></ul><p>Parallel Scavenge收集器是一个新生代的多线程收集器（并行收集器），它在回收期间不需要暂停其他用户线程，其采用的是Copying算法，该收集器与前两个收集器有所不同，它主要是为了达到一个可控的吞吐量。</p><ul>  <li>Parallel Old</li></ul><p>Parallel Old是Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和Mark-Compact算法。</p><ul>  <li>CMS</li></ul><p>CMS（Current Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是Mark-Sweep算法。</p><ul>  <li>G1</li></ul><p>G1收集器是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器，它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。</p><p><br><br>本文链接： <a href="http://meng.uno/articles/dde60b3a/">http://meng.uno/articles/dde60b3a/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      简介
Java GC（Garbage Collection，垃圾收集，垃圾回收）机制，是Java与C++/C的主要区别之一，作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码，对内存泄露和溢出的问题，也不需要像C程序员那样战战兢兢。这是因为在Java虚拟机中，存在自动内存管理和垃圾清扫机制。概括地说，该机制对JVM（Java Virtual Machine）中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，永不停息（Nerver Stop）的保证JVM中的内存空间，防止出现内存泄露和溢出问题。

关于JVM，需要说明一下的是，目前使用最多的Sun公司的JD
    
    </summary>
    
      <category term="Java开发Tips" scheme="http://meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/"/>
    
    
      <category term="JVM" scheme="http://meng.uno/tags/JVM/"/>
    
      <category term="GC" scheme="http://meng.uno/tags/GC/"/>
    
      <category term="垃圾回收" scheme="http://meng.uno/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>H5网页失去焦点Title改变的方法</title>
    <link href="http://meng.uno/articles/7794c7e7/"/>
    <id>http://meng.uno/articles/7794c7e7/</id>
    <published>2018-03-08T06:33:11.000Z</published>
    <updated>2018-03-08T06:47:36.988Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>今天要讲的其实是一个API：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/visibilitychange" target="_blank" rel="noopener">visibilitychange</a></p></blockquote><p>这个 API 本身非常简单，由以下三部分组成。</p><p>document.hidden：表示页面是否隐藏的布尔值。页面隐藏包括 页面在后台标签页中 或者 浏览器最小化 （注意，页面被其他软件遮盖并不算隐藏，比如打开的 sublime 遮住了浏览器）。</p><p>document.visibilityState：表示下面 4 个可能状态的值</p><p>hidden：页面在后台标签页中或者浏览器最小化</p><p>visible：页面在前台标签页中</p><p>prerender：页面在屏幕外执行预渲染处理 document.hidden 的值为 true</p><p>unloaded：页面正在从内存中卸载</p><p>Visibilitychange事件：当文档从可见变为不可见或者从不可见变为可见时，会触发该事件。</p><p>这样，我们可以监听 Visibilitychange 事件，当该事件触发时，获取 document.hidden 的值，根据该值进行页面一些事件的处理。</p><figure class="highlight html">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>这是原来的title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, maximum-scale=1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> tmptitle = <span class="built_in">document</span>.title;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.addEventListener(<span class="string">'visibilitychange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> isHidden = <span class="built_in">document</span>.hidden;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">if</span> (isHidden) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.title = <span class="string">'当焦点不在当前窗口时的网页标题'</span>;</span></span><br><span class="line"><span class="actionscript">          &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.title = tmptitle;</span></span><br><span class="line"><span class="undefined">          &#125;</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre>      </td>    </tr>  </table></figure><p><br><br>本文链接： <a href="http://meng.uno/articles/7794c7e7/">http://meng.uno/articles/7794c7e7/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      今天要讲的其实是一个API：visibilitychange

这个 API 本身非常简单，由以下三部分组成。

document.hidden：表示页面是否隐藏的布尔值。页面隐藏包括 页面在后台标签页中 或者 浏览器最小化 （注意，页面被其他软件遮盖并不算隐藏，比如打开的 sublime 遮住了浏览器）。

document.visibilityState：表示下面 4 个可能状态的值

hidden：页面在后台标签页中或者浏览器最小化

visible：页面在前台标签页中

prerender：页面在屏幕外执行预渲染处理 document.hidden 的值为 true

unloaded
    
    </summary>
    
      <category term="随笔" scheme="http://meng.uno/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="H5" scheme="http://meng.uno/tags/H5/"/>
    
      <category term="Title" scheme="http://meng.uno/tags/Title/"/>
    
      <category term="焦点" scheme="http://meng.uno/tags/%E7%84%A6%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Unix进程的那些事</title>
    <link href="http://meng.uno/articles/aeaab565/"/>
    <id>http://meng.uno/articles/aeaab565/</id>
    <published>2018-03-04T12:06:22.000Z</published>
    <updated>2018-03-04T12:56:59.397Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>不知道你们有没有这样的疑惑，每次在看资料时遇到<code>fork(2)</code>，我都不理解，为什么<code>fork()</code>函数需要<code>2</code>做参数？还只能是<code>2</code>。</p></blockquote><blockquote>  <p>本篇博客在阅读了《Working with Unix Processes》之后总结而成。</p></blockquote><h1>回答疑问</h1><p>首先，我就来解释一下之前留下的那个疑问，用过Mac或者Linux的同学都知道电脑中有很多<code>man</code>文件夹，我也不知道怎么回事，莫非是因为我是个<code>man</code>？后来我知道了，<code>man</code>是<code>manpages</code>的意思，中文译作“Unix手册页”，和我们现实中使用的手册一样，这个手册也是分节的，其中比较重要的几节：</p><ul>  <li>节1：一般命令</li>  <li>节2：系统调用</li>  <li>节3：C库函数</li>  <li>节4：特殊文件</li></ul><p>那么我们该如何使用这个手册呢？</p><p>很简单 我们只需要：<code>man [节号] 命令名</code>就可以了。</p><p>例如：<code>man 2 fork</code></p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre>      </td>      <td class="code">        <pre><span class="line">     fork() will fail and no child process will be created <span class="keyword">if</span>:</span><br><span class="line"></span><br><span class="line">     [EAGAIN]           The system-imposed limit on the total number of processes under</span><br><span class="line">                        execution would be exceeded.  This limit is configuration-depen-</span><br><span class="line">                        dent.</span><br><span class="line"></span><br><span class="line">     [EAGAIN]           The system-imposed limit MAXUPRC (&lt;sys/param.h&gt;) on the total num-</span><br><span class="line">                        ber of processes under execution by <span class="selector-tag">a</span> single user would be</span><br><span class="line">                        exceeded.</span><br><span class="line"></span><br><span class="line">     [ENOMEM]           There is insufficient swap space <span class="keyword">for</span> the new process.</span><br><span class="line"></span><br><span class="line">LEGACY SYNOPSIS</span><br><span class="line">     <span class="selector-id">#include</span> &lt;sys/types.h&gt;</span><br><span class="line">     <span class="selector-id">#include</span> &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">     The include file &lt;sys/types.h&gt; is necessary.</span><br><span class="line"></span><br><span class="line">SEE ALSO</span><br><span class="line">     execve(<span class="number">2</span>), sigaction(<span class="number">2</span>), wait(<span class="number">2</span>), compat(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">HISTORY</span><br><span class="line">     A fork() function call appeared <span class="keyword">in</span> Version <span class="number">6</span> AT&amp;T UNIX.</span><br><span class="line"></span><br><span class="line">CAVEATS</span><br><span class="line">     There are limits to what you can do <span class="keyword">in</span> the child process.  To be totally safe you</span><br><span class="line">     should restrict yourself to only executing async-signal safe operations until such</span><br><span class="line">     <span class="selector-tag">time</span> as one of the exec functions is called.  All APIs, including global data sym-</span><br><span class="line">     bols, <span class="keyword">in</span> any framework or library should be assumed to be unsafe after <span class="selector-tag">a</span> fork()</span><br><span class="line">     unless explicitly documented to be safe or async-signal safe.  If you need to use</span><br><span class="line">     these frameworks <span class="keyword">in</span> the child process, you must exec.  In this situation it is rea-</span><br><span class="line">     sonable to exec yourself.</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>th Berkeley Distribution        June <span class="number">4</span>, <span class="number">1993</span>        <span class="number">4</span>th Berkeley Distribution</span><br><span class="line">(END)</span><br></pre>      </td>    </tr>  </table></figure><p>这就是完整的对fork(2)的解释。</p><h1>Unix进程</h1><h2 id="提示">提示</h2><p>所有<code>Ruby</code>代码皆需要在<code>irb</code>环境下运行，如何安装<code>Ruby</code>，可以百度。</p><h2 id="进程标识">进程标识</h2><p>每个人都有一个唯一的身份证号，进程也是如此，这个唯一的标识符叫做<code>pid</code>。我们输入：<code>puts Process.pid</code>就可以得到当前进程的pid了。</p><p>pid并不传达关于进程本身的任何信息，它仅仅是一个顺序标识符。在内核眼中进程只是一个数字而已。</p><p>pid是对进程的一种简单通用的描述，至于用途之一，比如我们常常会在日志文件中发现pid，当有多个进程向一个日志文件写入日志的时候，在每一行加入pid就可以知道哪一行日志是由哪个进程写入的。</p><h2 id="父进程">父进程</h2><p>系统中运行的每一个进程都有对应的父进程，每一个进程都知道其父进程的标识符(ppid)。多数情况下特定进程的父进程就是调用它的那个进程。比如启动终端并进入bash提示符，此时新创建的bash进程的父进程就是终端进程。如果在bash中调用ls等命令，那么bash进程便是ls进程的父进程。</p><p>父进程对于检测守护进程有比较重要的作用。</p><p>我们输入：<code>puts Process.ppid</code>就可以得到当前进程的父进程pid了。</p><h2 id="文件描述符">文件描述符</h2><p>我们讨论进程，怎么突然说道“文件”？其实，在Unix眼中，一切皆为“文件”！设备是文件，套接字是文件，文件也是文件。当然为了避免误解，一般将文件称为文件，其他称为资源。</p><p>我们使用这样的语句打印某“文件”的描述符：<code>puts 文件名.fileno</code>。</p><p>例如，STDIN的描述符：<code>puts STDIN.fileno</code>，结果是不是很吃惊？因为居然是<code>0</code>！！！</p><p>同理，排在其后的分别是STDOUT与STDERR，他们三者也被称为标准流。</p><h2 id="资源限制">资源限制</h2><p>文件描述符代表已经打开的资源，当资源没有被关闭时，该资源的文件描述符编号会一直被占用，文件描述符编号一直处于递增状态，而内核为每个进程设置了最大文件描述符号，即施加了一些资源限制。对于文件描述符编号的限制有软限制和硬限制。软限制一般可以比较小而硬限制一般数值比较大而且可以修改。如果超出限制则会报错。</p><p>资源限制除了允许打开的最大资源数以外，还包括可创建的最大文件长度和进程最大段的大小等。对于用户内核会限制其最大并发进程数。</p><p>我们使用<code>p Process.getrlimit(:NOFILE)</code>来获取当前进程的资源限制，在我的电脑上结果是：<code>[256, 9223372036854775807]</code>。</p><p>可能我们觉得软限制256有点少，那好，我们尝试给他设置一个大的。使用如下命令：</p><p><code>Process.setrlimit(:NOFILE,4096)</code></p><h2 id="环境变量">环境变量</h2><p>我们每个人都设置过环境变量，环境变量是包含进程数据的键值对。所有进程都从其父进程继承环境变量，它们由父进程设置并被子进程所继承。每一个进程都有环境变量，环境变量对于特定进程而言是全局性的。比如环境变量PWD对应的值为当前的工作目录等等。环境变量经常作为一种将输入传递到命令行程序中的方法。</p><h2 id="参数">参数</h2><p>所有进程都可以访问名为ARGV的特殊数组（<code>p ARGV</code>），它是一个参数向量或数组。保存了在命令行中传递给当前进程的参数。有些像C语言中main函数中第二个参数：char** argv。</p><h2 id="进程名">进程名</h2><p>系统中每一个进程都有名称，进程名可以在运行期间被修改并作为一种通信手段。一般都会有一个全局变量来存储当前进程的名称。可以通过给这个全局变量赋值来修改当前进程的名称。</p><p>我们可以用<code>puts $PROGRAM_NAME</code>来打印当前进程的进程名。</p><h2 id="退出码">退出码</h2><p>我们写C程序的时候，总是默认加上<code>return 0</code>，可能大家也遇到过其他的返回值，例如<code>exit(1)</code>等，这里的0、1就是退出码。</p><p>所有进程在退出时都带有数字退出码(0-255)用于指明进程是否顺利结束。一般退出码为0的进程被认为是顺利结束，其他的退出码则表明出现了错误，不同的退出码代表不同的错误。</p><p>尽管退出码通常用来表明不同的错误，它们其实是一种通信手段。作为程序员的你可以以适合自己程序的方式来处理各种进程退出码。</p><ul>  <li>exit</li></ul><p>默认进程退出码为<code>0</code>，可以传递指定的退出码。<code>exit 22</code>代表定制进程退出码为<code>22</code>，不指定数字则默认为<code>0</code>，而且指定退出码在<code>0-255</code>之间的数值才是有效的。</p><ul>  <li>exit!</li></ul><p>默认进程退出码为<code>1</code>，可以传递指定的退出码。<code>exit!33</code>代表定制进程退出码为<code>33</code>，不指定数字时默认为<code>1</code>，而且指定退出码在<code>0-255</code>之间的数值才是有效的。</p><ul>  <li>abort</li></ul><p>会将当前进程的退出码设置为<code>1</code>，而且可以传递一条消息给STDERR。例如<code>abort “Something went wrong!”</code>，则进程退出码为<code>1</code>且会在<code>STDERR</code>中打印<code>“Something went wrong”</code>。注意该方法不能指定退出码。</p><ul>  <li>raise</li></ul><p><code>raise</code>方法不会立即结束进程，它只是抛出一个异常，该异常会沿着调用栈向上传递并可能会得到处理。如果没有代码对其进程处理，那么这个未处理的异常将会终结该进程。类似于<code>abort</code>方法，一个未处理的异常会将退出码设置为<code>1</code>。也可以传递一条消息给<code>STDERR</code>。例如<code>raise “Something went wrong!”</code>，则进程退出码为<code>1</code>且会在<code>STDERR</code>中打印<code>“Something went wrong”</code>。<strong>注意该方法也不能指定退出码。</strong></p><h2 id="fork-与友好进程">fork()与友好进程</h2><p>fork()系统调用允许运行中的进程以编程的形式创建新的进程，这个心进程和原始进程一模一样。调用fork()的进程被称为父进程，新创建的进程被称为子进程。因子进程是一个全新的进程，所以它拥有自己唯一的进程id。</p><p>子进程从父进程处继承了其所占用内存中的所有内容，以及所有属于父进程的已打开的文件描述符的编号。这样，两个进程就可以共享打开的文件、套接字等。因子进程会复制父进程在内存中的所有内容，所以子进程可以随意更改其内存内容的副本，而不会对父进程造成任何影响(后面会介绍COW写时复制技术)。</p><p>对于fork()方法的一次调用实际上会返回两次。fork方法创造了一个新进程，在调用进程(父进程)中返回一次，且会返回子进程的pid；在新创建的进程(子进程)中又返回一次，返回0。</p><p>fork创建了一个和旧进程一模一样的新进程。所以试想一个使用了500MB内存的进程进行了衍生，那么就有1GB的内存被占用了。重复同样的操作十次，很快就会耗尽内存，这通常被称为“fork炸弹”。</p><p>所以现代的Unix/Linux操作系统采用写时复制(copy-on-write, COW)的方法来克服这个问题。COW将实际的内存复制操作推迟到了真正需要写入的时候。所以说父进程和子进程实际上是在共享内存中的数据，直到它们其中一个需要对数据进行修改，届时才会进行内存复制，使得两个进程保持适当的隔离。</p><p>这里多补充点COW的知识，自己在面试中也被问到这个问题，当时并不了解这个知识点，所以对这个知识点印象比较深刻。当采用COW技术时，子进程并不完全复制父进程的数据，只是以只读的方式共享父进程的页表，并将符进程的页表项也标记为只读。当父子进程中任何一个进程试图修改这些地址空间时，就会引发系统的页错误异常。异常错误处理程序将会生成该页的一份复制，并修改进程的页表项，指向新生成的页面，并将该页标记为已修改。</p><p>除了修改的数据和页面之外，其余的部分依然可以共享。</p><p>在一些语言当中，比如ruby中，会通过block代码块来使用fork。将一个block代码块传递给fork方法，那么这个block代码块将在新的子进程中执行，而父进程会跳过block中的内容。而且子进程执行完block之后就会退出，并不会像父进程那样指向随后的代码。</p><h2 id="孤儿进程">孤儿进程</h2><p>当父进程结束后而子进程没有结束时，子进程会照常继续运行，此时子进程被称为孤儿进程。孤儿进程会被系统当中的守护进程所收养，该进程是一种长期运行的进程，而且是有意作为孤儿进程存在。</p><h2 id="进程等待与僵尸进程">进程等待与僵尸进程</h2><p>wait是一个阻塞调用，该调用使得父进程一直等到它的某个子进程退出以后才继续执行。wait会返回其等待子进程的pid。wait2会返回两个值(pid, status)。除了pid之外还包括status，该变量存储有大量关于子进程的有用的信息，可让我们获知某个进程是怎样退出的。</p><p>wait/wait2是等待任意子进程的退出，而waitpid/waitpid2则是等待特定的由pid指定的子进程退出。</p><p>内核将退出的进程信息加入到队列，这样以来父进程就总是能够依照子进程退出的顺序接收到信息。就是说，即使子进程退出而父进程还没有准备妥当的时候，父进程也总能够通过队列获取到每个子进程的退出信息。注意，如果不存在子进程，调用wait的任一变体都会抛出ERRNO::ECHILD异常。所以最好让调用wait的数量和创建的子进程的数量相等才不会抛出异常。</p><p>一些服务器会使用看护进程这一模式：有一个衍生出多个并发子进程的进程，这个进程看管这些子进程，确保它们能够保持响应，并对子进程的退出做出响应，这个进程就是看护进程。</p><p>内核会将已退出的子进程的状态信息加入队列，所以即便父进程在子进程退出很久之后才调用wait，依然可以获取它的状态信息。内核会一直保留已退出的子进程的状态信息直到父进程调用wait请求这些消息。如果父进程一直不发出请求，那么状态信息就会被内核一直保留着，因此创建一个即发即弃的子进程却不去请求状态信息，便是在浪费内核资源，比如pid，要知道内核可创建的pid和进程控制块PCB是有限的，如果一直创建进程其父进程却不去请求它的退出信息，那么pid和PCB有可能会被耗尽而使得系统无法继续产生新进程。此时的子进程就被称为僵尸进程，所以说僵尸进程是有害的。</p><p>任何应结束的进程，如果它的状态信息一直未能读取，那么它就是一个僵尸进程，任何子进程在结束之时其父进程仍在运行，那么这个子进程很快就会称为僵尸进程。一旦父进程读取了僵尸进程的状态信息，那么它就不复存在，也就不再消耗内核资源。</p><p>有一种避免僵尸进程出现的方法就是分离父子进程，当父进程新创建一个子进程以后，如果不打算调用wait去等待和读取子进程的退出信息，可以使用detach方法。detach方法核心就是生成一个新线程，这个线程唯一的工作就是等待有pid所指定的那个进程退出并获取进程退出信息，从而确保内核不会一直保留进程的状态信息造成僵尸进程的出现和内核资源的浪费。</p><p>那么怎么识别僵尸进程呢？</p><p>很简答，我们使用如下指令：<code>pid = fork{ sleep 1} ; puts pid; sleep</code>的方式，发现结果为：<code>z</code>。</p><h2 id="信号量">信号量</h2><p>wait为父进程提供了一种很好方式来监管子进程。但它是一个阻塞调用：直到子进程结束，调用才会返回，任何一行代码都可能被信号中断。信号投递时不可靠的。如果你的代码正在处理CHLD信号，这时候另一个子进程结束了，那么你未必能收到第二个CHLD信号(CHLD信号：提醒父进程子进程退出的信号)。如果同一个信号在极短间隔内被多次收到，就会出现这种情况。这时可以考虑使用wait的非阻塞方法，形如<code>wait(-1, Process::WNOHANG)</code>。当获得一个信号并返回值以后就继续等待信号的产生。</p><p>信号是一种异步通信，当进程从内核接收到一个信号时，它可以执行下列某一个操作：</p><ul>  <li>忽略该信号；</li>  <li>执行特定操作；</li>  <li>执行默认操作。</li></ul><p>信号有内核发出，信号是由一个进程发送给另一个进程，不过内核作为中介而已。下表为常用信号介绍，大部分信号的默认行为都是终止进程，其中dump动作表示进程会立即结束并进行核心转储(栈跟踪)，而且比较特殊信号有SIGKILL和SIGSTOP信号不能被捕获、阻塞或忽略，SIGSR1和SIGSR2两个信号对应的操作由你的进程来定义。</p><p>信号是一个了不起的工具，不过捕获一个信号有点像使用全局变量，有可能把其他程序锁依赖的东西给修改了，不过和全局变量不同的是信号处理程序并没有命名空间。从最佳事件角度来说，个人代码不应该定义任何信号处理程序，除非它是服务器。正如一个从命令行启动的长期运行的进程，库代码极少会捕获信号。</p><p>进程可以在任何时候接收到信号，这就是信号的美所在！而且信号是异步的。有了信号，一旦知道了对方的pid，系统中的进程便可以彼此通信，使得信号成为一种极其强大的通信工具，常见的用法是使用kill方法来发送信号。实践当中，信号多是由长期运行的进程响应和使用，例如服务器和守护进程。而多数情况下，发送信号的都是人类用户而非自动化程序。</p><h2 id="进程通讯">进程通讯</h2><p>进程间通信(IPC)两个常见的实用方法是管道和套接字对(socket pairs)。</p><p>管道是一个单向数据流。打开一个管道，一个进程拥有管道的一段，另一个进程拥有另一端。然后数据就沿着管道单向传递。因此如果某个进程将自己作为一个管道的reader，而非writer，那么它就无法向管道中写入数据，反之亦然。例如在ruby脚本程序中：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">reader，writer = IO.pipe</span><br><span class="line">writer.write(<span class="string">"I am writing something.."</span>)</span><br><span class="line">writer.close</span><br><span class="line">puts reader.read</span><br></pre>      </td>    </tr>  </table></figure><p>结果为：</p><figure class="highlight gams">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="title">I</span></span> am writing something..</span><br></pre>      </td>    </tr>  </table></figure><p>pipe返回一个包含两个元素的数组，第一个元素为reader的信息，第二个元素为writer的信息。</p><p>向管道写完信息就关闭writer，是因为reader调用read方法时，会不停地试图从管道中读取数据，直到读到一个EOF(文件结束标志)。这个标志告诉reader已经读完管道中所有的数据了。只要writer保持打开，那么reader就可能读到更多的数据，因此它就会一直等待。在读取之前关闭writer，将一个EOF放入管道中，这样一来，reader获得原始数据之后就会停止读取。要是忘记或者省去关闭writer这一步，那么reader就会被阻塞并不停地试图读取数据。</p><p>因为管道是单向的，所以再上诉程序中，reader只能读取，writer只能写入。</p><p>当某个进程衍生出一个子进程的时候，会与子进程共享打开的资源，管道也被认为是一种资源，它有自己的文件描述符等，因此可以与子进程共享。</p><p>当使用诸如管道或TCP套接字这样的IO流时，将数据写入流中，之后跟着一些特定协议的分隔符，随后从IO流中读取数据时，一次读取一块(chuck)，遇到分隔符就停止读取。</p><p>Unix套接字是一种只能用于在同一台物理主机中进行通信的套接字，它比TCP套接字快很多，非常适合用于IPC。</p><p>管道和套接字都是对进程间通信的有益抽象。它们即快速有简单，多被用作通信通道，来代替更为原始的方法，如共享数据库或日志文件。使用哪种方法取决于自己的需要，不过记得管道提供的是单向通信，套接字提供的是双向通信。</p><h2 id="终端进程">终端进程</h2><p>我们在终端执行每一条命令，其实都是创建了一个终端进程。</p><p>exec()系统调用非常简单，它允许使用另一个进程来替换当前进程，exec()这种转变是有去无回的，一旦你将当前进程转变为另外一个别的进程，那就再也变不回来了。</p><p>在要生成新进程的时候，fork()+exec()的组合是常见的一种用法，使用fork()创建一个新进程，然后用exec()把这个进程变成自己想要的进程，你的当前进程仍像从前一样运行，也仍可以根据需要生成其他进程。如果程序依赖于exec()调用的输出结果，可用wait方法来确保你的程序一直等到子进程完成它的工作，这样就可取回结果。exec()在默认情况下不会关闭任何打开的文件描述符或进行内存清理。</p><p>把字符串传递给exec实际上会启动一个shell进程，然后shell进程对这个字符串进行解释，传递一个数组的话，它会跳过shell，直接将此数组作为新进程的ARGV-参数数组，除非真的需要，一般尽可能地传递数组。</p><p>fork()是有成本的，记住这点有益无害，有时候它会成为性能瓶颈，主要是因为fork()的新子进程的两个独特属性：</p><ul>  <li>获得了一份父进程在内存中所有内容的副本；</li>  <li>获得了父进程已打开的所有文件描述符的副本。</li></ul><p>有一个系统调用posix_spawn，子保留了第2条，没有保留第1条。posix_spawn所生成的子进程可以访问父进程打开的所有文件描述符，却无法与父进程共享内存。这也是为什么posix_spawn比fork快、更有效率的原因。但事务都有两面性，也会因此而缺乏灵活性。</p><h2 id="守护进程">守护进程</h2><p>守护进程是在后台运行的进程，不受终端用户控制。Web服务器或数据库服务器都属于常见的守护进程，它们一直在后台运行响应请求。守护进程也是操作系统的核心功能，有很多进程一直在后台运行以保证系统的正常运行，任何进程都可变成守护进程。</p><p>当内核被引导时会产生一个叫做init的进程。该进程的pid是1，而ppid是0，作为所有进程的祖父。它是首个进程，没有祖先。一个孤儿进程会被init进程收养，孤儿进程的ppid始终是1，这是内核能够确保一直运行的唯一进程。</p><p>每一个进程都属于某个组，每一个组都有唯一的整数id，称为进程组id。进程组是一个相关进程的集合，通常是父进程与子进程。但是也可以按照需要将进程分组，可以通过setpgrp(new_group_ip)方法来设置进程组id。通常情况下，进程组id和进程组组长的id是相同的。进程组组长是终端命令的发起进程。也就是说，如果在终端启动一个进程，那么它就会成为一个新进程组的组长，它所创建的子进程就成为同一个进程组的组员。</p><p>这里进一步说明一下，之前讲过孤儿进程，子进程在父进程退出后会被init进程收养而继续运行，这是父进程退出的行为，但是如果父进程由终端控制并被信号终止的话，孤儿进程也会被终止的。这是因为父子进程属于同一个进程组，而父进程由终端控制，当父进程收到来自终端的终止信号时，与父进程属于同一个进程组的子进程也会收到终止信号而被终止。</p><p>会话组是更高一级的抽象，它是进程组的集合。一个会话组可以依附于一个终端，也可以不依附与任何终端，比如守护进程。终端用一种特殊的方法来处理会话组：发送给会话领导的信号会被转发到该会话中的所有进程组内，然后再转发到这些进程组中的所有进程。系统调用getsid()可用来检索当前的会话组id。</p><p>以下是创建一个守护进程的过程：</p><ul>  <li>首先在终端创建一个进程，并在进程中衍生出一个子进程，然后作为父进程的自己退出。启动该进程的终端察觉到进程退出后，将控制返回给用户，但是衍生出的子进程仍然拥有从父进程中继承而来的组id和会话组id，此时这个衍生进程既非会话领导也非进程组组长。因终端与衍生进程之间仍有牵连，如果终端发送信号到衍生进程的会话组，衍生进程会接收到这个信号，但我们想要的是完全脱离终端。</li>  <li>setsid方法可使得衍生进程成为一个新进程组的组长和新会话组的领导，而且此时新的会话组并没有控制终端。注意，如果在某个已经是进程组组长的进程中调用setsid方法，则会失败，它只能从子进程中调用。</li>  <li>已经成为进程组和会话组组长的衍生进程再次进行衍生，然后自己退出。新衍生出的进程不再是进程组和会话组组长，由于之前会话领导并没有相应的控制终端，且此进程也不是会话领导，因此该进程绝对不会有相应的控制终端存在，如此就可以确保进程现在是完全脱离了控制终端并且可以独立运行。</li>  <li>将进程的工作目录更改为系统的根目录，可避免进程的启动进程出于个各种问题被删除或者卸载。</li>  <li>将所有标准流重定向到“/dev/null”，也就是将其忽略，主要是因为守护进程已不再依附于某个终端会话，所以标准流也就无用了，但是不能简单的关闭，因为一些进程可能还指望它们随时可用。</li></ul><p>以下是ruby语言创建一个守护进程的完整程序：</p><figure class="highlight awk">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">exit</span> <span class="keyword">if</span> fork</span><br><span class="line">Process.setsid</span><br><span class="line"><span class="keyword">exit</span> <span class="keyword">if</span> fork</span><br><span class="line"></span><br><span class="line">Dir.chdir  <span class="string">"/"</span></span><br><span class="line">STDIN.reopen   <span class="string">"/dev/null"</span></span><br><span class="line">STDOUT.reopen   <span class="string">"/dev/null"</span>, <span class="string">"a"</span></span><br><span class="line">STDERR.reopen  <span class="string">"/dev/null"</span>, <span class="string">"a"</span></span><br></pre>      </td>    </tr>  </table></figure><p>对于是否需要创建一个守护进程，就应该问自己一个基本问题：这个进程是否需要一直保持响应？如果答案为否，那么你也许可以考虑定时任务或后台作业系统，如果答案是肯定的，那就去创建，不用犹豫。</p><p><br><br>本文链接： <a href="http://meng.uno/articles/aeaab565/">http://meng.uno/articles/aeaab565/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      不知道你们有没有这样的疑惑，每次在看资料时遇到fork(2)，我都不理解，为什么fork()函数需要2做参数？还只能是2。

本篇博客在阅读了《Working with Unix Processes》之后总结而成。

回答疑问
首先，我就来解释一下之前留下的那个疑问，用过Mac或者Linux的同学都知道电脑中有很多man文件夹，我也不知道怎么回事，莫非是因为我是个man？后来我知道了，man是manpages的意思，中文译作“Unix手册页”，和我们现实中使用的手册一样，这个手册也是分节的，其中比较重要的几节：

 * 节1：一般命令
 * 节2：系统调用
 * 节3：C库函数
 * 节4：特
    
    </summary>
    
      <category term="操作系统" scheme="http://meng.uno/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Unix" scheme="http://meng.uno/tags/Unix/"/>
    
      <category term="进程" scheme="http://meng.uno/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>自制简单搜索引擎及Wiser的使用</title>
    <link href="http://meng.uno/articles/c49b2caf/"/>
    <id>http://meng.uno/articles/c49b2caf/</id>
    <published>2018-03-03T06:10:07.000Z</published>
    <updated>2018-03-03T06:53:43.553Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>自己开发一个搜索引擎，可能是每一个计算机爱好者的梦想，但是当我们看到网上开源搜索引擎那么庞大时，未免有点害怕。那么开发一个搜索引擎真的很难么？</p></blockquote><blockquote>  <p>本博文在阅读了《How to Develop a Search Engineer》之后，总结而成。</p></blockquote><blockquote>  <p>代码下载：<a href="http://www.meng.uno/codes/wiser.zip" target="_blank" rel="noopener">Wiser</a></p></blockquote><h1>搜索引擎简介</h1><p>搜索引擎（Search Engine）是指根据一定的策略、运用计算机技术从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务。在日常生活中，可以看到 Google 等 Web 检索网站，还有邮件检索和专利检索等各种应用程序。</p><h2 id="背景知识">背景知识</h2><p>在自己写一个搜索引擎之前，需要先了解基本的原理和概念。比如分词，倒排索引，排序算法（BM25、PageRank）等。</p><p>搜索引擎工作步骤分为这几步：</p><ul>  <li>爬虫模块 Crawler 在网页上抓取感兴趣的网页数据存储为 Cached pages</li>  <li>索引构造器 Indexer 对 Cached pages 处理生成倒排索引(Inverted Index)</li>  <li>对查询词 Query 在倒排索引中查找对应的文档 Document</li>  <li>计算 Query 和 Document 的关联度，返回给用户 TopK 个结果</li>  <li>根据用户点击 TopK 的行为去修正用户查询的 Query，形成反馈闭环。</li></ul><p>搜索引擎的四大组件：</p><ul>  <li>文档管理器(Document Manager)</li>  <li>索引构建器(Indexer)</li>  <li>索引管理器(Index Manager)</li>  <li>索引检索器(Index Searcher)</li></ul><p>组件关系图：</p><p><img src="http://www.meng.uno/images/se/1.png" alt=""></p><h1>Wiser使用</h1><h3 id="编译运行">编译运行</h3><p>下载好<code>wiser.zip</code>文件，并解压缩到相应位置，进入文件夹，运行<code>make wiser</code>，稍待片刻，即可完成编译。</p><p><img src="http://www.meng.uno/images/se/4.png" alt=""></p><h3 id="收集数据">收集数据</h3><p>在本次使用wiser的实验中，直接从<code>https://dumps.wikimedia.org/zhwiki/latest/</code>下载相应的<code>xml</code>文件即可（省去了实际的爬虫过程）。</p><p><strong>使用wiser存入sqlite使用命令：<code>wiser -x XXX.xml -m 100 wiki.db</code></strong></p><p><img src="http://www.meng.uno/images/se/2.png" alt=""></p><p>此时，我们已经将10条数据存入<code>.db</code>文件中了。</p><h3 id="构建倒排索引">构建倒排索引</h3><p>*在上一步已经完成。</p><h3 id="检索文档">检索文档</h3><p><strong>使用wiser搜索一个关键词使用命令：<code>wiser -q &quot;XXX&quot; wiki.db</code></strong></p><h3 id="排序并呈现">排序并呈现</h3><p><img src="http://www.meng.uno/images/se/3.png" alt=""></p><p>从截图中可见，score代表匹配指数，已经计算好，并返回给我们。</p><h1>Wiser代码剖析</h1><p>在此先简单的介绍各个主要的<code>.c</code>文件实现的功能：</p><ul>  <li><code>wiser.c</code>: 主程序，接收命令行输入，并相应的调用其他函数；</li>  <li><code>database.c</code>: 操作sqlite，包括增，查等功能；</li>  <li><code>search.c</code>: 全文检索，TF-IDF求相关度；</li>  <li><code>postings.c</code>: 倒排索引压缩与解压缩；</li>  <li><code>token.c</code>: 创建倒排索引，N-gram分词；</li>  <li><code>wikiload.c</code>: 加载wikipedia上下载的<code>xml</code>文件；</li>  <li><code>util.c</code>: 编码相关的杂项。</li></ul><p>其他详情，还请实际使用啊！</p><p><br><br>本文链接： <a href="http://meng.uno/articles/c49b2caf/">http://meng.uno/articles/c49b2caf/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      自己开发一个搜索引擎，可能是每一个计算机爱好者的梦想，但是当我们看到网上开源搜索引擎那么庞大时，未免有点害怕。那么开发一个搜索引擎真的很难么？

本博文在阅读了《How to Develop a Search Engineer》之后，总结而成。

代码下载：Wiser

搜索引擎简介
搜索引擎（Search Engine）是指根据一定的策略、运用计算机技术从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务。在日常生活中，可以看到 Google 等 Web 检索网站，还有邮件检索和专利检索等各种应用程序。

背景知识
在自己写一个搜索引擎之前，需要先了解基本的原理和概念。比如分词，
    
    </summary>
    
      <category term="信息检索" scheme="http://meng.uno/categories/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2/"/>
    
    
      <category term="搜索引擎" scheme="http://meng.uno/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
      <category term="Wiser" scheme="http://meng.uno/tags/Wiser/"/>
    
      <category term="倒排文件" scheme="http://meng.uno/tags/%E5%80%92%E6%8E%92%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse的阿里巴巴代码规范配置</title>
    <link href="http://meng.uno/articles/6e79ab7a/"/>
    <id>http://meng.uno/articles/6e79ab7a/</id>
    <published>2018-03-01T15:25:33.000Z</published>
    <updated>2018-03-01T15:25:51.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="插件安装">插件安装</h2><p>环境：JDK1.8，Eclipse4+。有同学遇到过这样的情况，安装插件重启后，发现没有对应的菜单项，从日志上也看不到相关的异常信息，最后把JDK从1.6升级到1.8解决问题。</p><p>Help -&gt; Install New Software…</p><p><img src="https://gw.alicdn.com/tfscom/TB1LOyPifJNTKJjSspoXXc6mpXa.png" alt=""></p><p>输入Update Site地址：<a href="https://p3c.alibaba.com/plugin/eclipse/update" target="_blank" rel="noopener">https://p3c.alibaba.com/plugin/eclipse/update</a> 回车，然后勾选Ali-CodeAnalysis，再一直点Next Next…按提示走下去就好。 然后就是提示重启了，安装完毕。</p><p><img src="https://gw.alicdn.com/tfscom/TB1Ud5kifBNTKJjSszcXXbO2VXa.png" alt=""></p><p>注意：有同学反映插件扫描会触发很多 “JPA Java Change Event Handler (Waiting)” 的任务，这个是Eclipse的一个<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=387455" target="_blank" rel="noopener">bug</a>，因为插件在扫描的时候会对文件进行标记，所以触发了JPA的任务。卸载JPA插件，或者尝试升级到最新版的Eclipse。附：<a href="https://my.oschina.net/cimu/blog/278724" target="_blank" rel="noopener">JPA project Change Event Handler问题解决</a></p><h2 id="插件使用">插件使用</h2><p>目前插件实现了开发手册中的53条规则，大部分基于PMD实现，其中有4条规则基于Eclipse实现，支持4条规则的QuickFix功能。</p><pre><code>* 所有的覆写方法，必须加@Override注解， * if/for/while/switch/do等保留字与左右括号之间都必须加空格,* long或者Long初始赋值时，必须使用大写的L，不能是小写的l）* Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。</code></pre><p>目前不支持代码实时检测，需要手动触发，希望更多的人加入进来一起把咱们的插件做得越来越好，尽量提升研发的使用体验。</p><h3 id="代码扫描">代码扫描</h3><p>可以通过右键菜单、Toolbar按钮两种方式手动触发代码检测。同时结果面板中可以对部分实现了QuickFix功能的规则进行快速修复。</p><h4 id="触发扫描">触发扫描</h4><p>在当前编辑的文件中点击右键，可以在弹出的菜单中触发对该文件的检测。</p><p><img src="https://gw.alicdn.com/tfscom/TB1XGo8iPihSKJjy0FeXXbJtpXa.png" alt=""></p><p>在左侧的Project目录树种点击右键，可以触发对整个工程或者选择的某个目录、文件进行检测。</p><p><img src="https://gw.alicdn.com/tfscom/TB18UsJi2NZWeJjSZFpXXXjBFXa.png" alt=""></p><p>也可以通过Toolbar中的按钮来触发检测，目前Toolbar的按钮触发的检测范围与您IDE当时的焦点有关，如当前编辑的文件或者是Project目录树选中的项，是不是感觉与右键菜单的检测范围类似呢。</p><p><img src="https://gw.alicdn.com/tfscom/TB1vt1oifBNTKJjSszcXXbO2VXa.png" alt=""></p><h4 id="扫描结果">扫描结果</h4><p>简洁的结果面板，按规则等级分类，等级-&gt;规则-&gt;文件-&gt;违规项。同时还提供一个查看规则详情的界面。</p><p>清除结果标记更方便，支持上面提到的4条规则QuickFix。</p><p><img src="https://gw.alicdn.com/tfscom/TB1_uFJi6ihSKJjy0FlXXadEXXa.png" alt=""></p><h4 id="查看所有规则">查看所有规则</h4><p><img src="https://gw.alicdn.com/tfscom/TB1UNTnmYsTMeJjSszhXXcGCFXa.png" alt="">  <img src="https://gw.alicdn.com/tfscom/TB1_rf7sOAKL1JjSZFoXXagCFXa.png" alt=""></p><h4 id="国际化">国际化</h4><p><img src="https://gw.alicdn.com/tfscom/TB1KsyYsiFTMKJjSZFAXXckJpXa.png" alt=""></p><p><img src="https://gw.alicdn.com/tfscom/TB19bzdm3oQMeJjy1XaXXcSsFXa.png" alt=""></p><p><br><br>本文链接： <a href="http://meng.uno/articles/6e79ab7a/">http://meng.uno/articles/6e79ab7a/</a> 欢迎转载！</p><div><h1>其他推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="http://meng.uno/articles/548d5dfd/">Eclipse的Google样式Java代码自动规范配置</a></li><li><a href="http://meng.uno/articles/b0b4f7ec/">汇编语言代码规范</a></li><li><a href="http://www.libinx.com/2017/several-good-habits-in-project-development/">Python | 项目开发中的几个习惯</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      插件安装
环境：JDK1.8，Eclipse4+。有同学遇到过这样的情况，安装插件重启后，发现没有对应的菜单项，从日志上也看不到相关的异常信息，最后把JDK从1.6升级到1.8解决问题。

Help -&gt; Install New Software…



输入Update Site地址：https://p3c.alibaba.com/plugin/eclipse/update 回车，然后勾选Ali-CodeAnalysis，再一直点Next Next…按提示走下去就好。 然后就是提示重启了，安装完毕。



注意：有同学反映插件扫描会触发很多 “JPA Java Change Event Ha
    
    </summary>
    
      <category term="Java开发Tips" scheme="http://meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/"/>
    
      <category term="代码规范" scheme="http://meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="代码规范" scheme="http://meng.uno/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
      <category term="Alibaba Format" scheme="http://meng.uno/tags/Alibaba-Format/"/>
    
      <category term="Eclipse" scheme="http://meng.uno/tags/Eclipse/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse的Google样式Java代码自动规范配置</title>
    <link href="http://meng.uno/articles/548d5dfd/"/>
    <id>http://meng.uno/articles/548d5dfd/</id>
    <published>2018-03-01T12:59:33.000Z</published>
    <updated>2018-03-01T15:24:23.946Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>不知道大家在用Eclipse的时候有没有感觉到，当代码量一大就看不懂自己代码了呢？有人可能要说了，eclipse不是自己带有格式化代码工具吗？确实如此，但是我们可能想使用更高级的自动化工具，例如Google—Java-Style。这篇博文，我将展示如何使用eclipse自带的自动化代码规范工具，以及怎么配置Google-Java-Style。</p></blockquote><h1>准备</h1><p>文件下载：</p><ul>  <li>Eclipse: <a href="http://www.eclipse.org/" target="_blank" rel="noopener">进入官网</a></li>  <li>Google Java Format File: <a href="http://meng.uno/utils/eclipse-java-google-style.xml">点击下载</a></li></ul><h1>使用Eclipse自带</h1><ul>  <li>快捷键： <code>Ctrl/Command + Shift + F</code></li>  <li>鼠标：    <ul>      <li>单个文件：进入文件/对着文件名<code>点右键</code> &gt; 找到<code>Source</code> &gt; 点击<code>Format</code> (其实就是快捷键的作用！)</li>      <li>项目：对着项目名/包名<code>点右键</code> &gt; 找到<code>Source</code> &gt; 点击<code>Format</code></li>    </ul>  </li></ul><p>如下截图：</p><p><img src="http://www.meng.uno/images/format/3.png" alt="右键"></p><h1>更换成Google Style</h1><p>当我们下载了本博客提供的<code>eclipse-java-google-style.xml</code>，就可以开始为formatter改风格了。</p><ul>  <li>打开eclipse的<code>Preferences</code>找到<code>Java</code>，再展开<code>Code Style</code>，找到<code>Formatter</code>。</li></ul><p><img src="http://www.meng.uno/images/format/1.jpg" alt="Code Style"></p><p>点击<code>Import</code>，在弹出窗口里选择我们下载的文件，确定即可。</p><p><img src="http://www.meng.uno/images/format/2.jpg" alt="Code Style"></p><p>再次进入项目，对着想要格式化的对象进行格式化操作，在进度条走完，我们就得到一份Google Java Style的代码了。</p><h1>后记</h1><ul>  <li>按照相似的步骤，我们也可以<code>Import</code>其他风格的代码规范；</li>  <li>Google不仅提供了eclipse上Java的代码规范，还有其他很多规范，详见<a href="https://github.com/google/styleguide" target="_blank" rel="noopener">Goole Style Guile</a></li>  <li>如果任何代码规范都不和心意，也可以打开某个代码规范，自己做相应的改动。</li></ul><p><img src="http://www.meng.uno/images/format/4.png" alt="Code Style"></p><p><br><br>本文链接： <a href="http://meng.uno/articles/548d5dfd/">http://meng.uno/articles/548d5dfd/</a> 欢迎转载！</p><div><h1>其他推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="http://meng.uno/articles/6e79ab7a/">Eclipse的阿里巴巴代码规范配置</a></li><li><a href="http://meng.uno/articles/b0b4f7ec/">汇编语言代码规范</a></li><li><a href="http://www.libinx.com/2017/several-good-habits-in-project-development/">Python | 项目开发中的几个习惯</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      不知道大家在用Eclipse的时候有没有感觉到，当代码量一大就看不懂自己代码了呢？有人可能要说了，eclipse不是自己带有格式化代码工具吗？确实如此，但是我们可能想使用更高级的自动化工具，例如Google—Java-Style。这篇博文，我将展示如何使用eclipse自带的自动化代码规范工具，以及怎么配置Google-Java-Style。

准备
文件下载：

 * Eclipse: 进入官网
 * Google Java Format File: 点击下载

使用Eclipse自带
 * 快捷键： Ctrl/Command + Shift + F
 * 鼠标：  * 单个文件：进入文件/
    
    </summary>
    
      <category term="Java开发Tips" scheme="http://meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/"/>
    
      <category term="代码规范" scheme="http://meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="代码规范" scheme="http://meng.uno/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
      <category term="Eclipse" scheme="http://meng.uno/tags/Eclipse/"/>
    
      <category term="Google Format" scheme="http://meng.uno/tags/Google-Format/"/>
    
  </entry>
  
  <entry>
    <title>What are Human Genome Project and ENCODE Project?</title>
    <link href="http://meng.uno/articles/32469d52/"/>
    <id>http://meng.uno/articles/32469d52/</id>
    <published>2018-02-18T11:54:31.000Z</published>
    <updated>2018-02-18T13:25:50.293Z</updated>
    
    <content type="html"><![CDATA[<h1>Human Genome Project</h1><h2 id="the-profile-of-the-project">The Profile of the Project</h2><p>人类基因组计划(Human Genome Project,简称HGP)是由美国科学家于1985年率先提出，又于1990年正式启动的。来自美国、英国、法国、德国、日本和中国科学家共同参与了这一预算达30亿美元的人类基因组计划。按照这个计划的设想，在2005年，要把人体内约10万个基因的密码全部解开，同时绘制出人类基因的谱图。换句话说，就是要揭开组成人体4万个基因的30亿个碱基对的秘密。</p><p>这一计划的最终目的是测定人类基因组30亿个基本化学组成（称为碱基对或核苷酸），进而揭开与人类的生老病死有关的数万个基因的相互关系。1984年，美国能源部开会，开始酝酿“人类基因组计划”。1989年，美国能源部和美国国家卫生研究所提出了人类基因图谱工程。美国在1990年10月1日率先启动人类基因组计划。美国人类基因组顾问委员会委员梅纳德•奥尔森是人类基因组计划最早的推动者之一，另外美国一个测序中心的主任罗伯特•沃特斯顿以及英国的人类基因组总负责人均表示支持。美国完成人类基因组计划近54%的工作量，为人类基因组计划最大的贡献国。英国是人类基因组计划的第二大贡献国，共34%的贡献都是由Wellcome基金会资助的Sanger中心完成的。日本、法国、德国对人类基因组计划的贡献分别为6.8%、2.8%与2.2%。中国承担了3号染色体区域短臂端粒侧约30  cM，约占人类整个基因组1% 的测序工作。中国的华大基因、国家自然科学基金会、中科院遗传所南方基因中心、北方人类基因组中心等单位及于军、杨焕明、汪建、刘斯奇、吴旻、强伯勤、陈竺等也给予人类基因组计划大力的推动。</p><h2 id="the-importance-of-the-project">The Importance of the Project</h2><h3 id="目的">目的</h3><p>人类是在“进化”历程上最高级的生物，对人类基因的研究有助于认识自身、掌握生老病死规律、疾病的诊断和治疗、了解生命的起源。 测出人类基因组DNA的30亿个碱基对的序列，发现所有人类基因，找出它们在染色体上的位置，破译人类全部遗传信息。</p><p>在人类基因组计划中，还包括对五种生物基因组的研究：大肠杆菌、酵母、线虫、果蝇和小鼠，称之为人类的五种“模式生物”。</p><p>HGP的目的是解码生命、了解生命的起源、了解生命体生长发育的规律、认识种属之间和个体之间存在差异的起因、认识疾病产生的机制以及长寿与衰老等生命现象、为疾病的诊治提供科学依据。</p><h3 id="意义">意义</h3><p>人类基因组计划是一项规模宏大，跨国跨学科的科学探索工程。其宗旨在于测定组成人类染色体(指单倍体)中所包含的30亿个碱基对组成的核苷酸序列，从而绘制人类基因组图谱，并且辨识其载有的基因及其序列，达到破译人类遗传信息的最终目的。基因组计划是人类为了探索自身的奥秘所迈出的重要一步。</p><p>“人类基因组计划”与”曼哈顿原子弹计划”和”阿波罗计划”并称为二十世纪三大科学计划。</p><h2 id="the-achievement-of-the-project">The Achievement of the Project</h2><p>2000年6月26日，美国总统克林顿与英国首相布莱尔共同宣布人类基因组计划工作草图完成；次年2月，工作草图的具体序列信息、测序所采用的方法以及序列的分析结果被国际人类基因组测序联盟和塞雷拉基因组的科学家分别公开发表于《自然》与《科学》杂志。这一工作草图覆盖了基因组序列的83％，包括常染色质区域的90％（带有150,000个空缺，且许多片断的顺序和方位并没有得到确定）。</p><p>2001年2月12日，美国Celera公司与人类基因组计划分别在《科学》和《自然》杂志上公布了人类基因组精细图谱及其初步分析结果。</p><p>2003年，发现了新的方法通过检测另外的库来关闭Gaps。使用FISH技术或其他方法来分析没有闭合的Gaps大小。22，21条染色体就是用这种方式。</p><p>1999年至2006年，完成了全部23条染色体的测序工作，具体如下：</p><p>1999年12月，22号染色体测序完成；</p><p>2000年5月，21号染色体测序完成；</p><p>2001年12月，20号染色体测序完成；</p><p>2003年2月，14号染色体测序完成；</p><p>2003年6月，男性特有的Y染色体测序完成；</p><p>2003年5月和7月，7号染色体测序完成；</p><p>2003年10月，6号染色体测序完成；</p><p>2004年4月，13号和19号染色体测序完成；</p><p>2004年5月，9号和10号染色体测序完成；</p><p>2004年9月，5号染色体测序完成；</p><p>2004年12月，16号染色体测序完成；</p><p>2005年3月，X染色体测序完成；</p><p>2005年4月，2号和4号染色体测序完成；</p><p>2005年9月，18号染色体测序完成；</p><p>2006年1月，8号染色体测序完成；</p><p>2006年3月，11号,12号和15号染色体测序完成；</p><p>2006年4月，17号和3号染色体测序完成；Human Genome Project Information</p><p>2006年5月，1号染色体测序完成；Human Genome Project Information</p><p>2004年，国际人类基因组测序联盟的研究者宣布，人类基因组中所含基因的预计数目从先前的30,000至40,000（在计划初期的预计数目则高达2,000,000）调整为20,000至25,000。预期还需要多年的时间来确定人类基因组中所含基因的精确数目。</p><p>截止到2005年，人类基因组计划的测序工作已经完成。</p><h2 id="the-research-contents-of-the-project">The Research Contents of the Project</h2><h3 id="遗传图谱">遗传图谱</h3><p>遗传图谱又称连锁图谱（linkage map），它是以具有遗传多态性（在一个遗传位点上具有一个以上的等位基因，在群体中的出现频率皆高于1%）的遗传标记为“路标”，以遗传学距离（在减数分裂事件中两个位点之间进行交换、重组的百分率，1%的重组率称为1cM）为图距的基因组图。遗传图谱的建立为基因识别和完成基因定位创造了条件。意义：6000多个遗传标记已经能够把人的基因组分成6000多个区域，使得连锁分析法可以找到某一致病的或表现型的基因与某一标记邻近（紧密连锁）的证据，这样可把这一基因定位于这一已知区域，再对基因进行分离和研究。对于疾病而言，找基因和分析基因是个关键。</p><h3 id="物理图谱">物理图谱</h3><p>物理图谱是指有关构成基因组的全部基因的排列和间距的信息，它是通过对构成基因组的DNA分子进行测定而绘制的。绘制物理图谱的目的是把有关基因的遗传信息及其在每条染色体上的相对位置线性而系统地排列出来。DNA物理图谱是指DNA链的限制性酶切片段的排列顺序，即酶切片段在DNA链上的定位。因限制性内切酶在DNA链上的切口是以特异序列为基础的，核苷酸序列不同的DNA，经酶切后就会产生不同长度的DNA片段，由此而构成独特的酶切图谱。因此，DNA物理图谱是DNA分子结构的特征之一。DNA是很大的分子，由限制酶产生的用于测序反应的DNA片段只是其中的极小部分，这些片段在DNA链中所处的位置关系是应该首先解决的问题，故DNA物理图谱是顺序测定的基础，也可理解为指导DNA测序的蓝图。广义地说，DNA测序从物理图谱制作开始，它是测序工作的第一步。制作DNA物理图谱的方法有多种，这里选择一种常用的简便方法──标记片段的部分酶解法，来说明图谱制作原理。</p><h3 id="序列图谱">序列图谱</h3><p>随着遗传图谱和物理图谱的完成，测序就成为重中之重的工作。DNA序列分析技术是一个包括制备DNA片段化及碱基分析、DNA信息翻译的多阶段的过程。通过测序得到基因组的序列图谱。</p><h3 id="基因图谱">基因图谱</h3><h4 id="简介">简介</h4><p>基因图谱是在识别基因组所包含的蛋白质编码序列的基础上绘制的结合有关基因序列、位置及表达模式等信息的图谱。在人类基因组中鉴别出占具2%~5%长度的全部基因的位置、结构与功能，最主要的方法是通过基因的表达产物mRNA反追到染色体的位置。</p><h4 id="意义-v2">意义</h4><p>它能有效地反应在正常或受控条件中表达的全基因的时空图。通过这张图可以了解某一基因在不同时间不同组织、不同水平的表达；也可以了解一种组织中不同时间、不同基因中不同水平的表达，还可以了解某一特定时间、不同组织中的不同基因不同水平的表达。人类基因组是一个国际合作项目：表征人类基因组，选择的模式生物的DNA测序和作图，发展基因组研究的新技术，完善人类基因组研究涉及的伦理、法律和社会问题，培训能利用HGP发展起来的这些技术和资源进行生物学研究的科学家，促进人类健康。</p><h2 id="the-contributions-of-the-project">The Contributions of the Project</h2><h3 id="对人类疾病的贡献">对人类疾病的贡献</h3><p>人类疾病相关的基因是人类基因组中结构和功能完整性至关重要的信息。对于单基因病，采用“定位克隆”和“定位候选克隆”的全新思路，导致了亨廷顿氏舞蹈症、遗传性结肠癌和乳腺癌等一大批单基因遗传病致病基因的发现，为这些疾病的基因诊断和基因治疗奠定了基础。对于心血管疾病、肿瘤、糖尿病、神经精神类疾病（老年性痴呆、精神分裂症）、自身免疫性疾病等多基因疾病是疾病基因研究的重点。健康相关研究是HGP的重要组成部分，1997年相继提出：“肿瘤基因组解剖计划”“环境基因组学计划”。</p><h3 id="对医学的贡献">对医学的贡献</h3><p>基因诊断、基因治疗和基于基因组知识的治疗、基于基因组信息的疾病预防、疾病易感基因的识别、风险人群生活方式、环境因子的干预。</p><h3 id="对生物技术的贡献">对生物技术的贡献</h3><h4 id="基因工程药物">基因工程药物</h4><p>分泌蛋白（多肽激素，生长因子，趋化因子，凝血和抗凝血因子等）及其受体。</p><h4 id="诊断和研究试剂">诊断和研究试剂</h4><p>基因和抗体试剂盒、诊断和研究用生物芯片、疾病和筛药模型。</p><h4 id="细胞工程">细胞工程</h4><p>胚胎和成年期干细胞、克隆技术、器官再造技术。</p><h2 id="the-project-with-china">The Project with China</h2><p>作为继美、英、法、德、日6个成员国之后中唯一的发展中国家，中国对人类基因组的的贡献不只是工作量，在这个划时代的里程碑上，已经刻上了中国人的名字，中国在生物组学的发展上占有一席之地，通过参与这一计划，我们可以分享数据、资源、技术与发言权，最终来开发我国自己的基因资源。中国的加入改变了国际人类基因组计划原有的组织格局，提高其国际合作的形象，带来了国际社会对“国际人类基因组计划精神”的支持，联合国教科文组织关于人类基因组基本信息免费共享的声明，就是在中国代表的直接努力下促成的。可以说，中国需要人类基因组计划，而基因组计划也使我国的基因测序能力进人世界前列，在中国本土成长起来的作为我国基因组学的典型代表、创新型机构——华大基因已经成为全球最大的基因组学中心。</p><p>因此，人类基因组计划对华大基因的影响力也是举足轻重的，华大基因也因此而“生”的伟大。华大基因随着“国际人类基因组计划1%项目”的正式启动而诞生。华大基因自成立之日起就站在世界同步的轨迹上，使得中国的基因组学研究位于跟踪——参与——同步的国际地位。为后期的华大基因在基因组上的引领及跨越式发展奠定了基础。</p><p>在人类基因组计划之后，人类基因研究开始朝着与人类生育健康、肿瘤个体化治疗、病原微生物、遗传性疾病、血液病等的相关疾病的基因检测方向发展，未来，医疗技术将从末端的疾病治疗，逐步走向前端的基因诊断和预防，个性化医疗及精准医疗。人类将通过基因检测技术、通过个性化医疗以更精确的诊断，预测潜在疾病的风险，提供更有效、更有针对性的治疗，预防某种疾病的发生，比“治有病”更节约治疗成本。</p><p>华大基因希望凭借全球领先的基因组学技术，华大基因将千万家庭远离遗传性出生缺陷，肿瘤能早期检测和诊断并能全景式、定期监控个人健康动态，人人做到“我的基因我知道，我的健康我做主”。其研究方向主要涉及遗传性出生缺陷、肿瘤、心脑血管疾病、精准医疗 # The ENCODE Project</p><h2 id="the-profile-of-the-project-v2">The Profile of the Project</h2><p>The ENCODE Project（即Encyclopedia Of DNA Elements，中文译作DNA元件百科全书计划），是美国国立人类基因组研究院（US National Human Genome Research Institute，NHGRI）在2003年9月启动的跨国研究项目。该项目旨在解析人类基因组中的所有功能性元件，它是人类基因组计划完成之后，又一重要的跨国基因组学研究项目。该项目联合了来自美国，英国，西班牙，新加坡和日本的32个实验室的422名科学家的努力，获得了迄今最详细的人类基因组分析数据（他们获得并分析了超过15兆兆字节的原始数据）。研究花费了约300年的计算机时间，对147个组织类型进行了分析，以确定哪些能打开和关闭特定的基因，以及不同类型细胞之间的“开关”存在什么差异。</p><h2 id="the-achievement-of-the-project-v2">The Achievement of the Project</h2><p>近年来基因研究已经取得巨大进展。不过，迄今为止，这些研究主要还集中在编码蛋白的特定基因上，而它们所佔的比例不到整个人类基因组的2%。ENCODE计划首次系统地研究了所有类型的功能元件的位点和组织方式。</p><p>迄今为止，ENCODE计划主要集中研究了44个靶标共3000万个DNA硷基对。负责该计划数据整合和分析工作的欧洲分子生物学实验室主任Ewan Birney说：“我们的结论揭示了有关DNA功能元件构成的重要原理，为从DNA转录到哺乳动物进化的一切过程提供了新的认识。”</p><p>研究发现，人类基因组中的大多数DNA都会转录成RNA，这些副本会普遍交叠。因此，人类基因组实际上是一个非常复杂的网络，所谓的无用基因实际上非常少。基因只不过是众多具有特定功能的DNA序列类型之一。科学家们在基因之外的调控区域新发现了4491个转录启动位点，这一数字超过了已知基因的10倍。这些都挑战了长期以来的一个观点，即基因组中的基因是孤立的，同时，新的发现也支持了人类基因数量应该超过3万个的看法。</p><p>ENCODE计划的另一个巨大成就就是对哺乳动物基因组进化的认识。传统理论认为，与生理功能相关的重要DNA序列往往位于基因组中的“进化限制”区域，它们在物种进化过程中更容易保存下来。但是，最新的研究表明，大约一半人类基因组中的功能元件在进化过程中不会受到很大限制。科学家认为，哺乳动物缺乏“进化限制”这一点，很可能意味著许多物种的基因组都囊括了大量包括RNA转录副本在内的功能元件，在进化过程中，这些功能元件成了基因“仓库”。</p><p>此次ENCODE计划的成果亮点还包括：确定了许多之前不为人知的DNA转录启动位点；推翻了传统观点的认识，调控区域也有可能位于DNA转录启动位点的下游；确定了组蛋白变化的特定标记；加深了人们对组蛋白改变协调DNA复制的理解。</p><p>2012年9月5日，ENCODE项目的阶段性研究结果被整理成30篇论文发表于《自然》（6篇），《基因组研究》（6篇）和《基因组生物学》（18篇）上。</p><p>研究结果显示，人类基因组内的非编码DNA至少80%是有生物活性的，而并非之前认为的“垃圾” DNA （junk DNA）。这些新的发现有望帮助研究人员理解基因受到控制的途径，以及澄清某些疾病的遗传学风险因子。 ENCODE是人类基因组计划之后国际科学界在基因组学研究领域取得的又一重大进展。</p><p>2012年12月21日，ENCODE项目被《科学》杂志评为本年度十大科学突破之一。</p><h2 id="the-research-contents-of-the-project-v2">The Research Contents of the Project</h2><h3 id="试点研究的内容">试点研究的内容</h3><p>对编码的功能DNA进行鉴定和分类；对已存在的几种方法进行测试和比较，严格分析了人类基因组序列中已被定义的序列。</p><p>阐明人类生物学和疾病之间的关系。</p><p>对大量鉴定基因特征的方法、技术和手段进行检测和评估。</p><h3 id="研究对象">研究对象</h3><p>编码蛋白基因</p><p>非编码蛋白基因</p><p>调控区域</p><p>染色体结构维持和调节染色体复制能力的DNA元件</p><h3 id="研究特点">研究特点</h3><p>采用综合性研究策略</p><p>重视新技术的研发</p><p>将计划向学术界和公司开放</p><h2 id="the-contributions-of-the-project-v2">The Contributions of the Project</h2><h3 id="人细胞转录全景图">人细胞转录全景图</h3><p>通过ENCODE项目，人们知道RNA是基因组编码的遗传信息的直接输出。细胞的大部分调节功能都集中在RNA的合成、加工和运输、修饰和翻译之中。研究人员证实，75%的人基因组能够发生转录，并且观察到几乎所有当前已标注的RNA和上千个之前未标注的RNA的表达范围与水平、定位、加工命运、调节区和修饰。总之，这些观察结果表明人们需要重新定义基因的概念。</p><h3 id="人基因组中可访问的染色质全景图">人基因组中可访问的染色质全景图</h3><p>DNase I超敏感位点(DNase I hypersensitive sites, DHSs)是调节性DNA序列的标记物。研究人员通过对125个不同的细胞和组织类型进行全基因组谱分析而鉴定出大约290万个人DHSs，并且首次大范围地绘制出人DHSs图谱。</p><h3 id="基因启动子的远距离相互作用全景图">基因启动子的远距离相互作用全景图</h3><p>在ENCODE项目中，研究人员选择1%的基因组作为项目试点区域，并且利用染色体构象捕获碳拷贝(chromosome conformation capture carbon copy, 简称为5C)技术来综合性地分析了这个区域中转录起始位点和远端序列元件之间的相互作用。他们获得GM12878、K562和HeLa-S3细胞的5C图谱。在每个细胞系，他们发现启动子和远端序列元件之间存在1000多个远距离相互作用。</p><h3 id="gencode：encode项目的人基因组参照标注">GENCODE：ENCODE项目的人基因组参照标注</h3><p>GENCODE项目旨在利用计算分析、人工标注和实验验证来鉴定出人基因组中所有的基因特征。GENCODE第七版(GENCODE v7)公开发布了基因组标注数据集，包含了20687个蛋白编码的RNA基因座位、9640个长链非编码RNA基因座位，并且拥有33977个在UCSC基因数据库和RefSeq数据库中不存在的编码性转录本。它还对公开获得的长链非编码RNA(long noncoding RNA, lncRNA)进行最全面的标注。</p><h1>我的认识</h1><p>在上这门课之前，我从没认真想过这个问题，到底研究基因有什么用？通过这几天的学习，以及对文章所提的两个项目的检索、认识，我对基因测序这一工作，有了更深层次的认识。</p><p>虽然外界关于基因测序有不同的看法，例如有人支持，因为它可以为医学做贡献；有人反对，因为这样做相当于为基因做了一次曝光，这样一来，就有优劣基因之分。在我看来，这一任务还是利大于弊的，毕竟现在看来是这样。科学家可以通过对已有的基因测序结果的分析，总结出基因的“中心法则”，使我们对自身有了更进一步的了解。再者，基因分析有很多好的应用，通过对胎儿基因分析可以达到优生的目的，以及对有基因缺陷、先天性遗传病患者可以提供治标治本的治疗方案。</p><p>当然，要了解所有基因的功能还有很长的一段路要走。例如以前人们所认为的垃圾DNA实际上并不“垃圾”，它们在基因组的进化、每个个体的差异性以及许多其他方面扮演着重要角色，是世界上许多实验室着力研究的目标。</p><p>即使已经过了将近30年，人类基因组也没有完成“完全”测序，不过我们了解到了基因并不是静态的，而是处在复杂的变化之中，所以对人类基因的研究也是对人类自身的研究，这一研究将会一直进行下去，永无终点。 虽然人类基因组目前也只是一张初步的蓝图，需要经过更多的研究和分析。但是人类已经通过对基因组的学习，进入了医学的新纪元，为预防、诊断和治疗疾病带来了新的方法。所以对基因组的研究势必将成为人类新的曙光。</p><p>总之，我对基因组计划以及ENCODE计划充满期待与支持。</p><h1>参考资料</h1><ol>  <li>HGP计划百度百科：<a href="http://dwz.cn/3ITVf3" target="_blank" rel="noopener">http://dwz.cn/3ITVf3</a></li>  <li>人类基因组计划- 维基百科http://dwz.cn/3JHOap</li>  <li>科学松鼠会之人类基因组计划 <a href="http://dwz.cn/3JHOXZ" target="_blank" rel="noopener">http://dwz.cn/3JHOXZ</a></li>  <li>ENCODE项目百度百科：<a href="http://dwz.cn/3ITSPr" target="_blank" rel="noopener">http://dwz.cn/3ITSPr</a></li>  <li>Genome网 <a href="https://www.genome.gov/10005107/encode-project" target="_blank" rel="noopener">https://www.genome.gov/10005107/encode-project</a></li>  <li>ENCODE项目官网：<a href="https://www.encodeproject.org" target="_blank" rel="noopener">https://www.encodeproject.org</a></li>  <li>“DNA元件百科全书”首批成果出炉，链接：<a href="http://big5.cas.cn/xw/kjsm/gjdt/200706/t20070619_1011212.shtml" target="_blank" rel="noopener">http://big5.cas.cn/xw/kjsm/gjdt/200706/t20070619_1011212.shtml</a></li></ol><p><br><br>本文链接： <a href="http://meng.uno/articles/32469d52/">http://meng.uno/articles/32469d52/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      Human Genome Project
The Profile of the Project
人类基因组计划(Human Genome Project,简称HGP)是由美国科学家于1985年率先提出，又于1990年正式启动的。来自美国、英国、法国、德国、日本和中国科学家共同参与了这一预算达30亿美元的人类基因组计划。按照这个计划的设想，在2005年，要把人体内约10万个基因的密码全部解开，同时绘制出人类基因的谱图。换句话说，就是要揭开组成人体4万个基因的30亿个碱基对的秘密。

这一计划的最终目的是测定人类基因组30亿个基本化学组成（称为碱基对或核苷酸），进而揭开与人类的生老病死有关的数万个
    
    </summary>
    
      <category term="生物信息" scheme="http://meng.uno/categories/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="生物信息" scheme="http://meng.uno/tags/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF/"/>
    
      <category term="Genome" scheme="http://meng.uno/tags/Genome/"/>
    
      <category term="ENCODE" scheme="http://meng.uno/tags/ENCODE/"/>
    
  </entry>
  
  <entry>
    <title>关于比特币（Bitcoin）</title>
    <link href="http://meng.uno/articles/7bfe1542/"/>
    <id>http://meng.uno/articles/7bfe1542/</id>
    <published>2018-02-14T11:47:44.000Z</published>
    <updated>2018-02-14T12:14:20.810Z</updated>
    
    <content type="html"><![CDATA[<h1>比特币术语</h1><h2 id="比特币">比特币</h2><p>首字母大写的Bitcoin用来表示比特币的概念或整个比特币网络本身。例如：“今天我学了些有关Bitcoin协议的内容。”</p><p>而没有大写的bitcoin则表示一个记账单位。例如：“我今天转出了10个bitcoin。”该单位通常也简写为BTC或XBT。</p><h2 id="比特币地址">比特币地址</h2><p>比特币地址就像一个物理地址或者电子邮件地址。这是别人付给你比特币时你唯一需要提供的信息。然而一个重要的区别是，每个地址应该只用于单笔交易。</p><h2 id="对等式网络">对等式网络</h2><p>对等式网络是指，通过允许单个节点与其他节点直接交互，从而实现整个系统像有组织的集体一样运作的系统 。对于比特币来说，比特币网络以这样一种方式构建——每个用户都在传播其他用户的交易。而且重要的是，不需要银行作为第三方。</p><h2 id="哈希率">哈希率</h2><p>哈希率是衡量比特币网络处理能力的测量单位。为保证安全，比特币网络必须进行大量的数学运算。当网络达到10Th/秒的哈希率时，就意味着它能够进行每秒10万亿次的计算。</p><h2 id="交易确认">交易确认</h2><p>交易确认意味着一笔交易已经被网络处理且不太可能被撤销。当交易被包含进一个块时会收到一个确认，后续的每一个块都对应一个确认。对于小金额交易单个确认便可视为安全，然而对于比如1000美元的大金额交易，等待6个以上的确认比较合理。每一个确认都成指数级地降低交易撤销的风险。</p><h2 id="块链">块链</h2><p>块链是一个按时间顺序排列的比特币交易公共记录。块链由所有比特币用户共享。它被用来验证比特币交易的永久性并防止双重消费。</p><h2 id="密码学">密码学</h2><p>密码学是数学的一个分支，它让我们创造出可以提供很高安全性的数学证明。电子商务和网上银行也用到了密码学。对于比特币来说，密码学用来保证任何人都不可能使用他人钱包里的资金，或者破坏块链。密码学也用来给钱包加密，这样没有密码就用不了钱包。</p><h2 id="签名">签名</h2><p>密码学签名是一个让人可以证明所有权的数学机制。对于比特币来说，一个比特币钱包和它的私钥通过一些数学魔法关联到一起。当你的比特币软件用对应的私钥为一笔交易签名，整个网络都能知道这个签名和已花费的比特币相匹配。但是，世界上没有人可以猜到你的私钥来窃取你辛苦赚来的比特币。</p><h2 id="钱包">钱包</h2><p>比特币钱包大致实体钱包在比特币网络中的等同物。钱包中实际上包含了你的私钥，可以让你消费块链中分配给钱包的比特币。和真正的钱包一样，每个比特币钱包都可以显示它所控制的所有比特币的总余额，并允许你将一定金额的比特币付给某人。这与商家进行扣款的信用卡不同。</p><h2 id="区块">区块</h2><p>一个块是块链中的一条记录，包含并确认待处理的交易。平均约每10分钟就有一个包含交易的新块通过挖矿的方式添加到块链中。</p><h2 id="双重消费">双重消费</h2><p>如果一个不怀好意的用户试图将比特币同时支付给两个不同的收款人，就被称为双重消费。比特币挖矿和块链将就两比交易中那笔获得确认并被视为有效在网络上达成一致。</p><h2 id="私钥">私钥</h2><p>私钥是一个证明你有权从一个特定的钱包消费比特币的保密数据块，是通过一个密码学签名来实现的 。如果你使用的是钱包软件，你的私钥就存储在你的计算机内；如果使用的是在线钱包，你的私钥就存储在远程服务器上。千万不能泄露私钥，因为它们可以让你消费对应比特币钱包里的比特币。</p><h2 id="挖矿">挖矿</h2><p>比特币挖矿是利用计算机硬件为比特币网络做数学计算进行交易确认和提高安全性的过程。作为对他们服务的奖励，矿工可以得到他们所确认的交易中包含的手续费，以及新创建的比特币。挖矿是一个专业的、竞争激烈的市场，奖金按照完成的计算量分割。并非所有的比特币用户都挖矿，挖矿赚钱也并不容易。</p><h2 id="bit">Bit</h2><p>Bit是标明一个比特币的次级单位的常用单位 -1,000,000 bit 等于1 比特币 (BTC 或 B⃦).，这个单位对于标示小费、商品和服务价格更方便。</p><h2 id="btc">BTC</h2><p>BTC 是用于标示一个比特币 (B⃦). 的常用单位。</p><h1>比特币账户</h1><p>我们可以在<code>bitcoin.org</code>上选择自己的钱包。我在这里向大家展示使用一个浏览器插件<code>GreenAddress</code>，下载链接是：<code>https://chrome.google.com/webstore/detail/greenaddress/dgbimgjoijjemhdamicmljbncacfndmp/related</code></p><h2 id="注册">注册</h2><p>打开安装好的<code>GreenAddress</code>，没有账户点击右上角，开始注册。</p><p><img src="http://www.meng.uno/images/bitcoins/1.jpg" alt="BITCOIN"></p><p><strong>打码的位置请保存下来，应该需要用它来登录</strong></p><p>接着是验证你保存没保存（想的还很周到）。</p><p>再就是添加两步验证，这个比较常见了，我只选了“邮件”验证，推荐是选两个，要不然总是有warning。</p><p><img src="http://www.meng.uno/images/bitcoins/2.jpg" alt="BITCOIN"></p><h2 id="使用">使用</h2><p>接着就进入主界面了，有很多配置需要大家自己去查看，主界面显示了你的“Bitcoin URI”，分享这个，别人就可以向你转钱了，应该。</p><p><img src="http://www.meng.uno/images/bitcoins/3.jpg" alt="BITCOIN"></p><p><strong>最后强调一下，我的比特币地址是：3CEzyZnpij4WnrAsHhhcaoD1Kf5JqSAEGj</strong></p><p><br><br>本文链接： <a href="http://meng.uno/articles/7bfe1542/">http://meng.uno/articles/7bfe1542/</a> 欢迎转载！</p><div><h1>其他推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="http://hodlerstreet.com/Opinion/how-serious-should-a-hodler-follow-mcafee/">How serious should a hodler follow McAfee?</a></li><li><a href="http://davidfnck.com/tech/bitcoin_short.html/">金融投资|如何做空比特币？</a></li><li><a href="http://www.davidfnck.com/tech/bitcoin_short.html/">金融投资|如何做空比特币？</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      比特币术语
比特币
首字母大写的Bitcoin用来表示比特币的概念或整个比特币网络本身。例如：“今天我学了些有关Bitcoin协议的内容。”

而没有大写的bitcoin则表示一个记账单位。例如：“我今天转出了10个bitcoin。”该单位通常也简写为BTC或XBT。

比特币地址
比特币地址就像一个物理地址或者电子邮件地址。这是别人付给你比特币时你唯一需要提供的信息。然而一个重要的区别是，每个地址应该只用于单笔交易。

对等式网络
对等式网络是指，通过允许单个节点与其他节点直接交互，从而实现整个系统像有组织的集体一样运作的系统 。对于比特币来说，比特币网络以这样一种方式构建——每个用户都在传
    
    </summary>
    
    
      <category term="比特币" scheme="http://meng.uno/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="Bitcoin" scheme="http://meng.uno/tags/Bitcoin/"/>
    
  </entry>
  
  <entry>
    <title>简单的Python3爬虫</title>
    <link href="http://meng.uno/articles/51d32f19/"/>
    <id>http://meng.uno/articles/51d32f19/</id>
    <published>2018-02-12T12:18:15.000Z</published>
    <updated>2018-02-13T14:08:54.149Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>我们先从分析原理入手，然后再使用Python提供的基本的库urllib。</p>  <p>注意，我全程使用的是Python3，如果你必须使用不同版本，请自行百度某些库及函数的转换，需要使用的库不一定你的电脑上预装了，所以请自行百度安装。</p></blockquote><h1>原理</h1><p>网络爬虫，也叫网络蜘蛛(Web Spider)，如果把互联网比喻成一个蜘蛛网，Spider就是一只在网上爬来爬去的蜘蛛。网络爬虫就是根据网页的地址来寻找网页的，也就是URL。</p><h2 id="url">URL</h2><p>URL就是统一资源定位符(Uniform Resource Locator)，它的一般格式如下(带方括号[]的为可选项)：</p><p><code>protocol ://hostname[:port]/path/[;parameters][?query]#fragment</code></p><p>可见，一个URL包含三个部分：</p><ol>  <li>protocol：协议，例如https，http等；</li>  <li>hostname[:port]：主机名(端口号为可选参数)，一般网站默认的端口号为80，例如我的博客域名www.meng.uno，可以作为主机名使用;</li>  <li>path：第三部分就是主机资源的具体地址，如目录和文件名等。</li></ol><p>爬虫就是向URL发送请求，然后得到响应，基本就实现了爬取网页的功能。</p><p><strong>URI可以分为URL,URN或同时具备locators 和names特性的一个东西。URN作用就好像一个人的名字，URL就像一个人的地址。换句话说：URN确定了东西的身份，URL提供了找到它的方式。</strong></p><h2 id="从浏览器发送和接收数据看起">从浏览器发送和接收数据看起</h2><p>进入我的首页<code>www.meng.uno</code>，打开浏览器的“检查”功能，选项卡选到“Network”，然后点击所有文章，随便选择一条，我们可以发现如下截图的&quot;Headers&quot;</p><p><img src="http://meng.uno/images/crawl/1.png" alt="Headers"></p><p>我们可以发现最明显的有两个区域（我已经圈出来了）：“request”和“response”。从字面意思上来看，我们就知道分别是（发送的）请求和（收到的）回复。</p><p>接收的信息是我们请求的网页给的，不用我们管，但是“请求的网页”是我们需要提前设定的，当然最简单的方式就是什么都不设置。爬虫会增加网站的负荷，所以很多网站希望大家通过API的方式使用其开放的资源而禁止爬虫，其中的一个做法就是判断你的请求内容（不全的基本都是爬虫）。于是，为了做到一个完整的可用的爬虫，我们需要模拟真实用户的请求，这就要求我们伪造“User Agent”。</p><p>常见的“User Agent”列举如下：</p><ol>  <li>    <p>Android</p>    <ul>      <li>Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166 Safari/535.19</li>      <li>Mozilla/5.0 (Linux; U; Android 4.0.4; en-gb; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30</li>      <li>Mozilla/5.0 (Linux; U; Android 2.2; en-gb; GT-P1000 Build/FROYO) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1</li>    </ul>  </li>  <li>    <p>Firefox</p>    <ul>      <li>Mozilla/5.0 (Windows NT 6.2; WOW64; rv:21.0) Gecko/20100101 Firefox/21.0</li>      <li>Mozilla/5.0 (Android; Mobile; rv:14.0) Gecko/14.0 Firefox/14.0</li>    </ul>  </li>  <li>    <p>Google Chrome</p>    <ul>      <li>Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36</li>      <li>Mozilla/5.0 (Linux; Android 4.0.4; Galaxy Nexus Build/IMM76B) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.133 Mobile Safari/535.19</li>    </ul>  </li>  <li>    <p>iOS</p>    <ul>      <li>Mozilla/5.0 (iPad; CPU OS 5_0 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9A334 Safari/7534.48.3</li>      <li>Mozilla/5.0 (iPod; U; CPU like Mac OS X; en) AppleWebKit/420.1 (KHTML, like Gecko) Version/3.0 Mobile/3A101a Safari/419.3</li>    </ul>  </li></ol><p>User Agent已经设置好了，但是还应该考虑一个问题，程序的运行速度是很快的，如果我们利用一个爬虫程序在网站爬取东西，一个固定IP的访问频率就会很高，这不符合人为操作的标准，因为人操作不可能在几ms内，进行如此频繁的访问。所以一些网站会设置一个IP访问频率的阈值，如果一个IP访问频率超过这个阈值，说明这个不是人在访问，而是一个爬虫程序。</p><p>一个很简单的解决办法就是设置延时，但是这显然不符合爬虫快速爬取信息的目的，所以另一种更好的方法就是使用IP代理。使用代理的步骤：</p><ul>  <li>调用urlib.request.ProxyHandler()，proxies参数为一个字典；</li>  <li>创建Opener(类似于urlopen，这个代开方式是我们自己定制的)；</li>  <li>安装Opener；</li></ul><p><strong>这个网站提供了很多代理主机：<a href="http://www.xicidaili.com/" target="_blank" rel="noopener">http://www.xicidaili.com/</a></strong></p><h2 id="正则表达式">正则表达式</h2><p>我直接以表格的形式呈现好了：</p><table>  <thead>    <tr>      <th style="text-align:center">元字符</th>      <th style="text-align:right">说明</th>    </tr>  </thead>  <tbody>    <tr>      <td style="text-align:center">.</td>      <td style="text-align:right">代表任意字符</td>    </tr>    <tr>      <td style="text-align:center"></td>      <td style="text-align:right"></td>    </tr>    <tr>      <td style="text-align:center">[ ]</td>      <td style="text-align:right">匹配内部的任一字符或子表达式</td>    </tr>    <tr>      <td style="text-align:center">[^]</td>      <td style="text-align:right">对字符集和取非</td>    </tr>    <tr>      <td style="text-align:center">-</td>      <td style="text-align:right">定义一个区间</td>    </tr>    <tr>      <td style="text-align:center">\</td>      <td style="text-align:right">对下一字符取非（通常是普通变特殊，特殊变普通）</td>    </tr>    <tr>      <td style="text-align:center">*</td>      <td style="text-align:right">匹配前面的字符或者子表达式0次或多次</td>    </tr>    <tr>      <td style="text-align:center">*?</td>      <td style="text-align:right">惰性匹配上一个</td>    </tr>    <tr>      <td style="text-align:center">+</td>      <td style="text-align:right">匹配前一个字符或子表达式一次或多次</td>    </tr>    <tr>      <td style="text-align:center">+?</td>      <td style="text-align:right">惰性匹配上一个</td>    </tr>    <tr>      <td style="text-align:center">?</td>      <td style="text-align:right">匹配前一个字符或子表达式0次或1次重复</td>    </tr>    <tr>      <td style="text-align:center">{n}</td>      <td style="text-align:right">匹配前一个字符或子表达式</td>    </tr>    <tr>      <td style="text-align:center">{m,n}</td>      <td style="text-align:right">匹配前一个字符或子表达式至少m次至多n次</td>    </tr>    <tr>      <td style="text-align:center">{n,}</td>      <td style="text-align:right">匹配前一个字符或者子表达式至少n次</td>    </tr>    <tr>      <td style="text-align:center">{n,}?</td>      <td style="text-align:right">前一个的惰性匹配</td>    </tr>    <tr>      <td style="text-align:center">^</td>      <td style="text-align:right">匹配字符串的开头</td>    </tr>    <tr>      <td style="text-align:center">\A</td>      <td style="text-align:right">匹配字符串开头</td>    </tr>    <tr>      <td style="text-align:center">$</td>      <td style="text-align:right">匹配字符串结束</td>    </tr>    <tr>      <td style="text-align:center">[\b]</td>      <td style="text-align:right">退格字符</td>    </tr>    <tr>      <td style="text-align:center">\c</td>      <td style="text-align:right">匹配一个控制字符</td>    </tr>    <tr>      <td style="text-align:center">\d</td>      <td style="text-align:right">匹配任意数字</td>    </tr>    <tr>      <td style="text-align:center">\D</td>      <td style="text-align:right">匹配数字以外的字符</td>    </tr>    <tr>      <td style="text-align:center">\t</td>      <td style="text-align:right">匹配制表符</td>    </tr>    <tr>      <td style="text-align:center">\w</td>      <td style="text-align:right">匹配任意数字字母下划线</td>    </tr>    <tr>      <td style="text-align:center">\W</td>      <td style="text-align:right">不匹配数字字母下划线</td>    </tr>  </tbody></table><h1>代码</h1><h2 id="简单带错误信息的获取网页内所有url的爬虫">简单带错误信息的获取网页内所有URL的爬虫</h2><figure class="highlight python">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="comment">#获取URL的包</span></span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="comment">#获取字符集编码方式</span></span><br><span class="line"><span class="keyword">import</span> chardet</span><br><span class="line"><span class="comment">#正则表达式</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#Request 对象</span></span><br><span class="line">req = urllib.request.Request(<span class="string">"http://meng.uno/"</span>)</span><br><span class="line">data = <span class="keyword">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#得到Response</span></span><br><span class="line">    response = urllib.request.urlopen(req,data)</span><br><span class="line">    <span class="comment">#读出response == 请求文件的全部字符</span></span><br><span class="line">    html = response.read()</span><br><span class="line">    <span class="comment">#获取这个response的编码方式</span></span><br><span class="line">    charset = chardet.detect(html)</span><br><span class="line">    print(<span class="string">"编码方式："</span>,charset)</span><br><span class="line">    <span class="comment">#以这种编码方式解码打印</span></span><br><span class="line">    html = html.decode(charset.get(<span class="string">"encoding"</span>))</span><br><span class="line">    print(html)</span><br><span class="line">    urls = re.findall(<span class="string">'href=\"https*://w*\.*meng\.uno/.*?\"'</span>, html,re.S)</span><br><span class="line">    uris = re.findall(<span class="string">'href=\"/[^/].*?[^\.]\"'</span>,html, re.S)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> urls:</span><br><span class="line">        print(item[<span class="number">6</span>:<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> uris:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">".html"</span> <span class="keyword">in</span> item:</span><br><span class="line">            print(<span class="string">"http://www.meng.uno"</span>+item[<span class="number">6</span>:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">'.'</span> <span class="keyword">in</span> item:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"http://www.meng.uno"</span>+item[<span class="number">6</span>:<span class="number">-1</span>])</span><br><span class="line"><span class="keyword">except</span> urllib.error.HTTPError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">if</span> hasattr(e, <span class="string">'code'</span>):</span><br><span class="line">        print(<span class="string">"HTTPError"</span>)</span><br><span class="line">        print(e.code)</span><br><span class="line">    <span class="keyword">elif</span> hasattr(e, <span class="string">'reason'</span>):</span><br><span class="line">        print(<span class="string">"URLError"</span>)</span><br><span class="line">        print(e.reason)</span><br></pre>      </td>    </tr>  </table></figure><h2 id="模拟真实环境的爬虫">模拟真实环境的爬虫</h2><figure class="highlight python">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"> <span class="comment">#访问网址</span></span><br><span class="line">url = <span class="string">'http://www.whatismyip.com.tw/'</span></span><br><span class="line"><span class="comment">#这是代理IP</span></span><br><span class="line">proxy = &#123;<span class="string">'https'</span>:<span class="string">'110.73.48.189:8123'</span>&#125;</span><br><span class="line"><span class="comment">#创建ProxyHandler</span></span><br><span class="line">proxy_support = urllib.request.ProxyHandler(proxy)</span><br><span class="line"><span class="comment">#创建Opener</span></span><br><span class="line">opener = urllib.request.build_opener(proxy_support)</span><br><span class="line"><span class="comment">#添加User Angent</span></span><br><span class="line">opener.addheaders = [(<span class="string">'User-Agent'</span>,<span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'</span>)]</span><br><span class="line"><span class="comment">#安装OPener</span></span><br><span class="line">urllib.request.install_opener(opener)</span><br><span class="line"><span class="comment">#使用自己安装好的Opener</span></span><br><span class="line">response = urllib.request.urlopen(url)</span><br><span class="line"><span class="comment">#读取相应信息并解码</span></span><br><span class="line">html = response.read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line"><span class="comment">#打印信息</span></span><br><span class="line">print(html)</span><br></pre>      </td>    </tr>  </table></figure><h2 id="通过队列获取网站所有url的爬虫">通过队列获取网站所有URL的爬虫</h2><figure class="highlight python">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="comment">#python系统关于队列的包</span></span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="comment">#获取URL的包</span></span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="comment">#获取字符集编码方式</span></span><br><span class="line"><span class="keyword">import</span> chardet</span><br><span class="line"><span class="comment">#正则表达式</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">initial_page = <span class="string">"http://www.meng.uno"</span></span><br><span class="line"></span><br><span class="line">url_queue = queue.Queue()</span><br><span class="line">seen = set()</span><br><span class="line"></span><br><span class="line">seen.add(initial_page)</span><br><span class="line">url_queue.put(initial_page)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_urls</span><span class="params">(url)</span>:</span></span><br><span class="line">    req = urllib.request.Request(url)</span><br><span class="line">    <span class="comment">#得到Response</span></span><br><span class="line">    response = urllib.request.urlopen(req)</span><br><span class="line">    <span class="comment">#读出response == 请求文件的全部字符</span></span><br><span class="line">    html = response.read()</span><br><span class="line">    <span class="comment">#获取这个response的编码方式</span></span><br><span class="line">    charset = chardet.detect(html)</span><br><span class="line">    <span class="comment">#以这种编码方式解码打印</span></span><br><span class="line">    html = html.decode(charset.get(<span class="string">"encoding"</span>))</span><br><span class="line">    urls = re.findall(<span class="string">'href=\"https*://w*\.*meng\.uno/.*?\"'</span>, html,re.S)</span><br><span class="line">    uris = re.findall(<span class="string">'href=\"/[^/].*?[^\.]\"'</span>,html, re.S)</span><br><span class="line">    tempseen = set()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> urls:</span><br><span class="line">        tempseen.add(item[<span class="number">6</span>:<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> uris:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">".html"</span> <span class="keyword">in</span> item:</span><br><span class="line">            tempseen.add(<span class="string">"http://www.meng.uno"</span>+item[<span class="number">6</span>:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">'.'</span> <span class="keyword">in</span> item:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tempseen.add(<span class="string">"http://www.meng.uno"</span>+item[<span class="number">6</span>:<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> tempseen</span><br><span class="line">            </span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">True</span>): <span class="comment">#一直进行直到海枯石烂</span></span><br><span class="line">    <span class="keyword">if</span> url_queue.qsize()&gt;<span class="number">0</span>:</span><br><span class="line">        current_url = url_queue.get()    <span class="comment">#拿出队例中第一个的url</span></span><br><span class="line">        print(current_url)               <span class="comment">#把这个url代表的网页存储好</span></span><br><span class="line">        <span class="keyword">for</span> next_url <span class="keyword">in</span> extract_urls(current_url): <span class="comment">#提取把这个url里链向的url</span></span><br><span class="line">            <span class="keyword">if</span> next_url <span class="keyword">not</span> <span class="keyword">in</span> seen:      </span><br><span class="line">                seen.add(next_url)</span><br><span class="line">                url_queue.put(next_url)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre>      </td>    </tr>  </table></figure><p><strong><em>这里先简单解释，以后有实际项目会再补充！</em></strong></p><p><br><br>本文链接： <a href="http://meng.uno/articles/51d32f19/">http://meng.uno/articles/51d32f19/</a> 欢迎转载！</p><div><h1>其他推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="http://meng.uno/articles/5d4e2c71/">E-mail小爬虫</a></li><li><a href="http://www.libinx.com/2017/a-government-report-crawl-experience/">小记在中经网的一次爬虫踩坑经历</a></li><li><a href="http://www.davidfnck.com/tech/crawler_by_python.html/">我要系列｜爬虫真有用啊！</a></li><li><a href="http://www.libinx.com/2017/Chinese-government-report-text-analysis-over-the-years/">历年（1954-2016）政府工作报告文本分析及可视化</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      我们先从分析原理入手，然后再使用Python提供的基本的库urllib。

注意，我全程使用的是Python3，如果你必须使用不同版本，请自行百度某些库及函数的转换，需要使用的库不一定你的电脑上预装了，所以请自行百度安装。

原理
网络爬虫，也叫网络蜘蛛(Web Spider)，如果把互联网比喻成一个蜘蛛网，Spider就是一只在网上爬来爬去的蜘蛛。网络爬虫就是根据网页的地址来寻找网页的，也就是URL。

URL
URL就是统一资源定位符(Uniform Resource Locator)，它的一般格式如下(带方括号[]的为可选项)：

protocol ://hostname[:port]/
    
    </summary>
    
      <category term="Python" scheme="http://meng.uno/categories/Python/"/>
    
      <category term="爬虫" scheme="http://meng.uno/categories/Python/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="http://meng.uno/tags/Python/"/>
    
      <category term="爬虫" scheme="http://meng.uno/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>CPAchecker</title>
    <link href="http://meng.uno/articles/c5d9877c/"/>
    <id>http://meng.uno/articles/c5d9877c/</id>
    <published>2018-02-11T14:08:59.000Z</published>
    <updated>2018-02-11T14:15:48.025Z</updated>
    
    <content type="html"><![CDATA[<p>CPAchecker is a tool for configurable software verification which means expressing different program analysis and model checking approaches in one single formalism. The main algorithm is configurable to perform a reachability analysis on arbitrary combinations  of existing configurable program analysis (CPA). One application of CPAchecker is the verification of Linux device drivers.</p><p>CPA provides a conceptual basis for expressing different verification approaches in the same formal setting. The CPA formalism provides an interface for the definition of program analyses, which includes the abstract domain, the post operator, the merge  operator, and the stop operator. Consequently, the corresponding tool implementation CPAchecker provides an implementation framework that allows the seamless integration of program analyses that are expressed in the CPA framework. The comparison of  different approaches in the same experimental setting becomes easy and the experimental results will be more meaningful.</p><h2 id="architecture">Architecture</h2><p><img src="http://www.meng.uno/images/cpa/1.png" alt="CPAchecker"></p><p>The above picture is the overview of CPAchecker’s architecture. The central data structure is a set of control-flow automata (CFA), which consist of control-flow locations and control-flow edges. A location represents a program-counter value, and an edge  represents a program operation, which is either an assume operation, an assignment block, a function call, or a function return. Before a program analysis starts, the input program is transformed into a syntax tree, and further into CFAs. The framework  provides interfaces to SMT solvers and interpolation procedures, such that the CPA operators can be written in a concise and convenient way. From the picture, we know that they use MathSAT as an SMT solver, and CSIsat and MathSAT as interpolation procedures.  They also use JavaBDD as a BDD package, and provide an interface to an Octagon Library as well. The CPA Algorithm is the center of this project and the detailed design is shown as follows.</p><p><img src="http://www.meng.uno/images/cpa/2.png" alt="CPAchecker"></p><p>The CPA algorithm (shown at the top in the above figure) takes as input a set of control-flow automata (CFA) representing the program, and a CPA, which is in most cases a Composite CPA. The interfaces correspond one-to-one to the formal framework. The  elements in the gray box (top right) represent the abstract interfaces of the CPA and the CPA operations. The two gray boxes at the bottom of the figure show two implementations of the interface CPA, one is a Composite CPA that can combine several other  CPAs, and the other is a Leaf CPA.</p><h2 id="build-and-test">Build and Test</h2><p>Owing to the long development history, this project is very prefect which means you could use its binary directly, build from the source and even use their jar-ball in Java applications. To experience it, I will build it from the source and use it in  the command-line.</p><p>We need to install “jdk”, “ant”, “svn” and “subversion” before we build it. Then enter the root directory and run “ant”. Wait a moment and this is the result.</p><p>To test this project, we need to write a C/C++ code without “#include  <headers>”. I choose a simple one (QuickSort) shown in the attachment.</headers></p><p>The result contains a log file, a statistics file and a report which is in “html” format.</p><p><br><br>本文链接： <a href="http://meng.uno/articles/c5d9877c/">http://meng.uno/articles/c5d9877c/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      CPAchecker is a tool for configurable software verification which means expressing different program analysis and model checking approaches in one single formalism. The main algorithm is configurable to perform a reachability analysis on arbitrary combinations of existing configurable program analys
    
    </summary>
    
      <category term="Software Verification" scheme="http://meng.uno/categories/Software-Verification/"/>
    
      <category term="CPA" scheme="http://meng.uno/categories/Software-Verification/CPA/"/>
    
      <category term="CPAchecker" scheme="http://meng.uno/categories/Software-Verification/CPA/CPAchecker/"/>
    
    
      <category term="CPA" scheme="http://meng.uno/tags/CPA/"/>
    
      <category term="CPAchecker" scheme="http://meng.uno/tags/CPAchecker/"/>
    
  </entry>
  
  <entry>
    <title>Linux Test Project</title>
    <link href="http://meng.uno/articles/bfb74f68/"/>
    <id>http://meng.uno/articles/bfb74f68/</id>
    <published>2018-02-11T13:29:33.000Z</published>
    <updated>2018-02-11T14:04:49.151Z</updated>
    
    <content type="html"><![CDATA[<p>I found this project from the references of other papers, and I thought it was good, so I plan to run it. As we can see from its name, Linux Test Project (LTP) has a goal to deliver test suites to the open source community that validate the reliability,  robustness, and stability of Linux. This project wants to support Linux development by making unit testing more complete and minimizing user impact by building a barrier to keep bugs from making it to the user. There are two important testing techniques  which are supported by giving developers an ever growing set of tools to help identify any operational problems in their code: Design and Code Inspections. I knew that Yggdrasil and Hyperkernel which I have run successfully belong to the last category.  LTP doesn’t have a benchmark which means they don’t compare different kernel of Linux.</p><p>In LTP, we need to know:</p><ul>  <li>Test case: A single action and verification which has a result PASS/FAIL.</li>  <li>Test suite: Containing one or more test cases.</li>  <li>Test tags: Pairing a unique identifier with a test program and a set of command line options.</li></ul><p>We also need to know the ways of reporting the results of a test case. There are two main ways which are contained in LTP:</p><ul>  <li>Exit status: If a test program encounters unexpected or incorrect results, exit the test program with a non-zero exit status, i.e. exit(1). Conversely, if a program completes as expected, return a zero exit status, i.e. exit(0).</li>  <li>Standard output: Tools can be used to analyze the results, if they are written in a standard way.</li></ul><h2 id="build-and-run">Build and Run</h2><p>To build this project, we need to run the following executions:</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">$ git clone https:<span class="comment">//github.com/linux-test-project/ltp.git</span></span><br><span class="line">$ cd ltp</span><br><span class="line">$ make autotools</span><br><span class="line">$ ./configure</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre>      </td>    </tr>  </table></figure><p>Before these, we need to ensure “git, autoconf, automake, m4” are installed. If not, we can use “apt-get” to get them. The output of “make” is shown as following.</p><p><img src="http://www.meng.uno/images/ltp/1.png" alt="LTP"></p><p>After building this project, let’s run it personally. If we want to run all the test suites, we just need run “./runltp” in the “opt/ltp/” directory. However, I will run a single test suite to verify this project only with “./runltp -f syscalls” execution.</p><p><img src="http://www.meng.uno/images/ltp/2.png" alt="LTP"></p><p>The picture above is the output of “abort01” test case. From it we can see that the test method is “Exit status test” and it passes all the situations.</p><p>If a test case needs datafiles to work, these would be put in a subdirectory named datafilesand installed in the testcases/data/$TCID directory</p><h2 id="analyze-test-cases">Analyze Test Cases</h2><p>We could find LTP in “/opt/ltp” and the test suites are installed in the “/opt/ltp/runtest/” directory. The following picture is a screenshot of it.</p><p><img src="http://www.meng.uno/images/ltp/3.png" alt="LTP"></p><p>In a single file, such as “syscalls” file, there exist many single test cases which are like the follows.</p><p><img src="http://www.meng.uno/images/ltp/4.png" alt="LTP"></p><p>From this picture, those words, like “abort01”, represent different test cases which are laid in “/opt/ltp/testcases/bin/” directory.</p><p><img src="http://www.meng.uno/images/ltp/5.png" alt="LTP"></p><p>Each test case is a binary written either in portable Shell or C such as “abort01” which is from “abort01.c” which lays in the “ltp/testcases/kernel/syscalls/abort” directory. The test gets a configuration via environment variables and/or command line  parameters, it prints additional information into the stdout and reports overall success/failure via the exit value.</p><p><img src="http://www.meng.uno/images/ltp/6.png" alt="LTP"></p><h2 id="write-a-test-suite">Write A Test Suite</h2><p>To make things simple, I will use LTP standard interface, not add custom reporting functions and use LTP build system. The following are my steps (These steps are very simple, so I didn’t list any screenshot):</p><ul>  <li>Add a new file “meng” to “ltp/runtest/” directory;</li>  <li>Write some test cases’ names, such as “abort01 accept01”;</li>  <li>Run “make” and “make install”;</li>  <li>Enter “/opt/ltp/” directory;</li>  <li>Run “./runltp -f meng”;</li>  <li>Get the result as the picture. (You can also find the full logs from “meng_output.txt” file in the attachment)</li></ul><p><img src="http://www.meng.uno/images/ltp/7.png" alt="LTP"></p><h2 id="write-a-test-case">Write A Test Case</h2><p>As I said before, we can use C language or Shell to write a test case, however, in this section, I will just use C language to write a simple one which may make me have a deep understanding of this project.</p><p><strong>I used the “man-pages” to find the untested system calls, however, my linux version maybe a little old (2015 release, version 16.04), so that I can’t find a untested one which is excluded by the newest LTP.</strong></p><p>I will write a test for verifying system call “file rename”. First, I create a new file “meng.c” in the “ltp/testcases/kernel/syscalls/meng/” directory. Then I need to write the codes. The next thing I need to do is to include “tst_test.h” (There are  also another headers, however, this one is basic). We need to write “main(), setup(), clean()” functions and the detailed realizations are in the “meng.c” which is in the attachment (I give some notes of the code in the “meng.c” file as well). What’s  more, we need to create a “Makefile” in the same directory and write the compiling information. The compiled file is like this.</p><p><img src="http://www.meng.uno/images/ltp/8.png" alt="LTP"></p><p>Last, I will add this test case to the “meng” test suite and see the result (You can find the full output in “meng_syscall_output.txt” in the attachment).</p><p><img src="http://www.meng.uno/images/ltp/9.png" alt="LTP"></p><p>From the above picture, we can see that the verification is “pass” which means that not only the “rename” system call is correct, but also my code is right.</p><p><br><br>本文链接： <a href="http://meng.uno/articles/bfb74f68/">http://meng.uno/articles/bfb74f68/</a> 欢迎转载！</p><div><h1>其他推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="http://www.libinx.com/2017/five-steps-win10-ubuntu-dual-boot/">五步完美实现Win10 + Ubuntu 17.04双系统启动</a></li><li><a href="http://www.libinx.com/2017/linux-operations-notes-chmod/">Linux 使用笔记（2）修改文件权限 chmod</a></li><li><a href="http://frank-xjh.github.io/hustOJ的搭建与使用-0目录/">hustOJ的搭建与使用-0目录</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      I found this project from the references of other papers, and I thought it was good, so I plan to run it. As we can see from its name, Linux Test Project (LTP) has a goal to deliver test suites to the open source community that validate the reliability, robustness, and stability of Linux. This proje
    
    </summary>
    
      <category term="Linux" scheme="http://meng.uno/categories/Linux/"/>
    
      <category term="Linux Test" scheme="http://meng.uno/categories/Linux/Linux-Test/"/>
    
    
      <category term="Linux" scheme="http://meng.uno/tags/Linux/"/>
    
      <category term="Linux Test" scheme="http://meng.uno/tags/Linux-Test/"/>
    
  </entry>
  
  <entry>
    <title>A Melody Composer for both Tonal and Non-Tonal Languages</title>
    <link href="http://meng.uno/articles/2251dcee/"/>
    <id>http://meng.uno/articles/2251dcee/</id>
    <published>2018-02-11T04:03:24.000Z</published>
    <updated>2018-03-02T03:27:32.829Z</updated>
    
    <content type="html"><![CDATA[<h1>Summary</h1><h2 id="abstract">Abstract</h2><p>This paper contains some improvements on an algorithmic melody composer called “T-music”. “T-music” is an algorithm which can compose a melody for users’ input lyrics by mining the relationship between the melodies and lyrics. These relationships are  known as frequent patterns (FPS) . The ameliorations are two ways to enhance the methods of mining frequent patterns form instrumental compositions and an optimal way of using FPS mined from songs in one language to compose a melody for the input things  in another language.</p><h2 id="propse">Propse</h2><p>The propose is to get an algorithm which take lyrics as input and a good melody as outcome in order to help those people who have little music background to compose songs. In view of the fact that there is already a pretty well method, T-music, the authors’  tasks are making some improvements on the basis of the original algorithm.</p><h2 id="deficiencies-of-original-algorithm">Deficiencies of original algorithm</h2><p>At the first place, I need to borrow a figure from the paper as follows to express my understanding of the original T-music method.</p><p><img src="http://www.meng.uno/images/t-music/t-music-arch.png" alt="t-musuc"></p><p>As the picture shows that the system architecture of T-music can be divided as two phases which are “Frequent Pattern Mining” and “Melody Composition”. I will report this method following the flow of the algorithm.</p><ul>  <li>    <p>Mining the FPS from “Song Database” and storing them in the “Frequent Pattern Database”:</p>    <ul>      <li>Obtaining tone sequences from “Song Database” by reading the “Language Dictionary”;</li>      <li>Generating s-sequence from a melody, a pitch sequence and a duration sequence;</li>      <li>Mining the FPS from s-sequence;</li>      <li>Storing the FPS to “Frequent Pattern Database”.</li>    </ul>  </li>  <li>    <p>Composing a melody for the “Lyrics” based on FPS in the “Frequent Pattern Database”:</p>    <ul>      <li>Obtaining the tone sequence of the lyrics by reading the “Language Dictionary”;</li>      <li>Adding some “Music Parameters” such as some music rules;</li>      <li>Generating “Melody” by the process “Melody Composition” using FPS.</li>    </ul>  </li></ul><p>There are some deficiencies of the original T-music algorithm as follows. It can only mine FPS from songs in which lyrics must be present. What’s more, the original one can’t use the FPS mined from a language to compose melody in another language. However,  we can’t always get the ideal songs data which have lyrics embedded easily. What we can get from the Internet are those instrumental compositions in which lyrics are absent. Also, we want to achieve that composing melody in a language with the FPS mined  from another language which can make the algorithm more efficient.</p><h2 id="improvements">Improvements</h2><p>What the authors have done provided two ways to mine Frequent Patterns from instrumental compositions and an optimal mapping method for composing a melody using FPS in different language with the input lyrics.</p><p>The first way is “Method emphasizing the original FPS”. I will use the following picture to express my comprehension. Firstly, mining the FPS from songs and storing them in “FP database (General)”. Secondly, mining the frequent pitch trends from “Instrumental  compositions with style database” and storing them in “Frequent pitch trends (Style)” and then using it as a selector to select those FPS storing the matches in “FP database (Style)”.</p><p><img src="http://www.meng.uno/images/t-music/t-music-database.png" alt="t-musuc"></p><p>The second way is “Method emphasizing the newly mined frequent pitch trends”. I will also introduce it using the screenshot from the paper. The FPS based on those of the first way was subdivided. The frequent pitch trends are mined as usually. The most  difference is that one pitch trend may match a set of several tone trends.</p><p><img src="http://www.meng.uno/images/t-music/t-music-database2.png" alt="t-musuc"></p><p>The optimal mapping method is shown as follows. Firstly, using the same method gets a “FP database” in one language. Then, generating several tone sequences for each tone trend in this “FP database”. There are some lemmas proofed on the paper to decide  the specific number of the mapping.</p><h1>Improvements</h1><p>In this section, I will analysis some excellent algorithms, important thoughts or some key points. Some of them may look small or nothing special, but each has its function.</p><h2 id="using-the-trend-representation">Using the “Trend” representation</h2><p>If I were doing this job, I could have chosen the simple “absolute” representation, just because this is the most intuitive frequent pattern we can get from songs. After careful consideration, just as the author explains that same melodies which start  at different pitches may sound similar to us. Then, I understand that it is a big wisdom to use the “trend” representation which uses a FP to extract the general rules of a set of FPS with different pitches, simplifying a large number of calculations  and making the result more obvious.</p><h2 id="using-frequent-pitch-trends-style-as-a-selector">Using “Frequent pitch trends (Style)” as a selector</h2><p>Though we know that “T-music” uses “the FPS between the tone port and the pitch part” and agree the mining method used on mining the frequent pattern which contains a tone trend and a pitch trend, there must be some correlation between “Tone trend” and  “Pitch trend”. Since the instrumental compositions don’t contain lyrics, we couldn’t mine a whole frequent pattern from them. However, we can also mine part of the frequent pattern from them which is “Pitch trend”. For we have so much instrumental compositions  which means we can get enough “Pitch trend” and we already know the correlation between “Tone trend” and “Pitch trend”, we can estimate the frequency of the original frequent pattern and eliminate part of them which have a zero frequency.</p><h2 id="using-the-subsequences-of-original-frequent-pattern">Using the subsequences of original frequent pattern</h2><p>According to the Apriori property that all nonempty subsets of frequent item set must also be frequent, the authors artfully break the original FPS into smaller form and then making them combine more FPS which can be selected from the original FP database.  By doing this, we can get more frequent patterns from the identical data which means our mining algorithm is more efficient.</p><h2 id="using-multi-map-as-a-data-structure">Using multi-map as a data structure</h2><p>This data structure allows the task of retrieving a value by a key quickly and returns more than one frequent pattern with a support. From it, we can get a tuple in top-k tuples with some selection strategies and ensure that a pattern with a very large  support isn’t always selected because it doesn’t mean that it is always the best choice.</p><h2 id="employing-the-divide-and-conquer-idea">Employing the divide and conquer idea</h2><p>Considering to compose a melody of a very long lyric, we may need to divide the original tone trend into several shorter tone trends, apply the same procedure on them and then return the concatenation of the results of the sub-problems. It is a simple  idea of solving such problem, but we can’t resist its correctness and effectiveness.</p><h1>Limitations</h1><p>I just list some areas that I think need improvements or I think it can be added slightly on the basis of the original research.</p><h2 id="applying-word-segmentation">Applying word segmentation</h2><p>Though the paper has mentioned the use of word segmentation, there is just a word and no detailed explanation. I think I should express my own idea here. Firstly, the word segmentation here isn’t the same of those applied in the fields of natural language  processing (NLP). As we all known, the latter has so many strict norms to follow, however, in the lyrics, the norms aren’t very same. Why we do this in the input lyrics is because we want to determine the length of durations between every two words,  which is different from the propose in the NLP which just wants to add pause at the same length of time between words and words.</p><h2 id="handling-the-tone-trend-with-a-length-of-1">Handling the tone trend with a length of 1</h2><p>In this paper, the authors just simply set the pitch trend to be the input tone trend where, I think, may need improvement. Firstly, we all know that “the tone trend with a length of 1” couldn’t appear individually. It is usually because we matched the  tone sequences before it or after it. I think if we consider dividing the original sequence into overlapping parts using the similar idea of divide and conquer idea, the question may disappear.</p><h2 id="mining-the-relationship-between-tone-trend-and-pitch-trend">Mining the relationship between “tone trend” and “pitch trend”</h2><p>The authors just determine the relationship based on statistics in whether the original T-music method or the improved edition, store the regulars on a multi-map and when using the frequent pattern, the method just randomly selects a tuple from top-k  tuples from the multi-map. Therefore, no matter which one we choose, it is just the original sequence in the FP-database. If there is a very large database which contains a large number of every frequent pattern, it may have a remarkable effect without  complex computations. However, we can’t ensure it or we just want to improve our algorithm with little support of so many records. Let’s look at the following samples which has the form as same as those in the multi-map and assume that the same tone  trend only has the three tuples.</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&gt; —&gt; (&lt;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">1</span>,-<span class="number">2</span>&gt;, <span class="number">10</span>)</span><br><span class="line">&lt;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&gt; —&gt; (&lt;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">2</span>,-<span class="number">1</span>&gt;, <span class="number">9</span>) </span><br><span class="line">&lt;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&gt; —&gt; (&lt;<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">2</span>,-<span class="number">1</span>&gt;, <span class="number">5</span>)</span><br></pre>      </td>    </tr>  </table></figure><p>As we can see, they have the same tone trend and different pitch trends with different values of a support. If we just use the method described in the paper, we may get the result of the 1st, the 2nd, or the 3rd. However, is it the best one? Maybe not,  I think. I mean maybe <code>&lt;1,1,2,0,-2,-1&gt;</code> is better. I think we need to add some correlation analyses to the pitch trends which have the same tone trends.</p><h1>Expanding Research</h1><p>After reading this paper, I have some ideas for further research and some of them are listed as follows.</p><h2 id="adding-location-variables">Adding location variables</h2><p>I mean, as we all known, a same lyric may have different melodies when it is at the beginning or at the end of a song. Of course, if we just want to use a simple sentence as its input, this consideration is rather superfluous. However, if the input lyric  is long enough, it is very important then.</p><h2 id="generating-a-melody-with-a-longer-note">Generating a melody with a longer note</h2><p>This thought is mentioned in the end of the paper as well. We may have noticed that the normal notes will be longer than the syllables of lyrics, at least at the end of each sentence. We may need to modify the match method to add the frequent pattern  which contains group of pitch trends sequences and its corresponding longer tone trends sequences.</p><h2 id="applying-syntactic-analysis">Applying syntactic analysis</h2><p>The following is my exploratory opinion of the original T-music. If I have many songs with lyrics, I will mine the frequent patterns of syntactic analysis and add them to the “s-sequence” mentioned in this paper. Thus I will reform the original multi-map  as follows.</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">(&lt;pitch trend pattern&gt;, &lt;syntax pattern&gt;) —&gt; (&lt;tone trend pattern&gt;, support)</span><br></pre>      </td>    </tr>  </table></figure><p>When we match the input lyrics, we need to not only match the “pitch trend pattern” from the FP-database but also contrast the “syntax pattern” and then make the best decision.</p><h2 id="expanding-to-speech-recognization">Expanding to speech recognization</h2><p>I have a simple idea of speech recognization using the same method mentioned in this paper. If I could collect enough voice information spoken by the same person, I would mine the frequent patterns of his intonation habit from the voice data and then  using them to judge whether another voice is his or not.</p><h2 id="expanding-to-password-security">Expanding to password security</h2><p>In order to prevent the password being stolen, all websites are making efforts on password diversity. I think the method of mining frequent pattern can be applied to protect users’ password as well. For the same string of ciphers, different people may  type it out in different speeds with different intermission on every two letters. I, for example, usually use the combination of my name and birthday as a password and when I type it out there is a longer break between the last letter of my name and  the first number of my birthday. If we use the same way to mine the frequent patterns form enough times records of someone, we may use the frequent patterns to judge whether it is the right person or not who is typing the password.</p><h2 id="generating-good-problems">Generating “good problems”</h2><p>I often encounter some tricky programming problems and as we all known, “StackOverflow” is the biggest website which can offer you relevant solutions when you ask a question on it. However, we all want to get the best answer as soon as possible so we  may need to put forward “good questions”. I think the thought of this paper can be applied to this question. We can first collect enough “good questions” from the website and then mine the syntactic frequent patterns of each question by categories.  Finally, we can generate such “good questions” by adding the knowledge of sentence construction and providing some keywords needed.</p><h1>Related Research</h1><p>This paper is about mining frequent patterns which is a subfield of data mining. I will express my understanding mixing information retrieved from the Internet in this field.</p><p>With the rise of big data, so many research topics about data is more and more frequent such as forecasting passenger flow and passenger flow directions during the Spring Festival and predicting the composition of Chinese college entrance examination  this year. Data mining means the process of extracting valuable information and patterns from large amounts of data and these new discovery rules, patterns, information and concepts have potential value. It usually contains the association rules, classification,  estimation, clustering and so on.</p><p>As for association analysis, its propose is to discover interesting links hidden in large data sets and the patterns discovered are usually represented in association rules or frequent item sets just as this paper shown. There are several efficient and  scalable frequent item set mining methods such as Apriori algorithm and FP-growth which needs to construct FP-tree.</p><p>As for classification and prediction, I think it is a more stirring area. Think of this, a marketing manager needs data analysis to help guess whether or not a customer with a given profile will buy a new computer and then the marketing manager would  like to predict how much a given customer will spend during a sale, what an attractive job!</p><p><br><br>本文链接： <a href="http://meng.uno/articles/2251dcee/">http://meng.uno/articles/2251dcee/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      Summary
Abstract
This paper contains some improvements on an algorithmic melody composer called “T-music”. “T-music” is an algorithm which can compose a melody for users’ input lyrics by mining the relationship between the melodies and lyrics. These relationships are known as frequent patterns (FPS)
    
    </summary>
    
      <category term="Paper Report" scheme="http://meng.uno/categories/Paper-Report/"/>
    
      <category term="Data mining" scheme="http://meng.uno/categories/Paper-Report/Data-mining/"/>
    
    
      <category term="Paper Report" scheme="http://meng.uno/tags/Paper-Report/"/>
    
      <category term="Data Mining" scheme="http://meng.uno/tags/Data-Mining/"/>
    
  </entry>
  
  <entry>
    <title>.length与length()的区别</title>
    <link href="http://meng.uno/articles/61c2f1f1/"/>
    <id>http://meng.uno/articles/61c2f1f1/</id>
    <published>2018-02-10T13:58:04.000Z</published>
    <updated>2018-02-10T14:52:50.489Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>当我们需要使用数组或者字符串长度时，习惯了使用IDE自动补全的我们是否知道<code>.length</code>与<code>length()</code>的区别喻原因呢？</p></blockquote><p>上面问题的答案是：</p><ul>  <li>数组使用<code>.length</code>属性</li>  <li>字符串使用<code>length()</code>方法</li></ul><p>下面我来回答原因。</p><h2 id="为什么数组有-length属性？">为什么数组有<code>.length</code>属性？</h2><p>在Java中，数组是容器对象，其中包含了固定数量的同一类型的值，一旦数组创建，其长度就是固定的了，于是，其长度可以作为一个属性。</p><h2 id="为什么字符串需要length-方法？">为什么字符串需要<code>length()</code>方法？</h2><p>Java中的String，实际上是一个char类型数组，而char[]已经有了<code>.length</code>属性，所以在实现String时就没必要再定义重复的属性了，于是需要定义一个方法来返回其长度。</p><p><br><br>本文链接： <a href="http://meng.uno/articles/61c2f1f1/">http://meng.uno/articles/61c2f1f1/</a> 欢迎转载！</p><div><h1>其他推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="http://meng.uno/articles/7526d370/">Java异常处理</a></li><li><a href="http://meng.uno/articles/fff444e8/">二分查找的效率</a></li><li><a href="http://meng.uno/articles/f3057e6c/">Java Substring() 的实现</a></li><li><a href="http://meng.uno/articles/1164dab2/">Java异常结构层次图</a></li><li><a href="http://www.libinx.com/2017/auto-conversion-and-narrow-conversion-in-Java/">Java | 自动类型转换和强制类型转换</a></li><li><a href="http://www.libinx.com/2017/Java-GBK-error/">Java 错误 编码GBK的不可映射字符</a></li><li><a href="http://www.libinx.com/2017/variables-in-Java/">Java | 变量</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      当我们需要使用数组或者字符串长度时，习惯了使用IDE自动补全的我们是否知道.length与length()的区别喻原因呢？

上面问题的答案是：

 * 数组使用.length属性
 * 字符串使用length()方法

下面我来回答原因。

为什么数组有.length属性？
在Java中，数组是容器对象，其中包含了固定数量的同一类型的值，一旦数组创建，其长度就是固定的了，于是，其长度可以作为一个属性。

为什么字符串需要length()方法？
Java中的String，实际上是一个char类型数组，而char[]已经有了.length属性，所以在实现String时就没必要再定义重复的属性了，
    
    </summary>
    
      <category term="Java开发Tips" scheme="http://meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/"/>
    
      <category term="String" scheme="http://meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/String/"/>
    
      <category term="Object" scheme="http://meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/String/Object/"/>
    
    
      <category term="Java" scheme="http://meng.uno/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java异常结构层次图</title>
    <link href="http://meng.uno/articles/1164dab2/"/>
    <id>http://meng.uno/articles/1164dab2/</id>
    <published>2018-02-09T14:11:15.000Z</published>
    <updated>2018-02-10T14:51:35.021Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中，异常分为<code>checked</code>与<code>unchecked</code>，他们都在一个分类层次中，如下图。</p><p><img src="http://www.meng.uno/images/ehd.jpeg" alt="DEH"></p><p>其中，红色的异常是<code>checked</code>异常，意味着在一个方法中，他们<code>throw</code>后必须<code>catch</code>或者<code>declare</code>。</p><p>另一种颜色的为<code>unchecked</code>异常，他们的异常不需要被<code>recover</code>。</p><p><br><br>本文链接： <a href="http://meng.uno/articles/1164dab2/">http://meng.uno/articles/1164dab2/</a> 欢迎转载！</p><div><h1>其他推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="http://meng.uno/articles/7526d370/">Java异常处理</a></li><li><a href="http://meng.uno/articles/61c2f1f1/">.length与length()的区别</a></li><li><a href="http://meng.uno/articles/fff444e8/">二分查找的效率</a></li><li><a href="http://meng.uno/articles/f3057e6c/">Java Substring() 的实现</a></li><li><a href="http://www.libinx.com/2017/auto-conversion-and-narrow-conversion-in-Java/">Java | 自动类型转换和强制类型转换</a></li><li><a href="http://www.libinx.com/2017/Java-GBK-error/">Java 错误 编码GBK的不可映射字符</a></li><li><a href="http://www.libinx.com/2017/variables-in-Java/">Java | 变量</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      在Java中，异常分为checked与unchecked，他们都在一个分类层次中，如下图。



其中，红色的异常是checked异常，意味着在一个方法中，他们throw后必须catch或者declare。

另一种颜色的为unchecked异常，他们的异常不需要被recover。



本文链接： http://meng.uno/articles/1164dab2/ 欢迎转载！
    
    </summary>
    
      <category term="Java开发Tips" scheme="http://meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/"/>
    
      <category term="Exception" scheme="http://meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/Exception/"/>
    
    
      <category term="Java" scheme="http://meng.uno/tags/Java/"/>
    
      <category term="Exception" scheme="http://meng.uno/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>二分查找的效率</title>
    <link href="http://meng.uno/articles/fff444e8/"/>
    <id>http://meng.uno/articles/fff444e8/</id>
    <published>2018-02-08T09:20:00.000Z</published>
    <updated>2018-02-10T13:05:27.172Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>查找是比较常见的工作，今天我通过对比几种在数组中查找一个确定的值的例子来向大家展示二分查找的魅力。</p></blockquote><h2 id="数组查找元素的几种方法">数组查找元素的几种方法</h2><h3 id="使用list">使用List</h3><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">useList</span><span class="params">(String[] arr, String targetValue)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Arrays.asList(arr).contains(targetValue);</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="使用set">使用Set</h3><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">useSet</span><span class="params">(String[] arr, String targetValue)</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(arr));</span><br><span class="line"><span class="keyword">return</span> set.contains(targetValue);</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="使用for-loop">使用for-loop</h3><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">useLoop</span><span class="params">(String[] arr, String targetValue)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(String s: arr)&#123;</span><br><span class="line"><span class="keyword">if</span>(s.equals(targetValue))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="使用二分">使用二分</h3><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">useArraysBinarySearch</span><span class="params">(String[] arr, String targetValue)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a =  Arrays.binarySearch(arr, targetValue);</span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="时间复杂性">时间复杂性</h2><h3 id="代码">代码</h3><blockquote>  <p>使用如下代码来验证不同数据规模（5，1k，10k）的查找任务下四种方法的时间复杂性。（二分查找需要对数据排序，排序时间未计算在内。）</p></blockquote><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String[] arr = <span class="keyword">new</span> String[] &#123;  <span class="string">"CD"</span>,  <span class="string">"BC"</span>, <span class="string">"EF"</span>, <span class="string">"DE"</span>, <span class="string">"AB"</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//use list</span></span><br><span class="line"><span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">useList(arr, <span class="string">"A"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line"><span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">System.out.println(<span class="string">"useList:  "</span> + duration / <span class="number">1000000</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//use set</span></span><br><span class="line">startTime = System.nanoTime();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">useSet(arr, <span class="string">"A"</span>);</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.nanoTime();</span><br><span class="line">duration = endTime - startTime;</span><br><span class="line">System.out.println(<span class="string">"useSet:  "</span> + duration / <span class="number">1000000</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//use loop</span></span><br><span class="line">startTime = System.nanoTime();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">useLoop(arr, <span class="string">"A"</span>);</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.nanoTime();</span><br><span class="line">duration = endTime - startTime;</span><br><span class="line">System.out.println(<span class="string">"useLoop:  "</span> + duration / <span class="number">1000000</span>);</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="5-结果">&quot;5&quot;结果</h3><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">useList:  <span class="number">13</span></span><br><span class="line">useSet:  <span class="number">72</span></span><br><span class="line">useLoop:  <span class="number">5</span></span><br></pre>      </td>    </tr>  </table></figure><h3 id="1k-结果">&quot;1k&quot;结果</h3><h4 id="随机生成数据">随机生成数据</h4><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">String[] arr = <span class="keyword">new</span> String[<span class="number">1000</span>];</span><br><span class="line"> </span><br><span class="line">Random s = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">arr[i] = String.valueOf(s.nextInt());</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h4 id="结果">结果</h4><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">useList:  <span class="number">112</span></span><br><span class="line">useSet:  <span class="number">2055</span></span><br><span class="line">useLoop:  <span class="number">99</span></span><br><span class="line">useArrayBinary:  <span class="number">12</span></span><br></pre>      </td>    </tr>  </table></figure><h3 id="10k-结果">&quot;10k&quot;结果</h3><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">useList:  <span class="number">1590</span></span><br><span class="line">useSet:  <span class="number">23819</span></span><br><span class="line">useLoop:  <span class="number">1526</span></span><br><span class="line">useArrayBinary:  <span class="number">12</span></span><br></pre>      </td>    </tr>  </table></figure><h2 id="结论">结论</h2><p>通过以上结果，我们可以发现二分搜索确实很高效，而且当数据量变大时，其时间增长幅度还比较小。</p><p>以后，我们就可以使用<code>Arrays.binarySearch()</code>来高效查找某元素了。</p><p><br><br>本文链接： <a href="http://meng.uno/articles/fff444e8/">http://meng.uno/articles/fff444e8/</a> 欢迎转载！</p><div><h1>其他推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="http://meng.uno/articles/7526d370/">Java异常处理</a></li><li><a href="http://meng.uno/articles/61c2f1f1/">.length与length()的区别</a></li><li><a href="http://meng.uno/articles/f3057e6c/">Java Substring() 的实现</a></li><li><a href="http://meng.uno/articles/1164dab2/">Java异常结构层次图</a></li><li><a href="http://www.libinx.com/2017/auto-conversion-and-narrow-conversion-in-Java/">Java | 自动类型转换和强制类型转换</a></li><li><a href="http://www.libinx.com/2017/Java-GBK-error/">Java 错误 编码GBK的不可映射字符</a></li><li><a href="http://www.libinx.com/2017/variables-in-Java/">Java | 变量</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      查找是比较常见的工作，今天我通过对比几种在数组中查找一个确定的值的例子来向大家展示二分查找的魅力。

数组查找元素的几种方法
使用List
1
2
3


public static boolean useList(String[] arr, String targetValue) {
	return Arrays.asList(arr).contains(targetValue);
}


使用Set
1
2
3
4


public static boolean useSet(String[] arr, String targetValue) {
	Set&lt;String&gt; set = ne
    
    </summary>
    
      <category term="Java开发Tips" scheme="http://meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/"/>
    
      <category term="Search" scheme="http://meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/Search/"/>
    
    
      <category term="Java" scheme="http://meng.uno/tags/Java/"/>
    
      <category term="算法复杂性" scheme="http://meng.uno/tags/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E6%80%A7/"/>
    
      <category term="二分查找" scheme="http://meng.uno/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java Substring() 的实现</title>
    <link href="http://meng.uno/articles/f3057e6c/"/>
    <id>http://meng.uno/articles/f3057e6c/</id>
    <published>2018-02-08T07:43:08.000Z</published>
    <updated>2018-03-02T03:26:32.958Z</updated>
    
    <content type="html"><![CDATA[<p>写过Java的人应该都用过<code>substring(int bedinIndex, int endIndex)</code>方法。我发现这个简单的方法在实现上居然经过了一次大的变革。</p><h2 id="substring-的用途">substring()的用途</h2><p>代码:</p><figure class="highlight">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">String origin = "asdfg"; </span><br><span class="line">origin = origin.substring(1,3);</span><br><span class="line">System.out.println(origin);</span><br></pre>      </td>    </tr>  </table></figure><p>输出:</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">sd</span><br></pre>      </td>    </tr>  </table></figure><p>我们发现它能将原始字符串中从下标为beginIndex到endIndex-1之间的子串取出。那它是怎么实现的呢？</p><h2 id="substring-的实现">substring()的实现</h2><blockquote>  <p>Java中的字符串有三个域：char value[], int offset以及int count，它们分别存储字符串的值，起始下标与长度。</p></blockquote><h3 id="jdk6版本">JDK6版本</h3><p>在这个版本中，每次执行substring()方法时并不会新建新的string，仅仅只是将上述三个域中的offset，count做必要的修改。返回对象仍指向原来的数据。</p><p><img src="http://www.meng.uno/images/substring/substring_jdk.png" alt="Substring()实现版本一"></p><p>这样一来，<strong><em>缺点</em></strong>就比较明显：当原始字符串比较长，而截取的子串比较短时，在后续的使用中就会浪费大量的空间。</p><h3 id="jdk7-版本">JDK7+版本</h3><p>在上一个版本基础上，这个方法进行了改进，每次使用这个方法都会新建一个string对象，并将其返回。</p><p><img src="http://www.meng.uno/images/substring/substring_jdk7.png" alt="Substring()实现版本二"></p><p><br><br>本文链接： <a href="http://meng.uno/articles/f3057e6c/">http://meng.uno/articles/f3057e6c/</a> 欢迎转载！</p><div><h1>其他推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="http://meng.uno/articles/7526d370/">Java异常处理</a></li><li><a href="http://meng.uno/articles/61c2f1f1/">.length与length()的区别</a></li><li><a href="http://meng.uno/articles/fff444e8/">二分查找的效率</a></li><li><a href="http://meng.uno/articles/1164dab2/">Java异常结构层次图</a></li><li><a href="http://www.libinx.com/2017/auto-conversion-and-narrow-conversion-in-Java/">Java | 自动类型转换和强制类型转换</a></li><li><a href="http://www.libinx.com/2017/Java-GBK-error/">Java 错误 编码GBK的不可映射字符</a></li><li><a href="http://www.libinx.com/2017/variables-in-Java/">Java | 变量</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      写过Java的人应该都用过substring(int bedinIndex, int endIndex)方法。我发现这个简单的方法在实现上居然经过了一次大的变革。

substring()的用途
代码:

1
2
3


String origin = &quot;asdfg&quot;; 
origin = origin.substring(1,3);
System.out.println(origin);


输出:

1


sd


我们发现它能将原始字符串中从下标为beginIndex到endIndex-1之间的子串取出。那它是怎么实现的呢？

substring()的实现
Java中的字符串有三个域：
    
    </summary>
    
      <category term="Java开发Tips" scheme="http://meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/"/>
    
    
      <category term="Java" scheme="http://meng.uno/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java异常处理</title>
    <link href="http://meng.uno/articles/7526d370/"/>
    <id>http://meng.uno/articles/7526d370/</id>
    <published>2018-02-01T14:21:52.000Z</published>
    <updated>2018-02-10T14:51:35.019Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中，调用某方法，就必须处理被调用方法抛出的异常，同时超类也可以用来捕获或者处理子类异常。</p><h2 id="调用方法必须处理被调用方法抛出的异常">调用方法必须处理被调用方法抛出的异常</h2><p>下面是一个处理异常的程序。我们可以测试一下，如果在一个方法中抛出一个异常，不仅是该方法，而且所有调用该方法的方法都必须声明或抛出异常。</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">exceptionTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Exception exception;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            callDoOne(); </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doOne</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callDoOne</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        doOne();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="超类可以用来捕获或处理子类异常">超类可以用来捕获或处理子类异常</h2><p>可以使用如下代码验证。</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">exceptionTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Exception exception;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> myException myexception;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            callDoOne(); </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doOne</span><span class="params">()</span> <span class="keyword">throws</span> myException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> myexception;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callDoOne</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        doOne();</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>这也就是为什么catch子句只有一个父类在语法上安全的原因。</p><p><br><br>本文链接： <a href="http://meng.uno/articles/7526d370/">http://meng.uno/articles/7526d370/</a> 欢迎转载！</p><div><h1>其他推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="http://meng.uno/articles/61c2f1f1/">.length与length()的区别</a></li><li><a href="http://meng.uno/articles/fff444e8/">二分查找的效率</a></li><li><a href="http://meng.uno/articles/f3057e6c/">Java Substring() 的实现</a></li><li><a href="http://meng.uno/articles/1164dab2/">Java异常结构层次图</a></li><li><a href="http://www.libinx.com/2017/auto-conversion-and-narrow-conversion-in-Java/">Java | 自动类型转换和强制类型转换</a></li><li><a href="http://www.libinx.com/2017/Java-GBK-error/">Java 错误 编码GBK的不可映射字符</a></li><li><a href="http://www.libinx.com/2017/variables-in-Java/">Java | 变量</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      在Java中，调用某方法，就必须处理被调用方法抛出的异常，同时超类也可以用来捕获或者处理子类异常。

调用方法必须处理被调用方法抛出的异常
下面是一个处理异常的程序。我们可以测试一下，如果在一个方法中抛出一个异常，不仅是该方法，而且所有调用该方法的方法都必须声明或抛出异常。

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15


public class exceptionTest {
    private static Exception exception;
 
    public static void main(String[] args) throws Ex
    
    </summary>
    
      <category term="Java开发Tips" scheme="http://meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/"/>
    
      <category term="Exception" scheme="http://meng.uno/categories/Java%E5%BC%80%E5%8F%91Tips/Exception/"/>
    
    
      <category term="Java" scheme="http://meng.uno/tags/Java/"/>
    
      <category term="Exception" scheme="http://meng.uno/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>Analysis For Hyperkernel</title>
    <link href="http://meng.uno/articles/55c9299d/"/>
    <id>http://meng.uno/articles/55c9299d/</id>
    <published>2018-01-29T13:43:03.000Z</published>
    <updated>2018-02-10T14:56:55.140Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>Homepage: <a href="https://locore.cs.washington.edu/hyperkernel/" target="_blank" rel="noopener">https://locore.cs.washington.edu/hyperkernel/</a> Code: <a href="https://github.com/locore/hv6" target="_blank" rel="noopener">https://github.com/locore/hv6</a></p></blockquote><h2 id="state-machine-specification">State-machine Specification</h2><p>State-machine specification means the system function will first verify the old procedure until the procedure is runnable and then return a new procedure and write to the system image. All of these must run in the user level. This specification consists  of two parts: a definition of abstract kernel state, and a definition of trap handlers (e.g., system calls) in terms of abstract state transitions. They use fully automated technique to find bugs and this method is full functional verification if program  is free of loops and state is finite.</p><p>The “hv6/hv6/spec/kernel/spec/specs.py” file contains the system calls which use this kind of specification. From the picture, we can see that they use Z3 to prove the correction of the “old” procedure and if it can transfer to a new state or it is runnable,  it will return the new procedure so that it can be proved true.</p><h2 id="declarative-specification">Declarative Specification</h2><p>The authors also provide a declarative specification of the high level properties that the state-machine specification should satisfy. The verifier will check that these high level properties are indeed satisfied, helping increase the programmer’s confidence  in the correctness of the state-machine specification. To improve confidence in its correctness, there is a higher-level declarative specification to better capture programmer intuition about kernel behavior, in the form of a conjunction of crosscutting  properties that hold across all trap handlers.</p><p><br><br>本文链接： <a href="http://meng.uno/articles/55c9299d/">http://meng.uno/articles/55c9299d/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      Homepage: https://locore.cs.washington.edu/hyperkernel/ Code: https://github.com/locore/hv6

State-machine Specification
State-machine specification means the system function will first verify the old procedure until the procedure is runnable and then return a new procedure and write to the system i
    
    </summary>
    
      <category term="操作系统" scheme="http://meng.uno/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="系统验证" scheme="http://meng.uno/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E9%AA%8C%E8%AF%81/"/>
    
    
      <category term="System" scheme="http://meng.uno/tags/System/"/>
    
      <category term="Verification" scheme="http://meng.uno/tags/Verification/"/>
    
  </entry>
  
  <entry>
    <title>怎么处理噪声</title>
    <link href="http://meng.uno/articles/a12d1477/"/>
    <id>http://meng.uno/articles/a12d1477/</id>
    <published>2018-01-27T14:35:33.000Z</published>
    <updated>2018-02-17T02:10:40.282Z</updated>
    
    <content type="html"><![CDATA[<p>处理噪声是一个在机器学习学习过程中，总会被问到的问题。噪声可以出现在输入<code>X</code>，亦可以出现在输出<code>Y</code>中。</p><h2 id="x中缺失值"><code>X</code>中缺失值</h2><ol>  <li>使用来自所有可用数据的特征的平均值</li>  <li>忽略实例</li>  <li>使用来自类似项目的平均值</li>  <li>使用另一个机器学习算法来预测值</li></ol><ul>  <li>Bagging 或者 Boosting</li></ul><p><br><br>本文链接： <a href="http://meng.uno/articles/a12d1477/">http://meng.uno/articles/a12d1477/</a> 欢迎转载！</p><div><h1>其他推荐文章<span style="font-size:0.45em; color:gray"></h1><ul><li><a href="http://meng.uno/articles/6c0d033f/">主成分分析（PCA）</a></li><li><a href="http://meng.uno/articles/177fbbcc/">使用EM算法优化的GMM</a></li><li><a href="http://meng.uno/articles/1af17fd9/">多项式拟合曲线——最小二乘法</a></li><li><a href="http://www.libinx.com/2016/2016-11-09-machine-learning-algorithm-series-decision-tree/">机器学习算法系列（1）决策树</a></li><li><a href="http://www.libinx.com/2017/2017-02-26-machine-learning-algorithm-series-svm-2/">机器学习算法系列（5）支持向量机（二）</a></li><li><a href="http://www.libinx.com/2016/2016-11-12-machine-learning-algorithm-series-linearing-regression/">机器学习算法系列（2）多元线性回归</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      处理噪声是一个在机器学习学习过程中，总会被问到的问题。噪声可以出现在输入X，亦可以出现在输出Y中。

X中缺失值
 1. 使用来自所有可用数据的特征的平均值
 2. 忽略实例
 3. 使用来自类似项目的平均值
 4. 使用另一个机器学习算法来预测值

 * Bagging 或者 Boosting



本文链接： http://meng.uno/articles/a12d1477/ 欢迎转载！
    
    </summary>
    
      <category term="AI" scheme="http://meng.uno/categories/AI/"/>
    
      <category term="机器学习" scheme="http://meng.uno/categories/AI/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://meng.uno/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="噪声" scheme="http://meng.uno/tags/%E5%99%AA%E5%A3%B0/"/>
    
  </entry>
  
  <entry>
    <title>Analysis for Yggdrasil</title>
    <link href="http://meng.uno/articles/5ed9f695/"/>
    <id>http://meng.uno/articles/5ed9f695/</id>
    <published>2018-01-16T14:31:00.000Z</published>
    <updated>2018-02-11T14:48:52.840Z</updated>
    
    <content type="html"><![CDATA[<p>Yggdrasil is a toolkit for verifying file system with push-button verification via crash refinement. As for push-button verification, it means that Yggdrasil needs no manual annotations or proofs. As for crash refinement, it is amenable to fully automated  SMT reasoning. The whole verification is something like the State-Machine Specification in the project “Hyperkernel”.</p><p>The whole system architecture is shown as follows.</p><p><img src="http://www.meng.uno/images/yggdrasil/1.png" alt="Yggdrasil"></p><p>From this picture, we know that Yggdrasil needs three inputs: a specification of the expected behavior, an implementation and consistency invariants which indicate whether a file system image is in a consistent state or not. For better run-time performance,  Yggdrasil optionally performs optimizations. If there is a bug, Yggdrasil produces a counterexample to help identify and fix the cause. It requires no manual annotations or proofs about the implementation code. Once the verification passes, Yggdrasil  emits C code, which is then compiled and linked using a C compiler to produce an executable file system, as well as a “fsck” checker.</p><p>The above is the entire overall content of this project. The authors also introduced every part of this project. I will analyze it by following the paper.</p><h2 id="single-level-file-system-yminlfs">Single-level File System (YminLFS)</h2><p>In this project, every file system must contain three parts: an abstract data structure, a set of operations and a state equivalence predicate which defines whether a given implementation satisfies the specification. So the authors first defines a file  system which contains these features.</p><p><img src="http://www.meng.uno/images/yggdrasil/2.png" alt="Yggdrasil"></p><p><img src="http://www.meng.uno/images/yggdrasil/3.png" alt="Yggdrasil"></p><p><img src="http://www.meng.uno/images/yggdrasil/4.png" alt="Yggdrasil"></p><p><img src="http://www.meng.uno/images/yggdrasil/5.png" alt="Yggdrasil"></p><p>Then it runs the verification. Yggdrasil uses the Z3 solver to prove a two-part crash refinement.</p><p>The first part deals with crash-free executions which requires the implementation and specification are similar in the absence of crashes, which means if both YminLFS and FSSpec start in equivalent and consistent states, they end up in equivalent and  consistent states (just like state-machine). This project defines equivalence using the equivalent predicate and defines consistency using the consistency invariants as the above pictures show.</p><p>The second part deals with crash executions which requires the implementation to exist no more crash states than the specification, which means each possible state of the YminLFS implementation must be equivalent to some crash state of FSSpec. What’s  more, Yggdrasil provides a greedy optimizer that tries to remove every disk flush and re-verify the code.</p><h2 id="multi-level-file-system-yxv6">Multi-level File System (Yxv6)</h2><p>We could directly prove crash refinement between the entire file system specification and implementation in a single-level file system, however, we couldn’t use the same method in a complex multi-level file system. First, let’s look at the structure of  Yxv6 journaling file system.</p><p><img src="http://www.meng.uno/images/yggdrasil/6.png" alt="Yggdrasil"></p><p>This is the 5 layers of abstraction and every layer contains a specification and a implementation. The authors use this project to prove crash refinement for each layer and upper layers then use the specifications of lower layers. The lowest layer of  the stack is a specification of an asynchronous disk. This specification comprises the asynchronous disk model which is to implement YminLFS.</p><h2 id="application-level-ycp">Application-level (“Ycp”)</h2><p>Ycp has a formal specification which means if the copy operation succeeds, the result is the same as “cp”, however, if it fails, the file system is unchanged. To achieve this propose, the implementation of Ycp is something similar to Yxv6 file system  specification. There are 3 atomicity patterns which are “create a temporary file”, “write the source data to it” and “rename it to atomically create the target file”. After doing such an analogy, verifying this operation is similar to verify the single-level  file system.</p><p><br><br>本文链接： <a href="http://meng.uno/articles/5ed9f695/">http://meng.uno/articles/5ed9f695/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      Yggdrasil is a toolkit for verifying file system with push-button verification via crash refinement. As for push-button verification, it means that Yggdrasil needs no manual annotations or proofs. As for crash refinement, it is amenable to fully automated SMT reasoning. The whole verification is som
    
    </summary>
    
      <category term="System Verification" scheme="http://meng.uno/categories/System-Verification/"/>
    
      <category term="Yggdrasil" scheme="http://meng.uno/categories/System-Verification/Yggdrasil/"/>
    
    
      <category term="Yggdrasil" scheme="http://meng.uno/tags/Yggdrasil/"/>
    
      <category term="System Verification" scheme="http://meng.uno/tags/System-Verification/"/>
    
  </entry>
  
</feed>
