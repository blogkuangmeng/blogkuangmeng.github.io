<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">

  <meta http-equiv="X-Frame-Options" content="DENY">
  <title>I/O体系结构 | 欢迎来到匡盟盟的博客！</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta name="keywords" content="匡盟盟, Mengmeng Kuang, Blog, 博客" />


  <meta name="google-site-verification" content="3YclHsmiu1_poywYScAg4jt4RGqoHUoIXQJFV5vEZ1I" />


  <meta name="baidu-site-verification" content="d6tIQA0tgL" />


  <meta name="description" content="I/O体系结构 虚拟文件系统利用底层函数，调用每个设备的操作，那么这些操作是如何在设备上执行的，操作系统又是如何知道设备的操作是什么的呢？这些是由操作系统决定的。 我们知道，操作系统的工作，是依赖于数据通路的，它们让信息得以在CPU、RAM、I/O设备之间传递。这些数据通路称为 总线。这就包括数据总线（PCI、ISA、EISA、SCSI等）、地址总线、控制总线。I/O总线，指的就是用于CPU和I/">
  <meta name="keywords" content="Linux,I&#x2F;O">
  <meta property="og:type" content="article">
  <meta property="og:title" content="I&#x2F;O体系结构">
  <meta property="og:url" content="http://www.meng.uno/articles/d0c0e94a/index.html">
  <meta property="og:site_name" content="欢迎来到匡盟盟的博客！">
  <meta property="og:description" content="I/O体系结构 虚拟文件系统利用底层函数，调用每个设备的操作，那么这些操作是如何在设备上执行的，操作系统又是如何知道设备的操作是什么的呢？这些是由操作系统决定的。 我们知道，操作系统的工作，是依赖于数据通路的，它们让信息得以在CPU、RAM、I/O设备之间传递。这些数据通路称为 总线。这就包括数据总线（PCI、ISA、EISA、SCSI等）、地址总线、控制总线。I/O总线，指的就是用于CPU和I/">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:image" content="http://www.meng.uno/images/%E7%A3%81%E7%9B%98IO/IO%E7%BB%93%E6%9E%84.png">
  <meta property="og:image" content="http://www.meng.uno/images/%E7%A3%81%E7%9B%98IO/kobjmap.jpg">
  <meta property="og:image" content="http://ww.meng.uno/images/%E7%A3%81%E7%9B%98IO/%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8.png">
  <meta property="og:image" content="http://www.meng.uno/images/%E7%A3%81%E7%9B%98IO/biovec.gif">
  <meta property="og:updated_time" content="2018-04-10T05:46:42.000Z">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="I&#x2F;O体系结构">
  <meta name="twitter:description" content="I/O体系结构 虚拟文件系统利用底层函数，调用每个设备的操作，那么这些操作是如何在设备上执行的，操作系统又是如何知道设备的操作是什么的呢？这些是由操作系统决定的。 我们知道，操作系统的工作，是依赖于数据通路的，它们让信息得以在CPU、RAM、I/O设备之间传递。这些数据通路称为 总线。这就包括数据总线（PCI、ISA、EISA、SCSI等）、地址总线、控制总线。I/O总线，指的就是用于CPU和I/">
  <meta name="twitter:image" content="http://www.meng.uno/images/%E7%A3%81%E7%9B%98IO/IO%E7%BB%93%E6%9E%84.png">
  <meta name="twitter:creator" content="@kuangmengmeng">
  <link rel="publisher" href="mengmengkuang">
  <meta property="fb:admins" content="kuangmengmeng">
  <meta property="fb:app_id" content="1559086807462632">

  <link rel="alternate" href="/atom.xml" title="欢迎来到匡盟盟的博客！" type="application/atom+xml">




  <link rel="icon" id="myid" href="/css/images/logo.png">
  <link rel="apple-touch-icon" id="myid" href="/css/images/logo.png">

  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">

  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face {
      font-family: futura-pt;
      src: url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");
      font-weight: 500;
      font-style: normal;
    }

    @font-face {
      font-family: futura-pt;
      src: url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");
      font-weight: 500;
      font-style: normal;
    }

    @font-face {
      font-family: futura-pt;
      src: url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");
      font-weight: lighter;
      font-style: normal;
    }

    @font-face {
      font-family: futura-pt;
      src: url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");
      font-weight: 400;
      font-style: italic;
    }
  </style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>
  <script src="/js/bootstrap.js"></script>
  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">
  <link rel="stylesheet" href="/css/prism-duotone-sea.css">


  <link rel="stylesheet" href="/css/dialog.css">





  <link rel="stylesheet" href="/css/header-post.css">





  <link rel="stylesheet" href="/css/vdonate.css">




  <!-- 
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":["copy","weixin","linkedin","sqq","tsina","twi","fbook","mail"],"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"0","bdPos":"left","bdTop":"100"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

 -->





  <link rel="canonical" href="http://www.meng.uno/articles/d0c0e94a/" />

  <link rel="stylesheet" href="/css/animate.css">
  <link rel="stylesheet" href="/css/loading.css">

  <script>
    var linkEle = document.getElementById("myid");
    var tmplink = linkEle.href;

    var tmptitle = document.title;
    document.addEventListener('visibilitychange', function() {
      var isHidden = document.hidden;
      if (isHidden) {
        document.title = '喔唷，崩溃啦！';
        linkEle.href = '/css/images/avatar.png';
      } else {
        document.title = tmptitle;
        linkEle.href = tmplink;

      }
    });


    function Hide() {
      var mychar = document.getElementById("homelogoback").style.display = "none";
    }
  </script>

  <script defer src="https://use.fontawesome.com/releases/v5.0.8/js/all.js"></script>




</head>


<body data-spy="scroll" data-target="#toc" data-offset="50">



  <div id="container">
    <div id="wrap">

      <header>
        <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
          <div class="navbar-inner">
            <div class="container">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>


              <a class="brand" style="
                 border-width: 0px;  margin-top: 0px;" href="#" data-toggle="modal" data-target="#myModal">
                  <img class="img-rotate" style="box-shadow:1px 1px 10px 3px #e5e5e5; border-radius: 50%;" width="124px" height="124px" alt="匡盟盟的博客" src="/css/images/logo.png">
              </a>


              <div class="navbar-collapse collapse">
                <ul class="hnav navbar-nav">

                  <li> <a class="main-nav-link" href="/">首页</a> </li>

                  <li> <a class="main-nav-link" href="/archives">所有文章</a> </li>

                  <li> <a class="main-nav-link" href="/categories">分类</a> </li>

                  <li> <a class="main-nav-link" href="/tags">标签</a> </li>

                  <li> <a class="main-nav-link" href="/about">关于我</a> </li>

                  <li> <a class="main-nav-link" href="/comments">留言板</a> </li>

                  <li>
                    <div id="search-form-wrap">

                      <form class="search-form">
                        <input type="text" style="width=0;" class="ins-search-input search-form-input" placeholder="" />
                        <button type="submit" class="search-form-submit"></button>
                      </form>
                      <div class="ins-search">
                        <div class="ins-search-mask"></div>
                        <div class="ins-search-container">
                          <div class="ins-input-wrapper">
                            <input type="text" class="ins-search-input" placeholder="请输入关键词..." />
                            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
                          </div>
                          <div class="ins-section-wrapper">
                            <div class="ins-section-container"></div>
                          </div>
                        </div>
                      </div>
                      <script>
                        (function(window) {
                          var INSIGHT_CONFIG = {
                            TRANSLATION: {
                              POSTS: '文章',
                              PAGES: '页面',
                              CATEGORIES: '分类',
                              TAGS: '标签',
                              UNTITLED: '空标题',
                            },
                            ROOT_URL: '/',
                            CONTENT_URL: '/content.json',
                          };
                          window.INSIGHT_CONFIG = INSIGHT_CONFIG;
                        })(window);
                      </script>
                      <script src="/js/insight.js"></script>

                    </div>
                  </li>

                </ul>
              </div>
            </div>

          </div>
        </div>

      </header>

      <script>
        (function(w, i, d, g, e, t, s) {
          w[d] = w[d] || [];
          t = i.createElement(g);
          t.async = 1;
          t.src = e;
          s = i.getElementsByTagName(g)[0];
          s.parentNode.insertBefore(t, s);
        })(window, document, '_gscq', 'script', '//widgets.getsitecontrol.com/125646/script.js');
      </script>


      <div id="content" class="outer">

        <section id="main" style="float:none;">
          <article id="post-io-system" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost">
            <div id="articleInner" class="article-inner">


              <header class="article-header">
                <h1 class="thumb" class="article-title" itemprop="name">
                  I/O体系结构
                </h1>
              </header>

              <div class="article-meta">
                <a href="/articles/d0c0e94a/" class="article-date">
	  <time datetime="2016-07-15T04:28:52.000Z" itemprop="datePublished">2016-07-15</time>
	</a>
                <a class="article-category-link" href="/categories/操作系统/">操作系统</a>
                <a class="article-views">
	<span id="busuanzi_container_page_pv">
		阅读量<span id="busuanzi_value_page_pv"></span>
	</span>
	<span class="post-count"> | 字数5,206</span>
	<span class="post-count"> | 预计时间20分钟</span>
	</a>
              </div>
              <div class="article-entry" itemprop="articleBody">

                <h1>I/O体系结构</h1>
                <p>虚拟文件系统利用底层函数，调用每个设备的操作，那么这些操作是如何在设备上执行的，操作系统又是如何知道设备的操作是什么的呢？这些是由操作系统决定的。<br> 我们知道，操作系统的工作，是依赖于数据通路的，它们让信息得以在CPU、RAM、I/O设备之间传递。这些数据通路称为
                  <strong>总线</strong>。这就包括数据总线（PCI、ISA、EISA、SCSI等）、地址总线、控制总线。I/O总线，指的就是用于CPU和I/O设备之间通信的<strong>数据总线</strong>。I/O体系的通用结构如图所示：</p>
                <p><img src="http://www.meng.uno/images/%E7%A3%81%E7%9B%98IO/IO%E7%BB%93%E6%9E%84.png" alt=""></p>
                <p>那么CPU是如何通过I/O总线和I/O设备交互呢？这首先得从内存和外设的编址方式说起。第一种是“独立编址”，也就是内存和外设分开编址，I/O端口有独立的地址空间，这也被称为<strong>I/O映射方式</strong>。每个连接到I/O总线上的设备，都分配了自己的I/O地址集（在I/O地址空间中），它被称为I/O端口。<code>in</code>、<code>out</code>等指令用语CPU对I/O端口进行读写。在执行其中一条指令时，CPU使用地址总线选择所请求的I/O端口，使用数据总线在CPU寄存器和端口之间传送数据。这种方式编码逻辑清晰，速度快，但空间有限。</p>
                <p>第二种是“统一编址”，也被称为<strong>内存映射方式</strong>，I/O端口还可以被映射到内存地址空间（这也正是现代硬件设备倾向于使用的方式），这样CPU就可以通过对内存操作的指令，来访问I/O设备，并且和DMA结合起来。这种方式更加统一，易于使用。它实际上使用了<code>ioremap()</code>。<strong>自从PCI总线出现后，不论采用I/O映射还是内存映射方式，都需要将I/O端口映射到内存地址空间</strong>。</p>
                <p>每个I/O设备的I/O端口都是一组寄存器：控制寄存器、状态寄存器、输入寄存器和输出寄存器。内核会纪录分配给每个硬件设备的I/O端口。</p>
                <h1>设备驱动程序模型</h1>
                <p>在内核中，设备不仅仅需要完成相应的操作，还要对其电源管理、资源分配、生命周期等等行为进行统一的管理。因此，内核建立了一个统一的设备模型，提取设备操作的共同属性，进行抽象，并且为添加设备、安装驱动提供统一的接口。它们本身并不代表具体的对象，只是用来维持对象间的层次关系。</p>
                <p>这里首先要提的是<strong>sysfs</strong>文件系统。和/proc类似，安装于/sys目录，其目的是表现出设备驱动程序模型间的层次关系。在驱动程序模型当中，有三种重要的数据结构（旧版本），自上到下分别是<code>subsystem</code>、<code>kset</code>、<code>kobject</code>。如果要理解这个模型中，每个数据结构的作用，就必须理解它们和操作系统中的什么东西相对应。它们均对应着**/sys中的目录**。<code>kobject</code>是这个对象模型中，所有对象的基类。<code>kset</code>本身首先是一个<code>kobject</code>，而它又承担着一个<code>kobject</code>容器的作用，它把<code>kobject</code>组织成有序的目录；subsys则是更高的一层抽象，它本身首先是一个<code>kset</code>。驱动、总线、设备都能够用设备驱动程序模型中的对象表示。</p>
                <h1>设备驱动程序模型中的组件</h1>
                <p>设备驱动程序模型建立在几个基本数据结构之上，它们描述了总线、设备、设备驱动器等等。这里，我们来看看它们的数据结构。首先，<code>device</code>用来描述设备驱动程序模型中的设备。</p>
                <pre><code>struct device {
struct device		*parent;//父设备
struct kobject kobj;		//对应的kobject
const char		*init_name; //初始化名

const struct device_type *type;//设备的类型

struct mutex		mutex;	//驱动的互斥量

struct bus_type	*bus;		//设备在什么类型的总线
struct device_driver *driver;	//设备的驱动

void		*driver_data;	//驱动私有数据指针
struct dev_pm_info	power;
struct dev_pm_domain	*pm_domain;
//dma相关变量
u64		*dma_mask;			
u64		coherent_dma_mask;	
unsigned long	dma_pfn_offset;
struct device_dma_parameters *dma_parms;
struct list_head	dma_pools;	
struct dma_coherent_mem	*dma_mem; 

dev_t			devt;	//dev目录下的描述符
u32			id;	

spinlock_t		devres_lock;
struct list_head	devres_head;

struct klist_node	knode_class;
struct class		*class;	//类

void	(*release)(struct device *dev);//释放设备描述符时候的回调函数
};
</code></pre>
                <p>首先，可以看到<code>device</code>中包含有一个<code>kobject</code>，还包含有它相关驱动对象。所有的device对象，全部收集在devices_kset中，它对应着/sys/devices中。设备的引用计数则是由kobject来完成的。device还会被嵌入到一个更大的描述符中，例如<code>pci_dev</code>，它除了包含<code>dev</code>之外，还有PCI所特有的一些数据结构。<code>device_add</code>完成了新的device的添加工作。我注意到，<code>error = bus_add_device(dev);</code>，也就是说device的添加会把它和bus关联起来。</p>
                <hr>
                <p>再来看看驱动程序的结构。其数据结构为<code>device_driver</code>。相对于设备的数据结构来说，它相对较为简单：对于每个设备驱动，都有几个通用的方法，分别用语处理热插拔、即插即用、电源管理、探查设备等。同样，驱动也会被嵌入到一个更大的描述符中，例如<code>pci_driver</code>。</p>
                <pre><code>struct device_driver {
const char		*name;		//驱动名
struct bus_type		*bus;	//总线描述符

struct module		*owner;
const char		*mod_name;	//模块名

bool suppress_bind_attrs;	/* disables bind/unbind via sysfs */

const struct of_device_id	*of_match_table;
const struct acpi_device_id	*acpi_match_table;

int (*probe) (struct device *dev);		//探测设备
int (*remove) (struct device *dev);	//移除设备
void (*shutdown) (struct device *dev);	//断电方法
int (*suspend) (struct device *dev, pm_message_t state);//低功率
int (*resume) (struct device *dev);	//恢复方法
const struct attribute_group **groups;

const struct dev_pm_ops *pm;	//电源管理的操作

struct driver_private *p;
};
</code></pre>
                <p>为什么这里没有<code>kobject</code>呢？它实际上保存在了<code>driver_private</code>当中，这个结构和device_driver是双向链接的。</p>
                <pre><code>struct driver_private {
struct kobject kobj;
struct klist klist_devices;
struct klist_node knode_bus;
struct module_kobject *mkobj;
struct device_driver *driver;
};  
</code></pre>
                <p>driver的添加，通过调用<code>driver_register()</code>来完成，它同样包含一个函数：<code>bus_add_driver()</code>，也就是将driver添加到某个bus。</p>
                <hr>
                <p>再来看看总线的结构。bus是连接device和driver的桥梁，bus中的很多代码，都是为了让device找到driver来设计的。总线的数据结构如下：</p>
                <pre><code>struct bus_type {
const char		*name;
const char		*dev_name;
struct device		*dev_root;
struct device_attribute	*dev_attrs;	/* use dev_groups instead */
const struct attribute_group **bus_groups;
const struct attribute_group **dev_groups;
const struct attribute_group **drv_groups;
//检查驱动是否支持特定设备
int (*match)(struct device *dev, struct device_driver *drv);	//回调事件，在kobject状态改变时调用
int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
//探测设备
int (*probe)(struct device *dev);
//从总线移除设备
int (*remove)(struct device *dev);
//掉电
void (*shutdown)(struct device *dev);	

int (*online)(struct device *dev);
int (*offline)(struct device *dev);

//改变电源状态和恢复
int (*suspend)(struct device *dev, pm_message_t state);
int (*resume)(struct device *dev);

const struct dev_pm_ops *pm;

const struct iommu_ops *iommu_ops;

struct subsys_private *p;
struct lock_class_key lock_key;
};
</code></pre>
                <p>同样，总线也有一个<code>subsys_private</code>，它保存了kobject。<code>but_type</code>中定义了一系列的方法。例如，当内核检查一个给定的设备是否可以由给定的驱动程序处理时，就会执行<code>match</code>方法。可以用<code>bus_for_each_drv()</code>和<code>bus_for_each_dev()</code>函数分别循环扫描drivers和device两个链表中的所有元素，来进行match。</p>
                <h1>设备文件</h1>
                <p>设备驱动程序使得硬件设备，能以特定方式，响应控制设备的编程接口（一组规范的VFS函数，open，read，lseek，ioctl等），这些函数都是由驱动程序来具体实现的。在设备文件上发出的系统调用，都会由内核转化为对应的设备驱动程序函数，因此设备驱动必须被注册，也即构造一个<code>device_driver</code>，并且加入到设备驱动程序模型中。在注册时，内核会试图进行一次match。注意，这个注册的过程基本<code>driver_register</code>通常不会在驱动中直接调用，但我们但驱动通常都会间接的调用它来完成注册。</p>
                <p>遵循linux“一切皆文件”的原则，I/O设备同样可以当作设备文件来处理，它和磁盘上的普通文件的交互方式一样，例如都可以通过<code>write()</code>系统调用写入数据。设备文件可以通过<code>mknod()</code>节点来创建，它们保存在/dev/目录下。</p>
                <p>linux当中，硬件设备可以花费为两种：字符设备和块设备。其中，块设备指的是可以随机访问的设备，例如硬盘、软盘等；而字符设备则指的是声卡、键盘这样的设备。设备文件同样在VFS当中，但它的索引节点没有指向磁盘数据的指针，相反地它对应一个标识符（包含一个主设备号和一个次设备号）。VFS会在设备文件打开时，改变一个设备文件的缺省文件操作，让它去调用和设备相关的操作。</p>
                <h1>字符设备驱动程序</h1>
                <p>这里我们以字符设备驱动程序为例。首先，字符设备的驱动，在linux系统中，是以<code>cdev</code>结构来表示的：</p>
                <pre><code>struct cdev {
struct kobject kobj;
struct module *owner;
const struct file_operations *ops;
struct list_head list;	//包括的inode的devices
dev_t dev;
unsigned int count;
};
</code></pre>
                <p>现在让我们回顾一下inode的数据结构：</p>
                <pre><code>struct inode {
	...
	union {
	struct pipe_inode_info	*i_pipe;
	struct block_device	*i_bdev;
	struct cdev		*i_cdev;
};
	...
}
</code></pre>
                <p>我们看到了<code>cdev</code>指针的影子，可见cdev和inode确实是直接相关的。要实现驱动，首先就要对cdev进行初始化，注册字符设备。驱动的安装，首先要分配cdev结构体、申请设备号并初始化cdev。注意，驱动程序是如何和刚才我们所说的设备驱动模型建立联系的呢？实际上在初始化cdev的时候，就调用了<code>kobject_init()</code>，在模型中添加了一个<code>kobject</code>。</p>
                <p>随后，驱动要注册cdev，也即调用<code>cdev_add()</code>函数。这个工作主要是由<code>kobj_map()</code>来实现的，它是一个数组。对于每一类设备，都有一个全局变量，例如字符设备的<code>cdev_map</code>，块设备的<code>bdev_map</code>。最后要进行硬件资源的初始化。</p>
                <pre><code>int cdev_add(struct cdev *p, dev_t dev, unsigned count)
{
	int error;

	p-&gt;dev = dev;
	p-&gt;count = count;

	error = kobj_map(cdev_map, dev, count, NULL,
			 exact_match, exact_lock, p);
	if (error)
		return error;

	kobject_get(p-&gt;kobj.parent);

	return 0;
}  
</code></pre>
                <p>kobj_map的结构如下，它用来保存设备号和kobject的对应关系</p>
                <pre><code>struct kobj_map {
	struct probe {
		struct probe *next;
		dev_t dev;
		unsigned long range;
		struct module *owner;
		kobj_probe_t *get;
		int (*lock)(dev_t, void *);
		void *data;
	} *probes[255];
	struct mutex *lock;
};
</code></pre>
                <p><img src="http://www.meng.uno/images/%E7%A3%81%E7%9B%98IO/kobjmap.jpg" alt=""></p>
                <p>不过到现在为止，我们都还没有说明，程序在访问字符设备时，是如何去调用正确的方法的。我们曾提到过，<code>open()</code>系统调用会改变字符文件对象的f_op字段，将默认文件操作替换为驱动的操作。在字符设备文件创建时，会调用<code>init_special_inode</code>来进行索引节点对象的初始化。其inode的操作(def_chr_fops)只包含一个默认的文件打开操作，也即<code>chrdev_open</code>。它会根据inode，首先利用<code>cdev_map</code>，找到对应的kobject，随后再进一步找到cdev，然后从中提取出文件操作的函数<code>fops</code>，并把它填充到file当中去。</p>
                <pre><code>static int chrdev_open(struct inode *inode, struct file *filp)
{
	const struct file_operations *fops;
	struct cdev *p;
	struct cdev *new = NULL;
	int ret = 0;

	spin_lock(&amp;cdev_lock);
	p = inode-&gt;i_cdev;
	if (!p) {
		struct kobject *kobj;
		int idx;
		spin_unlock(&amp;cdev_lock);
		kobj = kobj_lookup(cdev_map, inode-&gt;i_rdev, &amp;idx);//获取对应的kobject
		if (!kobj)
			return -ENXIO;
		new = container_of(kobj, struct cdev, kobj);
		spin_lock(&amp;cdev_lock);
		/* Check i_cdev again in case somebody beat us to it while
		   we dropped the lock. */
		p = inode-&gt;i_cdev;
		if (!p) {
			inode-&gt;i_cdev = p = new;
			list_add(&amp;inode-&gt;i_devices, &amp;p-&gt;list);//将device加入到cdev的list中去
			new = NULL;
		} else if (!cdev_get(p))
			ret = -ENXIO;
	} else if (!cdev_get(p))
		ret = -ENXIO;
	spin_unlock(&amp;cdev_lock);
	cdev_put(new);
	if (ret)
		return ret;

	ret = -ENXIO;
	fops = fops_get(p-&gt;ops)
	if (!fops)
		goto out_cdev_put;

	replace_fops(filp, fops);//替换file当中的fops  	
	return ret;
}
</code></pre>
                <p>这里很奇怪的是，我们并没有看到类似前面提到的<code>driver_register()</code>、<code>device_register()</code>这样的函数。实际上这里并没有真正创建一个设备，而只是说创建了一个接口，所以有这样一个这个问题：<a href="http://blog.csdn.net/luckywang1103/article/details/47860805" target="_blank" rel="noopener">为什么cdev_add没有产生设备节点？</a>对于这个问题，我们应该理解为<code>cdev</code>和<code>driver/device</code>二者是配套工作的，cdev用来和用户交互，而device则是内核中的结构。<br>                  另一个问题是，在上面的过程中，似乎没有提及设备文件的创建。实际上，作为一个rookie，那么设备文件常常是用
                  <code>mknod</code>命令手动创建的。当然，linux自然也提供了自动创建的借口，那就是利用udev来实现，调用<code>device_create()</code>函数。</p>
                <p>当然，这个例子只是为了说明，操作系统的驱动程序是如何工作的，为什么对I/O设备的操作可以抽象成对设备文件的操作，程序在操作I/O文件时，是如何使用正确的操作的。</p>
                <h1>块设备的驱动</h1>
                <p>和字符设备类似，操作系统中的块设备，也是以文件的形式来访问。这里有一个很拗口的问题：磁盘是一个块设备，块设备有一个块设备文件。那么访问块设备文件和访问普通的磁盘上的文件有什么关系呢？<br> 不论是块设备文件还是普通的文件，它们都是通过VFS来统一访问的。只不过对于一个普通文件，它可能已经在RAM中了（高速缓存机制），因此它的访问可能会直接在RAM中进行；但如果说要修改磁盘上的内容，或者文件内容不在RAM中，则也会间接地，通过块设备文件进行访问。这个驱动模型可以用这样一个图表示：
                </p>
                <p><img src="http://ww.meng.uno/images/%E7%A3%81%E7%9B%98IO/%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8.png" alt=""></p>
                <p>这里我们只考虑最底层的情况：内核从块设备读取数据。为了从块设备中读取数据，内核必须知道数据的物理位置，而这正是<strong>映射层</strong>的工作。映射层的工作包括两步：</p>
                <ul>
                  <li>根据文件所在文件系统的块，将文件拆分成块，然后内核能够确定请求数据所在的块号；</li>
                  <li>映射层调用文件系统具体的函数，找到数据在磁盘上的位置，也就是完成文件块号，到逻辑块号的映射关系。</li>
                </ul>
                <p>随后的工作在<strong>通用块层</strong>进行，内核在这一层，启动I/O操作。通常一个I/O操作对应一组连续的块，我们把它称为<code>bio</code>，它用来搜集底层需要的信息。</p>
                <p><strong>I/O调度层</strong>负责根据内核中的各种策略，把待处理的I/O数据传送请求，进行归类。它的作用是把物理介质上相邻的数据请求，进行合并，一并处理。</p>
                <p>最后一层也就是通过块设备的驱动来完成了，它向I/O接口发送适当的命令，从而进行实际的数据传送。</p>
                <h1>通用块层</h1>
                <p>通用块层负责处理所有块设备的请求，其核心数据结构就是<code>bio</code>。它代表<strong>一次块设备I/O请求</strong>。</p>
                <pre><code>struct bio {
struct bio		*bi_next;		//请求队列中的下一个bio
struct block_device	*bi_bdev;	//块设备描述符指针
unsigned long		bi_flags;	/* status, command, etc */
unsigned long		bi_rw;		//rw位

struct bvec_iter	bi_iter;	

unsigned int		bi_phys_segments;//合并后有多少个段

unsigned int		bi_seg_front_size;
unsigned int		bi_seg_back_size;

atomic_t		bi_remaining;//剩余的bio_vec

bio_end_io_t		*bi_end_io;//bio结束的回调函数

void			*bi_private;

unsigned short		bi_vcnt;	//bio中biovec的数量

unsigned short		bi_max_vecs;//最多能有多少个

atomic_t		bi_cnt;		//结构体的使用计数

struct bio_vec		*bi_io_vec;	//bio_vec数组
};  
</code></pre>
                <p>在这个数据结构中，还包含了一个<code>bio_vec</code>。这是什么意思呢？在linux中，相邻数据块被称为一个段，每个<code>bio_vec</code>对应一个内存页中的段。在io操作期间，bio是会一直更新的，其中的<code>bi_iter</code>用来在数组中遍历，按每个段来执行下一步的操作。</p>
                <p><img src="http://www.meng.uno/images/%E7%A3%81%E7%9B%98IO/biovec.gif" alt=""></p>
                <p>那么当通用块层收到一个I/O请求操作时，会发生什么呢？首先内核会为这次操作分配<code>bio</code>描述符，并对它进行填充。随后通用块层会调用<code>generic_make_request</code>，这个函数的作用很明确：它会进行一系列检查和设置，保证bio中的信息是<strong>针对整个磁盘，而不是磁盘分区的</strong>；随后获取这个块设备相关的请求队列q，调用<code>q-&gt;make_request_fn</code>，把bio插入请求队列中去。</p>
                <h1>I/O调度层</h1>
                <p>在块设备上，每个I/O请求操作都是异步处理的，通用块层的请求会被加入块设备的请求队列中，每个块设备都会单独地进行I/O的调度，这样能够有效提高磁盘的性能。</p>
                <p>前面提到，通用块层会调用一个<code>q-&gt;make_request_fn</code>，向I/O调度程序发送一个请求，该函数会进一步调用<code>__make_request()</code>。这个函数的目的，就是把<code>bio</code>放进请求队列当中：（1）如果请求队列是空的，就构造一个新的请求插入；（2）如果请求队列不是空的，但是<code>bio</code>不能合并（不能合并到某个请求的头和尾），也构造一个新的请求插入；（3）请求队列不是空的，并且<code>bio</code>可以合并，就合并到对应的请求中去。注意，bio，请求和请求队列的关系如下：</p>
                <pre><code>-- request_queue
		|-- request1
				|-- bio0
		|-- request2
				|-- bio1
				|-- bio2
</code></pre>
                <p>而I/O的调度，就是对请求队列进行排序，针对磁盘的特点，降低寻道的次数。这里说说几个常见的算法：</p>
                <ul>
                  <li>CFQ完全公平队列：默认的调度算法，完全公平排队。每个进程/线程都单独创建一个队列，并且用上面提到的策略进行管理。队列间采用时间片的方式来分配I/O。</li>
                  <li>Deadline最后期限算法：在电梯调度的基础上，根据读写请求的“最后期限”进行排序，并通过读期限短于写期限来保证写操作不被饿死。</li>
                  <li>预期I/O算法：与最后期限类似，但是在读操作时，会预先判断当前的进程是否马上会有读操作，并且优先地进行处理。</li>
                  <li>NOOP：适用于固态硬盘，不进行任何优化。</li>
                </ul>
                <p>总而言之，I/O调度层的作用，就是把请求的队列重新排序，并逐个交给块设备驱动程序进行处理。</p>
                <h1>块设备驱动程序</h1>
                <p>I/O调度层排序好的请求，会由块设备的驱动程序来处理。同样，块设备也遵循着我们前面提到的驱动程序模型：块设备对应一个<code>device</code>，而驱动程序对应了一个<code>device_driver</code>。对于块设备来说，驱动程序也要通过<code>register_blkdev()</code>注册一个设备号。随后，驱动程序要初始化<code>gendisk</code>描述符，以及它所包含的设备操作表<code>fops</code>。在此之后，是“请求队列”的初始化，以及中断程序的设置：要为设备注册IRQ线。最后要把磁盘注册到内核（<code>add_disk</code>）,并把它激活。</p>
                <p>当一个块设备文件被<code>open()</code>时，内核同样也要为它初始化操作。对于块设备来说，其默认的文件操作如下：</p>
                <pre><code>const struct file_operations def_blk_fops = {
.open		= blkdev_open,
.release	= blkdev_close,
.llseek		= block_llseek,
.read		= new_sync_read,
.write		= new_sync_write,
.read_iter	= blkdev_read_iter,
.write_iter	= blkdev_write_iter,
.mmap		= generic_file_mmap,
.fsync		= blkdev_fsync,
.unlocked_ioctl	= block_ioctl,
#ifdef CONFIG_COMPAT
.compat_ioctl	= compat_blkdev_ioctl,
#endif
.splice_read	= generic_file_splice_read,
.splice_write	= iter_file_splice_write,
};
</code></pre>
                <p><code>dentry_open()</code>方法会调用<code>blkdev_open()</code>。它（1）首先会获取块设备的描述符：如果块设备已经打开，则可以通过inode-&gt;i_bdev直接获取，否则则需要根据设备号去查找块设备描述符。（2）获取块设备相关的<code>gendisk</code>地址，<code>get_gendisk</code>是通过设备号来找到gendisk的。（3）如果是第一次打开块设备，则要根据它是整盘还是分区，进行相应的设置和初始化。（4）如果不是第一次打开，只需要按需要执行自定义的<code>open()</code>函数就行了。</p>
                <h1>补充：I/O的监控方式</h1>
                <ul>
                  <li>轮询：CPU重复检查设备的状态寄存器，直到寄存器的值表明I/O操作已经完成了。</li>
                  <li>中断：设备发出中断信号，告知I/O操作已经完成了，数据放在对应的端口，当数据缓冲满了时，由CPU去取，CPU需要控制数据传输的过程。</li>
                  <li>DMA：由CPU的DMA电路来辅助数据的传输，CPU不需要参与内存和IO之间的传输过程，只需要通过DMA的中断来获取信息。DMA能够在所有数据处理完时才通知CPU处理。</li>
                </ul>
                <p><br><br>本文链接： <a href="http://www.meng.uno/articles/d0c0e94a/">http://www.meng.uno/articles/d0c0e94a/</a> 欢迎转载！</p>

              </div>
              <footer class="article-footer">

                <!-- Go to www.addthis.com/dashboard to customize your tools -->

                <div id="wpac-rating" style="margin: 10px auto; text-align:center;"></div>
                <script type="text/javascript">
                  wpac_init = window.wpac_init || [];
                  wpac_init.push({
                    widget: 'Rating',
                    id: 9986
                  });
                  (function() {
                    if ('WIDGETPACK_LOADED' in window) return;
                    WIDGETPACK_LOADED = true;
                    var mc = document.createElement('script');
                    mc.type = 'text/javascript';
                    mc.async = true;
                    mc.src = 'https://embed.widgetpack.com/widget.js';
                    var s = document.getElementsByTagName('script')[0];
                    s.parentNode.insertBefore(mc, s.nextSibling);
                  })();
                </script>

                <div id="donation_div"></div>

                <script src="/js/vdonate.js"></script>
                <script>
                  var a = new Donate({
                    title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
                    btnText: '打赏支持', // 可选参数，打赏按钮文字
                    el: document.getElementById('donation_div'),
                    wechatImage: 'http://www.meng.uno/money/wechat.JPG',
                    alipayImage: 'http://www.meng.uno/money/alipay.JPG'
                  });
                </script>


                <div id="comment">
                  <!-- 来必力City版安装代码 -->
                  <div id="lv-container" data-id="city" data-uid="MTAyMC8zNDA2OC8xMDYwNg==">
                    <script type="text/javascript">
                      (function(d, s) {
                        var j, e = d.getElementsByTagName(s)[0];

                        if (typeof LivereTower === 'function') {
                          return;
                        }

                        j = d.createElement(s);
                        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                        j.async = true;

                        e.parentNode.insertBefore(j, e);
                      })(document, 'script');
                    </script>
                    <noscript>为正常使用评论功能请激活JavaScript</noscript>
                  </div>
                  <!-- City版安装代码已完成 -->
                </div>

                <ul class="article-tag-list">
                  <li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/I-O/">I/O</a></li>
                  <li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li>
                </ul>
              </footer>
            </div>

            <nav id="article-nav">

              <a href="/articles/b0b4f7ec/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          汇编语言代码规范
        
      </div>
    </a>


              <a href="/articles/51c782dd/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">rIOMMU：Efficient IOMMU for I/O Devices that Employ Ring Buffers</div>
    </a>

            </nav>

          </article>

          <!-- Table of Contents -->

          <aside id="toc-sidebar">
            <div id="toc" class="toc-article">
              <strong class="toc-title">目录导航</strong>

              <ol class="nav">
                <li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">I/O体系结构</span></a></li>
                <li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">2.</span> <span class="nav-text">设备驱动程序模型</span></a></li>
                <li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">3.</span> <span class="nav-text">设备驱动程序模型中的组件</span></a></li>
                <li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">4.</span> <span class="nav-text">设备文件</span></a></li>
                <li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">5.</span> <span class="nav-text">字符设备驱动程序</span></a></li>
                <li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">6.</span> <span class="nav-text">块设备的驱动</span></a></li>
                <li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">7.</span> <span class="nav-text">通用块层</span></a></li>
                <li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">8.</span> <span class="nav-text">I/O调度层</span></a></li>
                <li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">9.</span> <span class="nav-text">块设备驱动程序</span></a></li>
                <li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">10.</span> <span class="nav-text">补充：I/O的监控方式</span></a></li>
              </ol>

            </div>
          </aside>
        </section>

      </div>


      <footer id="footer">


        <div class="container">
          <div class="row">
            <p id="copyRightEn">&copy; 2018.02.08 - 2019.04.26 <a href="http://www.meng.uno/">Mengmeng Kuang</a>&nbsp;<i class="fas fa-cogs"></i> 保留所有权利！</p>

            <p class="busuanzi_uv">

              访客数 : <span id="busuanzi_value_site_uv"></span> | 访问量 : <span id="busuanzi_value_site_pv"></span>

            </p>


            <p id="hitokoto">:D 获取中...</p>
            <!-- 以下写法，选取一种即可 -->

            <!-- 现代写法，推荐 -->
            <!-- 兼容低版本浏览器 (包括 IE)，可移除 -->
            <script src="https://cdn.bootcss.com/bluebird/3.5.1/bluebird.core.min.js"></script>
            <script src="https://cdn.bootcss.com/fetch/2.0.3/fetch.min.js"></script>
            <!--End-->
            <script>
              fetch('https://v1.hitokoto.cn')
                .then(function(res) {
                  return res.json();
                })
                .then(function(data) {
                  var hitokoto = document.getElementById('hitokoto');
                  hitokoto.innerText = data.hitokoto;
                })
                .catch(function(err) {
                  console.error(err);
                })
            </script>

            <a href="http://webscan.360.cn/index/checkwebsite/url/www.meng.uno"><img border="0" height=27px width=74px src="/css/images/webscan.png"/></a>
            <!-- <img border="0" height=27px width=109px style="background-color:white;"src="/css/images/kaba.png"/> -->
            <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" height=27px style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a>
            <script type="text/javascript">
              var locationUrl = escape(document.location.href);
              document.write(unescape("%3Cscript") + " height='27px' width='74px' charset='utf-8' src='http://union.rising.com.cn//InfoManage/TrojanInspect.aspx?p1=XNk3xHG5v8uxFHYb4KaGpnyWjJlbHp7K&p2=RqCQt7iMKRw=&p3=XNk3xHG5v8vv3Z1xqd/V8w==&url=" + locationUrl + "' type='text/javascript'" + unescape("%3E%3C/script%3E"));
            </script>
          </div>

        </div>
      </footer>


      <!-- min height -->

      <script>
        var wrapdiv = document.getElementById("wrap");
        var contentdiv = document.getElementById("content");
        var allheader = document.getElementById("allheader");

        wrapdiv.style.minHeight = document.body.offsetHeight + "px";
        if (allheader != null) {
          contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
        } else {
          contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
        }
      </script>

      <script>
        (function() {
          var src = (document.location.protocol == "http:") ? "http://js.passport.qihucdn.com/11.0.1.js?5d3bca9f7d6a95532f3ebb56e3c6bf11" : "https://jspassport.ssl.qhimg.com/11.0.1.js?5d3bca9f7d6a95532f3ebb56e3c6bf11";
          document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
      </script>
    </div>
    <!-- <nav id="mobile-nav">

  <a href="/" class="mobile-nav-link">Home</a>

  <a href="/archives" class="mobile-nav-link">Archives</a>

  <a href="/categories" class="mobile-nav-link">Categories</a>

  <a href="/tags" class="mobile-nav-link">Tags</a>

  <a href="/about" class="mobile-nav-link">About</a>

  <a href="/comments" class="mobile-nav-link">Comments</a>

</nav> -->
    <!-- mathjax config similar to math.stackexchange -->

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] } });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() { var all = MathJax.Hub.getAllJax(), i; for(i=0; i
      < all.length; i +=1 ) { all[i].SourceElement().parentNode.className +=' has-jax' ; } }); </script>

        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>


        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
        <script src="/fancybox/jquery.fancybox.pack.js"></script>


        <script src="/js/scripts.js"></script>




        <script src="/js/dialog.js"></script>


        <!-- Google Analytics -->
        <script type="text/javascript">
          (function(i, s, o, g, r, a, m) {
            i['GoogleAnalyticsObject'] = r;
            i[r] = i[r] || function() {
              (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o),
              m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m)
          })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

          ga('create', 'UA-113947925-1', 'auto');
          ga('send', 'pageview');
        </script>
        <!-- End Google Analytics -->


        <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
        </script>
  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h2 class="modal-title" id="myModalLabel">设置</h2>
        </div>
        <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
        <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
        <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
            <div class="panel-body">
              您已调整页面字体大小
            </div>
          </div>
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
          </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
            <div class="panel-body">
              夜间模式已经开启，再次单击按钮即可关闭
            </div>
          </div>

          <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
          </div>
          <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
            <div class="panel-body">
              欢迎来到匡盟盟的博客！
            </div>
            <div class="panel-body">
              A first year MPhil student in CS at HKU
            </div>
            <div class="panel-body">
              © 2019 Mengmeng Kuang All Rights Reserved.
            </div>
          </div>
        </div>


        <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
        <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
        <div class="modal-footer">
          <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
        </div>
      </div>
    </div>
  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>

  <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>



</body>
<style>
  .test-div {
    width: 300px;
    height: 300px;
    margin: 20px auto;
    border: 1px solid #aaa;
    position: relative;
  }
</style>

<script src="/js/loading.js"></script>
<script>
  function loading7() {
    $('body').loading({
      loadingWidth: 240,
      title: '请稍等!',
      name: 'test',
      discription: '精彩马上就来...',
      direction: 'row',
      type: 'origin',
      originBg: '#71EA71',
      originDivWidth: 30,
      originDivHeight: 30,
      originWidth: 4,
      originHeight: 4,
      smallLoading: false,
      titleColor: '#388E7A',
      loadingBg: '#312923',
      loadingMaskBg: 'rgba(22,22,22,0.2)'
    });
    setTimeout(function() {
      removeLoading('test');
    }, 1000);
  }
</script>

</html>