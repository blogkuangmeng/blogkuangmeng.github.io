{"meta":{"title":"Mengmeng Kuang's Blog!","subtitle":null,"description":"I want to have my cake, and eat it.","author":"Mengmeng Kuang","url":"https://blog.nooa.tech","root":"/"},"pages":[{"title":"","date":"2021-01-02T04:13:38.000Z","updated":"2021-01-02T04:13:38.000Z","comments":true,"path":"hexo-admin-ehc-images.json","permalink":"https://blog.nooa.tech/hexo-admin-ehc-images.json","excerpt":"","text":"[{\"name\":\"DASHENG-900x700-1.png\",\"date\":1518959551960},{\"name\":\"DASHENG-900x700-2.png\",\"date\":1518959599098},{\"name\":\"DASHENG-900x700-3.png\",\"date\":1518959609913},{\"name\":\"DASHENG-900x700-4.png\",\"date\":1518959618105}]"},{"title":"仓库","date":"2020-11-27T06:19:35.000Z","updated":"2018-04-24T08:54:24.000Z","comments":true,"path":"repository/index.html","permalink":"https://blog.nooa.tech/repository/index.html","excerpt":"","text":""},{"title":"我的作品","date":"2020-11-27T06:19:35.000Z","updated":"2018-03-11T04:57:40.000Z","comments":true,"path":"works/index.html","permalink":"https://blog.nooa.tech/works/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-27T06:19:35.000Z","updated":"2018-02-11T06:17:12.000Z","comments":true,"path":"categories/index.html","permalink":"https://blog.nooa.tech/categories/index.html","excerpt":"","text":""},{"title":"标签云","date":"2020-11-27T06:19:35.000Z","updated":"2018-02-11T06:17:27.000Z","comments":true,"path":"tags/index.html","permalink":"https://blog.nooa.tech/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"二分查找的效率","slug":"binsearch","date":"2018-02-08T09:20:00.000Z","updated":"2020-12-02T01:41:34.000Z","comments":true,"path":"articles/fff444e8/","permalink":"https://blog.nooa.tech/articles/fff444e8/","excerpt":"查找是比较常见的工作，今天我通过对比几种在数组中查找一个确定的值的例子来向大家展示二分查找的魅力。 数组查找元素的几种方法 使用List 1 2 3 public static boolean useList(String[] arr, String targetValue) { return Arrays.asList(arr).contains(targetValue); } 使用Set 1 2 3 4 public static boolean useSet(String[] arr, String targetValue) { Set set =","text":"查找是比较常见的工作，今天我通过对比几种在数组中查找一个确定的值的例子来向大家展示二分查找的魅力。 数组查找元素的几种方法 使用List 123public static boolean useList(String[] arr, String targetValue) &#123; return Arrays.asList(arr).contains(targetValue);&#125; 使用Set 1234public static boolean useSet(String[] arr, String targetValue) &#123; Set&lt;String&gt; set = new HashSet&lt;String&gt;(Arrays.asList(arr)); return set.contains(targetValue);&#125; 使用for-loop 1234567public static boolean useLoop(String[] arr, String targetValue) &#123; for(String s: arr)&#123; if(s.equals(targetValue)) return true; &#125; return false;&#125; 使用二分 1234567public static boolean useArraysBinarySearch(String[] arr, String targetValue) &#123; int a = Arrays.binarySearch(arr, targetValue); if(a &gt; 0) return true; else return false;&#125; 时间复杂性 代码 使用如下代码来验证不同数据规模（5，1k，10k）的查找任务下四种方法的时间复杂性。（二分查找需要对数据排序，排序时间未计算在内。） 123456789101112131415161718192021222324252627282930public static void main(String[] args) &#123; String[] arr = new String[] &#123; &quot;CD&quot;, &quot;BC&quot;, &quot;EF&quot;, &quot;DE&quot;, &quot;AB&quot;&#125;; //use list long startTime = System.nanoTime(); for (int i = 0; i &lt; 100000; i++) &#123; useList(arr, &quot;A&quot;); &#125; long endTime = System.nanoTime(); long duration = endTime - startTime; System.out.println(&quot;useList: &quot; + duration / 1000000); //use set startTime = System.nanoTime(); for (int i = 0; i &lt; 100000; i++) &#123; useSet(arr, &quot;A&quot;); &#125; endTime = System.nanoTime(); duration = endTime - startTime; System.out.println(&quot;useSet: &quot; + duration / 1000000); //use loop startTime = System.nanoTime(); for (int i = 0; i &lt; 100000; i++) &#123; useLoop(arr, &quot;A&quot;); &#125; endTime = System.nanoTime(); duration = endTime - startTime; System.out.println(&quot;useLoop: &quot; + duration / 1000000);&#125; &quot;5&quot;结果 123useList: 13useSet: 72useLoop: 5 &quot;1k&quot;结果 随机生成数据 123456String[] arr = new String[1000]; Random s = new Random();for(int i=0; i&lt; 1000; i++)&#123; arr[i] = String.valueOf(s.nextInt());&#125; 结果 1234useList: 112useSet: 2055useLoop: 99useArrayBinary: 12 &quot;10k&quot;结果 1234useList: 1590useSet: 23819useLoop: 1526useArrayBinary: 12 结论 通过以上结果，我们可以发现二分搜索确实很高效，而且当数据量变大时，其时间增长幅度还比较小。 以后，我们就可以使用Arrays.binarySearch()来高效查找某元素了。 The link of this page is https://blog.nooa.tech/articles/fff444e8/ . Welcome to reproduce it!","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://blog.nooa.tech/categories/Algorithm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.nooa.tech/tags/Java/"},{"name":"算法复杂性","slug":"算法复杂性","permalink":"https://blog.nooa.tech/tags/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E6%80%A7/"},{"name":"二分查找","slug":"二分查找","permalink":"https://blog.nooa.tech/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]}],"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://blog.nooa.tech/categories/Algorithm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.nooa.tech/tags/Java/"},{"name":"算法复杂性","slug":"算法复杂性","permalink":"https://blog.nooa.tech/tags/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E6%80%A7/"},{"name":"二分查找","slug":"二分查找","permalink":"https://blog.nooa.tech/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]}